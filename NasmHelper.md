### Запуск
```
nasm <имя файла>
```
### Ключи
```
nasm <имя файла> ;... ключи
```
#### Формат получаемого кода, в нашем случае elf
`-f`
> Если не указать этот ключ, ассемблер создаст выходной файл в "сыром формате", то есть переведет наши команды в двоичное представление и в таком виде запишет в файл. Работая под управлением ОС, мы такой файл запустить на выполнение не сможем, однако если бы мы хотели написать программу для размещения в загрузочном секторе диска, то "сырой" формат оказался бы как раз тем, что нам нужно.
#### Имя файла в который следует записать результат трансляции
`-o`
> Можно не указывать, nasm сам позаботится о имени (отбрасывает суффикс .asm и заменяет на .o)
#### Определение макросимвола
`-d`
> Например `-dSYMBOL` дает тот же эффект, что и вставленная в начало программы строка `%define SYMBOL`, а `-dSIZE=1024` не только определит символ `SIZE`, но и припишет ему значение `1024`, как это сделала бы директива `%define SIZE 1024`.
#### Генерация листинга
`nasm -f elf -l prog.lst prog.asm`
#### Включение в результаты трансляции отладочной информации 
`-g`
> Дает возможность воспользоваться отладчиком `gdb`

### Говорит компилятор считывать следующую строку как продолжение предыдущей
`\`
### Строка обычно состоит из 4 полей
* метка - начинаться метка может только с буквы или символов `_`, `?`, `.`. Метки начинающиеся с `.` считаются локальными. Символ `$` вначале метки используется для имени метки, которое совпадает с именем регистра, команды или директивы. Ассемблер различает регистр букв в имени метки.
* имя команды - в именах машинных команд, ассемблер регистр букв не различает, но в именах макросов различается.
* операнды
* комментарий
> пустые строки ассемблер игноирурет
### Псевдокоманды
#### Определение констант
```
four equ 4 # метка `four`, задающая число `4`
# теперь 
mov eax, four
# то же самое, что и 
mov eax, 4
```
> `equ` свзяывает стоящую перед ней метку с явно заданным числом.

> Любая метка представляет собой не более чем число, но когда меткой снабжается строка программы, содержащая мнемонику машинной команды или директиву выделения памяти, тогда как директива `equ` позволяет указать число явно.

Директивы `equ` часто применяются чтобы связать с некоторым именем (меткой) длину массива, только что заданного с помощью директивы `db`,`dw` или любой другой. Для этого используется `$`:
```
msg     db "Hello and welcome", 10, 0
msglen  equ $-msg
# выражение $-msg, представляющее собой разность двух чисел, известных ассемблеру во время его работы, будет вычислено во время ассемблирования. Поскольку $ означает адрес, ставший текущем после описания строки, а msg - адрес начала строки, то их разность дает длинну строки - 19.
```
#### Позволяет выполнить команду заданное количество раз
`stars  times 4096 db '*'`
> задает область памяти в 4096 байт, заполненную кодом символа `'*'`, точно также, как это сделали бы 4096 одинаковых строк, содержащих директиву `db` `'*'`.

### Константы
Делятся на четыре категории:
* целые числа, *десятичные* - `123`, `-123`, *шестнадцатеричные* - `2af3h` (в конце буква `h`), `$2af3` (перед числом `$`, но надо чтобы после `$` обязательно стояло число, а не буква, или добавить `0`, например `$0f9`), `0x2af3` (перед числом `0x`), *восьмеричные* - `634o` (в конце `o`), `754q` (в конце `q`), *двоичные* - `10011011b` (в конце `b`).  
* символьные константы
* строковые константы 
* числа с плавающей точкой
