### Запуск
```
nasm <имя файла>
```
### Ключи
```
nasm <имя файла> ;... ключи
```
#### Формат получаемого кода, в нашем случае elf
`-f`
> Если не указать этот ключ, ассемблер создаст выходной файл в "сыром формате", то есть переведет наши команды в двоичное представление и в таком виде запишет в файл. Работая под управлением ОС, мы такой файл запустить на выполнение не сможем, однако если бы мы хотели написать программу для размещения в загрузочном секторе диска, то "сырой" формат оказался бы как раз тем, что нам нужно.
#### Имя файла в который следует записать результат трансляции
`-o`
> Можно не указывать, nasm сам позаботится о имени (отбрасывает суффикс .asm и заменяет на .o)
#### Определение макросимвола
`-d`
> Например `-dSYMBOL` дает тот же эффект, что и вставленная в начало программы строка `%define SYMBOL`, а `-dSIZE=1024` не только определит символ `SIZE`, но и припишет ему значение `1024`, как это сделала бы директива `%define SIZE 1024`.
#### Генерация листинга
`nasm -f elf -l prog.lst prog.asm`
#### Включение в результаты трансляции отладочной информации 
`-g`
> Дает возможность воспользоваться отладчиком `gdb`

### Говорит компилятор считывать следующую строку как продолжение предыдущей
`\`
### Строка обычно состоит из 4 полей
* метка - начинаться метка может только с буквы или символов `_`, `?`, `.`. Метки начинающиеся с `.` считаются локальными. Символ `$` вначале метки используется для имени метки, которое совпадает с именем регистра, команды или директивы. Ассемблер различает регистр букв в имени метки.
* имя команды - в именах машинных команд, ассемблер регистр букв не различает, но в именах макросов различается.
* операнды
* комментарий
> пустые строки ассемблер игноирурет
### Псевдокоманды
#### Определение констант
```
four equ 4 # метка `four`, задающая число `4`
# теперь 
mov eax, four
# то же самое, что и 
mov eax, 4
```
> `equ` свзяывает стоящую перед ней метку с явно заданным числом.

> Любая метка представляет собой не более чем число, но когда меткой снабжается строка программы, содержащая мнемонику машинной команды или директиву выделения памяти, тогда как директива `equ` позволяет указать число явно.

Директивы `equ` часто применяются чтобы связать с некоторым именем (меткой) длину массива, только что заданного с помощью директивы `db`,`dw` или любой другой. Для этого используется `$`:
```
msg     db "Hello and welcome", 10, 0
msglen  equ $-msg
# выражение $-msg, представляющее собой разность двух чисел, известных ассемблеру во время его работы, будет вычислено во время ассемблирования. Поскольку $ означает адрес, ставший текущем после описания строки, а msg - адрес начала строки, то их разность дает длинну строки - 19.
```
#### Позволяет выполнить команду заданное количество раз
`stars  times 4096 db '*'`
> задает область памяти в 4096 байт, заполненную кодом символа `'*'`, точно также, как это сделали бы 4096 одинаковых строк, содержащих директиву `db` `'*'`.

### Константы
Делятся на четыре категории:
* целые числа, **десятичные** - `123`, `-123`, **шестнадцатеричные** - `2af3h` (в конце буква `h`), `$2af3` (перед числом `$`, но надо чтобы после `$` обязательно стояло число, а не буква, или добавить `0`, например `$0f9`), `0x2af3` (перед числом `0x`), **восьмеричные** - `634o` (в конце `o`), `754q` (в конце `q`), **двоичные** - `10011011b` (в конце `b`).  
* символьные константы
* строковые константы 
* числа с плавающей точкой
### Критическое выражение - выражением, вычисляемое во время ассемблирования, которое ассемблеру необходимо вычислить во время прохода, для размещения в памяти.
### Макросы
```
# макроопределение
%macro pcall1 2     ;2 -- количество параметров
       push %2
       call %1
       add esp, 4
%endmacro

# макровызов
pcall1 proc, eax
```
### Однострочные макросы
```
%define arg1 ebp+8
%define arg2 ebp+12
%define arg3 ebp+16
%define local1 ebp-4
%define local2 ebp-8
%define local3 ebp-12
...
%define arg(n) ebp+(4*n)+4
%define local(n) ebp-(4*n)

# теперь к параметру процедуры можно обратится так
mov eax, [arg1]

# или так
mov [arg(7)], edx

# можно квадратные скобки включить внутрь макросов 
%define arg1 [ebp+8]

# тогда вызов будет такой
mov eax, arg1
```
### Удаление одностраничного макроса
`%undef <имя макроса>`
### Макропеременная. Вычисление арифметического выражения
```
%assign      var    25
%assign      var    var+1
# var = 26
```
### Директивы условной компиляции
```
%ifdef DEBUG_PRINT # компилирует в случае если определен однострочный макрос DEBUG_PRINT
       PRINT "Entering suspicious section"
       PUTCHAR 10
%endif

# определить символ можно как внутри программы, так и ключем
nasm -f elf -dDEBUG_PRINT prog.asm
```
### Макроповторения
```
%rep <количество повторений>
%endrep
# %exitrep - досрочно прекращает повторение
```
пример:
```
%assign n 50
%rep 100
    db n
  %assign n n+1
%endrep
```
### Многостраничные макросы и локальные метки
`%%<имя метки>`
### Макросы с переменным числом параметров
```
%macro mymacro 1-3
%macro mysecondmacro 2-*
```
> `%0` в таком случае возвращает количество параметров
#### Сдвиг указателя на параметр
```
%rotate 1
# параметр, ранее обозначавшийся %2, после этой директивы будет иметь обозначение %1, а %3 будет %2 и т.д.
```
#### Циклический сдвиг
```
%rotate - 1
# %1 -> %2, %2 -> %1
```
### Вызов подпрограммы с любым количеством аргументов
```
%macro pcall 1-*     ; от одного до скольки угодно 
  %rep %0 - 1        ; цикл по всем параметрам, кроме первого
    %rotate - 1      ; последний параметр становился %1
      push dword %1
  %endrep
  %rotate - 1        ; адрес процедуры становится %1
    call %1
    add esp, (%0 - 1) * 4
%endmacro

# пример вызова
pcall myproc, eax, myvar, 27

# будет вызваны команды
push dword 27
push dword myvar
push dword eax
call myproc
add esp, 12
```
