## C++
### Конструкторы
`File(){ fd = -1; }`
### Конструкторы преобразования 
Конструктор, который получает на вход один параметр, имеющий тип, отличный от описываемого.
### Дескрукторы
`~File() { if(fd!=-1) close(fd); }`
### Ссылки
`int &r`
### Константные ссылки
`const int &r`

> Слева от присваивания, а ровно и в дргуих модифицирующих случаях могут применятсься ссылки и только они, если же ссылка применяется в выражении, в котором требуется значение, то ссылка автоматически преобразуется к своему значению (т.е. выполняется извлечение из памяти).

### Константные методы
```
class C1 {
  void method(int a, int b) const
};
```
> Он заведомо не может изменить состояние объекта (значение его полей).

> При написании программ рекомендуется все методы, которые по своему смыслу не должны изменять состояние объекта, обязательно помечать как константные, тем самым разрешая вызывать их для константных объектов

### Операции работы с динамической памятью
Создание:
```
int *p  ;
p = new int;

Complex *p;
p = new Complex(2.4, 7.12);

int *p = new int[200] // массив из 200 чисел
```
Удаление:
```
delete p;
delete [] p; // удаление массива
```
### Конструктор копирования
```
class Cls1 {
  int *p;
public:  
  Cls1() { p = new int[20]; }
  Cls1(const Cls1& a) { // конструктор копирования
    p = new int[20];
    for(int i=0; i<20; i++)
      p[i] = a.p[i];
  }
  ~Cls1() { delete [] p; }
};
```
### Временные и анонимные объекты
```
t = z * Complex(0,1);
```
> Временные и анонимные объекты существуют до момента окончания вычисления выражения, содержащего их, после чего удаляются. Но если временный или анонимный объект был использован в качестве инициализатора ссылки, то такой объект будет существовать до тех пор, пока существует ссылка.

> На временный или анонимный объект нельзя ссылаться неконстантной ссылкой.

> Используйте модификатор `const` для всех ссылок, для которых это возможно.

### Значение параметров по умолчанию
```
void f(int a = 3, const char *b = "string", int c = 5);
```
Пример конструктора по умолчанию, преобразования и обычного конструктора от двух аргументов:
```
Complex(double a_re = 0, double a_im = 0) { re = a_re; im = a_im; } 
```
Такой конструктор может быть вызван и без параметров, то есть как конструктор по умолчанию, и с одним параметром типа `double`, то есть как конструктор преобразования из `double` в `Complex`.

### Описание метода вне класса. Области видимости.

```
class C1 {
  public:
    C1();
    void f(int a, int b);
    int g(const char *str) const;
  };
 
 C1::C1()
 {
  // тело конструктора 
 }
 
 void C1::f(int a, int b)
 {
  // тело метода f
 }
 
 int C1::g(const char *str) const
 {
  // тело метода g
 }
```

> Вызов глобальной функции `func` из программы в классе, где также есть метод `func`, можно осуществить так -`::func`.


### Подставляемые функции (inline)
```
inline int f(int x)
{
//
}
```

### Инициализация членов класса в конструкторе 
```
class A {
//...
public:
  A(int x, int y) { /.../ }
};

class B {
  A a;
public:
  B::B() : a(2, 3) {/.../} // инициализация членов класса в конструкторе
  // ...
};
```
> Инициализаторы полей должны следовать в списке после двоеточия в том же порядке, в котором сами поля описаны в классе.

```
class Complex {
  double re, im;
public:
  Complex(double a_re, double a_im) : re(a_re), im(a_im) {}
  Complex(double a_re) : re(a_re), im(0) {}
  Complex() : re(0), im(0) {}
  //...
```

### Перегрузка операций простыми функциями
```
Complex operator+(const Complex& a, const Complex& b)
{
  return Complex(a.GetRe() + b.GetRe(), a.GetIm() + b.GetIm());
}

Complex z, t;
z = t + 0.5;
z = 0.5 + t;

// Выражение a + b компилятор пытается превратить в одно из следующих выражений
a.operator+(b)
operator+(a,b)
```
### Дружественные функции и классы
Все детали реализации класса или структуры будут доступны 
```
class Complex {
  friend Complex operator+(const Complex&, const Complex&);
  //..
}
Complex operator+(const Complex& a, const Complex& b)
{
  return Complex(a.re + b.re, a.im + b.im);
}
```
Дружественной может быть и обычная функция
```
class Cls1 {
  friend void f(int, const char*);
  //...
};

void f(int, const char *)
{
    // используются закрытые поля Cls1
}
```
Можно сделать дружественной целый класс 
```
class A {
  friend class B;
};
```

### Переопределение операций присваивания
```
class Complex {
  const Complex& operator=(const Complex& c)
    { re = c.re; im = c.im; return *this; }
  const Complex& operator+=(const Complex& c)
    { re += c.re; im += c.im; return *this; }
};
```
Или ничего не возвращая:
```
class Complex {
  void operator=(const Complex& c)
    { re = c.re; im = c.im; }
  void operator+=(const Complex& c)
    { re += c.re; im += c.im; }
```
Аргумент операции присваивания не обязан иметь тот же тип, что и описываемый класс:
```
class Complex {
  void operator=(double x) { re = x; im = 0; }
};
```

### Методы, возникшие неявно
> Конструктор копирования неявно генерируется для любого класса или структуры, в которых программист не описал конструктор копирования явно.

> Конструктор по умолчанию генерируется неявно, если программист не описал в структуре или классе вообще ни одного конструктора.

> Если в некотором классе A не описать явным образом операцию присваивания с параметром, имеющим тот же тип А или ссылку на него, то компилятор неявно создаст операцию со следующим профилем:
```
class A {
  // ...
  A& A::operator=(const A& other);
  // ...
};
```

> Для запрета копирования объекта некоторого класса, необходимо описать конструктор копирования объекта класса в приватной части класса
```
class A {
  // ...
private: 
  void operator=(const A& ref) {} // no assign
};
```
### Переопределение операции индексирования
```
int& IntArray::operator[](unsigned int idx)
{
  if(idx >= size)
    Resize(idx);
  return p[idx];
}
```
### Переопределение операций ++ и --
```
class A {
public: 
  void operator++() { printf("first\n"); }
  void operator--() { printf("second\n"); }
  void operator++(int) { printf("third\n"); }
  void operator--(int) { printf("fourth\n"); }
};

A a;
++a; // first
a++; // third
--a; // second
a--; // fourth
```
Возвращение значений:
```
class MyInt {
  int i;
public: 
  MyInt(int x) : i(x) {}
  const MyInt& operator++() { i++; return *this; }
  MyInt operator++(int)
    { MyInt tmp(*this); i++; return tmp; } 
  // ...
```
### Переопределение операции ->
```
s1* operator->() const { return p; }
```
### Переопределение операции вызова функции
```
void operator()() {}
```
### Переопределение операции преобразования типа
Операция неявного преобразования типов определяется методом, имя которого состоит из слова `operator` и имени типа, к которому будет происходить преобразование.
```
class A {
  // ...
public:
  // ...
  operator int() const { /* ... */ }
};

A a;
int x;
// ...
x = a;
```
### Статические поля и методы
Переменные и методы, доступные только ищ класса и/или воспринимаются как его часть, но, с другой стороны, не привязаны ни к какому из объектов и могут использоваться даже когда ни одного объекта данного класса не существует - **такие члены класса называются статическими (static)**.

> Время жизни статической переменной совпадает с временем жизни работы программы (как у глобальных переменных).

```
class A {
  // ...
  static int the_static_field;
  // ...
};
```
Чтобы завершить создание статического поля, нужно вне заголовка класса поместить его описание:
```
int A::the_static_field = 0;
```
Обращение:
```
A a;
a.the_static_field = 15;
A::the_static_field = 15;
```

> Использование статических полей рекомендуется в одной ситуации: когда такое поле представляет собой константу, то есть его значение никогда не изменяется во время работы программы.

**Статический метод** - это особый вид функции-метода, которая, являясь методом класса и имея доступ к его закрытми деталям реализации, при этом вызывается независимо от объектов класса.

```
class Cls {
  //...
  static int TheStaticMethod(int a, int b);
  //...
};

Cls::TheStaticMethod(5, 15); 
Cls c;
c.TheStaticMethod(5, 15);
```
### Возбуждение исключений
```
unsigned int line_count_in_file(count char *file_name)
{
  FILE *f = fopen(file_name, "r");
  if(!f)
    throw "couldnt open the file"; // возбуждение исключения
  int n = 0;
  int c = 0;
  while ((c = fgetc(f)) != EOF)
    if(c == '\n')
      n++;
  fclose(f);
  return n;
}
```
### Обработка исключений
В данном случае ловим исключение `const char*`, а не просто `char*`, поскольку именно такой тип (адрес константы типа `char`) имеет в Си и Си++ строковый литерал. Если убирать модификатор `const`, исключение поймано не будет.
```
#include <stdio.h>

unsigned int line_count_in_file(const char *file_name);

int main(int argc, char **argv)
{
  if(argc<2) {
    fprintf(stderr, "No file name\n");
    return 1;
  }
  try {
    int res = line_count_in_file(argv[1]);
    printf("The file %s contains %d lines\n", argv[1], res);
  }
  catch(const char *exception) {
    fprintf(stderr, "Exception (string): %s\n", exception);
    return 1;
  }
  return 0;
}
```
> В этом примере исключение может возникнуть в функции, из `try` блока, но также может возникнуть в функции, вызванной из `line_count_in_file` прямо или косвенно на любую глубину. 

```
try {
  //...
}
catch(const char *x) {
  //...
}
catch(int x) {
  //...
}
```
> Если исключение не поймано ни одним из обработчиков, оно выбрасывается дальше, как если бы фрагмент кода, в котором исключение возникло, вовсе не был обрамлен никаким `try` блоком.

### Обработчики с многоточием
Ловит произвольное исключение вне зависимости от его типа
```
int main()
{
  try {
    // код 
    return 0;
  }
  catch(const char *x) {
    fprintf(stderr, "Exception (string): %s\n", x);
  }
  catch(int x) {
    fprintf(stderr, "Exception (int): %d\n", x);
  }
  catch(...) {
    fprintf(stderr, "Something strange caught\n");
  }
  return 1;
}
```
Освобождение памяти при возникновения исключения:
```
void f(int n)
{
  int *p = new int[n];
  try {
    // остальной код функции
  }
  catch(...) {
    delete[] p;
    throw; // бросает исключение дальше
  }
  delete[] p;
}
```
### Объект класса в роли исключения
Тот объект, который поймается в обработчике исключения, заведомо не может быть тем же экземпляром объекта, который фигурировал в операторе `throw`, и является его копией. Поэтому практически всегда в классе, используемом для исключений, описывают конструктор копирования.
```
class FileException {
  int err_code;
  char *filename;
  char *comment;
public:
  FileException(const char *fn, const char *cmt);
  FileException(const FileException& other);
  ~FileException();
  const char *GetName() const { return filename; }
  const char *GetComment() const { return comment; }
  int GetErrno() const { return err_code; }
private:
  static char *strdup(const char *str);
};
```
### Автоматическая очистка 
Компилятор гарантирует вызов деструкторов для всех локальных объектов, у которых деструкторы есть, прежде чем функция завершится - по исключению ли или обычным путем. **Это называется автоматической очисткой**.

### Преобразование типов исключений
Любой тип может быть преобразован к ссылке на этот тип, если оператор `throw` использует выражение `A`, то такое исключение может быть обработано `catch` блоком вида `catch(A &ref)`.


### Наследование структур и полиморфизм адресов
С++ разрешает неявное преобразование адреса переменной порожденного типа в адрес объекта родительского типа.
```
student s1;
person *p;
p = &s1;
person &ref = s1;
```
### Методы и защита при наследовании
Все свойства класса А будут доступны для объектов класса В отовсюду.
```
class B : public A {
  // ...
};
```
Из методов класса С, будут доступны для объекта класса, а остальная программа не будет знать, что класс С унаследован от А.
```
class C : private A {
  // ...
};
```
### Конструирование и деструкция наследника
```
class A {
  // ...
public:
  A(int p, int q) { // ... }
  // ...
};

class B : public A {
  int i;
public:
  B();
  // ...
};
```
Конструктор:
```
B::B() : A(2,3), i(4)
{
  // ...
}
```
### Виртуальные функции
Виртуальным методом задается реакция объекта класса на некоторый тип сообщений в случае, если:
* предполагается, что у данного класса будут классы потомки
* объекты классов-потомков будут способны получать сообщения того же типа
* объекты некоторых или всех потомков будут реагировать на эти сообщения иначе, чем это делает объект класса-предка.

```
class Pixel {
protected:
  double x, t;
  int color;
public: 
  Pixel(double ax, double ay, int acolor)
    : x(ax), y(ay), color(acolor) {}
  virtual ~Pixel() {}
  virtual void Show();
  virtual void Hide();
  void Move(double nx, double ny);
};

class Circle : public Pixel {
  double radius;
public:
  Circle(double x, double y, double rad, int color)
    : Pixel(x, y, color), radius(rad) {}
  virtual ~Circle() {}
  virtual void Show();
  virtual void Hide();
};
```
> Функции совпадающие по профилю с виртуальными функциями базового класса, объявляются виртуальными автоматически.

**Чисто виртуальная функция**
```
class A {
  // ...
  virtual void f() = 0;
  // ...
};
```
Видя на месте тела функции специальную лексическую последовательность `= 0`, компилятор воспринимает функцию как чисто виртуальную.

> Класс, в которым есть хотя бы одна чисто виртуальная функция, называется **абстрактным классом**. Компилятор не позволяет создавать объекты абстрактных классов.

> Если в порожденном классе не описывается хотя бы одна из функций, объявленных в базовом классе как чисто виртуальные, компилятор считает, что функция осталась чисто виртуальной. Такой класс-потомок считается абстрактным, как и его предок.

### Виртуальность в конструкторах и деструкторах
Во время выполнения тела конструктора вызываются те виртуальные функции, которые описаны для данного класса, вне зависимости от того, объект какого класса на самом деле конструируется.


