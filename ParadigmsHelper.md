### C++
* Конструкторы
`~File(){ fd = -1; }`
* Конструкторы преобразования - конструктор, который получает на вход один параметр, имеющий тип, отличный от описываемого.
* Дескрукторы
`~File() { if(fd!=-1) close(fd); }`
* Ссылки
`int &r`
* Константные ссылки
`const int &r`

> Слева от присваивания, а ровно и в дргуих модифицирующих случаях могут применятсься ссылки и только они, если же ссылка применяется в выражении, в котором требуется значение, то ссылка автоматически преобразуется к своему значению (т.е. выполняется извлечение из памяти).

* Константные методы
```
class C1 {
  void method(int a, int b) const
};
```
> Он заведомо не может изменить состояние объекта (значение его полей).

> При написании программ рекомендуется все методы, которые по своему смыслу не должны изменять состояние объекта, обязательно помечать как константные, тем самым разрешая вызывать их для константных объектов

* Операции работы с динамической памятью
Создание:
```
int *p  ;
p = new int;

Complex *p;
p = new Complex(2.4, 7.12);

int *p = new int[200] // массив из 200 чисел
```
Удаление:
```
delete p;
delete [] p; // удаление массива
```
* Конструктор копирования
```
class Cls1 {
  int *p;
public:  
  Cls1() { p = new int[20]; }
  Cls1(const Cls1& a) { // конструктор копирования
    p = new int[20];
    for(int i=0; i<20; i++)
      p[i] = a.p[i];
  }
  ~Cls1() { delete [] p; }
};
```
* Временные и анонимные объекты
```
t = z * Complex(0,1);
```
> Временные и анонимные объекты существуют до момента окончания вычисления выражения, содержащего их, после чего удаляются. Но если временный или анонимный объект был использован в качестве инициализатора ссылки, то такой объект будет существовать до тех пор, пока существует ссылка.

> На временный или анонимный объект нельзя ссылаться неконстантной ссылкой.

> Используйте модификатор `const` для всех ссылок, для которых это возможно.

* Значение параметров по умолчанию
```
void f(int a = 3, const char *b = "string", int c = 5);
```
Пример конструктора по умолчанию, преобразования и обычного конструктора от двух аргументов:
```
Complex(double a_re = 0, double a_im = 0) { re = a_re; im = a_im; } 
```
Такой конструктор может быть вызван и без параметров, то есть как конструктор по умолчанию, и с одним параметром типа `double`, то есть как конструктор преобразования из `double` в `Complex`.

* Описание метода вне класса. Области видимости.

```
class C1 {
  public:
    C1();
    void f(int a, int b);
    int g(const char *str) const;
  };
 
 C1::C1()
 {
  // тело конструктора 
 }
 
 void C1::f(int a, int b)
 {
  // тело метода f
 }
 
 int C1::g(const char *str) const
 {
  // тело метода g
 }
```

> Вызов глобальной функции `func` из программы в классе, где также есть метод `func`, можно осуществить так -`::func`.



  
    
