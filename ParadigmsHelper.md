### C++
#### Конструкторы
`~File(){ fd = -1; }`
* Конструкторы преобразования - конструктор, который получает на вход один параметр, имеющий тип, отличный от описываемого.
* Дескрукторы
`~File() { if(fd!=-1) close(fd); }`
* Ссылки
`int &r`
* Константные ссылки
`const int &r`

> Слева от присваивания, а ровно и в дргуих модифицирующих случаях могут применятсься ссылки и только они, если же ссылка применяется в выражении, в котором требуется значение, то ссылка автоматически преобразуется к своему значению (т.е. выполняется извлечение из памяти).

* Константные методы
```
class C1 {
  void method(int a, int b) const
};
```
> Он заведомо не может изменить состояние объекта (значение его полей).

> При написании программ рекомендуется все методы, которые по своему смыслу не должны изменять состояние объекта, обязательно помечать как константные, тем самым разрешая вызывать их для константных объектов

* Операции работы с динамической памятью
Создание:
```
int *p  ;
p = new int;

Complex *p;
p = new Complex(2.4, 7.12);

int *p = new int[200] // массив из 200 чисел
```
Удаление:
```
delete p;
delete [] p; // удаление массива
```
* Конструктор копирования
```
class Cls1 {
  int *p;
public:  
  Cls1() { p = new int[20]; }
  Cls1(const Cls1& a) { // конструктор копирования
    p = new int[20];
    for(int i=0; i<20; i++)
      p[i] = a.p[i];
  }
  ~Cls1() { delete [] p; }
};
```
* Временные и анонимные объекты
```
t = z * Complex(0,1);
```
> Временные и анонимные объекты существуют до момента окончания вычисления выражения, содержащего их, после чего удаляются. Но если временный или анонимный объект был использован в качестве инициализатора ссылки, то такой объект будет существовать до тех пор, пока существует ссылка.

> На временный или анонимный объект нельзя ссылаться неконстантной ссылкой.

> Используйте модификатор `const` для всех ссылок, для которых это возможно.

* Значение параметров по умолчанию
```
void f(int a = 3, const char *b = "string", int c = 5);
```
Пример конструктора по умолчанию, преобразования и обычного конструктора от двух аргументов:
```
Complex(double a_re = 0, double a_im = 0) { re = a_re; im = a_im; } 
```
Такой конструктор может быть вызван и без параметров, то есть как конструктор по умолчанию, и с одним параметром типа `double`, то есть как конструктор преобразования из `double` в `Complex`.

* Описание метода вне класса. Области видимости.

```
class C1 {
  public:
    C1();
    void f(int a, int b);
    int g(const char *str) const;
  };
 
 C1::C1()
 {
  // тело конструктора 
 }
 
 void C1::f(int a, int b)
 {
  // тело метода f
 }
 
 int C1::g(const char *str) const
 {
  // тело метода g
 }
```

> Вызов глобальной функции `func` из программы в классе, где также есть метод `func`, можно осуществить так -`::func`.


* Подставляемые функции (inline)
```
inline int f(int x)
{
//
}
```

* Инициализация членов класса в конструкторе 
```
class A {
//...
public:
  A(int x, int y) { /.../ }
};

class B {
  A a;
public:
  B::B() : a(2, 3) {/.../} // инициализация членов класса в конструкторе
  // ...
};
```
> Инициализаторы полей должны следовать в списке после двоеточия в том же порядке, в котором сами поля описаны в классе.

```
class Complex {
  double re, im;
public:
  Complex(double a_re, double a_im) : re(a_re), im(a_im) {}
  Complex(double a_re) : re(a_re), im(0) {}
  Complex() : re(0), im(0) {}
  //...
```

* Перегрузка операций простыми функциями
```
Complex operator+(const Complex& a, const Complex& b)
{
  return Complex(a.GetRe() + b.GetRe(), a.GetIm() + b.GetIm());
}

Complex z, t;
z = t + 0.5;
z = 0.5 + t;

// Выражение a + b компилятор пытается превратить в одно из следующих выражений
a.operator+(b)
operator+(a,b)
```
* Дружественные функции и классы
Все детали реализации класса или структуры будут доступны 
```
class Complex {
  friend Complex operator+(const Complex&, const Complex&);
  //..
}
Complex operator+(const Complex& a, const Complex& b)
{
  return Complex(a.re + b.re, a.im + b.im);
}
```
Дружественной может быть и обычная функция
```
class Cls1 {
  friend void f(int, const char*);
  //...
};

void f(int, const char *)
{
    // используются закрытые поля Cls1
}
```
Можно сделать дружественной целый класс 
```
class A {
  friend class B;
};
```

* Переопределение операций присваивания
```
class Complex {
  const Complex& operator=(const Complex& c)
    { re = c.re; im = c.im; return *this; }
  const Complex& operator+=(const Complex& c)
    { re += c.re; im += c.im; return *this; }
};
```
Или ничего не возвращая:
```
class Complex {
  void operator=(const Complex& c)
    { re = c.re; im = c.im; }
  void operator+=(const Complex& c)
    { re += c.re; im += c.im; }
```
Аргумент операции присваивания не обязан иметь тот же тип, что и описываемый класс:
```
class Complex {
  void operator=(double x) { re = x; im = 0; }
};
```

* Методы, возникшие неявно



