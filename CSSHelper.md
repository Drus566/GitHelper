# Содержание
1. [Основа](#1)
* 1.1 [Популярные псевдоклассы](#1.1)
* 1.2 [Дочерние селекторы](#1.2)
* 1.3 [Дополнительные псевдоклассы](#1.3)
* 1.4 [Соседние селекторы](#1.4)
* 1.5 [Родственные селекторы](#1.5)
* 1.6 [Селекторы атрибутов](#1.6)
* 1.7 [Атрибуты со значениями](#1.7)
* 1.8 [Выборка по началу текста](#1.8)
* 1.9 [Выборка по концу текста](#1.9)
* 1.10 [Наследование](#1.10)
* 1.11 [Сброс стилей](#1.11)
2. [Работа с текстом](#2)
* 2.1 [Шрифт](#2.1)
* 2.2 [Подключаем веб-шрифт с помощью `@font-face`](#2.2)
* 2.3 [Шрифты Google Fonts](#2.3)
* 2.4 [Размер шрифта в процентах](#2.4)
* 2.5 [Единица измерения `em`](#2.5)
* 2.6 [Единица измерения `rem`](#2.6)
* 2.7 [Ключевые слова](#2.7)
* 2.8 [Жирный шрифт в CSS: свойство `font-weigh`](#2.8)
* 2.9 [Курсив в CSS: свойство `font-style`](#2.9)
* 2.10 [Прописные и строчные буквы в CSS: свойство `text-transform`](#2.10)
* 2.11 [Подчеркивание, зачеркивание текста в CSS: свойство `text-decoration`](#2.11)
* 2.12 [Тень для текста: свойство CSS `text-shadow`](#2.12)
* 2.13 [Несколько теней CSS для текста](#2.13)
* 2.14 [Межсимвольный интервал CSS: `letter-spacing`](#2.14)
* 2.15 [Интервал между словами: `word-spacing`](#2.15)
* 2.16 [Межстрочный интервал: `line-height`](#2.16)
* 2.17 [Выравнивание текста в CSS: свойство `text-align`](#2.17)
* 2.18 [`List-style-type`: изменение маркера / нумерации](#2.18)
* 2.19 [`List-style-image`: маркер-картинка](#2.19)
* 2.20 [`List-style-position`: расположение маркеров / нумерации](#2.20)
* 2.21 [`List-style`: все вместе](#2.21)
3. [Блоки](#3)
* 3.1 [Базовый набор](#3.1)
* 3.2 [Поля и отступы CSS: отличия свойств `margin` и `padding`](#3.2)
* 3.3 [Схлопывание `margin`](#3.3)
* 3.4 [Блочные элементы](#3.4)
* 3.5 [Строчные элементы](#3.5)
* 3.6 [CSS-свойство `display`: меняем тип элемента](#3.6)
* 3.7 [`Border-width`: ширина границы](#3.7)
* 3.8 [`Border-color`: цвет границы](#3.8)
* 3.9 [`Border-style`: стиль границы](#3.9)
* 3.10 [Общее CSS-свойство `border`: 3 в 1](#3.10)
* 3.11 [Как закруглить углы: свойство CSS3 `border-radius`](#3.11)
* 3.12 [Принцип скругления углов](#3.12)
* 3.13 [Свойство `box-shadow`: синтаксис](#3.13)
* 3.14 [`Width` и `height`: определяем размеры элемента](#3.14)
* 3.15 [`Box-sizing`](#3.15)
* 3.16 [`Overflow`: управление переполненными элементами](#3.16)
* 3.17 [`Max-width`, `max-height`, `min-width`, `min-height`: максимальные и минимальные размеры элемента](#3.17)
* 3.18 [CSS `float`](#3.18)
* 3.19 [Отмена обтекания: свойство `clear`](#3.19)
4. [Работа с графикой](#4)
5. [Ссылки и навигация](#5)
6. [Трансформация и анимация](#6)
7. [Разметка](#7)

# Основа <a name="1"></a>
## Популярные псевдоклассы CSS <a name="1.1"></a>
* `:link` – этот псевдокласс задает стиль ссылкам, по которым пользователь еще не перешел;
* `:visited` – этот же, наоборот, применяет стиль к уже посещенным ссылкам;
* `:hover` – определяет стиль элемента, когда на него наведен курсор (может применяться не только к ссылкам);
* `:active` – задает стиль активной ссылке (то есть, в момент клика по ней);
* `:focus` – применяет стиль к элементу при фокусировке на нем (например, при установке курсора в строку поиска);
* `:not()` – этот полезный псевдокласс позволяет выбрать и стилизовать только те элементы, которые не содержат селектор, указанный в скобках.
* `::after` – используется вместе со свойством `content` и позволяет вывести необходимые данные после содержимого элемента;
* `::before` – выполняет похожую функцию, что и предыдущий, только выводит данные перед содержимым элемента;
* `::selection` – этот псевдоэлемент распознается браузерами только при использовании двух двоеточий и позволяет установить цвет и фон для текста, который выделен пользователем;
* `::first-letter` – используется для изменения стиля первого символа в тексте элемента;
* `::first-line` – используется для изменения стиля первой строки текста элемента.

## Дочерние селекторы CSS <a name="1.2"></a>
```
body > p {
	color: #333;
}
```
Обратите внимание на символ `>` после `body`. С помощью него вы указываете, что стиль применяется исключительно для дочерних тегов `<p>` родителя `<body>`. Если символ убрать, то стиль применится абсолютно ко всем тегам `<p>`, которые находятся внутри тега `<body>`, хотя они могут и не являться для него дочерними.

## Дополнительные псевдоклассы <a name="1.3"></a>
* `:first-child` – с помощью этого псевдокласса можно применить стиль к указанному элементу веб-страницы, при условии, что он является первым дочерним элементом своего родителя;
* `:last-child` – стиль применяется к указанному элементу веб-страницы при условии, что он является последним дочерним элементом своего родителя;
* `:nth-child` – позволяет выбрать четные (`even`) и нечетные (`odd`) дочерние элементы; также с помощью данного псевдокласса можно стилизовать чередующиеся дочерние элементы, используя выражения вида `an+b` и числа;
* `:only-child` – применяется к дочернему элементу при условии, что тот является единственным ребенком у родителя;
* `:first-of-type` – стиль применяется к первому элементу указанного типа (даже если этот элемент не является первым дочерним для своего родителя и над ним находятся другие дочерние элементы других типов);
* `:last-of-type` – работает точно так же, как и предыдущий псевдокласс, с той лишь разницей, что стиль применяется к последнему элементу указанного типа;
* `:nth-of-type` – по принципу работы похож на `:nth-child`, но ориентируется на тип элемента;
* `:only-of-type` – применяется к дочернему элементу указанного типа при условии, что тот является у родителя единственным ребенком своего типа.

## Соседние селекторы <a name="1.4"></a>
```
h1+p {
  font-style: italic;
}
```
Записывая это правило, в первую очередь необходимо указать имя первого соседа, затем добавить символ `+` и имя второго соседа (того, к которому мы желаем применить стиль). Можно создавать и более длинные комбинации. Схема написания селектора такая: `selector1+selector2+…+selectorN {}` (стиль применяется к `selectorN`).
Примеры написания:
```
/* Отступ от абзаца до картинки 30px */
p+img {
   padding-top: 30px;
}
```
```
/* Зеленый цвет для абзаца, который следует после h3 в связке с h2 */
h2+h3+p {
   color: green;
}
```
## Родственные селекторы <a name="1.5"></a>
```
h1 ~ p {
  font-style: italic;
}
```
…и немного HTML для примера:
```
<div>
  <p>Текст</p>
  <h1>Заголовок 1</h1>
  <p>Текст</p>
  <p>Текст</p>
  <h2>Заголовок 2</h2>
  <p>Текст</p>
 </div>

<div>
  <p>Текст</p>
 </div>
```
Взгляните на HTML-код: стиль **применится ко всем тегам `p`, которые следуют после тега `h1` и находятся до закрывающего тега родителя `div`**. В нашем варианте насчитывается 3 элемента `p`, к которым применится стиль.
  Используя соседние (смежные) селекторы, вы можете применять стиль к элементу в случае, когда он следует сразу за другим элементом (или группой элементов). Это работает с элементами, которые находятся на одном уровне и имеют общего родителя.
  С помощью родственных селекторов можно применять стиль ко всем элементам выбранного типа в случае, когда они следуют сразу за другим элементом (или группой элементов). Это работает с элементами, которые находятся на одном уровне и имеют общего родителя.

## Селекторы атрибутов <a name="1.6"></a>
С помощью CSS селекторов атрибутов (англ. attribute selectors) вы можете задавать стиль тем тегам, которые имеют указанные атрибуты. Пример: вы желаете присвоить определенный стиль всем фотографиям, которые имеют атрибут `title`, не затрагивая все остальные изображения. Делается это просто:
```
img[title] {
   width: auto;
   height: auto;
}
```
Как видим, атрибут `title` записан в квадратных скобках после названия img, затем идет блок объявлений. А что если вам понадобится создать стиль только для тех изображений с атрибутом `title`, которым присвоен определенный класс, скажем, `.gallery?` В таком случае это записывается так:
```
.gallery[title] {
   width: auto;
   height: auto;
}
```
## Атрибуты со значениями <a name="1.7"></a>
```
img[title="portrait"] {
   border-style: solid;
}
```
## Выборка по началу текста <a name="1.8"></a>
Селекторы атрибутов также могут пригодиться при оформлении ссылок. Представьте, что вам нужно особым образом выделить все адреса URL с протоколом `https://`. Для этого достаточно описать, как выглядит начало адреса URL:
```
a[href^="https://"] {
   color: green;
}
```
Обратите внимание на символ `^`, который в переводе на наш язык означает «начинается с». Используя его, вы можете придавать свой стиль различным ссылкам (и не только им). Например, чтобы изменить цвет всех ссылок, которые ведут на главную или другие страницы `https://google.com`, нужно записать:
```
a[href^="https://google.com"] {
   color: green;
}
```
Обратите внимание на то, что наш стиль будет применен строго к тем ссылкам, которые начинаются так `https://google.com`. Другие варианты написания ссылок, например, `https://www.google.com` или `http://google.com`, необходимо записывать отдельно. Пример:
```
a[href^="https://google.com"] {
   color: green;
}

a[href^="https://www.google.com"] {
   color: green;
}


/* Или более короткий способ: */

a[href^="https://google.com"], [href^="https://www.google.com"] {
   color: green;
}
```
## Выборка по концу текста <a name="1.9"></a>
А может быть вы желаете красиво оформить все ссылки на файлы с расширением `.rar`? Тогда вам понадобится описать, как выглядит окончание URL:
```
a[href$=".rar"] {
	color: #FFF;
	text-decoration: none;
	background-color: orange;
	padding: 5px 10px;
	cursor: pointer;
}
```
Не забудьте указать после названия атрибута символ `$`, который означает «заканчивается на».

## Наследование <a name="1.10"></a>
С помощью inherit можно указать, чтобы элемент наследовал значение свойства у своего предка. Такое значение доступно практически для каждого свойства в CSS.

Для демонстрации используем предыдущий пример: чтобы всё-таки заставить теги `p` унаследовать рамку `border` от своего предка `body`, необходимо записать:
```
p {
   border: inherit;
}
```
## Сброс стилей <a name="1.11"></a>
* reset css
* normalize


# Работа с текстом <a name="2"></a>
## Шрифт <a name="2.1"></a>
Допустим, вы желаете оформить текст шрифтом `Verdana`, а в качестве запасных установить шрифты `Trebuchet MS`, `Geneva` и любой шрифт без засечек. Записывается это таким образом:
```
p  {
   font-family: Verdana, "Trebuchet MS", Geneva, sans-serif;
}
```
Обратите внимание: в коде мы записали название шрифта Trebuchet MS в кавычках. Необходимо брать название шрифта в двойные либо одинарные кавычки тогда, когда в нем содержатся пробелы.

## Подключаем веб-шрифт с помощью `@font-face` <a name="2.2"></a>
Предположим, у вас есть свой уникальный шрифт под названием `MyUniqueFont` в формате `TTF` и вы желаете, чтобы основной текст веб-страницы отображался именно этим шрифтом. Первое, что нужно сделать, это скопировать файл шрифта в папку, где находятся все остальные файлы сайта. Чтобы не создавать беспорядок, вы можете создать отдельную папку специально для шрифтов, назвав ее, к примеру, `fonts`.
Далее нам необходимо дать команду браузеру загрузить шрифт `MyUniqueFont`. Записывается это с помощью директивы `@font-face` следующим образом:
```
@font-face {
   font-family: MyUniqueFont;
   src: url('fonts/MyUniqueFont.ttf');
}
```
Свойство `font-family` в данном случае играет другую роль: с помощью него мы присваиваем имя шрифту, чтобы потом использовать это имя при написании стиля:
```
p {
   font-family: MyUniqueFont;
}
```
Во второй строке указывается путь к файлу шрифта. В нашем примере файл `MyUniqueFont.ttf` находится в папке `fonts`. У вас URL-адрес может отличаться.

## Шрифты Google Fonts <a name="2.3"></a>
```
<head>
<link href='http://fonts.googleapis.com/css?family=Roboto&subset=latin,cyrillic'
rel='stylesheet' type='text/css'>

...
</head>
```
Второй способ – подключение шрифта с помощью директивы `@import`. Готовый код находится во второй вкладке пункта 3 на странице выбранного Google-шрифта. Его нужно добавить в самое начало вашей таблицы стилей (в противном случае файл не импортируется). Выглядит код примерно так:
```
@import url(http://fonts.googleapis.com/css?family=Roboto&subset=latin,cyrillic);
```
После осуществления предыдущих шагов можно начать применять шрифт. Как записывается такое правило CSS, вы уже видели ранее:
```
p {
   font-family: 'Roboto', sans-serif;
}
```
Если на первом шаге вы выбрали несколько вариантов начертания (к примеру, добавили вариант жирного шрифта Bold 700), тогда на третьем шаге код немного видоизменится:
```
<link href='http://fonts.googleapis.com/css?family=Roboto:700,400&subset=latin,cyrillic'
rel='stylesheet' type='text/css'>
```
Или:
```
@import url(http://fonts.googleapis.com/css?family=Roboto:700,400&subset=latin,cyrillic);
```
Чтобы затем придать шрифту жирное начертание, запишите CSS-стиль таким образом:
```
p {
   font-family: 'Roboto', sans-serif;
   font-weight: 700;
}
```
## Размер шрифта в процентах <a name="2.4"></a>
Вы наверняка уже сталкивались с ситуацией, когда размер шрифта в CSS не задан, вследствие чего браузеру приходится определять размер шрифта «по своему усмотрению». Если точнее, берется предустановленное значение по умолчанию. Именно от него зависят установленные в процентах значения. Например, базовый размер основного текста `p`, как правило, равняется 16 пикселям. Значение 100% эквивалентно базовому размеру шрифта, который предустановлен в браузере. Поэтому:
```
p {
   font-size: 100%;
}
```
...то же самое, что и значение в браузере по умолчанию:
```
p {
   font-size: 16px;
}
```
Если же в этом случае задать размер шрифта 50%, то он будет равен половине базового размера. Значение 200%, наоборот, увеличит шрифт в два раза.
> Важно: процентные значения размера шрифта наследуются. Например, если для родительского тега задан размер шрифта 150%, то все вложенные в него теги также унаследуют это значение.

## Единица измерения `em` <a name="2.5"></a>
По принципу работы единица измерения `em` похожа на проценты. Значение `1em` эквивалентно 100% и соответствует базовому размеру шрифта по умолчанию. Соответственно, `0.6em = 60%`, `3em = 300%` и так далее. Пример записи:
```
font-size: 0.9em;

/* перед точкой можно опустить ноль: */

font-size: .9em;
```
Значения размеров шрифтов, указанные в `em`, наследуются (как и проценты). Это создает некоторые трудности при работе с CSS. Например, если для родительского элемента `div` задан размер шрифта `2em`, то для вложенного в него такого же элемента `div` шрифт будет увеличен еще в два раза. 

## Единица измерения `rem`<a name="2.6"></a>
В качестве альтернативы можно воспользоваться новой единицей измерения, введенной в CSS3 – `rem`, которая всегда отталкивается от базового размера шрифта.
Недостатком единицы измерения `rem` является то, что она не поддерживается некоторыми браузерами, а именно Internet Explorer версии 8 (и ранее), а также Opera Mini 8.

## Ключевые слова <a name="2.7"></a>
* `xx-small` 9px
* `x-small` 10px
* `small` 13px
* `medium` 16px
* `large` 19px
* `x-large` 24px
* `xx-large` 32px

Как видим, значение `medium` соответствует базовому размеру шрифта `16px`. 
> Использование ключевых слов ограничивает возможности и лишает гибкости, поэтому профессиональные разработчики не применяют их.

## Жирный шрифт в CSS: свойство `font-weight` <a name="2.8"></a>
* `bold` - Полужирный шрифт
* `normal` - Обычный шрифт
* `bolder` - Более жирный шрифт, чем у родителя
* `lighter` - Менее жирный шрифт, чем у родителя
* `inherit` - Наследует значение родителя
* `Числовое значение от 100 до 900` - От очень тонкого до очень жирного шрифта

Пример записи:
```
p {
   font-weight: bold;
}
```

## Курсив в CSS: свойство `font-style` <a name="2.9"></a>
* `italic` Курсивный шрифт
* `oblique` Наклонный шрифт
* `normal` Обычный шрифт
* `inherit` Наследует значение родителя

Пример записи:
```
p {
   font-style: italic;
}
```

## Прописные и строчные буквы в CSS: свойство `text-transform` <a name="2.10"></a>
* `uppercase` Делает заглавными (прописными) все буквы в тексте
* `lowercase` Делает строчными все буквы в тексте
* `capitalize` Делает заглавной первую букву каждого слова в тексте
* `none` Не делает изменений
* `inherit` Наследует значение родителя

Пример записи стиля:
```
h3 {
   text-transform: uppercase;
}
```

## Подчеркивание, зачеркивание текста в CSS: свойство `text-decoration` <a name="2.11"></a>
* `underline` Нижнее подчеркивание текста
* `overline` Верхнее подчеркивание текста
* `line-through` Зачеркивание текста
* `blink` Мигание текста
* `none` Удаление всех эффектов
* `inherit` Наследование значений родителя

Пример записи стиля:
```
p a {
   text-decoration: underline;
}
```

## Тень для текста: свойство CSS `text-shadow` <a name="2.12"></a>
```
h1 {
   text-shadow: 3px 5px 6px #6C9;
}
```
Как видно, мы указали целых четыре значения через пробел. Пройдемся по порядку:
* `3px` – первое значение отвечает за смещение тени по оси X (вправо, влево). Положительным значением тень сдвигается вправо, а отрицательным – влево.
* `5px` – второе значение отвечает за смещение тени по оси Y (вниз, вверх). Положительным значением тень сдвигается вниз, а отрицательным – вверх.
* `6px` – третье значение отвечает за радиус размытия тени. Этот параметр указывать необязательно. По умолчанию размытие равняется 0 пикселей, что делает тень четкой и неразмытой.
* `#6c9` – четвертое значение отвечает за цвет тени. Этот параметр указывать необязательно. По умолчанию цвет тени устанавливается такой же, как у текста, к которому применяется стиль.

## Несколько теней CSS для текста <a name="2.13"></a>
Можно установить более двух
```
h1 {
  text-shadow: 3px 5px 6px #6C9, -6px -7px 6px #D9FFA7;
}
```

## Межсимвольный интервал CSS: `letter-spacing` <a name="2.14"></a>
Задать межсимвольный интервал можно с помощью свойства CSS `letter-spacing`. Помимо обычных значений (положительных и отрицательных) также можно использовать значения `inherit` (чтобы наследовать значение у родителя) и `normal` (если необходимо вернуть нормальное расстояние между символами).

Пример записи межсимвольного интервала:
```
p {
   letter-spacing: 2em;
}
```

## Интервал между словами: `word-spacing` <a name="2.15"></a>
Свойство CSS `word-spacing` отличается от предыдущего тем, что устанавливает расстояние между словами, а не между символами. Для данного свойства тоже предусмотрены значения `normal` и `inherit`. Можно задавать отрицательные значения. Ниже показан пример записи стиля:
```
p {
   word-spacing: 6px;
}
```

## Межстрочный интервал: `line-height` <a name="2.16"></a>
С помощью свойства CSS `line-height` можно задавать расстояние между строками текста. Как было сказано в начале темы, для установки интерлиньяжа, помимо других единиц измерения, допускается использовать проценты. Также разрешено записывать значение в виде множителя (числа больше 0): для вычисления расстояния браузер умножит размер шрифта на заданное число. Отрицательные значения не работают. Доступны значения `normal` и `inherit`.

Ниже – пример, как сделать межстрочный интервал CSS:
```
p {
   line-height: 180%;
}
```

## Выравнивание текста в CSS: свойство `text-align` <a name="2.17"></a>
* По левому краю `left`
* По правому краю `right`
* По центру страницы/блока `center`
* По ширине страницы/блока `justify`
* Выравнивание текста по тому краю, с которого он начинается (то есть текст, идущий слева направо, выравнивается по левому краю) `start` 				 	 
* Выравнивание текста по противоположному краю (то есть текст, идущий слева направо, выравнивается по правому краю) `end` 

Пример записи стиля:
```
p {
   text-align: left;
}
```

## `List-style-type`: изменение маркера / нумерации <a name="2.18"></a>
* Маркер-точка (по умолчанию) `disc`
* Маркер-окружность `circle`
* Маркер-квадрат `square`
* Нумерация арабскими цифрами (по умолчанию) `decimal`
* Нумерация арабскими цифрами (перед числами 1-9 добавляется 0) `decimal-leading-zero`
* Нумерация прописными буквами латинского алфавита `upper-latin`
* Нумерация строчными буквами латинского алфавита `lower-latin`
* Наследование значений родителя `inherit`
* Удаление маркеров / нумерации `none`

> Примечание: в таблице приведены только основные значения. Существует более обширный список (грузинская и армянская нумерации, нумерация римскими числами, греческими буквами и т. д.)

## `List-style-image`: маркер-картинка <a name="2.19"></a>
```
ul {
   list-style-image: url(images/star.png);
}
```

## `List-style-position`: расположение маркеров / нумерации <a name="2.20"></a>
Для CSS свойства `list-style-position`, которое задает расположение маркеров / нумерации относительно текста, есть два значения – `outside` и `inside`. По умолчанию используется значение `outside` – это значит, что маркер / число отображается как бы отдельно от текста списка, тогда как при значении `inside маркер` / число располагается внутри текстового блока и обтекается текстом.

Ниже показан пример записи стиля:
```
ul {
   list-style-position: inside;
}
```

## `List-style`: все вместе <a name="2.21"></a>
```
/* нумерация прописными латинскими буквами внутри текстового блока: */
ol {
   list-style: upper-latin inside;
}

/* графические маркеры снаружи текстового блока: */
ul {
   list-style: url(images/star.png) outside;
}
```

# Блоки <a name="3"></a>
## Базовый набор <a name="3.1"></a>
* `padding` (и производные `padding-left`, `padding-right`, `padding-top`, `padding-bottom`) – это внутренний отступ от края содержимого до границы блока. Можно устанавливать отступы либо от всех четырех сторон контента, либо только от нужных вам.
* `margin` (и производные `margin-left`, `margin-right`, `margin-top`, `margin-bottom`) – это поле, которое являет собой расстояние от границы одного блока до другого. Новички иногда путают свойство `margin` со свойством `padding`, поэтому для наглядности ниже показаны рисунки, где лучше понятна разница между этими свойствами. Поля можно задавать как для всех сторон блока одновременно, так и для отдельных.
* `border` (и производные `border-left`, `border-right`, `border-top`, `border-bottom`) – это рамка (граница), которую можно задать для блока. Поля `margin` остаются за пределами рамки, всё остальное находится внутри неё. Рамку можно установить на всех четырех сторонах или только на нужных вам.
* `background-color` – это цвет фона, заливка цветом, которая применяется к заднему фону блока и не выходит за его пределы. Поля этим цветом не закрашиваются, а контент и рамка располагаются поверх фона.

Также можно настраивать ширину `width` и высоту `height` блока (а точнее, контента, который содержится в блоке). Чтобы затем посчитать ширину или высоту всего блока (вместе с отступами, рамкой и полями), необходимо сложить все эти значения. 

Например:
`width + padding-left + border-left + margin-left + padding-right + border-right + margin-right` = полная ширина блока

## Поля и отступы CSS: отличия свойств `margin` и `padding` <a name="3.2"></a>
Создавать промежутки между элементами можно и тем, и другим способом, но если `padding` – это отступ от содержимого до края блока, то `margin` – это расстояние от одного блока до другого, межблоковое пространство.
Значения могут быть указаны в любых единицах CSS – `px`, `em`, `%` и т.д.
Также существует очень удобная вещь как сокращенная запись `margin` и `padding` CSS. Если вам необходимо задать поля или отступы для всех четырех сторон элемента, совсем необязательно записывать свойство для каждой стороны по отдельности. Всё делается проще: для `margin` и `padding` можно указывать сразу 1, 2, 3 или 4 значения. От количества значений зависит, как распределяются настройки:
* 4 значения: задаются отступы для всех сторон элемента в такой последовательности: сверху, справа, снизу, слева: `padding`: 2px 4px 5px 10px;
* 3 значения: задается отступ сначала для верхней стороны, потом одновременно для левой и правой, а затем – для нижней: `padding`: 3px 6px 9px;
* 2 значения: задаются отступы сначала одновременно от верхней и нижней стороны, а затем – одновременно для левой и правой: `padding`: 6px 12px;
* 1 значение: задаются одинаковые отступы для всех сторон элемента:`padding`: 3px;

Те же правила касаются и свойства `margin` CSS. Обратите внимание на то, что для margin можно использовать и отрицательные значения (например, -3px), которые иногда бывают весьма полезными.

## Схлопывание `margin` <a name="3.3"></a>
Схлопывание `margin` работает только для верхних и нижних полей элементов и не относится к полям с правой и левой сторон. Окончательная величина промежутка высчитывается в разных ситуациях по-разному:
* Когда оба значения `margin` положительные, итоговый размер поля будет равен бóльшему значению.
* Если одно из значений является отрицательным, то для вычисления размера поля нужно получить сумму значений. Например, при значениях 20px и -18px размер поля будет равен:
`20 + (-18) = 20 — 18 = 2 пикселя.`
* Если оба значения отрицательные, сравниваются модули этих чисел и выбирается число, бóльшее по модулю (следовательно, меньшее из отрицательных чисел). Пример: необходимо сравнить значения полей -6px и -8px. Модули сравниваемых чисел равны 6 и 8 соответственно. Отсюда следует, что 6 < 8, то есть, -6 > -8. Итоговый размер поля равен -8 пикселей.
* В случае, когда значения указаны в разных единицах CSS, они приводятся к одной, после чего сравниваются и выбирается бóльшее значение.
* Размер `margin` для дочерних элементов определяется еще более интересно: если у потомка поле `margin` больше, чем у родителя, то приоритет отдается ему. В этом случае размеры верхнего и нижнего полей родителя станут такими, как задано у потомка. При этом расстояния между родителем и потомком не будет.

## Блочные элементы <a name="3.4"></a>
Блочные элементы являются основой, которая используется для верстки веб-страниц. Такой элемент представляет собой прямоугольник, который по умолчанию занимает всю доступную ширину страницы (если иное значение не указано в CSS), а длина элемента зависит от его содержимого. Такой элемент всегда начинается с новой строки, то есть, располагается под предыдущим элементом. Блочный элемент может содержать в себе другие блочные и строчные элементы.
Примеры блочных элементов: `<div>, <p>, <ul>, <ol>, <h1>` и другие.

## Строчные элементы <a name="3.5"></a>
В отличие от блочного, строчный элемент не переносится на новую строку, а располагается на той же строке, что и предыдущий элемент. Такие элементы, как правило, находятся внутри блочных элементов и их ширина зависит лишь от содержимого и настроек CSS. Еще одно отличие строчного элемента от блочного заключается к том, что в нем может находиться только контент и другие строчные элементы. Блочные элементы в строчные вкладывать нельзя.
Примеры строчных элементов: `<a>, <span>, <strong>, <em>, <img>` и т. д.	

> в HTML5 порядок вложения тегов такой роли не играет. Элементы уже не просто делятся на блочные и строчные, а группируются по смыслу и назначению, представляя собой категории контента.

## CSS-свойство `display`: меняем тип элемента <a name="3.6"></a>
При помощи крайне полезного свойства `display` в CSS можно заставить блочный элемент выглядеть как строчный и наоборот. Чтобы блочный элемент вел себя как `inline`-элемент (т. е. не переводился на новую строку), для него необходимо записать правило:
```
display: inline;
```
Если же необходимо отобразить строчный элемент как `block`-элемент (чтобы до и после элемента происходил перенос строки), запишите следующее:
```
display: block;
```
Также можно сделать «гибрид» — блочный элемент с поведением, как у строчного. В этом случае всё содержимое таких блочных элементов будет отображаться, как обычно, но при этом блоки будут вести себя как строчные элементы, выстраиваясь в одной строке друг за другом и переносясь на новую строку лишь при необходимости. Схлопывание `margin` в таких случаях перестает действовать. Для превращения элемента в блочно-строчный запишите:
```
display: inline-block;
```

## `Border-width`: ширина границы <a name="3.7"></a>
С помощью свойства `border-width` задается ширина границы. Наиболее часто этот размер указывается в пикселях. Можно задать одинаковую либо различную ширину для всех четырех границ, например:
```
/* все 4 границы имеют ширину 2px: */
border-width: 2px;

/* верхняя и нижняя границы имеют ширину 2px, левая и правая — 4px: */
border-width: 2px 4px;

/* верхняя граница — 2px, левая и правая — 6px, нижняя — 3px: */
border-width: 2px 6px 3px;

/* верхняя граница — 2px, правая — 3px, нижняя — 4px, левая — 5px: */
border-width: 2px 3px 4px 5px;
```
Кроме этого, существуют ключевые слова для обозначения ширины границы:
* `thin` — граница шириной 2px;
* `medium` — граница шириной 4px;
* `thick` — граница шириной 6px.

## `Border-color`: цвет границы <a name="3.8"></a>
Свойство `border-color` задает цвет для границ. Цвета можно указывать в любом формате CSS: ключевыми словами, в шестнадцатеричном виде либо в RGB — зависит от того, как вам удобнее. По аналогии с предыдущим свойством, можно устанавливать как один цвет для всех границ, так и выбирать разные цвета для каждой границы.
```
border-color: #FFFF00;
```
Также можно задать прозрачный цвет, записав:
```
border-color: transparent;
```

## `Border-style`: стиль границы <a name="3.9"></a>
* `solid` — сплошная граница;
* `dotted` — граница из точек;
* `dashed` — пунктирная граница;
* `double` — двойная граница;
* `groove` — объемная граница-выемка;
* `ridge` — объемная граница с толстой кромкой (по сути, инверсия предыдущего стиля);
* `outset` — выдавленная граница;
* `inset` — вдавленная граница (по сути, инверсия предыдущего стиля).

## Общее CSS-свойство `border`: 3 в 1 <a name="3.10"></a>
` border: 2px dotted #FF0000;`

## Как закруглить углы: свойство CSS3 `border-radius` <a name="3.11"></a>
```
.borderElement {
  background-color: #EEDDFF;
  border: 6px solid #7922CC;
  border-radius: 25px;
}

.borderElement1 {
  background-color: #FFE8DB;
  border: 6px solid #FF5A00;
  border-radius: 15px 100px 15px 100px;
}
```
вместо простых круглых углов можно задавать эллиптическое скругление. Для этого понадобится указать два значения, разделенные косой чертой (для горизонтальной и вертикальной полуосей эллипса). Приведем пример на блоке размером `150×450` пикселей:
```
.borderElement {
  background-color: #EEDDFF;
  border: 6px solid #7922CC;
  border-radius: 280px/100px;
}
```
* `border-top-left-radius` — для верхнего левого угла;
* `border-top-right-radius` — для верхнего правого угла;
* `border-bottom-left-radius` — для нижнего левого угла;
* `border-bottom-right-radius` — для нижнего правого угла.

## Принцип скругления углов <a name="3.12"></a>
Eсли для угла указано одно значение, — например, 20px, — это означает, что закругление будет происходить по окружности с радиусом 20 пикселей. В случае, когда задаются два значения через косую черту, например, 30px/20px, закругление углов будет происходить по эллипсу. `Первое значение` в таком случае является длиной горизонтальной полуоси эллипса — 30px, а `второе` — длиной вертикальной полуоси — 20px

## Свойство `box-shadow`: синтаксис <a name="3.13"></a>
Данный стиль записывается следующим образом:
`box-shadow: inset 4px 4px 8px 5px #333333;`

Рассмотрим по порядку, за что отвечает каждый параметр (слева направо):
* Ключевое слово `inset`: параметр, который необязательно указывать рисует тень внутри элемента.
* Сдвиг по оси X: указывает степень смещения тени по горизонтали относительно элемента. Положительное значение означает сдвиг вправо, отрицательное — влево. Значение 0 означает, что тень без сдвига.
* Сдвиг по оси Y: указывает степень смещения тени по вертикали. Положительное значение означает сдвиг вниз, отрицательное — вверх. Значение 0 — это тень без сдвига.
* Радиус размытия: это степень размытия тени. Чем больше значение, тем более размыта тень. Если параметр не указан, используется значение по умолчанию — 0. В таком случае тень будет идеально четкой.
* Расширение: необязательный параметр, отвечающий за растяжение тени по обеим осям; чем больше значение, тем больше растяжение. Расширение работает только при наличии предыдущего параметра. Значение по умолчанию — 0.
* Цвет тени: с этим параметром всё понятно — он задает цвет тени элемента. Цвет по умолчанию — черный.

Данное свойство может принимать несколько групп значений (делать несколько теней одновременно). Для этого понадобится перечислить эти группы параметров через запятую. Например:
```
box-shadow: 15px 15px 20px #8b0163,
            inset 15px 15px 20px #630046;
```

## `Width` и `height`: определяем размеры элемента <a name="3.14"></a>
* В качестве значения ширины можно использовать и единицу `em`, которая является примерно тем же, чем и размер шрифта текста, но только в условных единицах. К примеру, вы установили размер для шрифта 24px. Тогда 1em для этого элемента будет равен 24 пикселам, а если вы зададите `width: 2em`, то ширина составит 2×24px = 48 пикселов. Если размер шрифта не задан, он будет унаследован.
* Высота `height`, заданная в процентах, вычисляется аналогичным образом, что и ширина, но расчет основывается уже на высоте родительского элемента, а не на его ширине. Если родитель отсутствует, высота будет зависеть от высоты окна браузера.
* Сразу стоит запомнить, что у свойств `width` и `height` есть особенность — они не включают в себя значения `margin`, `padding` и `border`. Значение, которое вы установите для `width/height`, будет означать лишь ширину/высоту области содержимого элемента.
* Таким образом, для того чтобы вычислить, например, фактическую ширину элемента (место, которое он в действительности займет на экране), понадобится немного арифметики. Фактическая ширина — это сумма значений, таких как `width`, `padding`, `border` и `margin`.
* Свойство `height` может быть удобным, если надо точно контролировать, например, высоту изображения. Однако, если в контейнере будет содержаться текст или любой другой контент, у которого может варьироваться высота, крайне не рекомендуется устанавливать фиксированную высоту для контейнера, так как подобная верстка может привести к неожиданному результату — контент будет отображаться поверх другого содержимого.
* Вместо фиксированной высоты использовать `height: auto` — эта запись означает, что высота объекта будет рассчитываться автоматически, в зависимости от содержимого, которое он содержит.
* Другой способ избежать развала верстки — использовать запись `overflow: auto`. В таком случае, если высота содержимого будет превышать значение `height` своего контейнера, браузер добавит к контейнеру полосу прокрутки.

## `Box-sizing` <a name="3.15"></a>
Нередко в процессе верстки возникает необходимость управлять стандартным вычислением размеров элемента. Допустим, вы хотите, чтобы ширина определенного блока `<div>` составляла 50% от ширины веб-страницы. Для этого вы задаете свойству `width` значение 50%. И здесь возникает загвоздка: если у блока имеются отступы (`padding`), поля (`margin`) либо рамка (`border`), то они будут считаться отдельно. В итоге ширина блока будет более 50%, а это уже не входит в ваши планы.

Как же сделать так, чтобы браузер учитывал отступы, а иногда и рамку, вычисляя ширину блока? На помощь приходит свойство `box-sizing`, которое может принимать три значения, а именно:

* `content-box` — значение по умолчанию (поведение, описанное выше). Ширина и высота элемента определяется только свойствами `width` и `height`.
* `border-box` — в данном случае браузер включает отступы `padding` и рамку `border` в общую ширину/высоту элемента. Это значит, что если для блока задана ширина, скажем, `width: 50%`, отступы (например, `padding-left: 10px` и `padding-right: 10px`) и рамка (`border-width: 1px`), то браузер будет считать эти отступы и рамку частью ширины 50%. Ширина самого содержимого составит 50% минус 22 пикселя. Обратите внимание, что значения `margin` включены **НЕ** будут.
* `padding-box` — это значение похоже на предыдущее, только в ширину/высоту элемента будут включены только отступы `padding`, без рамки. Значения `margin` также не учитываются. 

> Значение `padding-box` было исключено из спецификации CSS, однако оно все еще поддерживается браузером Firefox.

   Чтобы свойство `box-sizing` работало в браузерах Firefox, а также старых версиях Safari, Chrome и Android, следует записывать несколько его вариаций, используя соответствующие префиксы производителя:
```
-moz-box-sizing: border-box;
-webkit-box-sizing: border-box;
box-sizing: border-box;
```
Что же насчет поддержки браузером Internet Explorer? Хорошие новости: `box-sizing` работает в IE8 и выше.

## `Overflow`: управление переполненными элементами <a name="3.16"></a>
* `hidden` — всё содержимое, выходящее за пределы контейнера, будет скрыто. Не подходит в случае с текстовым контентом, но очень часто используется на практике для решения других задач и предотвращения некоторых «казусов».
* `scroll` — к контейнеру будут добавлены вертикальные и горизонтальные полосы прокрутки (скролл). Внешне блок становится похож на фрейм. Скролл отображается постоянно.
* `auto` — также добавляются полосы скролла, но только тогда, когда они необходимы (т. е. если содержимое не влазит в контейнер).
* `visible` — значение, установленное по умолчанию в браузере. Контент виден, даже если блок переполнен. Можно использовать для сброса другого значения, заданного ранее.

## `Max-width`, `max-height`, `min-width`, `min-height`: максимальные и минимальные размеры элемента <a name="3.17"></a>
* `min-width` — с помощью этого свойства вы можете указать минимальную ширину элемента. Например, если вы зададите блоку стиль `min-width: 50px`, то ширина блока может стать больше, но она никогда не станет меньше, чем 50 пикселей. Это очень удобно, например, при создании адаптивной верстки, когда при определенных размерах экрана элемент с относительной шириной становится слишком узким. Свойство `min-width` позволяет предотвратить такие искажения.
* `min-height` — работает аналогично предыдущему свойству, но только по отношению к высоте элемента. Безусловно, это тоже очень полезное свойство в практике, которое позволяет задать минимальную высоту элемента.
* `max-width` — как вы уже догадались, это свойство позволяет задать максимально допустимую ширину элемента. Например, элемент со стилем `max-width: 960px` может иметь ширину меньше максимальной, но он никогда не станет больше, чем 960 пикселей. Данное свойство удобно использовать при создании адаптивной разметки, когда вам необходимо, чтобы элемент адаптировался под ширину экрана любого устройства, но при этом не слишком широко разъезжался на больших экранах.
* `max-height` — работает аналогично предыдущему свойству, только по отношению к высоте. Но, как мы уже говорили ранее, лучше не играть с ограничением высоты элемента без крайней надобности.
* `auto` — это значение можно использовать для отмены действия свойства.

## CSS `float` <a name="3.18"></a>
* `left` — элемент выравнивается по левой стороне. Элементы, находящиеся ниже в потоке, обтекают его с правой стороны.
* `right` — значение, противоположное предыдущему. Элемент выравнивается по правой стороне, а элементы, находящиеся ниже в потоке, обтекают его слева по левому краю.
* `none` — элемент не обтекается и находится в своей обычной позиции.

## Отмена обтекания: свойство `clear` <a name="3.19"></a>
* `left` — элемент, к которому применяется свойство `clear:left`, перестает обтекать элемент со свойством `float:left`, однако правое обтекание сохраняется.
* `right` — элемент, к которому применяется свойство `clear:right`, перестает обтекать элемент со свойством `float:right`, однако левое обтекание сохраняется.
* `both` — полностью отменяет обтекание со всех сторон. Элемент смещается вниз и образовывает стандартный поток. На следующие за ним элементы обтекание также перестает влиять.
* `none` — отменяет очистку `clear`. Элемент будет вести себя, как обычно, и на него будут влиять настройки `float`.


# Работа с графикой <a name="4"></a>
## CSS для тега img
Элемент <img> является стандартным тегом для добавления графических элементов на веб-страницу. Его используют для размещения фотографий, логотипов, графических элементов интерфейса и т. п. Для стилизации тега img можно пользоваться стандартными свойствами CSS, например, border, box-shadow, opacity, float и другими. Это позволяет определять вид и расположение изображения на веб-странице.
На практике, чаще всего к тегу img применяются следующие свойства:
* border — вы можете создать рамку для изображения (или даже для целой галереи фотографий), при этом указав любую ширину и цвет границ. Как вы помните, можно даже стилизовать рамку индивидуально для каждой стороны.
* padding — небольшие внутренние отступы между фотографией и рамкой помогут сымитировать эффект подложки. А с помощью свойства background-color можно изменить и сам цвет подложки.
* box-shadow
* float — применив это свойство ко всем миниатюрам фотографий и добавив еще несколько строк CSS-кода, можно легко создать многострочную галерею
## Background-image: установка фонового изображения
Свойство background-image устанавливает выбранное изображение в качестве фона элемента. В зависимости от цели, можно задать графический фон как для отдельного блока, так и для всей страницы. В качестве единственного значения принимается URL-адрес графического файла. Запись выглядит так:
```
div {
    background-image: url(/img/bg.jpg); /* в круглых скобках — URL картинки */
}
```
## Пути к файлу
* Абсолютный путь
`background-image: url(http://www.example.com/img/bg.png);`
* Относительный путь к файлу
`background-image: url(/img/bg.png);`
`background-image: url(../../bg.png); /* поднимаемся на два уровня */`
* Абсолютный адрес ссылки понадобится использовать, если файл, на который вы ссылаетесь, находится на другом сайте. В пределах одного сайта абсолютный путь практически не используется (хоть он и будет работать). Это связано с несколькими моментами: во-первых, такие ссылки могут быть весьма громоздкими, а во-вторых, если имя домена изменится, то возникнет проблема — все ссылки будут вести на старый домен, что может повлечь за собой множество ошибок и битых ссылок.
* Корневой относительный путь будет работать на веб-сервере, но он бесполезен при разработке на локальном компьютере. Но преимущество этого типа ссылок в том, что вы можете перемещать свою таблицу стилей в любую папку сайта и не бояться, что адреса фоновых изображений станут нерабочими.
* Относительный путь от документа — наилучший вариант при веб-разработке на локальной машине без использования сервера. В браузере вы сможете нормально просматривать веб-страницы, хранящиеся на вашем компьютере, и адреса файлов будут работать. Они будут работать и на живом сайте, но с одним условием — если не перемещать таблицу стилей в другое место (иначе придется корректировать пути).
## Background-repeat: повторение фоновой картинки
Если элементу задать свойство background-image, то фоновый рисунок будет по умолчанию повторяться в двух осях — по горизонтали (x) и по вертикали (y).
Свойство background-repeat предназначено для управления повтором фона, заданного через background-image. Принимает оно следующие значения:
* repeat — то же, что и значение по умолчанию — полностью заполняет элемент фоновым рисунком натурального размера, повторяя его сверху вниз и слева направо. Такой эффект хорошо смотрится только при правильном подборе фона, который в идеале должен быть бесшовным, не слишком ярким, малоконтрастным.
* no-repeat — заполняет элемент фоновым рисунком один раз. Размер фона остается натуральным (не сужается и не растягивается). Свойство с данным значением очень часто применяется на практике (мы рассмотрим это далее в книге).
* repeat-x — фон повторяется только по горизонтали (оси x), до полного заполнения элемента по ширине. Удобно использовать для оформления элементов интерфейса (графическая полоска вдоль шапки сайта и т. п.).
* repeat-y — фон повторяется только по вертикали (оси y), до полного заполнения элемента по высоте. Удобно использовать для оформления элементов интерфейса (графическая полоска по высоте сайдбара и т. п.).
* round — фон повторяется так, чтобы в область элемента поместилось целое число изображений. Если это не удается сделать, фон автоматически подгоняется (масштабируется), чтобы соответствовать условию.
* space — работает так же, как и предыдущее свойство, но с одним отличием: если целое число изображений не помещается в область, рисунки не масштабируются, а между ними добавляется пространство.
## Background-position: позиционирование фона
Свойство `background-position` позволяет указывать начальную позицию фонового рисунка сразу для двух осей — x и y. Впрочем, можно воспользоваться и отдельными свойствами для каждой оси — `background-position-x` и `background-position-y`.
* Горизонтальное позиционирование
```
    left — фоновый рисунок прилеплен к левой стороне элемента;
    center — фоновый рисунок расположен в центре оси x;
    right — фоновый рисунок прилеплен к правой стороне элемента.

div {
	background-position-x: left;
}
```
* Вертикальное позиционирование
```
    top — фоновый рисунок прилеплен к верхней стороне элемента;
    center — фоновый рисунок расположен в центре оси y;
    bottom — фоновый рисунок прилеплен к нижней стороне элемента.

div {
	background-position-y: bottom;
}
```
Если вы установили повтор фона с помощью свойства background-repeat, то background-position будет определять, от какой точки будет начинаться дублирование изображения.
```
background-position: top center; /* фон вверху по центру */
background-position: top right; /* фон в верхнем правом углу */
background-position: bottom left; /* фон в левом нижнем углу */
background-position: center right; /* фон справа по центру */

background-position: center; /* фон по центру */
background-position: left; /* фон слева по центру */
background-position: right; /* фон справа по центру */
background-position: top; /* фон вверху по центру */
background-position: bottom; /* фон внизу по центру */
```
* Точные значения в единицах измерения CSS
```
div {
background-position: 10px 25px;
}

div {
background-position: right 15px bottom 40px;
}
```
Обратите внимание: значение 50% идеально центрирует фоновое изображение (как по вертикали, так и по горизонтали), поскольку точка центра устанавливается в середине фона, а не в его начале или конце.
Как правило, при печати страницы фоновые изображения не отображаются. Учитывайте это при работе с важной графикой — например, логотип компании, карту проезда и другие иллюстрации, содержащие важную информацию, рекомендуется добавлять через тег <img>.
Запись background-position с двумя параметрами поддерживается всеми используемыми браузерами.
## Значения background-attachment
* scroll (значение по умолчанию) — фоновое изображение перемещается вместе с другими элементами при скролле веб-страницы.
* fixed — значение фиксирует фоновое изображение, делая его нечувствительным к скроллу. При прокручивании страницы фон на заднем плане останется неподвижным.
* local — данное значение было добавлено из-за того, что в случае с локальным скроллом фон со значением scroll ведет себя как fixed. При значении local фон прокручивается вместе с содержимым элемента, и не прокручивается, если содержимое не скроллится (но прокручивается вместе с самим элементом).
## Background-origin: позиционирование фонового рисунка
background-origin управляет его позицией относительно рамки (border), отступа (padding) или содержимого элемента. По умолчанию фоновый рисунок отображается, накладываясь на отступы элемента (если они есть), и не подкладывается под рамку. Это положение можно менять, используя следующие значения background-origin:
* padding-box (значение по умолчанию) — фоновое изображение располагается в верхнем левом углу элемента, который является областью отступов padding.
* border-box — фоновое изображение располагается в верхнем левом углу элемента, который является областью рамки (при этом рамка накладывается на фон, перекрывая его часть).
* content-box — фоновое изображение располагается в верхнем левом углу, который принадлежит содержимому элемента.
## Background-clip: свойство для обрезки фона
Свойство background-clip позволяет определять, какую область элемента фон заполняет, а какую — нет. Согласно спецификации, свойство принимает следующие значения:
* padding-box — фон заполняет элемент, включая его отступы, и не заполняет область границ, так что в просветах пунктирной или точечной рамки фон не будет виден.
* border-box (значение по умолчанию) — фон заполняет элемент, включая область рамки (при этом рамка накладывается поверх фона). В случае с фоновым рисунком эффект данного значения будет заметен только при условии, что он повторяется.
* content-box — фон заполняет элемент, включая его содержимое, и не заполняет область отступов и границ.
  Заметьте, что background-clip не меняет начальную точку позиционирования фона, поэтому верхняя и левая стороны фонового рисунка могут обрезаться, если позиционирование у него осталось по умолчанию (это видно на примере с background-clip:content-box).
  Используя background-origin и background-clip в паре, можно исправить проблему обрезки фонового рисунка, о которой мы только что говорили. Например, следующий код заполнит фоном элемент <div> в области контента, а также задаст соответствующую начальную точку позиционирования фонового рисунка:

```
div {
	background-clip: content-box;
	background-origin: content-box;
}
```
## Background-size: масштабирование фонового рисунка
* auto (значение по умолчанию) — если данное значение установлено для горизонтали и вертикали, т. е.:
`background-size: auto auto;`

…то размеры фона останутся оригинальными. Если значение auto задано лишь для одной из сторон, то размер фона будет автоматически подогнан под пропорции изображения. Например, если записать следующее:

`background-size: 250px auto;`

…то высота фоновой картинки будет вычисляться автоматически.

* contain — фоновое изображение масштабируется так, чтобы поместиться внутрь элемента целиком. В зависимости от своей формы и формы элемента, рисунок растягивается, чтобы поместиться полностью либо по ширине, либо по высоте. Пропорции картинки сохраняются.
* cover — фоновое изображение масштабируется так, чтобы полностью заполнить пространство элемента, при этом сохраняя свои пропорции. Если пропорции элемента не соответствуют пропорциям изображения, это может привести к тому, что часть рисунка будет скрыта.

Свойство background-size часто используется на практике. Например, его очень удобно использовать, когда размер элемента указан в процентах. Если задать блоку ширину 50% от ширины экрана, а его фону — ширину 100%, то при изменении размера окна фон всегда будет соответствовать ширине элемента.
##  Свойство background: все настройки фона в одном месте
мы пишем значения всех свойств через пробел как обычно. Исключением являются свойства background-position и background-size — их необходимо разделять знаком слэша /.

Ни одно значение не является обязательным: вы можете не указывать значений тех свойств, которые хотите оставить по умолчанию. К слову, настройки background по умолчанию следующие:
```
background-image: none;
background-position: 0% 0%;
background-size: auto;
background-repeat: repeat;
background-attachment: scroll;
background-origin: padding-box;
background-clip: border-box;
background-color: transparent;
```
Для примера запишем стиль через свойство background, определив только цвет фона (background-color) и порядок его обрезки (background-clip):
```
background: content-box #aaa;
```
Этот код эквивалентен такому коду:
```
background-image: none; /* осталось по умолчанию */
background-position: 0% 0%; /* осталось по умолчанию */
background-size: auto; /* осталось по умолчанию */
background-repeat: repeat; /* осталось по умолчанию */
background-attachment: scroll; /* осталось по умолчанию */
background-origin: content-box;
background-clip: content-box;
background-color: #aaa;
```
## Несколько фоновых рисунков для одного элемента
```
.frame {
  background-image: url(https://goo.gl/tKyzHt), /* верхняя часть рамки */
                    url(https://goo.gl/SUKymM), /* нижняя часть рамки */
                    url(https://goo.gl/Km7HVV); /* середина рамки */

  background-position: center top, /* позиция верха рамки */
                       center bottom, /* позиция низа рамки */
                       center top; /* позиция середины рамки */

  background-repeat: no-repeat, /* верх рамки не повторяется */
                     no-repeat, /* низ рамки не повторяется */
                     repeat-y; /* середина рамки повторяется по вертикали */

  background-size: contain; /* здесь для всех фонов одинаковое значение */
  height: auto; /* высота блока зависит от количества содержимого */
  width: 400px;  /* ширина блока фиксированная */
  padding: 30px; /* внутренние отступы блока */
}
```
```
background: url(https://goo.gl/tKyzHt) center top / contain no-repeat, /* верх рамки */
	         url(https://goo.gl/SUKymM) center bottom / contain no-repeat, /* низ рамки */
	         url(https://goo.gl/Km7HVV) center top / contain repeat-y; /* середина рамки */
```
Такой вариант выглядит менее громоздко и легче воспринимается.
## Linear-gradient(): линейный градиент в фоне
`background-image: linear-gradient(to left, violet, red);`
Цвета точек градиента можно записывать в любом формате, доступном в CSS, будь-то шестнадцатеричный код, формат RGB или другой. Направление градиента задается с помощью приставки to и затем ключевых слов left, right, top и bottom, которые можно комбинировать для изменения наклона. Например:
`background-image: linear-gradient(to bottom right, #ee82ee, #ff0000);`
При заданном угле 0º либо 360º градиентная линия будет идти снизу вверх. При увеличении угла наклона движение вектора происходит по часовой стрелке (при использовании отрицательного значения движение меняется на противоположное). 
`background-image: linear-gradient(-110deg, #ee82ee, #ff0000);`
Если вы хотите увеличить количество данных точек в градиенте, просто допишите их через запятую. Например:
`background-image: linear-gradient(145deg, #ee82ee, slateblue, #ffd86a, purple);`
По умолчанию браузер размещает точки на равном расстоянии, поэтому и градация получается равномерной. Но этим расстоянием можно управлять, используя единицы измерения CSS.
`background-image: linear-gradient(#92009b 20%, #f5e944 90%, #00ffa2);`
В нашем коде после цвета #92009b указано значение 20%. Поскольку оно стоит возле первой опорной точки, это означает, что указанным цветом будет закрашено 20% длины элемента. После чего уже начинается градиент: значение 90% говорит браузеру, что нужно достичь цвета #f5e944 к 90% длины элемента (начав на уровне 20%). После чего в оставшемся пространстве начинается переход к третьему цвету — #00ffa2.
Градиентный фон тоже требует использования данных префиксов, если есть необходимость в поддержке максимального количества браузеров. Для этого адаптируйте код следующим образом:
```
background-image: -webkit-linear-gradient(left, violet, red);
background-image: -moz-linear-gradient(left, violet, red);
background-image: -o-linear-gradient(left, violet, red);
background-image: linear-gradient(to left, violet, red);
```
Для добавления префикса требуется создавать отдельное объявление. Кроме того, как вы могли заметить, свойства с вендорными префиксами не требуют использования приставки to при указании направления градиента.
## Repeating-linear-gradient(): градиент с повторением
`background-image: repeating-linear-gradient(to top right, #034320 60px, #24d24a 120px, #012c13 121px);`
Если разобрать наш пример, то из нижнего левого угла по направлению к верхнему правому углу браузер сначала закрашивает 60 пикселей цветом #034320, затем генерирует градиентный переход к цвету #24d24a, достигая 120 пикселей, после чего, начиная со 121-го пикселя, закрашивает оставшееся пространство цветом #012c13. И, поскольку это не простой, а повторяющийся градиент, действие повторяется заново с самого начала, а градиенты накладываются слоями один на другой.
## Radial-gradient(): радиальный градиент
`background-image: radial-gradient(#5b4ffc, #df02cd);`
Начальная точка вектора радиального градиента находится в центре эллиптической формы (который в свою очередь по умолчанию размещается в центре стилизуемого элемента), откуда градиент расходится кругами. Центр можно смещать, пользуясь теми же значениями, которые принимает background-position. Перед указанием позиции следует использовать приставку at:
`background-image: radial-gradient(at top left, #5b4ffc, #df0253);`
Форма радиального градиента может быть круглой либо эллиптической. Определить форму можно с помощью указания радиуса либо одного из ключевых слов:
* ellipse — градиент эллиптической формы (значение по умолчанию);
* circle — градиент круглой формы.
`background-image: radial-gradient(circle, #5b4ffc, #df0253);`
Значение радиуса может быть указано в любых доступных единицах CSS. Если указать одно значение, то оно будет принято за радиус круга. Два значения интерпретируются как радиус эллипса по оси X и радиус по оси Y. По умолчанию радиальным градиентом полностью заполняется фон элемента.
`background-image: radial-gradient(ellipse 180px 90px, #a09af1, #000038);`
* closest-side — создается градиент, который расходится только до ближайшей стороны элемента:
`background-image: radial-gradient(circle closest-side at 75% 40%, #ffee0e, #2e0a9f);`
* closest-corner — градиент расходится только до ближайшего угла элемента:
`background-image: radial-gradient(circle closest-corner at 75% 40%, #ffee0e, #2e0a9f);`
* farthest-side — противоположно closest-side, градиент расходится до самой дальней стороны элемента:
`background-image: radial-gradient(circle farthest-side at 75% 40%, #ffee0e, #2e0a9f);`
* farthest-corner — противоположно closest-corner, градиент расходится до самого дальнего угла элемента:
`background-image: radial-gradient(circle farthest-corner at 75% 40%, #ffee0e, #2e0a9f);`
* В точности как и с линейным градиентом, для создания многоцветного радиального градиента можно добавлять несколько опорных цветовых точек с указанием расстояния:
`background-image: radial-gradient(#144bf1 30%, #3ee9ca 60%, #0a38e5);`
## Repeating-radial-gradient(): повторяющийся радиальный градиент
По аналогии с линейным градиентом, радиальный градиент также может быть повторяющимся. За это отвечает функция repeating-radial-gradient(). В ней можно указывать те же параметры, что и для просто радиального градиента. Чтобы градиент повторялся, необходимо перечислить не только цвета, но и размеры каждого градиента в подходящих единицах CSS:
`background-image: repeating-radial-gradient(#ff00ea 10px, #2417d7 20px);`
Если вы хотите, чтобы градиентные кольца были размытыми, а не резкими, то первый и последний цвета градиента должны быть одинаковыми:
`background-image: repeating-radial-gradient(circle,#ff00ea 10px, #2417d7 20px, #ff00ea 30px);`
# Ссылки и навигация <a name="5"></a>
## Состояния ссылок в CSS. Псевдоклассы
```
    :hover — ссылка, на которую наведен курсор;
    :active — активная ссылка (та, по которой совершается клик, или на которой удерживается кнопка мыши);
    :link — ссылка, еще не посещенная пользователем;
    :visited — посещенная ссылка
```
> Для справки: из соображений безопасности набор стилей, которые можно использовать для ссылок :visited, ограничен. Посещенные ссылки принимают только свойства color, background-color, border-color (и его производные), column-rule-color, outline-color. При этом свойство к посещенной ссылке можно применить, только если это же свойство задано и для обычной. Прозрачность цвета, установленная через альфа-канал для элемента :visited, будет проигнорирована. JavaScript-метод getComputedStyle всегда возвращает значение цвета непосещенных ссылок, даже если у посещенных ссылок цвет иной.
   Если в ваши планы входит максимально детальная проработка дизайна ссылок, то желательно определить стили для всех четырех состояний. При этом очень важно соблюсти порядок, в котором будут записаны селекторы с псевдоклассами. Обязательно размещайте их в следующей последовательности:
```
a:link { color: red; }
a:visited { color: grey; }
a:hover { color: blue; }
a:active { background-color: yellow; }
```
Что будет, если поменять строки местами? В этом случае некоторые стили перестанут работать согласно правилам каскадности. Дело в том, что ссылка может находиться одновременно в двух состояниях, к примеру, в :visited и в :hover, и если расположить стиль для :hover выше, чем стиль для :visited, то первый перекроется.
Чтобы определить стили для всех состояний данных ссылок, запишите для каждого псевдокласса отдельное правило:
```
#main-menu .menu-link:link { color: red; }
#main-menu .menu-link:visited { color: grey; }
#main-menu .menu-link:hover { background-color: #a38beb; }
#main-menu .menu-link:active { background-color: yellow; }
```
## Варианты стилизации ссылок в CSS
Со ссылками работают самые разнообразные свойства: `color, background, border, border-radius, text-decoration, padding` и т. д
Чтобы иметь возможность подобным образом стилизовать ссылку, нужно заставить ее вести себя как блочный (block) либо строчно-блочный элемент (inline-block). Дело в том, что если вы будете добавлять отступы к строчному элементу (коим по умолчанию является ссылка), то не увидите никакого эффекта.
## Навигационные панели с помощью CSS
* Вертикальное меню
```
.menu {
    list-style-type: none;
    margin: 0;
    padding: 0;
}
```
> По сути, идентичные действия по отношению к спискам делает файл сброса стилей Reset.css, поэтому, если вы используете его на вашем сайте, то код выше можно не записывать.
Прежде всего нужно сделать все теги <a> блочными элементами:
	
`.menu a { display: block; }`
Следующее, что нам понадобится сделать — это задать ширину меню.
`.menu { width: 300px; }`
Чтобы визуально разделить пункты меню, можно задать каждому из них нижнюю или верхнюю границу. В зависимости от того, какую из них вы используете, у вас будет не хватать границы сверху или снизу меню. Это можно исправить, добавив еще одну границу к самому блоку .menu:
```
.menu a {
    border-top: 1px solid blue;
}
.menu {
    border-bottom: 1px solid blue;
}
```
Сейчас ссылки меню выглядят слишком низкими, расположенными близко друг к другу. Если текст каждой ссылки не будет занимать более одной строки, то увеличить их высоту и сохранить при этом текст вертикально по центру можно с помощью свойств height и line-height:
```
.menu a {
  height: 30px;
  line-height: 30px;
}
```
* Горизонтальное меню
1. Первый вариант — задать пунктам списка свойство display со значением inline либо inline-block:
```
.menu li {
  display: inline;
}
```
При этом теги `a` внутри li нельзя делать блочными, иначе пункты перестанут выстраиваться горизонтально и снова встанут в вертикальную позицию. Ссылкам можно также задать значение inline или inline-block. Выберите второе, если вы собираетесь в дальнейшем создавать отступы для ссылок.
После этого можно заняться оформлением ссылок. Например, можно сделать такой стиль:
	
```
.menu a {
  text-decoration: none;
  font-family: sans-serif;
  color: #5757a0;
  display: inline-block;
  padding: 10px 20px;
  background-color: lavender;
  border-bottom: 5px solid #5757a0;
}
```
```
.menu li {
  margin-right: -5px;
}
```
Этот код не убирает промежутки, а прикрывает их за счет сдвига элементов на пять пикселей влево. Данный способ нельзя назвать очень надежным, потому что размер промежутка может варьироваться в зависимости от других стилей.

Если промежутки между пунктами не запланированы в вашем дизайне, лучше воспользоваться вторым методом горизонтального выстраивания элементов.

2. Второй способ
Возможно, вы уже догадались, что второй вариант создания горизонтального меню заключается в использовании свойства float. Для этого добавьте стиль для тегов li:
	
```
.menu li {
  float: left;
}
```
Как видим, промежутков между пунктами уже нет. Все остальные стили работают, как и прежде. Но если вы добавите после навигации другой HTML-элемент (допустим, h1), то на него повлияет обтекание и он встанет в один ряд с пунктами меню. Отменить это действие можно, добавив заголовку свойство clear: left. Но при разработке сайта с большим количеством разных страниц может стать сложно следить за тем, нигде ли вы не забыли указать данное свойство. Гораздо легче отменить обтекание со стороны навигации. В этом поможет такая запись:
	
```
.menu {
  overflow: hidden;
}
```
Это также поможет вернуть нормальную высоту родителя плавающих элементов. Мы уже говорили об этой проблеме в предыдущих уроках, но тогда мы решали ее через специальный хак с использованием псевдоэлемента :after. Пример выше — это еще один способ решить вопрос с исчезнувшей высотой контейнера.
> Примечание: если вы установите фон для элемента .menu, то вы не увидите его до тех пор, пока не примените к нему overflow: hidden. Логично, ведь как можно увидеть фон элемента, чья высота равна нулю?
## Стили для особых ссылок
* Ссылки на e-mail и телефон
```
a[href^="tel:"] { ... }
a[href^="mailto:"] { /* ваш стиль для ссылок на электронную почту */ }
a[href^="tel:+44"] { ... }
a[href^="tel:+38067"] { ... }
```
* Ссылки на файлы
` a[href$=".zip"] { ... } `
* Ссылки с data- атрибутами
В HTML5 есть возможность добавлять пользовательские атрибуты к любому тегу. Эти атрибуты используются для хранения различных значений. Атрибут, который добавляется, обязательно должен начинаться с приставки data-, после чего может идти произвольное имя. Одним из практических вариантов применения таких атрибутов является создание всплывающих подсказок с текстом, который как раз и хранится в значении пользовательского атрибута.

Допустим, что у некоторых ссылок есть пользовательский атрибут data-description. Обратиться к ним можно следующим образом:

`a[data-description] { ... }`

Как вы догадываетесь, можно делать подобные выборки не только на основе data- атрибутов, а и на основе любых других — rel, title, target, class и т. д.

## CSS-спрайты
Переходим к CSS. Первым делом запишем общие стили для всех ссылок:
```
a {
  background-image: url(https://goo.gl/1t18Rz);
  background-repeat: no-repeat;
  height: 98px;
  width: 100px;
  display: inline-block;
  margin-right: 10px;
}
```
Первая строка содержит ссылку на спрайт. По факту, мы задали одно фоновое изображение для всех ссылок. Вторая строка отменяет дублирование фона — здесь оно не потребуется.

Следующие две строки — высота и ширина каждого элемента <a>. Каким образом определялись эти значения? Здесь мы отталкивались от размеров значков в спрайте. Высота каждой иконки равна 98 пикселям, а ширина — 100 пикселей. Далее мы будем позиционировать фоновую картинку для каждой ссылки, подстраивая фон таким образом, чтобы значок ровно вписался в «окошко» ссылки размером 98×100 пикселей.

Первая наша ссылка имеет класс .facebook. Зададим позиционирование для ее фона. Иконка Facebook находится точно в левом верхнем левом углу спрайта, поэтому определить ее позицию будет легко — left top:
```
a.facebook { background-position: left top; }
```
Идем дальше: позиционируем фон для ссылки на Twitter. Иконка Твиттера расположена справа от Facebook и примыкает к ней, не создавая пустых промежутков. Нам необходимо переместить спрайт влево на столько пикселей, чтобы скрыть иконку Facebook и полностью заполнить область ссылки иконкой Twitter. Поскольку ширина каждой иконки равна 100 пикселям, то мы и сдвигаем фон влево на 100 пикселей. Вертикальное позиционирование мы пока нигде не меняем, а оставляем значение top:
```
a.twitter { background-position: -100px top; }
```
Аналогичное действие мы проделаем для остальных ссылок, прибавляя к каждому последующему горизонтальному позиционированию еще 100 пикселей, тем самым сдвигая спрайт всё больше и больше влево. Получится такая картина:
```
a.youtube { background-position: -200px top; }
a.instagram { background-position: -300px top; }
a.linkedin { background-position: -400px top; }
a.tumblr { background-position: -500px top; }
a.google { background-position: -600px top; }
```
# Трансформирование и анимация <a name="6"></a>
## Свойство transform: трансформация элементов
`transform` широко применяется в веб-анимации, но еще его нередко используют для позиционирования и центрирования элементов.
Следует учитывать, что трансформированные элементы не влияют на размещение своих соседей. Передвинутый, наклоненный, увеличенный элемент может перекрыть соседний, наложиться на него. Это работает так потому, что при рендеринге веб-страницы браузер резервирует для элемента то место, где он находился бы до трансформации, после чего применяет стили преобразования. Преобразованный элемент никак не затрагивает положение соседних элементов.
### Функция rotate()
Функция rotate() свойства transform позволяет вращать элемент в 2D-пространстве. В скобках задается угол от 0 до 360 градусов. К числу дописывается приставка deg. Пример:
`transform: rotate(90deg); /* поворот элемента на 90° по часовой стрелке */`
Если установлено значение 0deg, элемент останется в исходном положении. 360deg означает, что элемент совершит один полный оборот по часовой стрелке, 1080deg — три полных оборота, -720deg — два полных оборота против часовой стрелки и т. д.
* Свойство transform поддерживает дополнительные функции, которые позволяют совершать трансформации относительно осей трехмерного пространства:
```
rotateX() — поворот элемента по оси X;
rotateY() — поворот по оси Y;
rotateZ() — поворот элемента по оси Z.
```
* Изначально поворот элемента происходит относительно его центральной оси. Но центр вращения можно изменить, воспользовавшись свойством transform-origin. В качестве значения указываются координаты для трех осей — X, Y и Z.
Единицы измерения для X и Y могут быть любыми. Также принимаются ключевые слова left, center, right (для X) и top, center, bottom (для Y). Для оси Z позволительно использовать корректные единицы измерения длины, кроме процентов.
По умолчанию настройки transform-origin следующие:
`transform-origin: 50% 50% 0; /* x y z */`
### Функция scale()
С помощью функции scale() свойства transform можно увеличивать и уменьшать объекты на веб-странице. Принцип работы заключается в масштабировании элемента по горизонтали и вертикали с указанием коэффициента масштабирования. Пример:
```
transform: scale(3); /* пропорциональное увеличение элемента в 3 раза */
transform: scale(0.5); /* пропорциональное уменьшение элемента наполовину */
```
В качестве параметров функция scale() принимает целые и дробные числа. Для пропорционального масштабирования достаточно указать нужное число в скобках. Так, число выше единицы увеличит масштаб, а число в диапазоне от 0.01 до 0.99 уменьшит его. Число 1 никак не масштабирует элемент, а число 0 приведет к визуальному исчезновению элемента.

Для более произвольного масштабирования можно указать два параметра — для горизонтали и вертикали соответственно. Например, следующий код увеличит масштаб элемента в четыре раза по горизонтали и в полтора раза по вертикали:

`transform: scale(4, 1.5);`

* В CSS также имеется набор функций для управления масштабированием каждой из трех осей по отдельности — X, Y и Z. Называются они соответственно:
```
scaleX() — масштабирование по горизонтали X;
scaleY() — масштабирование по вертикали Y;
scaleZ() — масштабирование по оси Z.
```
В качестве параметра принимаются те же числа, что и для основной функции.
* Вы можете добиться эффекта «отражения в зеркале», если примените отрицательное число в качестве коэффициента масштабирования. При этом флип произойдет даже в том случае, если вы используете -1 (просто не будет эффекта масштабирования):
```
transform: scale(1, -1); /* флип по оси X */
transform: scale(-1, 1); /* флип по оси Y */
transform: scale(-1); /* флип по осям X и Y */
```
### Функция skew()
Функция наклона skew() хорошо подходит для создания эффекта 3D. Принцип ее работы заключается в наклоне всех горизонтальных либо вертикальных линий элемента на определенное количество градусов. Визуально элемент словно искажается, растягивается в определенные стороны. Наклон может производиться по осям X и Y.

Функция skew() принимает два параметра. Первый параметр отвечает за наклон по горизонтали, второй — за наклон по вертикали. В качестве значения указывается угол от 0 до 360 с приставкой deg. Например:
```
transform: skew(30deg, 0);
```
Второй параметр, соответственно, отвечает за наклон горизонтальных линий к оси Y. Направление движения — по часовой стрелке, начиная от правой стороны элемента:
```
transform: skew(0, 30deg);
```
* По аналогии с предыдущими рассмотренными функциями, в CSS есть отдельные функции skewX() и skewY() для управления наклоном от каждой оси по отдельности.

### Функция translate()
`translate(20px, 50px);`
Независимо от того, куда и на какое расстояние вы переместите элемент, место его изначального расположения в потоке документа будет зарезервировано за ним, и другие элементы не смогут его занять. На месте перемещаемого элемента останется пустое пространство, а сам элемент в смещенном состоянии может накладываться либо подкладываться под соседние элементы. Какой элемент будет находиться выше, а какой — ниже, можно определить с помощью свойства z-index 
* Вы также можете управлять перемещением элемента, используя отдельные функции translate для трех осей — translateX(), translateY(), translateZ(). Если в параметре translateZ() указано положительное число, перемещение элемента происходит вперед, если отрицательное — назад.
* Некоторые функции свойства transform имеют дополнительную 3D-версию себя, которая принимает три значения — для трех осей. Так, в расширенной функции translate3d() можно указать значения для X, Y и Z через запятую. Такие же вариации существуют и у некоторых ранее рассмотренных функций — rotate3d() и scale3d().
> Обратите внимание: если у вас не работает translateZ() или другая аналогичная функция, где затрагивается ось Z, не спешите паниковать. Дело в том, что движение по оси Z будет заметным лишь в том случае, если в CSS установлена перспектива.
### Несколько значений свойства transform
В качестве значений свойства transform можно перечислить сразу несколько функций, разделив их пробелом. При этом к элементу последовательно будет применено несколько трансформаций. Пример:

`transform: rotate(45deg) scale(1.2) skew(30deg, 0deg) translate(10px, 20px);`

Порядок записи функций имеет значение. От перестановки значений может измениться конечный результат. В нашем примере элемент сначала поворачивается на 45 градусов в двухмерном пространстве, затем масштабируется, наклоняется и в конце перемещается. Если первой функцией записать, к примеру, skew(), то элемент первым делом будет наклонен, после чего повернут на 45 градусов, масштабирован и перемещен.
### 3D-трансформации в CSS
С помощью 3D-трансформаций, появившихся в спецификации CSS3, есть возможность управлять поведением объекта по оси Z. Если говорить буквально, то данная ось расположена перпендикулярно экрану, т. е. по сути она смотрит зрителю в лицо.

Функции 3D-трансформации являются расширенными функциями двухмерных трансформаций, в которые добавлен параметр для оси Z. Этими функциями являются, например, translate3d(), rotate3d(), scale3d(), а также одиночные записи, такие как translateZ(), rotateZ(), scaleZ().

* Кроме всего прочего, в CSS3 была добавлена еще одна функция — perspective(), которая может быть использована для создания эффекта перспективы, глубины в сцене. Перемещая элемент по оси Z с установленной перспективой, можно наблюдать, как он приближается или отдаляется от зрителя.

Итак, данная функция задает расстояние между плоскостью экрана и точкой сходимости линий. Масштабирование элемента пропорционально d/(d – Z), где d (значение перспективы) — это расстояние от графической плоскости до предполагаемого положения глаз зрителя
* Для перспективы можно изменить точку отсчета при помощи свойства perspective-origin. Оно словно задает точку расположения зрителя при взгляде на перспективу. По умолчанию эта точка находится в центре элемента, но можно определить координаты точки по осям X и Y, из которой наблюдатель будет смотреть на дочерние элементы
* Свойство backface-visibility со значением visible не скрывает содержимое блока, и оно отображается зеркально.

Но если установить для свойства backface-visibility значение hidden, то содержимое элемента будет скрыто с его обратной стороны (включая фон блока). По сути, объект будет невидим на экране, пока он повернут обратной стороной к зрителю.

Но эта возможность может пригодиться, если вам необходимо создать впечатление, что у объекта имеется две стороны. На примере ниже показано, как можно создать игральную карту, используя два фоновых изображения и свойство backface-visibility: hidden. Повернув карту по оси Y на угол более 90 градусов, можно увидеть, как карта развернулась «рубашкой» к зрителю, а лицо карты при этом скрылось
## CSS3 transition: плавные переходы
Чтобы реализовать переход в CSS, необходимо записать два стиля для элемента — начальный и конечный. Также к начальному стилю дописывается свойство transition с необходимыми настройками для осуществления перехода. И, наконец, чтобы воспроизвести переход, понадобится «спусковой крючок», который запустит анимацию. Самый простой пример такого «спускового крючка» — это псевдокласс :hover. В этом случае переход от начального стиля к конечному будет происходить при наведении курсора на элемент. При снятии курсора с элемента конечный стиль будет преобразован обратно в начальный.
Во-первых, анимированию поддаются все трансформации (scale(), rotate(), skew() и т. д.). Во-вторых, можно создавать переходы между значениями таких свойств, как color, background, width, height, opacity и т. д. Весь перечень можно посмотреть на сайте W3.org
### Свойство transition-property
С помощью свойства transition-property можно определить, для каких стилей элемента будет действовать переход. Можно указать одно либо несколько свойств через запятую, а можно задать отслеживание значений всех свойств сразу.
```
/* имена свойств */ — например, если нужно плавно изменять значения свойств color и background-color, просто запишите их имена через запятую;
all — выбрать все свойства;
none — не выбирать никакое свойство.
```
Рассмотрим пример со стилизацией ссылки. Допустим, нам нужно, чтобы при наведении курсора цвет и фон ссылки плавно менялся. Запишем следующее:
```
a {
    display: inline-block;
    width: 200px;
    padding: 10px;
    text-align: center;
    text-decoration: none;
    background-color: #9b20ff;
    color: #fafafa;
    transition-property: color, background-color;
}
a:hover {
    color: #9b20ff;
    background-color: #c9ff20;
    letter-spacing: 2px;
}
```
Итак, мы указали стиль для двух состояний ссылки — начального и конечного (:hover).
Свойство transition-property добавлено к первому стилю, и в его значении содержатся названия свойств, которые мы хотим анимировать.

Но желаемого плавного перехода от цвета к цвету у нас не будет до тех пор, пока не указана длительность анимации.
### Свойство transition-duration
Свойство transition-duration определяет, сколько времени должен длиться переход от одного состояния к другому. Именно оно обеспечивает плавность анимации. По умолчанию переход происходит мгновенно.
Свойство transition-duration определяет, сколько времени должен длиться переход от одного состояния к другому. Именно оно обеспечивает плавность анимации. По умолчанию переход происходит мгновенно.

В качестве значения указывается время в секундах либо миллисекундах. Время записывается целым либо дробным числом, после которого следует приставка s (для секунд) или ms (для миллисекунд). Пробел между числом и приставкой не ставится.
```
transition-duration: 0.6s; /* эта запись эквивалентна нижней */
transition-duration: .6s; /* ноль перед точкой можно опускать */
```
Вернемся к нашему примеру из предыдущего урока. Нам необходимо добавить плавность для перехода между стилями ссылки. Предположим, мы хотим, чтобы переход длился одну секунду. Добавим одну строчку к уже готовому стилю:
```
a {
    display: inline-block;
    width: 200px;
    padding: 10px;
    text-align: center;
    text-decoration: none;
    background-color: #9b20ff;
    color: #fafafa;
    transition-property: color, background-color;
    transition-duration: 1s; /* добавляем длительность перехода */
}
a:hover {
    color: #9b20ff;
    background-color: #c9ff20;
    letter-spacing: 2px;
}
```
Если вы перечислили свойства в transition-property, вы можете указать соответствующую длительность перехода для каждого из них. Порядок указания значений длительности должен соответствовать порядку перечисления свойств. Например:
```
transition-property: color, background-color, letter-spacing;
transition-duration: 1s, .5s, 2s;
```
Такая запись будет означать, что свойство color перейдет от своего начального значения к конечному за одну секунду, background-color — за половину секунды, а letter-spacing — за две секунды.
### Свойство transition-timing-function
Свойство transition-timing-function устанавливает, как будет распределяться скорость движения анимации в течение ее длительности. Распределение скорости анимации происходит в рамках того интервала, который задан через transition-duration.
Скорость анимации можно изобразить в виде математической функции, которая показывает характер ее движения от начальной точки с координатами 0.0, 0.0 до конечной точки с координатами 1.0, 1.0.

В качестве значений можно использовать как предустановленные функции, так и создавать свои. Список ключевых слов, принимаемых свойством transition-timing-function, следующий:
* ease (значение по умолчанию) — начало анимации медленное, к середине скорость повышается и в конце вновь снижается.
* ease-in — начало анимации медленное, к концу она ускоряется.
* ease-out — начало анимации быстрое, к концу она замедляется.
* ease-in-out — начало и конец анимации медленные.
* linear — скорость равномерная на протяжении всей анимации.
* step-start — переход от одного стиля к другому происходит моментально и резко (анимации нет).
* step-end — по истечении заданного времени происходит резкий переход от одного стиля к другому (без анимации).
* steps() — анимация происходит ступенчато. В скобках сначала указывается число шагов, за которые должен осуществиться переход от одного стиля к другому, после чего ставится запятая и указывается параметр start или end, от которого зависит, когда будет начинаться анимация — в начале первого шага или в конце. Пример записи:
* transition-timing-function: steps(10, start);
* cubic-bezier() — значение, позволяющее задать свою функцию движения в виде кубической кривой Безье. Кубическая кривая строится по четырем координатам, которые указываются в скобках в следующем порядке: (x1, y1, x2, y2), где x1 и y1 — это координаты первой точки, а x2 и y2 — координаты второй точки. Аргументы x1 и x2 всегда должны быть в диапазоне от 0 до 1. Многие разработчики для экономии времени создают такие функции на специально созданных для этого онлайн-сервисах с удобным графическим интерфейсом.
### Свойство transition-delay
CSS-анимация не обязательно должна начинаться мгновенно после ее инициализации. Вы можете управлять ее началом с помощью свойства transition-delay. Чтобы отложить совершение перехода на определенное время, укажите его в значении свойства:
```
transition-delay: 1s; /* отложить начало анимации на одну секунду */
```
Данное свойство мало используется при реализации простой интерактивности на сайте, однако оно может быть весьма полезным, если вам предстоит создавать более сложные эффекты. По аналогии с transition-duration можно записать время задержки для каждого свойства, указанного в transition-property (при этом также важно придерживаться порядка перечисления):
```
transition-property: color, background-color, letter-spacing;
transition-duration: 1s, .5s, 2s;
transition-delay: 0s, 0s, 2s; /* задержка анимации letter-spacing на 2 секунды */
```
Не забывайте о кроссбраузерности — абсолютно все свойства семейства transition требуют использования вендорных префиксов:
```
-webkit-transition-delay: 1s;
-moz-transition-delay: 1s;
-o-transition-delay: 1s;
transition-delay: 1s;
```
Возможно, вы замечали, что на некоторых сайтах выпадающие подменю исчезают слишком быстро, при этом сложно поймать нужную ссылку и кликнуть по ней. Предотвратить такое поведение как раз и помогает свойство transition-delay, установленное для обычного элемента и для элемента с псевдоклассом :hover. Значения будут отличаться: для обычного состояния свойство transition-delay должно иметь значение больше нуля, а для состояния наведенного курсора оно должно равняться 0. Пример:
```
.submenu {
    opacity: 0;
    transition-property: all;
    transition-duration: .5s;
    transition-delay: 1s;
}
.menu:hover .submenu {
    opacity: 1;
    transition-delay: 0s;
}
```
Данный код приведет к тому, что появление меню при наведении курсора будет происходить без задержки, а исчезновение задержится на одну секунду. Такой трюк однозначно сделает меню более удобным для использования.
### Сокращенная запись transition
Порядок записи следующий: необходимо указать значения свойств transition-property, transition-duration, transition-timing-function и transition-delay, отделяя их пробелами. Пример:
```
transition: all 1s ease 0s;
```
В ситуации, когда необходимо записать несколько свойств transition-property и, соответственно, несколько значений transition-duration и т. д., запись будет выглядеть таким образом:
```
transition: color 1s ease-in 0s,
            background-color .5s step-end 0s,
            letter-spacing 2s ease-out 2s;
```
Проще говоря, значения для первого свойства вы записываете через пробел, после чего ставите запятую и указываете значения для второго свойства и так далее. В конце ставится точка с запятой.

Из четырех значений обязательно нужно указывать лишь два — transition-property и transition-duration. Для двух других свойств будут использованы значения по умолчанию, если вы не установите другие.
## Анимация CSS3
В отличие от обычного transition, расширенная CSS-анимация позволяет создавать цепочку переходов: от одного набора стилевых правил ко второму, от второго к третьему, от третьего к четвертому и так далее. Кроме этого, увеличивается и количество вариантов запуска анимации: вы можете сделать проигрывание сразу после загрузки веб-страницы, а не только при наведении курсора. Также можно заставить анимацию повториться несколько раз либо вообще сделать бесконечный цикл.
Порядок создания анимации можно разделить на два этапа:
1. Создание необходимого количества ключевых кадров через правило @keyframes. Запись стилей для каждого кадра.
2. Подключение анимации к одному либо нескольким элементам.
### Правило @keyframes
```
@keyframes changeBackgroundColor {
    from {
        background-color: red;
    }
    50% {
        background-color: yellow;
    }
    to {
        background-color: green;
    }
}
```
Запись 50% означает, что фон станет желтым ровно в середине анимации. По такому принципу можно добавлять сколько угодно ключевых кадров — просто используйте необходимое число в процентах (30%, 60%, 75% и так далее). Позже, когда будет задана длительность анимации, станет понятно, сколько времени пройдет до появления желтого цвета. К примеру, если вы установите длительность в размере 6 секунд, то желтый цвет фона появится через 3 секунды после старта анимации.
   Еще более интересно то, что можно создавать паузы в анимации, записывая один набор свойств для нескольких ключевых кадров сразу. Например, чтобы красный цвет сменился на желтый к 33% от длительности анимации, а переход от желтого к зеленому начался после 66%, запишите следующее:
```
@keyframes changeBackgroundColor {
    from {
        background-color: red;
    }
    33%, 66% {
        background-color: yellow;
        transform: translateY(50px);
    }
    to {
        background-color: green;
        transform: translateY(100px);
    }
}
```
Таким образом мы создадим эффект паузы на временном отрезке с 33% до 66%.

Ключевые слова from и to равнозначны процентным записям 0% и 100% соответственно. Вам не обязательно начинать анимацию с 0% и заканчивать на 100%. Ее можно запускать позже и завершать раньше, при этом добиваясь интересных эффектов.
### Запуск анимации: аnimation-name и animation-duration
После того, как будут созданы ключевые кадры @keyframes, вы можете применить анимацию к нужному элементу через CSS. Для этого понадобится добавить к стилю элемента как минимум два свойства группы animation — это animation-name и animation-duration
* Свойство animation-name позволяет привязать к элементу одну или больше анимаций. Для примера возьмем ту анимацию, которую мы создали на прошлом уроке. Мы задали ей имя changeBackgroundColor (оно указано сразу после слова @keyframes). Теперь, чтобы применить ее, например, к элементу <div> с классом .traffic-light, нужно написать такой код:

```
.traffic-light {
    animation-name: changeBackgroundColor;
}
```
Итак, мы сообщили браузеру, какую анимацию нужно применить к элементу .traffic-light, указав ее имя в качестве значения свойства animation-name. Но чтобы анимация выполнилась, потребуется задать еще и ее длительность.
* Данное свойство похоже на рассмотренное нами ранее свойство transition-duration. Оно принимает аналогичные значения времени и устанавливает продолжительность анимации для конкретного элемента. Предположим, мы хотим, чтобы анимация с именем changeBackgroundColor, примененная к элементу .traffic-light, длилась 6 секунд. Добавим к стилю еще одну строку:
```
.traffic-light {
    animation-name: changeBackgroundColor;
    animation-duration: 6s;
}
```
Рядом со свойствами для запуска анимации допускается записывать и другие стили элемента. Так, полный CSS-код для нашего блока выглядит следующим образом:
```
.traffic-light {
    animation-name: changeBackgroundColor;
    animation-duration: 6s;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: red;
}
```
* К одному элементу можно применить сразу две или больше анимаций. Для этого следует перечислить их названия через запятую в свойстве animation-name. Если при этом вы хотите задать разную длительность для каждой анимации (animation-duration), то перечислите в таком же порядке время исполнения:
```
.traffic-light {
    animation-name: firstAnimation, secondAnimation;
    animation-duration: 3s, 1s;
}
```
Порядок расположения названий анимаций в свойстве animation-name влияет на последовательность их выполнения. В примере выше сначала будет воспроизведена анимация под названием firstAnimation длительностью 3 секунды, а затем запустится анимация secondAnimation с продолжительностью 1 секунда.
### Свойства animation-timing-function и animation-delay
В CSS помимо продолжительности анимации можно задать скорость перехода от одного ключевого кадра к другому, а также время задержки перед воспроизведением анимации. Для этого существуют два свойства – animation-timing-function и animation-delay. 
1. С помощью свойства animation-timing-function можно управлять как скоростью всей анимации, так и скоростью смены значений свойств между ключевыми кадрами анимации. Принцип работы свойства аналогичен свойству transition-timing-function, которое мы не так давно рассматривали.
В качестве значений принимаются те же самые ключевые слова и функции – ease, ease-in, cubic-bezier() и так далее. Мы не будем повторяться – список значений и их описание вы можете найти в уроке по transition-timing-function. Они полностью совместимы со свойством animation-timing-function. Там же объясняется тонкая разница между длительностью и скоростью анимации.

Чтобы задать функцию распределения скорости для всей анимации в целом, просто добавьте еще одну строку кода к вашему общему стилю для анимированного элемента:
```
.traffic-light {
    animation-name: changeBackgroundColor;
    animation-duration: 6s;
    animation-timing-function: ease;
}
```
Если же вы хотите установить разные значения animation-timing-function для каждого ключевого кадра анимации, тогда следует указать их в правиле @keyframes. Вернемся к нашему примеру: допустим, мы хотим, чтобы при переходе от первого ключевого кадра ко второму использовалась функция ease-in, а при переходе от второго кадра к третьему – функция ease-out. Запись будет выглядеть следующим образом:
```
@keyframes changeBackgroundColor {
    from {
        background-color: red;
        animation-timing-function: ease-in;
    }
    50% {
        background-color: yellow;
        transform: translateY(50px);
        animation-timing-function: ease-out;
    }
    to {
        background-color: green;
        transform: translateY(100px);
    }
}
```

2. Данное свойство аналогично свойству transition-delay. С помощью него можно отложить начало выполнения анимации, указав в качестве значения время в секундах либо миллисекундах:
```
.traffic-light {
        animation-name: changeBackgroundColor;
        animation-duration: 6s;
        animation-delay: 2s;
}
```
Оба рассмотренных здесь свойства нуждаются в указании префиксов производителей для обеспечения максимальной кроссбраузерности. Впрочем, как уже неоднократно говорилось, префиксы необходимо добавлять ко всем свойствам CSS-анимации.

### Свойство animation-iteration-count
По умолчанию анимация на веб-странице проигрывается один раз, после чего останавливается. К счастью, в CSS имеется инструмент, с помощью которого можно управлять количеством повторений анимации. Свойство называется animation-iteration-count и принимает следующие значения:
```
    число — вы указываете произвольное число, которое определяет, сколько раз повторится анимация. Кроме целых чисел можно использовать и дробные, в том числе меньше единицы. К примеру, число 0.25 означает, что будет воспроизведена четверть одного цикла анимации, а число 3 — что анимация повторится три раза.
    infinite — ключевое слово, которое означает бесконечное повторение анимации.
```
Свойство записывается рядом с другими стилями анимируемого элемента:
```
.traffic-light {
    animation-name: changeBackgroundColor;
    animation-duration: 6s;
    animation-iteration-count: infinite;
}
```
### Свойство animation-direction
В обычном состоянии анимация проигрывается от начала до конца, затем резко, в один момент возвращается в свое первоначальное состояние и, в зависимости от настроек animation-iteration-count, либо повторяется снова, либо больше не воспроизводится.

Резкий возврат анимации из конечного состояния в начальное часто выглядит некрасиво и бросается в глаза. И здесь на помощь приходит свойство animation-direction, которое управляет направлением движения анимации. Например, вы можете сделать так, чтобы по окончанию своего пути анимация возвращалась назад, но не резко, а плавно. Кроме этого, можно заставить анимацию воспроизводиться задом наперед.

Итак, рассмотрим поближе значения свойства animation-direction:
```
    normal — значение по умолчанию. Анимация воспроизводится от начала до конца, затем резко возвращается к первоначальному состоянию.
    alternate — анимация воспроизводится от начала до конца, после чего плавно возвращается к исходному состоянию, что напоминает перемотку назад. Эффект от этого значения не будет заметен, если анимация проигрывается всего один раз.
    reverse — анимация воспроизводится с конца в начало реверсом, затем резко возвращается в первоначальное состояние, т. е. к первому ключевому кадру.
    alternate-reverse — значение, объединяющее в себе два предыдущих. Анимация воспроизводится с конца в начало, после чего плавно возвращается в исходное состояние, т. е. к первому ключевому кадру. Эффект от этого значения не будет заметен, если анимация проигрывается всего один раз.
```
Чтобы указать направление анимации, добавьте правило к стилю элемента:
```
.traffic-light {
        animation-name: changeBackgroundColor;
        animation-duration: 6s;
        animation-direction: alternate-reverse;
}
```
### Свойство animation-fill-mode


Как уже говорилось в предыдущих уроках, после прохождения цикла анимация возвращается к своему исходному положению и стилю. Это поведение не всегда бывает уместным, поэтому в CSS для таких случаев имеется свойство animation-fill-mode. Оно определяет, какой стиль будет применен к анимированному элементу по окончанию анимации.

По правде говоря, выбор здесь небольшой – по окончанию анимации элемент может принять либо первоначальный стиль, либо остаться в том стиле, который он принял в конце цикла. Представим, что вы создали анимацию прямоугольного блока: он плавно увеличивается в течение анимации, и к ее концу становится в три раза больше первоначального размера. Когда анимация завершится, ваш блок вернется в исходное состояние, то есть уменьшится в три раза. Но вы можете сохранить размер увеличенного блока, воспользовавшись свойством animation-fill-mode. Оно принимает два значения:
```
    forwards — по окончанию анимации элемент сохраняет стиль последнего ключевого кадра.
    none — значение по умолчанию. Элемент возвращается к исходному стилю.
```
Итак, чтобы блок из вышеописанного примера остался увеличенным после завершения анимации, добавьте к его стилю следующую строку:
```
animation-fill-mode: forwards;
```
Стоит отметить, что на внешний вид последнего ключевого кадра влияют значения свойств animation-iteration-count и animation-direction. К примеру, если наряду с animation-fill-mode вы задали стиль animation-direction: reverse, то после завершения анимации элемент останется с тем стилем, который определен для первого, а не последнего ключевого кадра.
###  Свойство animation-play-state
Для CSS-анимации существует еще одно полезное свойство — animation-play-state. Оно позволяет определять, будет ли анимация воспроизводиться или же она будет стоять на паузе. Для данного свойства предусмотрены два значения:
```
    running — анимация проигрывается;
    paused — анимация стоит на паузе. Если запустить анимацию после постановки на паузу, то она продолжится с того места, на котором была приостановлена.
```
### Сокращенная запись animation
```
div {
    animation-name: coolAnimation;
    animation-duration: 3s;
    animation-timing-function: ease-in;
    animation-delay: 500ms;
    animation-iteration-count: 6;
    animation-direction: reverse;
    animation-fill-mode: forwards;
    animation-play-state: paused;
}

/* Стиль выше эквивалентен следующему: */

div {
    animation: coolAnimation 3s ease-in 500ms 6 reverse forwards paused;
}
```
Конечно же, нет необходимости использовать каждое из восьми свойств анимации, ведь обязательными являются только два — animation-name и animation-duration. И если вам нужно добавить третий параметр (к примеру, animation-iteration-count), вы можете сделать следующую запись:
```
div {
    animation: coolAnimation 3s 6;
}
```
Если нужно применить к элементу сразу несколько анимаций и задать им разные настройки, то каждую группу значений следует отделять запятой, а в конце поставить точку с запятой:
```
div {
    animation: firstAnimation 300ms ease-in,
               secondAnimation 1s linear alternate;
}
```
## Таблицы и формы
### Стилизация таблиц с помощью CSS
Для придания таблицам красивого внешнего вида можно использовать многие CSS-свойства, с которыми вы уже хорошо знакомы: padding, border, width, height, color, display и прочие.
* Align
С помощью этого атрибута можно выровнять всю таблицу относительно края окна браузера, выбрав одно из трех значений — left, center либо right. Обратите внимание, атрибут выравнивает не текст, а сам блок таблицы. Аналогом CSS в данном случае является комбинация свойств:
```
/* аналог align="left" */
table {
    display: table;
    margin-right: auto;
}

/* аналог align="center" */
table {
    display: table;
    margin-left: auto;
    margin-right: auto;
}

/* аналог align="right" */
table {
    display: table;
    margin-left: auto;
}
```
Также таблицу можно выровнять, задав ее родительскому элементу свойство text-align с соответствующим значением. Но это сработает только при условии, что для таблицы установлено свойство display со значением inline либо inline-block.

* Background
Данный атрибут позволяет задать фоновое изображение для всей таблицы, указав его URL-адрес в качестве значения. Контролировать поведение такого фона нет возможности, в отличие от аналога CSS — свойства background-image и других свойств для настройки фона.
```
/* аналог background="img/bg.png" */
table {
    background-image: url(img/bg.png);
}
```
* BgColor
Устанавливает цвет фона для всей таблицы. Вы наверняка уже догадались, каким CSS-свойством можно успешно заменить атрибут bgcolor:
```
/* аналог bgcolor="#eaeaea" */
table {
    background-color: #eaeaea;
}
```
* Border, bordercolor и frame
Атрибуты таблицы border, bordercolor и frame задают толщину рамки, ее цвет и расположение соответственно. Рекомендуем забыть о них и пользоваться CSS-свойством border (и его производными), которое объединяет эти атрибуты и дает даже больше.
```
/* аналоги border="1" и bordercolor="#eee" */
table {
    border: 1px solid #eee;
}
```
Если в CSS задано свойство border, оно перекроет значение атрибута. Такое же поведение будет и в случае с другими атрибутами, имеющими точный аналог в CSS.
* Rules
Атрибут, который определяет, где отображать границы (вокруг ячеек, между колонками, между строками и т. д.), опять-таки можно заменить CSS-свойством border, применяя его к соответствующим тегам таблицы.
```
/* аналог rules="cols" */
td {
    border-right: 1px solid black;
}
```
* Cellpadding
Устанавливать отступы между внутренними сторонами ячейки и ее содержимым можно не только через атрибут, но и с помощью CSS-свойства padding, примененного к тегу td.
```
/* аналог cellpadding="10" */
td {
    padding: 10px;
}
```
Дополнительное преимущество CSS в данном случае заключается в том, что вы можете задать разные размеры отступов по вертикали и горизонтали, тогда как через HTML-атрибут устанавливается один размер отступа для всех сторон.
* Cellspacing
Этот атрибут устанавливает расстояние между самими ячейками таблицы. В качестве аналога существует CSS-свойство border-spacing, при помощи которого тоже можно создать промежутки между ячейками. Кроме того, это свойство может принимать два значения одновременно (разделяются пробелом): одно для промежутков по горизонтали, второе — по вертикали.
```
/* аналог cellspacing="10" */
table {
    border-spacing: 10px;
}
```
* Width и height
Разумеется, эти атрибуты можно легко заменить на CSS width и height:
```
/* аналоги width="500" и height="500" */
table {
    width: 500px;
    height: 500px;
}
```
# Разметка CSS <a name="7"></a>
## Ширина веб страницы
Золотая середина и наилучшее решение для современного сайта — это адаптивный веб-дизайн. Суть его заключается в создании нескольких вариаций разметки с коррекцией ширины контейнера в зависимости от размеров экрана. Например, для настольных компьютеров можно установить ширину страницы в 960 пикселей, для планшетов — ширину этой же страницы в 700 пикселей, а для всех смартфонов вообще задать непостоянную ширину в процентах. Таким образом вы можете превратить, к примеру, большой трехколоночный макет в узкий одноколоночный, если сайт просматривается с небольшого экрана.
## Блочная верстка
С помощью разметки определяется расположение элементов на веб-странице. Например, мы создаем шапку сайта, внутри которой размещаем необходимый нам контент (логотип, номера телефонов, навигационное меню и т. п.). Точно так же мы поступаем с основным разделом веб-страницы, а также боковой панелью и футером. Все эти элементы, по сути, являются определенными HTML-тегами. И тегом номер один в блочной верстке является тег div.
## Создание разметки: основные правила
### Mobile First
Mobile First подразумевает совершенно другое мышление в плане размещения элементов на страницах и создания структуры. Главными пунктами здесь являются компактность и информативность, отсутствие отвлекающих факторов и второстепенных элементов.
### Каркас
Прежде чем приступать к верстке страниц сайта, желательно иметь примерные наброски их структуры: количество колонок, расположение основного контента, содержимое хедера и футера и т. д. Это можно сделать как на бумаге, так и в графическом редакторе. Определившись с тем, где и как будут расположены элементы веб-страниц, вы сможете более быстро создать HTML-каркас, который затем будет стилизоваться через CSS.
Структурные схемы страниц на английском называются wireframes. При разработке серьезных сайтов созданию схематических страниц уделяется большое внимание, поскольку они являются отображением результата работ по проектированию. 
### Верстка
На основе макетов можно приступать к написанию HTML и CSS-кода. Имея представление о том, какие элементы будут на веб-странице, можно подобрать для них соответствующие теги.

С помощью CSS добавляется стилевое оформление для элементов. Есть есть необходимость в дополнительных «зацепках» для стилей CSS, к тегам добавляются классы. Давайте описательные и лаконичные имена классам — это хороший тон.

В большинстве случаев, создавая HTML-каркас страницы, необходимо двигаться сверху вниз — от шапки к футеру. Все элементы будут отображаться последовательно друг за другом, если только вы не повлияете на это через CSS.
### Позиционирование и слои
С помощью каскадных таблиц стилей можно исключать элементы страницы из общего потока, фиксировать их на экране, перемещать на другой конец страницы, накладывать одни элементы на другие, словно слои и т. д. Для этого используется свойство position.
Кстати, визуально перемещать элементы можно и с помощью уже хорошо знакомых вам свойств margin и padding. При добавлении к элементу полей и/или отступов с определенной стороны образуется пустое пространство, которое, по сути, смещает элемент. Например, добавив с верхней стороны блочного элемента свойство margin с положительным значением, мы сместим элемент вниз, а отрицательное значение приведет к смещению элемента вверх.
### Подходы к созданию макета
Как уже не раз упоминалось, до развития блочной верстки веб-страницы часто создавались таблицами (т. н. табличная верстка). Это позволяло относительно легко построить колоночный макет и расположить элементы в желаемом порядке.

С появлением свойства float стало возможным создавать макеты без таблиц. И хотя этот подход еще популярен, он уже не является самым современным способом создания разметки.

Спецификация CSS Flexible Box Layout Module подняла верстку на новый уровень и очень упрощает разработку макетов. Среди преимуществ Flexbox выделяется возможность сделать любой блок «резиновым», гибкое поведение элементов, инструмент для горизонтального и вертикального выравнивания, автоматическое преобразование элементов в столбцы и строки и многое другое.
## Медиа-запросы CSS
```
/* ------------------------------------------ */
/* ----- От маленьких экранов к большим ----- */
/* ------------------------------------------ */

/* Стили для очень маленьких экранов (телефоны в книжной ориентации,
дисплей менее 576 пикселей). Записываются без медиа-запросов,
поскольку в Bootstrap это значение по умолчанию */

/* Стили для маленьких экранов (телефоны в альбомной ориентации,
дисплей 576 пикселей и более) */
@media (min-width: 576px) { ... }

/* Стили для средних экранов (планшеты, дисплей 768 пикселей и более) */
@media (min-width: 768px) { ... }

/* Стили для больших экранов (ПК, дисплей 992 пикселей и более) */
@media (min-width: 992px) { ... }

/* Стили для очень больших экранов (ПК с большим монитором,
дисплей 1200 пикселей и более) */
@media (min-width: 1200px) { ... }

/* ------------------------------------------ */
/*------ От больших экранов к маленьким ------*/
/* ------------------------------------------ */

/* Стили для очень больших экранов (дисплей 1200 пикселей и более).
Записываются без медиа-запросов, так как контрольная точка
для очень больших экранов не имеет верхней границы по ширине */

/* Стили для больших экранов (дисплей максимум 1199 пикселей) */
@media (max-width: 1199px) { ... }

/* Стили для средних экранов (дисплей максимум 991 пикселей) */
@media (max-width: 991px) { ... }

/* Стили для маленьких экранов (дисплей максимум 767 пикселей) */
@media (max-width: 767px) { ... }

/* Стили для очень маленьких экранов (дисплей максимум 575 пикселей) */
@media (max-width: 575px) { ... }
```
Кроме этого, в Bootstrap задействуются еще несколько вариаций контрольных точек для записи стилей под конкретный диапазон ширины экранов. При этом используются сразу оба условия — для минимума и для максимума:
```
/* Стили для очень маленьких экранов (дисплей максимум 575 пикселей) */
@media (max-width: 575px) { ... }

/* Стили для маленьких экранов (дисплей шириной от 576 пикселей до 767 пикселей) */
@media (min-width: 576px) and (max-width: 767px) { ... }


/* Стили для средних экранов (дисплей шириной от 768 пикселей до 991 пикселей) */
@media (min-width: 768px) and (max-width: 991px) { ... }


/* Стили для больших экранов (дисплей шириной от 992 пикселей до 1199 пикселей) */
@media (min-width: 992px) and (max-width: 1199px) { ... }


/* Стили для очень больших экранов (дисплей минимум 1200 пикселей) */
@media (min-width: 1200px) { ... }
```

Чтобы добавить медиа-запрос в таблицу стилей, запишите следующее:
```
@media (min-width: 576px) {
	/* здесь будут CSS-стили */
}
```
Внутрь скобок медиа-запроса поместите стили CSS, как вы делаете это обычно:
```
@media (min-width: 576px) {
	.column {
		width: 100%;
	}
	h1 {
		font-size: 24px;
	}
	/* и так далее... */
}
```
Желательно размещать все медиа-запросы под обычными стилями, а не над ними. Если вы используете контрольные точки, отталкиваясь от минимальной ширины экрана (min-width), размещайте их в порядке возрастания ширины экрана. Если вы применяете max-width, тогда расположите медиа-запросы в порядке уменьшения ширины. В противном случае одни медиа-запросы будут перезатирать предыдущие.
## От фиксированных значений к относительным
Если вы создаете гибкую сетку с нуля, при этом и руководствуясь правильной grid-системой, то с вычислением ширины колонок у вас не должно возникнуть проблем. Однако, если вы переводите уже готовый макет из фиксированного в адаптивный, то ситуация может немного усложниться.

Допустим, имеется двухколоночный макет. Ширина основного контейнера составляет 960 пикселей. Ширина одной колонки — 600 пикселей, второй — 360 пикселей:
```
.container {
	width: 960px;
}
.main {
	width: 600px;
}
.sidebar {
	width: 360px;
}
```
Как правильно перевести эти значения из пикселей в проценты? Для начала займемся основным контейнером и перепишем для него стили таким образом:
```
.container {
	width: 100%;
	max-width: 960px;
}
```
Далее, для перевода значений ширины колонок из пикселей в проценты необходимо разделить это значение на значение ширины контейнера (в пикселях), а затем полученное дробное число перевести в проценты, умножив его на 100. В случае с нашим примером мы разделим число 600 на 960, получим 0,625. Умножим результат на 100 и получим 62,5. Это и есть процентное значение, которое мы поставим вместо пиксельного:
```
.main {
	width: 62.5%;
}
```
Те же самые расчеты проведем для второй колонки: 360 / 960 = 0,375 * 100 = 37,5.
```
.sidebar {
	width: 37.5%;
}
```
Обратите внимание, что полученные числа округлять не нужно. В противном случае вы рискуете получить сумму либо более 100 (что приведет к выпадению колонки из ряда), либо менее 100 (что отобразится на внешнем виде макета: он уже не будет идеально соответствовать старому виду, который определялся пиксельными значениями).

Браузер нормально воспринимает дробные значения, несмотря на то, что пиксель не делится, поэтому смело используйте их. В том же Bootstrap можно встретить значения ширины колонок наподобие 33.33333333% и 66.66666667%. Самое главное, помните, что общая ширина всех колонок в одном ряду не должна превышать 100% ни на йоту.
## Адаптивные изображения с помощью CSS
Как сделать изображение адаптивным с помощью CSS? Для начала вам понадобится убрать атрибуты ширины и высоты в теге изображения (если таковые имеются). Ваш HTML-код не должен их содержать:
```
<img src="https://goo.gl/PAuNsb" alt="baobab" width="400" height="300" />

<!-- атрибуты width и height необходимо убрать -->

<img src="https://goo.gl/PAuNsb" alt="baobab" />
```
В таблицу стилей добавьте следующую запись:
```
img {
	max-width: 100%;
}
```
## Адаптивные видео
Чтобы сделать адаптивными теги <video>, а также <embed> и <object>, добавьте для них такой же CSS-код, как и для изображений. Желательно перечислить сразу все селекторы:
	
```
img, video, embed, object {
	max-width: 100%;
}
```
	
## Адаптивные iframe
Дела обстоят сложнее, если вы встраиваете видео через тег iframe. Тогда вышеописанный метод здесь не работает. Придется прибегнуть либо к помощи JavaScript, либо использовать более хитрый CSS-код.

Если вы выбрали второй вариант, вам понадобится поместить тег iframe в дополнительный контейнер div. Например:
	
```
<div class="video">
	<iframe src="video_url" allowfullscreen></iframe>
</div>
```
Затем добавьте следующий код CSS:
```
.video {
	height: 0;
	position: relative;
	padding-bottom: 56.25%;
}
.video iframe {
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
}
```
Как вы заметили, в коде присутствует свойство padding-bottom со странным значением 56.25%. Что это означает? Значение padding-bottom, указанное в процентах, считается относительно ширины блока. Число 56.25 мы получили, определив соотношение сторон встраиваемого видео (16:9) и разделив число короткой стороны на число длинной стороны, после чего умножив результат на 100:

(9/16) * 100 = 56.25%

Если вы собираетесь встраивать видео с другим соотношением сторон, скажем, 4:3, то для определения подходящего значения padding-bottom проделайте ту же процедуру:

(3/4) * 100 = 75%

Данный метод используется и в фреймворке Bootstrap.
## Flexbox
Flexbox — мощный модуль, который включает в себя большой набор свойств и обладает большими возможностями. Рассмотрим основные преимущества flexbox:
* Блоки легко становятся гибкими, элементы могут сжиматься и растягиваться, заполняя пространство.
* Нет никаких проблем с тем, чтобы выровнять элементы по вертикали и горизонтали.
* Неважно, в каком порядке расположены HTML-элементы. Вы можете изменить их порядок через CSS.
* Элементы могут самостоятельно выстраиваться в ряд или образовывать столбец.
* Очень простая адаптация под направление текста RTL (right-to-left). Если в браузере установлена локаль RTL, все flex-элементы автоматически отобразятся в обратном порядке.

Чтобы получить возможность пользоваться модулем flexbox, первым делом необходимо задать родительскому контейнеру свойство display: flex, вот так:
```
.container {
    display: flex;
}
```
Это свойство превратит обычный блок во flex-контейнер. После этого дочерние элементы контейнера автоматически преобразуются во flex-элементы. Кроме этого, можно задать значение inline-flex, которое сделает flex-контейнер инлайновым (строчным).
### CSS-свойства для flex-контейнера

1. Свойство flex-direction позволяет управлять направлением главной оси flex-контейнера. Данное свойство предназначено для применения к контейнерам и принимает следующие значения:
* row (значение по умолчанию) — направление главной оси пролегает слева направо (как на схеме выше) для локали LTR и справа налево для локали RTL.
* row-reverse — здесь, наоборот, направление главной оси пролегает справа налево, если локаль LTR, и слева направо, если локаль RTL.
* column — направление главной оси пролегает сверху вниз.
* column-reverse — направление главной оси пролегает снизу вверх.

2. Вы можете указать flex-контейнеру, каким образом будут выравниваться его дочерние элементы вдоль главной оси. Как правило, это помогает распределить лишнее свободное пространство, если flex-элементы негибкие, либо гибкие, но достигшие максимального размера.
Свойство justify-content применяется к flex-контейнеру, и принимает такие значения:
* flex-start (значение по умолчанию) — flex-элементы прижимаются к началу главной оси.
* flex-end — flex-элементы прижимаются к концу главной оси.
* center — flex-элементы центрируются по главной оси.
* space-between — первый flex-элемент находится в начале главной оси, последний flex-элемент — в ее конце, а все остальные flex-элементы равномерно распределяются в пределах оставшегося пространства.
* space-around — все flex-элементы равномерно распределяются на главной оси, при этом свободное пространство поровну делится между ними.

3. Align-items — еще одно свойство, применяемое к flex-контейнеру для выравнивания его дочерних элементов. Только на этот раз выравнивание происходит не по главной оси, а по поперечной. Рассмотрим список значений:
* stretch (значение по умолчанию) — flex-элементы растягиваются вдоль поперечной оси (если при этом указаны свойства min-width/max-width, они принимаются во внимание).
* flex-start — flex-элементы прижимаются к началу поперечной оси.
* flex-end — flex-элементы прижимаются к концу поперечной оси.
* center — flex-элементы центрируются по поперечной оси.
* baseline — flex-элементы выравниваются по своим базовым линиям.

4. На примерах выше были показаны примитивные примеры с использованием лишь одной строки (столбца) flex-контейнера. Да, по умолчанию так и есть: flex-контейнер содержит в себе лишь одну линию. Но благодаря свойству flex-wrap можно активировать многострочность во flex-контейнере. Свойство принимает следующие значения:
* nowrap (значение по умолчанию) — flex-элементы размещаются в одной линии, слева направо (либо справа налево для локации RTL).
* wrap — flex-элементы выстраиваются горизонтально в несколько рядов (при условии, что они не помещаются в один ряд). Направление элементов — слева направо (или справа налево для RTL).
* wrap-reverse — принцип действия идентичен предыдущему свойству, с той лишь разницей, что расположение flex-элементов происходит в реверсном порядке.

5. Свойство flex-flow — это, по сути, сокращенная запись свойств flex-direction и flex-wrap. Вы можете одной строкой задать направление главной оси и определить многострочность flex-контейнера. В свойстве указываются два значения через пробел: одно для flex-direction, второе для flex-wrap. Пример:
`flex-flow: column wrap-reverse;`

6. Данное свойство работает только в том случае, если flex-контейнер поддерживает многострочность. При помощи align-content можно указать, как будут выравниваться ряды flex-элементов по вертикали. Доступные значения:
* stretch (значение по умолчанию) — ряд flex-элементов растягивается по вертикали, пока не упрется в следующий ряд (если при этом указаны свойства min-width/max-width, они принимаются во внимание).
* flex-start — ряды flex-элементов прижимаются к началу flex-контейнера.
* flex-end — ряды flex-элементов прижимаются к концу flex-контейнера.
* center — ряды flex-элементов вертикально центрируются во flex-контейнере.
* space-between — первый ряд flex-элементов находится в начале flex-контейнера, последний ряд flex-элементов — в конце, а все остальные ряды равномерно распределяются в пределах оставшегося пространства.
* space-around — все ряды flex-элементов равномерно распределяются в вертикальном пространстве flex-контейнера, при этом свободное пространство поровну делится между ними.

### CSS-свойства для flex-элементов

1. Свойство flex-basis задает базовый размер flex-элемента по главной оси. Значение может быть указано в любых единицах измерения CSS, таких как проценты, пиксели и т. д. В качестве значения также принимается ключевое слово auto — тогда на размеры элемента влияют свойства width/height либо контент, который в нем содержится.

2. С помощью свойства flex-grow можно определить, какое количество свободного пространства может занять flex-элемент по сравнению с другими flex-элементами. В качестве значения указывается число (можно использовать целые и дробные числа), которое обозначает пропорции.
Разберемся, как работает свойство flex-grow. По умолчанию дочерние элементы flex-контейнера выстраиваются друг за другом горизонтально. Если места не хватает, flex-элементы сужаются. Но если места достаточно, элементы не растягиваются — вы можете сами решать, насколько сильно они будут растянуты. Свойство flex-grow определяет, каким образом оставшееся свободное место распределяется между flex-элементами, и какая доля этого пустого пространства отводится для каждого из них. Иными словами, положительное свободное пространство «раздается» flex-элементам в указанных пропорциях (в зависимости от их значения flex-grow).

Для примера: если для всех flex-элементов установлено значение flex-grow: 1, а один из них получил значение flex-grow: 2, то он займет в два раза больше свободного места, чем элементы со значением flex-grow: 1. Обратите внимание, что размер самого элемента не будет вдвое увеличен.

3. Свойство flex-shrink задает коэффициент сужения flex-элементов в контейнере и определяет, насколько сильно flex-элемент будет уменьшаться по отношению к другим flex-элементам, чтобы уместить все элементы в один ряд. В качестве значения указывается число (можно использовать целые и дробные числа), которое обозначает пропорции.

По своему действию данное свойство похоже на предыдущее, с той разницей, что здесь пространство не «раздается», а «отбирается», а количество этого отбираемого пространства зависит от указанного значения для flex-shrink, а также от flex-basis.

4.Свойство flex является короткой записью и объединяет в себе три свойства: flex-grow, flex-shrink и flex-basis. Второй и третий параметры (flex-shrink и flex-basis) опциональны. По умолчанию установлены следующие параметры:

flex: 0 1 auto;

Рекомендуется использовать сокращенную запись flex вместо того, чтобы записывать каждое из трех свойств по отдельности.

5. Свойство align-self позволяет переопределить выравнивание по умолчанию (либо перезаписать значение, заданное свойством align-items) для отдельных flex-элементов.

Свойство align-self принимает те же значения, что и align-items:
* stretch (значение по умолчанию) — flex-элемент растягивается вдоль поперечной оси (если при этом указаны свойства min-width/max-width, они принимаются во внимание).
* flex-start — flex-элемент прижимается к началу поперечной оси.
* flex-end — flex-элемент прижимается к концу поперечной оси.
* center — flex-элемент центрируется по поперечной оси.
* baseline — flex-элемент выравнивается по своей базовой линии.

6. По умолчанию flex-элементы выводятся на странице в исходном порядке (т. е. в котором они расположены в HTML). При помощи свойства order можно управлять порядком вывода flex-элементов в контейнере. В качестве значения задается целое число, которое означает вес позиции. Чем меньше число, тем выше позиция.

На примере ниже показано, каким образом работает свойство order. Элемент «Default» выводится первым, потому что у него вес 0 (и это значение по умолчанию). Следом за ним идет элемент «First» с весом 1, затем — элемент «Second» с весом 6, и в конце — элемент «Third» с весом 99.

7. Flex-элемент легко поддается вертикальному и горизонтальному центрированию через свойство margin: auto (в обычном режиме данная запись дает лишь горизонтальное центрирование).

8. Flex-контейнер не является блочным контейнером, поэтому некоторые свойства, которые были созданы для блочной разметки, не работают с flex-разметкой. В частности:
* Свойства float и clear не оказывают влияния на flex-элементы и не исключают их из потока.
* Свойство vertical-align не влияет на flex-элементы.
* Псевдоэлементы ::first-line и ::first-letter не применяются к flex-контейнеру.
* «Схлопывание» margin не работает во flex-потоке.

## Позиционирование CSS. Свойство position
Свойство position позволяет определить то, как будет позиционироваться элемент на странице. Для этого существует пять различных значений, которые рассмотрены ниже.
* absolute — данное значение задает абсолютное позиционирование элемента. Что это значит? Во-первых, абсолютно позиционированный элемент полностью отделяется от общего потока HTML-документа. Другие элементы страницы будут вести себя так, будто абсолютно позиционированного элемента не существует. Во-вторых, абсолютно позиционированный элемент можно перемещать относительно его родителя (по умолчанию это окно браузера) при помощи свойств top, right, bottom и left (о них мы расскажем уже в следующем уроке).
* relative — относительное позиционирование элемента. В данном случае элемент, как обычно, размещается относительно своего текущего положения в потоке документа, то есть визуальных изменений не видно. Но затем, пользуясь свойствами top, right, bottom и left, можно двигать относительно позиционированный элемент в нужном направлении (начальной точкой отсчета будет исходное положение элемента). Это чем-то похоже на функцию translate() свойства transform.
* fixed — фиксированное позиционирование элемента. По принципу работы это похоже на абсолютное позиционирование, однако разница в том, что в отличие от абсолютно позиционированного элемента, фиксированный элемент остается на месте при прокрутке веб-страницы (аналогичным образом себя ведет фиксированное фоновое изображение).
* sticky — это микс относительного и фиксированного позиционирования. Элемент позиционируется относительно до тех пор, пока не пересекает определенный порог, после чего элемент становится фиксированным в рамках ближайшего родителя. По состоянию на 2017 год не очень хорошо поддерживается браузерами. Необходимо использование вендорного префикса -webkit-.
* static (значение по умолчанию) — статическое позиционирование. Такой элемент ведет себя как обычно. На практике данное значение может применяться, например, для перезаписи другого значения. Свойства top, right, bottom и left не влияют на элемент со статическим позиционированием.

Еще одна особенность абсолютно позиционированного элемента заключается в том, что если его родителем является элемент с относительным, фиксированным либо абсолютным позиционированием, то при перемещении абсолютно позиционированного элемента свойствами top, right, bottom и left точка отсчета будет вестись от данного родительского элемента. В противном случае абсолютно позиционированный элемент ведет свой отсчет от окна браузера. Таким образом можно привязать абсолютно позиционированный элемент к родительскому контейнеру и контролировать пределы, за которые он выходит.
### Свойства top, left, bottom, right
Как вы знаете, в браузере есть область просмотра — это та его часть, в которой отображается веб-страница. У данной области есть четыре стороны — верхняя, левая, нижняя и правая. И в CSS для каждой из этих сторон существует соответствующее свойство: top, left, bottom и right.

С помощью данных свойств вы можете задавать расстояние между позиционированным элементом и:
* соответствующей стороной окна браузера,
* соответствующей стороной родительского элемента,
* его точкой отсчета (для относительно позиционированных элементов).

Совершенно не обязательно задавать значения сразу для четырех сторон: используйте лишь те свойства, которые необходимы для перемещения элемента в нужном направлении.

В качестве значений принимаются любые единицы измерения длины в CSS. Например, вы можете установить расстояние между позиционированным элементом и сторонами браузера в размере 5% от левого края окна браузера и 40px от верхнего края окна браузера. Если расстояние задано в процентах, оно вычисляется, исходя из ширины/высоты родительского элемента. Также принимаются и отрицательные значения.

Помимо этого, можно установить значение auto (к слову, оно задано по умолчанию) и тем самым перезаписать предыдущие настройки. Обратите внимание, что значения 0 и auto не равны между собой и действуют по-разному.

Кратко рассмотрим каждое свойство:
* top — задает расстояние от верхнего края родительского элемента до верхнего края дочернего элемента. Если значение положительное, позиционируемый элемент смещается вниз относительно его точки отсчета. При отрицательном значении элемент смещается вверх.
* left — задает расстояние от левого края родительского элемента до левого края дочернего элемента. Если значение положительное, позиционируемый элемент смещается вправо относительно его точки отсчета. При отрицательном значении элемент смещается влево.
* bottom — задает расстояние от нижнего края родительского элемента до нижнего края дочернего элемента. Если значение положительное, позиционируемый элемент смещается вверх относительно его точки отсчета. При отрицательном значении элемент смещается вниз.
* right — задает расстояние от правого края родительского элемента до правого края дочернего элемента. Если значение положительное, позиционируемый элемент смещается влево относительно его точки отсчета. При отрицательном значении элемент смещается вправо.
### Z-index: наслаивание элементов
Свойство z-index принимает числовые значения — подходят целые числа (положительные, отрицательные, ноль). Чем больше число, тем выше находится элемент по оси Z. При равных значениях z-index элементы накладываются в порядке следования в HTML.

Значением свойства z-index по умолчанию является auto

Вышеописанная способность элементов изменять порядок наложения друг на друга с помощью свойства z-index работает лишь в том случае, если эти элементы существуют в одном контексте наложения. Что это значит?

Контекст наложения (англ. stacking context) — это концепция трехмерного размещения HTML-элементов по оси Z, расположенной перпендикулярно экрану. Контекст наложения может быть сформирован любым элементом, который соответствует хотя бы одному из следующих условий:
* Элемент является корневым, т. е. существует в корневом контексте наложения. Любой элемент веб-страницы является таковым, если только он не присутствует в локальном контексте наложения (в том, который создается любым из способов ниже).
* Абсолютно позиционированный (position: absolute) либо относительно позиционированный (position: relative) элемент с любым значением z-index, кроме auto.
* Элемент со свойством position: fixed и любым значением z-index.
* Элемент со свойством display: flex либо display: inline-flex и любым значением z-index, кроме auto.
* Элемент со свойством opacity и значением менее 1.
* Элемент с любым значением свойства transform, кроме none.
* Элемент с любым значением свойства mix-blend-mode, кроме normal.
* Элемент с любым значением свойства filter, кроме none.

Итак, если соблюдать один из вышеперечисленных пунктов (применить к элементу позиционирование и z-index либо свойство opacity со значением меньше единицы и т. п.), то формируется новый контекст наложения. Внутри контекста наложения дочерние элементы можно перемещать по оси Z в соответствии с обычными правилами.

Контекст наложения может являться частью другого контекста наложения, тем самым создавая своеобразную иерархию контекстов. Если внутри родителя дочерний элемент создает свой собственный контекст наложения, то значения z-index будут учтены в пределах родителя. Элементы, которые не создают свой контекст наложения, используют родительский контекст наложения.

Один контекст наложения является полностью независимым от соседнего контекста. Это означает, что вы не можете, к примеру, наложить дочерний элемент А из одного контекста поверх дочернего элемента Б из другого контекста, если родитель элемента А находится ниже родителя элемента Б (подразумевается, что эти родители являются создателями разных контекстов).

В начале урока мы сравнили принцип работы z-index со слоями в Adobe Photoshop. После того, как вы узнали о контекстах наложения, имеет смысл вспомнить и о группах слоев в Фотошопе. Представьте себе, что элемент со свойством z-index — это слой, а контекст наложения — это группа слоев. Вы можете как угодно изменять порядок наложения слоев в пределах группы. Также вы можете менять порядок наложения самих групп. Однако вы не можете наложить определенный слой из нижней группы на слои верхней группы — разве что переместить наверх всю нижнюю группу либо извлечь нужный слой из этой группы.

В примитивном варианте свойство z-index работает просто: чем больше значение, тем выше находится элемент (слой). Но стоит только столкнуться с разными контекстами наложения (группами), как всё становится намного сложнее, и начинает казаться, что z-index не работает. Рекомендуем дополнительно попрактиковаться в данной теме: создайте различные контексты наложения, используя список выше, и понаблюдайте за тем, как ведут себя элементы с z-index в этих контекстах. А в качестве удобной ассоциации вспоминайте слои и группы Adobe Photoshop.
### Скрытие элементов средствами CSS
1. Если быть точным, свойство opacity не скрывает элемент, а лишь определяет его степень прозрачности. Значение 1 означает полную непрозрачность объекта, а значение 0, соответственно, приводит к полной прозрачности, в результате чего элемент перестает быть виден для посетителя. Последняя часть предложения важна: элемент будет скрыт лишь визуально, но при этом он будет занимать свое место на странице, влиять на положение других элементов, и с ним можно будет взаимодействовать (к примеру, он станет непрозрачным при наведении мыши, если определить соответствующий стиль для состояния :hover). Скрин-ридеры также будут видеть данный элемент.

Преимуществом свойства opacity является его совместимость с transition. Это значит, что можно заставить элемент изменять свою прозрачность плавно, а не рывком. Тем самым можно создать красивое появление элемента

2. В отличие от свойства прозрачности, свойство visibility специально предназначено для визуального скрытия элементов. Значение hidden скрывает элемент, а значение visible — показывает. Как и в случае с opacity, элемент продолжает занимать свое место на странице, однако взаимодействовать с элементом, скрытым с помощью visibility: hidden, нельзя. Скрин-ридеры не видят такой элемент.

Свойство visibility не реагирует на свойство transition, а это означает, что изменение значения с hidden на visible (либо наоборот) будет происходить мгновенно.

На практике для временного скрытия элементов часто используется два свойства сразу — visibility и opacity (в одном из практических уроков мы уже показывали этот прием). При этом убивается сразу несколько зайцев: с помощью visibility элемент скрывается как положено (в т. ч. от скрин-ридеров), а с помощью opacity обеспечивается плавное появление элемента в необходимый момент.

3. Свойство display со значением none стоит использовать в том случае, если вам нужно полностью скрыть элемент. Такой объект (и все его дочерние элементы) не только перестает быть виден посетителю и скрин-ридеру, но и не занимает места на странице и не влияет на расположение других элементов. Всё выглядит так, словно элемента и нет. Естественно, взаимодействовать с элементом, который скрыт данным образом, тоже невозможно.

Как и в случае со свойством visibility, свойство display не поддерживает плавные переходы transition. 

4. Еще один способ скрыть элемент исключительно визуально — задать ему абсолютное позиционирование, выдернув из общего потока документа, и затем переместить далеко за пределы видимой области путем установки больших отрицательных значений для свойств top и left. Например:
```
div {
	position: absolute;
	top: -9999px;
	left: -9999px;
}
```
Логично предположить, что спрятать таким образом элемент от скрин-ридеров нельзя, да и в целом не рекомендуется применять этот вариант скрытия, поскольку есть более надежные и правильные способы, описанные выше. Однако в некоторых нетривиальных ситуациях веб-разработчики всё же используют его.

## Кратко о CSS Grid Layout
Работа с Grid Layout похожа на Flexbox и заключается в применении специальных CSS-правил к родительскому элементу (grid-контейнеру) и к его дочерним элементам (grid-элементам). Для начала необходимо:

* определить grid-контейнер путем добавления к нему свойства display со значением grid;
* задать размеры строк и столбцов, используя свойства grid-template-rows и grid-template-columns;
* поместить дочерние элементы в сетку при помощи свойств grid-row и grid-column.

Как и в случае с Flexbox, последовательность расположения HTML-элементов не сильно важна для Grid: при помощи CSS можно упорядочить объекты по вашему желанию. Это позволяет легко перестраивать макет, используя медиа-запросы. Только представьте себе, что для адаптации веб-страницы под разные размеры экрана вам понадобится написать всего несколько строк CSS-кода. Grid Layout однозначно является самым мощным модулем из когда-либо представленных.

1. Grid-контейнер (англ. grid container) — это элемент, которому задано свойство display: grid. Он является непосредственным родителем всех grid-элементов. Пример grid-контейнера:
```
<div class="grid-container"> <!-- это grid-контейнер -->
    <div class="grid-item"></div>
    <div class="grid-item"></div>
    <div class="grid-item"></div>
    <div class="grid-item"></div>
</div>
```
2. Grid-элементы (англ. grid items) — прямые потомки grid-контейнера. Важно: потомки grid-элементов уже не являются потомками grid-контейнера. Пример grid-элементов:
```
<div class="grid-container">
    <div class="grid-item"></div> <!-- это grid-элемент -->
    <div class="grid-item"></div> <!-- это grid-элемент -->
    <div class="grid-item">       <!-- это grid-элемент -->
        <div class="some-item"></div> <!-- это НЕ grid-элемент -->
    </div>
    <div class="grid-item"></div> <!-- это grid-элемент -->
</div>
```
3. Grid-линии (англ. grid lines) — это разделительные линии, которые составляют структуру сетки. Линии могут быть горизонтальными и вертикальными (grid-линии строк и grid-линии столбцов) и располагаться по обе стороны от строки или столбца.

4. Grid-путь (англ. grid track) — пространство между двумя соседними grid-линиями. Можно думать о них как о строках и столбцах сетки.

5. Grid-ячейка (англ. grid cell) — пространство между двумя соседними горизонтальными и двумя соседними вертикальными grid-линиями.

6. Grid-область (англ. grid area) — это общее пространство, окруженное четырьмя grid-линиями. Grid-область может состоять из любого количества grid-ячеек.

### CSS-свойства для grid-контейнера
Итак, для инициализации grid-контейнера необходимо применить к необходимому HTML-элементу свойство display, указав одно из трех следующих значений:
* grid (создает блочный grid-контейнер);
* inline-grid (создает строчный grid-контейнер);
* subgrid (если ваш grid-контейнер сам по себе является grid-элементом, вы можете использовать это свойство, чтобы размеры его строк/столбцов были взяты из его родительского элемента).
```
.grid-container {
    display: grid;
}
```
> Обратите внимание: на grid-контейнер не оказывают влияния такие свойства, как float, clear, vertical-align и column.

1. Свойства grid-template-rows и grid-template-columns
Данные свойства определяют размеры строк и столбцов сетки. В значениях указываются необходимые параметры через пробел, которые означают размеры каждого grid-пути, а между ними можно указывать названия grid-линий.

Значения:
* <длина-пути> — может быть указана в единицах измерения длины CSS, в процентах или же в виде доли свободного места в сетке (с использованием единицы fr (англ. fraction));
* <имя-линии> — произвольное имя на ваше усмотрение, заключенное в квадратные скобки.

Схема:
```
.grid-container {
    grid-template-rows: <длина-пути> ...
                        или <имя-линии> <длина-пути> ...;
    grid-template-columns: <длина-пути> ...
                           или <имя-линии> <длина-пути> ...;
}
```
 Grid-линия может иметь несколько имен одновременно! В примере ниже третьей grid-линии будет присвоено два имени — col-three и the-end:
```
.grid-container {
    grid-template-columns: [col-one] 50% [col-two] 50% [col-three the-end];
}
```
Если некоторые условия построения сетки повторяются, можно использовать функцию repeat() для компактности и удобства. Например:
```
.grid-container {
    grid-template-columns: 40px [col-40] 40px [col-40] 40px [col-40] 10%;
}

/* код выше эквивалентен коду ниже */

.grid-container {
    grid-template-columns: repeat(3, 40px [col-40]) 10%;
}
```
Единица fr позволяет задать размер grid-пути в виде доли свободного пространства в grid-контейнере. Например, следующий код приведет к тому, что каждая колонка будет занимать ⅓ ширины grid-контейнера:
```
.grid-container {
    grid-template-columns: 1fr 1fr 1fr;
}
```
Вычисление свободного пространства происходит только после применения фиксированных значений. В примере ниже общий объем свободного пространства, доступного для значений fr, не включает в себя 70 пикселей:
```
.grid-container {
    grid-template-columns: 1fr 70px 1fr 1fr;
}
```
2. Свойство grid-template-areas
Свойство grid-template-areas определяет шаблон сетки, используя имена grid-областей, которые заданы с помощью свойства grid-area (данное свойство применяется к grid-элементам и рассматривается в следующем уроке). Количество повторов имени grid-области определяет, сколько grid-ячеек образует эта область. Точка обозначает пустую grid-ячейку. Сам синтаксис являет собой визуализацию структуры сетки.

Значения:
* <имя-области> — имя grid-области, заданное свойством grid-area;
* . — точка, которая обозначает пустую grid-ячейку;
* none — grid-области не определены.

Схема:
```
.grid-container {
    grid-template-areas: "<имя-области>
                         или .
                         или none 
                         или ..."
                         "...";
}
```
Пример использования:
```
.grid-item-header {
    grid-area: header;
}
.grid-item-main {
    grid-area: main;
}
.grid-item-sidebar {
    grid-area: sidebar;
}
.grid-item-footer {
    grid-area: footer;
}
.grid-container {
    display: grid;
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: auto;
    grid-template-areas: "header header header header header"
                         "main main main . sidebar"
                         "footer footer footer footer footer";
}
```
Этот код определяет сетку с пятью столбцами и тремя строками. Ширина столбцов одинаковая — каждый занимает одну долю (1fr) свободного пространства grid-контейнера. Вся верхняя строка является grid-областью с названием header и содержит пять ячеек. Средняя строка включает в себя трехъячеечную grid-область main, одну пустую ячейку и одноячеечную grid-область sidebar. Последнюю строку полностью занимает grid-область footer из пяти ячеек.

> Важно: каждая строка в объявлении должна иметь одинаковое количество ячеек.

Для создания одной пустой grid-ячейки можно использовать любое количество точек, стоящих рядом. Иными словами, до тех пор, пока между этими точками нет пробелов, они будут представлять собой одну grid-ячейку.

Обратите внимание, что здесь вы не даете имена grid-линиям, а именуете только grid-области. При этом grid-линии на обоих концах grid-областей будут получать имена автоматически. К примеру, если grid-область называется header, то начальная горизонтальная grid-линия и начальная вертикальная grid-линия получат имя header-start, а конечная горизонтальная grid-линия и конечная вертикальная grid-линия получат имя header-end. Таким образом некоторые grid-линии могут иметь несколько имен. В нашем примере выше крайняя левая grid-линия имеет три имени: header-start, main-start и footer-start.

3. Свойство grid-template
Свойство grid-template — это сокращенная запись, которая позволяет одновременно задать значения для свойств grid-template-rows, grid-template-columns и grid-template-areas.

Значения:
* none — устанавливает исходные значения для всех трех свойств;
* <grid-template-rows> / <grid-template-columns> — задает свойствам grid-template-columns и grid-template-rows соответствующие указанные значения, а свойству grid-template-areas присваивает значение none.

Схема:
```
.grid-container {
    grid-template: none
                   или <grid-template-rows> / <grid-template-columns>;
}
```
Также существует более сложный, но весьма удобный синтаксис для указания значений всех трех свойств. Примеры полной и сокращенной записи:
```
.grid-container {
    grid-template-rows: [row1-start] 100px [row1-end row2-start] 100px [row2-end];
    grid-template-columns: auto 50px auto;
    grid-template-areas: "header header header" 
                         "footer footer footer";
}

/* код выше эквивалентен коду ниже */

.grid-container {
    grid-template: [row1-start] "header header header" 100px [row1-end]
                   [row2-start] "footer footer footer" 100px [row2-end]
                   / auto 50px auto;
}
```
Поскольку свойство grid-template не сбрасывает неявные свойства сетки (grid-auto-columns, grid-auto-rows и grid-auto-flow), при том, что в большинстве случаев вы захотите это сделать, рекомендуем использовать свойство grid вместо grid-template.

4. Свойства grid-row-gap и grid-column-gap
Данные свойства определяют размеры grid-линий. Вы можете думать об этом как об установке промежутков между строками и столбцами. Значение задается в любых доступных единицах измерения CSS:
```
.grid-container {
    grid-column-gap: 15px;
    grid-row-gap: 30px;
}
```
Такие промежутки создаются только между строками/колонками, но не с внешних краев.

5. Свойство grid-gap
Как вы догадались, свойство grid-gap представляет собой сокращенную запись свойств grid-row-gap и grid-column-gap. В значении указываются два параметра через пробел — сначала для промежутков между строками, затем для промежутков между столбцами:
```
.grid-container {
    grid-gap: 30px 15px;
}
```
Если между строками и колонками планируются одинаковые промежутки, в значении свойства grid-gap можно указать один параметр.

6. Свойство justify-items
Свойство justify-items выравнивает содержимое внутри grid-элемента вдоль оси строки. Значение влияет на все grid-элементы контейнера.

Доступные значения:
* stretch (значение по умолчанию) — содержимое заполняет всю ширину grid-области;
* start — содержимое прижимается к левому краю grid-области;
* end — содержимое прижимается к правому краю grid-области;
* center — содержимое выравнивается по центру grid-области.

7. Свойство align-items
Свойство align-items выравнивает содержимое внутри grid-элемента вдоль оси столбца. Применяется ко всем grid-элементам контейнера.

Доступные значения:
* stretch (значение по умолчанию) — содержимое заполняет всю высоту grid-области;
* start — содержимое прижимается к верхнему краю grid-области;
* end — содержимое прижимается к нижнему краю grid-области;
* center — содержимое выравнивается по центру grid-области.

8. Свойство justify-content
Может случиться так, что общий размер сетки будет больше, чем размер grid-контейнера. Например, такое может произойти, если ширина всех grid-элементов является фиксированной (т. е. задана в таких единицах как px). В этом случае вы можете установить выравнивание сетки в grid-контейнере с помощью свойства justify-content. Это свойство выравнивает сетку вдоль оси строки.

Доступные значения:
* stretch — изменяет размеры grid-элементов так, чтобы сетка могла заполнить всю ширину grid-контейнера;
* start — выравнивает сетку по левому краю grid-контейнера;
* end — выравнивает сетку по правому краю grid-контейнера;
* center — выравнивает сетку по центру grid-контейнера;
* space-around — добавляет равное количество пространства между каждым grid-элементом, а по краям сетки оставляет половину этого пространства;
* space-between — добавляет равное количество пространства между каждым grid-элементом, но по краям сетки не создает пространства;
* space-evenly — добавляет равное количество пространства между каждым grid-элементом, включая края сетки.

9. Свойство align-content
Данное свойство похоже на предыдущее, с той лишь разницей, что теперь выравнивание сетки происходит по оси столбца. Свойство align-content принимает те же значения, что и justify-content (вы можете посмотреть их выше). Мы не будем их дублировать, но упомянем об отличии значений start и end: если в случае со свойством justify-content сетка выравнивается по левому (start) или правому (end) краю, то при использовании данных значений со свойством align-content сетка будет выравниваться либо по верхнему краю grid-контейнера (start), либо по нижнему (end).

10. Свойства grid-auto-rows и grid-auto-columns
Данные свойства определяют размеры любых grid-путей, сгенерированных автоматически (неявных grid-путей). Неявные grid-пути создаются, когда вы явно задаете позицию строк и столбцов (через свойства grid-template-rows и grid-template-columns), которые находятся за пределами заданной сетки.

В качестве значения устанавливается размер пути в любых единицах измерения длины CSS, а также в процентах или долях свободного пространства fr.

Чтобы понять, как создаются неявные grid-пути, взгляните на демонстрацию ниже:
```
.grid-container {
    grid-template-rows: 150px 150px;
    grid-template-columns: 250px 250px;
}
```
Этот код создаст сетку 2×2. Но теперь представьте, что вы используете свойства grid-row и grid-column для размещения ваших grid-элементов следующим образом:
```
.item-a {
    grid-row: 2 / 3;
    grid-column: 1 / 2;
}
.item-b {
    grid-row: 2 / 3;
    grid-column: 5 / 6;
}
```
Мы сказали элементу .item-b начинаться в столбце 5 и заканчиваться в столбце 6, но мы никогда не создавали столбцы 5 и 6. Именно потому, что мы ссылаемся на несуществующие столбцы, появятся неявные grid-пути с шириной 0. И мы можем использовать свойства grid-auto-rows и grid-auto-columns для определения размеров этих неявных grid-путей:
```
.grid-container {
    grid-auto-columns: 250px;
}
```
11. Свойство grid-auto-flow
Если у вас есть grid-элементы, которые вы не создавали явно, то сработает алгоритм автоматического размещения этих элементов. Свойство grid-auto-flow позволяет управлять тем, как работает алгоритм авторазмещения.

Допустимые значения:

* row (значение по умолчанию) — говорит алгоритму авторазмещения заполнять каждую строку сетки поочередно, добавляя новые строки по мере необходимости;
* column — говорит алгоритму авторазмещения заполнять каждый столбец сетки поочередно, добавляя новые столбцы по мере необходимости;
* dense — говорит алгоритму авторазмещения попытаться заполнить ранее образовавшиеся промежутки в сетке, если появятся подходящие по размеру grid-элементы. Важно: это может привести к изменению порядка вывода элементов.

Например, взгляните на этот HTML-код:
```
<div class="grid-container">
    <div class="item-a">item-a</div>
    <div class="item-b">item-b</div>
    <div class="item-c">item-c</div>
    <div class="item-d">item-d</div>
    <div class="item-e">item-e</div>
</div>
```
Мы определяем сетку с двумя строками и пятью столбцами и задаем свойство grid-auto-flow со значением row:
```
.grid-container {
    display: grid;
    grid-template-rows: 150px 150px;
    grid-template-columns: 250px 250px 250px 250px 250px;
    grid-auto-flow: row;
}
```
При размещении элементов в сетке укажем позиции только для двух из них:
```
.item-a {
    grid-column: 1;
    grid-row: 1 / 3;
}
.item-e {
    grid-column: 5;
    grid-row: 1 / 3;
}
```
Поскольку мы установили значение row для свойства grid-auto-flow, наша сетка будет выглядеть так. Обратите внимание, как три элемента, которые мы не размещали (.item-b, .item-c и .item-d), размещаются в строках самостоятельно:

И, соответственно, если мы зададим для свойства grid-auto-flow значение column, то элементы .item-b, .item-c и .item-d разместятся в столбцах:
```
.grid-container {
    display: grid;
    grid-template-rows: 150px 150px;
    grid-template-columns: 250px 250px 250px 250px 250px;
    grid-auto-flow: column;
}
```
12. Свойство grid
Наконец, мы дошли до последнего свойства в списке. Итак, свойство grid — это краткая запись, позволяющая в одной строке определить следующие свойства:
```
    grid-template-rows
    grid-template-columns
    grid-template-areas
    grid-auto-rows
    grid-auto-columns
    grid-auto-flow
```
Также свойство grid устанавливает исходные значения для свойств grid-column-gap и grid-row-gap, даже если они не заданы явно в данном свойстве.

Значения:
* none — устанавливает значения по умолчанию для всех свойств;
* <grid-template-rows> / <grid-template-columns> — устанавливает указанные значения для свойств grid-template-rows и grid-template-columns соответственно, а также задает значения по умолчанию для других свойств;
* <grid-auto-flow> [<grid-auto-rows> [ / <grid-auto-columns>] ] — устанавливает указанные значения для свойств grid-auto-flow, grid-auto-rows и grid-auto-columns соответственно. Если значение для свойства grid-auto-columns не задано, то ему задается значение, установленное для grid-auto-rows. Если значения не заданы для обоих свойств, устанавливаются значения по умолчанию.

Схема:
```
.grid-container {
    grid: none
          или <grid-template-rows> / <grid-template-columns>
          или <grid-auto-flow> [<grid-auto-rows> [/ <grid-auto-columns>]];
}
```
Следующие блоки CSS-кода идентичны по своему действию:
```
.grid-container {
  grid-template-rows: 150px auto;
  grid-template-columns: 1fr auto 1fr;
  grid-template-areas: none;
}

/* код выше эквивалентен коду ниже */

.grid-container {
  grid: 150px auto / 1fr auto 1fr;
}
```
Следующая пара также эквивалентна:
```
.grid-container {
  grid-auto-flow: column;
  grid-auto-rows: 1fr;
  grid-auto-columns: auto;
}

/* код выше эквивалентен коду ниже */

.grid-container {
  grid: column 1fr / auto;
}
```
Свойство grid также понимает более сложный, но удобный синтаксис для установки всех параметров сразу. Вы определяете свойства grid-template-areas, grid-template-rows и grid-template-columns, а для всех остальных свойств устанавливаются их значения по умолчанию. Иными словами, вы определяете имена grid-линий, размеры grid-путей и шаблон сетки. Это проще описать на примере:
```
.grid-container {
    grid-template-areas: "header header header"
                         "footer footer footer";
    grid-template-rows: [row1-start] 1fr [row1-end row2-start] 30px [row2-end];
    grid-template-columns: auto 65px auto;    
}

/* код выше эквивалентен коду ниже */

.grid-container {
    grid: [row1-start] "header header header" 1fr [row1-end]
          [row2-start] "footer footer footer" 30px [row2-end]
          / auto 65px auto;
}
```
### CSS-свойства для grid-элементов
1. Свойства grid-row-start, grid-row-end, grid-column-start, grid-column-end
С помощью этих свойств можно назначить расположение grid-элемента в сетке, ссылаясь на конкретные grid-линии.

Свойствами grid-row-start / grid-column-start определяется grid-линия, в которой начинается grid-элемент, а свойствами grid-row-end / grid-column-end определяется grid-линия, в которой grid-элемент заканчивается.

Значения:
* <line> — число (номер grid-линии) либо имя grid-линии;
* span <number> — grid-элемент будет занимать указанное количество grid-путей;
* span <name> — grid-элемент будет занимать диапазон до grid-линии, имя которой указано в значении;
* auto — автоматическое размещение.

Схема:
```
.grid-item {
  grid-row-start: <number> или
                  <name> или
                  span <number> или
                  span <name> или
                  auto
}

/* схема идентична и для остальных трех свойств */
```
Если свойства grid-row-end / grid-column-end не объявлены, то по умолчанию grid-элемент будет занимать один grid-путь.

Grid-элементы могут перекрывать друг друга. Вы можете использовать свойство z-index для управления порядком их наслоения.

2. Свойства grid-row и grid-column
Свойства grid-row и grid-column являются краткими записями для свойств grid-row-start + grid-row-end и grid-column-start + grid-column-end соответственно. В качестве значений принимаются те же выражения, что и для обычных версий свойств.

Схема:
```
.grid-item {
    grid-row: <start-line> / <end-line> или
              <start-line> / span <value>;
    grid-column: <start-line> / <end-line> или
                 <start-line> / span <value>;
}
```
Если конечные точки grid-элемента не заданы, он займет один grid-путь.

3. Свойство grid-area
С помощью свойства grid-area можно назначать имена grid-элементам, чтобы затем на них можно было ссылаться из шаблона, созданного через свойство grid-template-areas. Также это свойство можно использовать в качестве еще более короткой записи параметров свойств grid-row-start + grid-column-start + grid-row-end + grid-column-end.

Значения:
* <name> — имя (по вашему выбору);
* <row-start> / <column-start> / <row-end> / <column-end> — номера либо имена grid-линий.

Схема:
```
.grid-item {
    grid-area: <name> или
               <row-start> / <column-start> / <row-end> / <column-end>;
}
```
Присвоение имени grid-элементу:
```
.grid-item {
    grid-area: header;
}
```
Использование свойства в качестве короткой записи значений свойств grid-row-start, grid-column-start, grid-row-end и grid-column-end:
```
.grid-item {
    grid-area: 1 / col4-start / last-line / 6;
}
```

4. Свойство justify-self
Свойство justify-self выравнивает содержимое grid-элемента вдоль оси строки. Это значение применяется к содержимому внутри одного grid-элемента.

Значения:
* stretch (значение по умолчанию) — содержимое заполняет всю ширину grid-элемента;
* start — содержимое прижимается к левому краю grid-элемента;
* end — содержимое прижимается к правому краю grid-элемента;
* center — содержимое выравнивается по центру grid-элемента.

5. Свойство align-self
Свойство align-self выравнивает содержимое grid-элемента вдоль оси столбца. Это значение применяется к содержимому внутри одного grid-элемента.

Значения:
* stretch (значение по умолчанию) — содержимое заполняет всю высоту grid-элемента;
* start — содержимое прижимается к верхнему краю grid-элемента;
* end — содержимое прижимается к нижнему краю grid-элемента;
* center — содержимое выравнивается по центру grid-элемента.


