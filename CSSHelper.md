# Основа
## Популярные псевдоклассы CSS
```
    :link – этот псевдокласс задает стиль ссылкам, по которым пользователь еще не перешел;
    :visited – этот же, наоборот, применяет стиль к уже посещенным ссылкам;
    :hover – определяет стиль элемента, когда на него наведен курсор (может применяться не только к ссылкам);
    :active – задает стиль активной ссылке (то есть, в момент клика по ней);
    :focus – применяет стиль к элементу при фокусировке на нем (например, при установке курсора в строку поиска);
    :not() – этот полезный псевдокласс позволяет выбрать и стилизовать только те элементы, которые не содержат селектор, указанный в скобках.
```
```
    ::after – используется вместе со свойством content и позволяет вывести необходимые данные после содержимого элемента;
    ::before – выполняет похожую функцию, что и предыдущий, только выводит данные перед содержимым элемента;
    ::selection – этот псевдоэлемент распознается браузерами только при использовании двух двоеточий и позволяет установить цвет и фон для текста, который выделен пользователем;
    ::first-letter – используется для изменения стиля первого символа в тексте элемента;
    ::first-line – используется для изменения стиля первой строки текста элемента.
```
## Дочерние селекторы CSS
```
body > p {
	color: #333;
}
```
Обратите внимание на символ > после body. С помощью него вы указываете, что стиль применяется исключительно для дочерних тегов <p> родителя <body>. Если символ убрать, то стиль применится абсолютно ко всем тегам <p>, которые находятся внутри тега <body>, хотя они могут и не являться для него дочерними.

## Дополнительные псевдоклассы
```
    :first-child – с помощью этого псевдокласса можно применить стиль к указанному элементу веб-страницы, при условии, что он является первым дочерним элементом своего родителя;
    :last-child – стиль применяется к указанному элементу веб-страницы при условии, что он является последним дочерним элементом своего родителя;
    :nth-child – позволяет выбрать четные (even) и нечетные (odd) дочерние элементы; также с помощью данного псевдокласса можно стилизовать чередующиеся дочерние элементы, используя выражения вида an+b и числа;
    :only-child – применяется к дочернему элементу при условии, что тот является единственным ребенком у родителя;
    :first-of-type – стиль применяется к первому элементу указанного типа (даже если этот элемент не является первым дочерним для своего родителя и над ним находятся другие дочерние элементы других типов);
    :last-of-type – работает точно так же, как и предыдущий псевдокласс, с той лишь разницей, что стиль применяется к последнему элементу указанного типа;
    :nth-of-type – по принципу работы похож на :nth-child, но ориентируется на тип элемента;
    :only-of-type – применяется к дочернему элементу указанного типа при условии, что тот является у родителя единственным ребенком своего типа.
```
## Соседние селекторы
```
h1+p {
font-style: italic;
}
```
Записывая это правило, в первую очередь необходимо указать имя первого соседа, затем добавить символ + и имя второго соседа (того, к которому мы желаем применить стиль). Можно создавать и более длинные комбинации. Схема написания селектора такая: selector1+selector2+…+selectorN {} (стиль применяется к selectorN).
Примеры написания:
```
/* Отступ от абзаца до картинки 30px */
p+img {
padding-top: 30px;
}
```
```
/* Зеленый цвет для абзаца, который следует после h3 в связке с h2 */
h2+h3+p {
color: green;
}
```
## Родственные селекторы
```
h1 ~ p {
  font-style: italic;
}
```
…и немного HTML для примера:
```
<div>
<p>Текст</p>
<h1>Заголовок 1</h1>
<p>Текст</p>
<p>Текст</p>
<h2>Заголовок 2</h2>
<p>Текст</p>
 </div>

<div>
<p>Текст</p>
 </div>
```
Взгляните на HTML-код: стиль применится ко всем тегам p, которые следуют после тега h1 и находятся до закрывающего тега родителя div. В нашем варианте насчитывается 3 элемента p, к которым применится стиль.
  Используя соседние (смежные) селекторы, вы можете применять стиль к элементу в случае, когда он следует сразу за другим элементом (или группой элементов). Это работает с элементами, которые находятся на одном уровне и имеют общего родителя.
  С помощью родственных селекторов можно применять стиль ко всем элементам выбранного типа в случае, когда они следуют сразу за другим элементом (или группой элементов). Это работает с элементами, которые находятся на одном уровне и имеют общего родителя.

## Селекторы атрибутов
С помощью CSS селекторов атрибутов (англ. attribute selectors) вы можете задавать стиль тем тегам, которые имеют указанные атрибуты. Пример: вы желаете присвоить определенный стиль всем фотографиям, которые имеют атрибут title, не затрагивая все остальные изображения. Делается это просто:
```
img[title] {
	width: auto;
	height: auto;
}
```
Как видим, атрибут title записан в квадратных скобках после названия img, затем идет блок объявлений. А что если вам понадобится создать стиль только для тех изображений с атрибутом title, которым присвоен определенный класс, скажем, .gallery? В таком случае это записывается так:
```
.gallery[title] {
	width: auto;
	height: auto;
}
```
## Атрибуты со значениями
```
img[title="portrait"] {
	border-style: solid;
}
```
## Выборка по началу текста
Селекторы атрибутов также могут пригодиться при оформлении ссылок. Представьте, что вам нужно особым образом выделить все адреса URL с протоколом https://. Для этого достаточно описать, как выглядит начало адреса URL:
```
a[href^="https://"] {
	color: green;
}
```
Обратите внимание на символ ^, который в переводе на наш язык означает «начинается с». Используя его, вы можете придавать свой стиль различным ссылкам (и не только им). Например, чтобы изменить цвет всех ссылок, которые ведут на главную или другие страницы https://google.com, нужно записать:
```
a[href^="https://google.com"] {
	color: green;
}
```
Обратите внимание на то, что наш стиль будет применен строго к тем ссылкам, которые начинаются так https://google.com. Другие варианты написания ссылок, например, https://www.google.com или http://google.com, необходимо записывать отдельно. Пример:
```
a[href^="https://google.com"] {
	color: green;
}

a[href^="https://www.google.com"] {
	color: green;
}


/* Или более короткий способ: */

a[href^="https://google.com"], [href^="https://www.google.com"] {
	color: green;
}
```
## Выборка по концу текста
А может быть вы желаете красиво оформить все ссылки на файлы с расширением .rar? Тогда вам понадобится описать, как выглядит окончание URL:
```
a[href$=".rar"] {
	color: #FFF;
	text-decoration: none;
	background-color: orange;
	padding: 5px 10px;
	cursor: pointer;
}
```
Не забудьте указать после названия атрибута символ $, который означает «заканчивается на».
## Наследование
С помощью inherit можно указать, чтобы элемент наследовал значение свойства у своего предка. Такое значение доступно практически для каждого свойства в CSS.

Для демонстрации используем предыдущий пример: чтобы всё-таки заставить теги p унаследовать рамку border от своего предка body, необходимо записать:
```
p {
	border: inherit;
}
```
## Сброс стилей 
* reset css
* normalize
# Работа с текстом
## Шрифт
Допустим, вы желаете оформить текст шрифтом Verdana, а в качестве запасных установить шрифты Trebuchet MS, Geneva и любой шрифт без засечек. Записывается это таким образом:
```
p  {
	font-family: Verdana, "Trebuchet MS", Geneva, sans-serif;
}
```
Обратите внимание: в коде мы записали название шрифта Trebuchet MS в кавычках. Необходимо брать название шрифта в двойные либо одинарные кавычки тогда, когда в нем содержатся пробелы.
## Подключаем веб-шрифт с помощью @font-face
Предположим, у вас есть свой уникальный шрифт под названием MyUniqueFont в формате TTF и вы желаете, чтобы основной текст веб-страницы отображался именно этим шрифтом. Первое, что нужно сделать, это скопировать файл шрифта в папку, где находятся все остальные файлы сайта. Чтобы не создавать беспорядок, вы можете создать отдельную папку специально для шрифтов, назвав ее, к примеру, fonts.
Далее нам необходимо дать команду браузеру загрузить шрифт MyUniqueFont. Записывается это с помощью директивы @font-face следующим образом:
```
@font-face {
	font-family: MyUniqueFont;
	src: url('fonts/MyUniqueFont.ttf');
}
```
Свойство font-family в данном случае играет другую роль: с помощью него мы присваиваем имя шрифту, чтобы потом использовать это имя при написании стиля:
```
p {
	font-family: MyUniqueFont;
}
```
Во второй строке указывается путь к файлу шрифта. В нашем примере файл MyUniqueFont.ttf находится в папке fonts. У вас URL-адрес может отличаться.
## Шрифты Google Fonts
```
<head>
<link href='http://fonts.googleapis.com/css?family=Roboto&subset=latin,cyrillic'
rel='stylesheet' type='text/css'>

...
</head>
```
Второй способ – подключение шрифта с помощью директивы @import. Готовый код находится во второй вкладке пункта 3 на странице выбранного Google-шрифта. Его нужно добавить в самое начало вашей таблицы стилей (в противном случае файл не импортируется). Выглядит код примерно так:
```
@import url(http://fonts.googleapis.com/css?family=Roboto&subset=latin,cyrillic);
```
После осуществления предыдущих шагов можно начать применять шрифт. Как записывается такое правило CSS, вы уже видели ранее:
```
p {
font-family: 'Roboto', sans-serif;
}
```
Если на первом шаге вы выбрали несколько вариантов начертания (к примеру, добавили вариант жирного шрифта Bold 700), тогда на третьем шаге код немного видоизменится:
```
<link href='http://fonts.googleapis.com/css?family=Roboto:700,400&subset=latin,cyrillic'
rel='stylesheet' type='text/css'>
```
Или:
```
@import url(http://fonts.googleapis.com/css?family=Roboto:700,400&subset=latin,cyrillic);
```
Чтобы затем придать шрифту жирное начертание, запишите CSS-стиль таким образом:
```
p {
font-family: 'Roboto', sans-serif;
font-weight: 700;
}
```
## Размер шрифта в процентах
Вы наверняка уже сталкивались с ситуацией, когда размер шрифта в CSS не задан, вследствие чего браузеру приходится определять размер шрифта «по своему усмотрению». Если точнее, берется предустановленное значение по умолчанию. Именно от него зависят установленные в процентах значения. Например, базовый размер основного текста p, как правило, равняется 16 пикселям. Значение 100% эквивалентно базовому размеру шрифта, который предустановлен в браузере. Поэтому:
```
p {
	font-size: 100%;
}
```
...то же самое, что и значение в браузере по умолчанию:
```
p {
	font-size: 16px;
}
```
Если же в этом случае задать размер шрифта 50%, то он будет равен половине базового размера. Значение 200%, наоборот, увеличит шрифт в два раза.
Важно: процентные значения размера шрифта наследуются. Например, если для родительского тега задан размер шрифта 150%, то все вложенные в него теги также унаследуют это значение.
## Единица измерения em
По принципу работы единица измерения em похожа на проценты. Значение 1em эквивалентно 100% и соответствует базовому размеру шрифта по умолчанию. Соответственно, 0.6em = 60%, 3em = 300% и так далее. Пример записи:
```
font-size: 0.9em;

/* перед точкой можно опустить ноль: */

font-size: .9em;
```
Значения размеров шрифтов, указанные в em, наследуются (как и проценты). Это создает некоторые трудности при работе с CSS. Например, если для родительского элемента div задан размер шрифта 2em, то для вложенного в него такого же элемента div шрифт будет увеличен еще в два раза. 
## Единица измерения rem
В качестве альтернативы можно воспользоваться новой единицей измерения, введенной в CSS3 – rem, которая всегда отталкивается от базового размера шрифта.
Недостатком единицы измерения rem является то, что она не поддерживается некоторыми браузерами, а именно Internet Explorer версии 8 (и ранее), а также Opera Mini 8.
## Ключевые слова
```
xx-small 9px
x-small  10px
small 	 13px
medium 	 16px
large 	 19px
x-large  24px
xx-large 32px
```
Как видим, значение medium соответствует базовому размеру шрифта 16px. Использование ключевых слов ограничивает возможности и лишает гибкости, поэтому профессиональные разработчики не применяют их.
## Жирный шрифт в CSS: свойство font-weight
```
bold 	                          Полужирный шрифт
normal 	                          Обычный шрифт
bolder 	                          Более жирный шрифт, чем у родителя
lighter 	                  Менее жирный шрифт, чем у родителя
inherit 	                  Наследует значение родителя
Числовое значение от 100 до 900   От очень тонкого до очень жирного шрифта
```
Пример записи:
```
p {
font-weight: bold;
}
```
## Курсив в CSS: свойство font-style
```
italic 	 Курсивный шрифт
oblique  Наклонный шрифт
normal 	 Обычный шрифт
inherit  Наследует значение родителя
```
Пример записи:
```
p {
font-style: italic;
}
```
## Прописные и строчные буквы в CSS: свойство text-transform
```
uppercase 	Делает заглавными (прописными) все буквы в тексте
lowercase 	Делает строчными все буквы в тексте
capitalize 	Делает заглавной первую букву каждого слова в тексте
none 	        Не делает изменений
inherit 	Наследует значение родителя
```
Пример записи стиля:
```
h3 {
	text-transform: uppercase;
}
```
## Подчеркивание, зачеркивание текста в CSS: свойство text-decoration
```
underline 	Нижнее подчеркивание текста
overline 	Верхнее подчеркивание текста
line-through 	Зачеркивание текста
blink 	        Мигание текста
none 	        Удаление всех эффектов
inherit 	Наследование значений родителя
```
Пример записи стиля:
```
p a {
	text-decoration: underline;
}
```
## Тень для текста: свойство CSS text-shadow
```
h1 {
	text-shadow: 3px 5px 6px #6C9;
}
```
Как видно, мы указали целых четыре значения через пробел. Пройдемся по порядку:
* 3px – первое значение отвечает за смещение тени по оси X (вправо, влево). Положительным значением тень сдвигается вправо, а отрицательным – влево.
* 5px – второе значение отвечает за смещение тени по оси Y (вниз, вверх). Положительным значением тень сдвигается вниз, а отрицательным – вверх.
* 6px – третье значение отвечает за радиус размытия тени. Этот параметр указывать необязательно. По умолчанию размытие равняется 0 пикселей, что делает тень четкой и неразмытой.
* #6c9 – четвертое значение отвечает за цвет тени. Этот параметр указывать необязательно. По умолчанию цвет тени устанавливается такой же, как у текста, к которому применяется стиль.
## Несколько теней CSS для текста
Можно установить более двух
```
h1 {
  text-shadow: 3px 5px 6px #6C9, -6px -7px 6px #D9FFA7;
}
```
## Межсимвольный интервал CSS: letter-spacing
Задать межсимвольный интервал можно с помощью свойства CSS letter-spacing. Помимо обычных значений (положительных и отрицательных) также можно использовать значения inherit (чтобы наследовать значение у родителя) и normal (если необходимо вернуть нормальное расстояние между символами).
Пример записи межсимвольного интервала:
```
p {
	letter-spacing: 2em;
}
```
## Интервал между словами: word-spacing
Свойство CSS word-spacing отличается от предыдущего тем, что устанавливает расстояние между словами, а не между символами. Для данного свойства тоже предусмотрены значения normal и inherit. Можно задавать отрицательные значения. Ниже показан пример записи стиля:
```
p {
	word-spacing: 6px;
}
```
## Межстрочный интервал: line-height
С помощью свойства CSS line-height можно задавать расстояние между строками текста. Как было сказано в начале темы, для установки интерлиньяжа, помимо других единиц измерения, допускается использовать проценты. Также разрешено записывать значение в виде множителя (числа больше 0): для вычисления расстояния браузер умножит размер шрифта на заданное число. Отрицательные значения не работают. Доступны значения normal и inherit.
Ниже – пример, как сделать межстрочный интервал CSS:
```
p {
	line-height: 180%;
}
```
## Выравнивание текста в CSS: свойство text-align
```
По левому краю 				left
По правому краю 			right
По центру страницы/блока 		center
По ширине страницы/блока 		justify
Выравнивание текста по тому краю,       start
с которого он начинается 
(то есть текст, идущий слева направо, 
выравнивается по левому краю) 				 	 
Выравнивание текста по противоположному end
краю (то есть текст, идущий слева 
направо, выравнивается по правому краю) 						
```
Пример записи стиля:
```
p {
text-align: left;
}
```
## List-style-type: изменение маркера / нумерации
```
Маркер-точка (по умолчанию) 					disc
Маркер-окружность 						circle
Маркер-квадрат 							square
Нумерация арабскими цифрами (по умолчанию) 			decimal
Нумерация арабскими цифрами (перед числами 1-9 добавляется 0) 	decimal-leading-zero
Нумерация прописными буквами латинского алфавита 		upper-latin
Нумерация строчными буквами латинского алфавита 		lower-latin
Наследование значений родителя 					inherit
Удаление маркеров / нумерации 					none
```
Примечание: в таблице приведены только основные значения. Существует более обширный список (грузинская и армянская нумерации, нумерация римскими числами, греческими буквами и т. д.)
## List-style-image: маркер-картинка
```
ul {
	list-style-image: url(images/star.png);
}
```
## List-style-position: расположение маркеров / нумерации
Для CSS свойства list-style-position, которое задает расположение маркеров / нумерации относительно текста, есть два значения – outside и inside. По умолчанию используется значение outside – это значит, что маркер / число отображается как бы отдельно от текста списка, тогда как при значении inside маркер / число располагается внутри текстового блока и обтекается текстом.
Ниже показан пример записи стиля:
```
ul {
	list-style-position: inside;
}
```
## List-style: все вместе
```
/* нумерация прописными латинскими буквами внутри текстового блока: */
ol {
	list-style: upper-latin inside;
}

/* графические маркеры снаружи текстового блока: */
ul {
	list-style: url(images/star.png) outside;
}
```
# Блоки
## Базовый набор
* padding (и производные padding-left, padding-right, padding-top, padding-bottom) – это внутренний отступ от края содержимого до границы блока. Можно устанавливать отступы либо от всех четырех сторон контента, либо только от нужных вам.
* margin (и производные margin-left, margin-right, margin-top, margin-bottom) – это поле, которое являет собой расстояние от границы одного блока до другого. Новички иногда путают свойство margin со свойством padding, поэтому для наглядности ниже показаны рисунки, где лучше понятна разница между этими свойствами. Поля можно задавать как для всех сторон блока одновременно, так и для отдельных.
* border (и производные border-left, border-right, border-top, border-bottom) – это рамка (граница), которую можно задать для блока. Поля margin остаются за пределами рамки, всё остальное находится внутри неё. Рамку можно установить на всех четырех сторонах или только на нужных вам.
* background-color – это цвет фона, заливка цветом, которая применяется к заднему фону блока и не выходит за его пределы. Поля этим цветом не закрашиваются, а контент и рамка располагаются поверх фона.
Также можно настраивать ширину width и высоту height блока (а точнее, контента, который содержится в блоке). Чтобы затем посчитать ширину или высоту всего блока (вместе с отступами, рамкой и полями), необходимо сложить все эти значения. Например:
`width + padding-left + border-left + margin-left + padding-right + border-right + margin-right = полная ширина блока`
## Поля и отступы CSS: отличия свойств margin и padding
Создавать промежутки между элементами можно и тем, и другим способом, но если padding – это отступ от содержимого до края блока, то margin – это расстояние от одного блока до другого, межблоковое пространство.
Значения могут быть указаны в любых единицах CSS – px, em, % и т. д.
Также существует очень удобная вещь как сокращенная запись margin и padding CSS. Если вам необходимо задать поля или отступы для всех четырех сторон элемента, совсем необязательно записывать свойство для каждой стороны по отдельности. Всё делается проще: для margin и padding можно указывать сразу 1, 2, 3 или 4 значения. От количества значений зависит, как распределяются настройки:
```
4 значения: задаются отступы для всех сторон элемента в такой последовательности: сверху, справа, снизу, слева:
padding: 2px 4px 5px 10px;
3 значения: задается отступ сначала для верхней стороны, потом одновременно для левой и правой, а затем – для нижней:
padding: 3px 6px 9px;
2 значения: задаются отступы сначала одновременно от верхней и нижней стороны, а затем – одновременно для левой и правой:
padding: 6px 12px;
1 значение: задаются одинаковые отступы для всех сторон элемента:
padding: 3px;
```
Те же правила касаются и свойства margin CSS. Обратите внимание на то, что для margin можно использовать и отрицательные значения (например, -3px), которые иногда бывают весьма полезными.
## Схлопывание margin
Схлопывание margin работает только для верхних и нижних полей элементов и не относится к полям с правой и левой сторон. Окончательная величина промежутка высчитывается в разных ситуациях по-разному:
* Когда оба значения margin положительные, итоговый размер поля будет равен бóльшему значению.
* Если одно из значений является отрицательным, то для вычисления размера поля нужно получить сумму значений. Например, при значениях 20px и -18px размер поля будет равен:
`20 + (-18) = 20 — 18 = 2 пикселя.`
* Если оба значения отрицательные, сравниваются модули этих чисел и выбирается число, бóльшее по модулю (следовательно, меньшее из отрицательных чисел). Пример: необходимо сравнить значения полей -6px и -8px. Модули сравниваемых чисел равны 6 и 8 соответственно. Отсюда следует, что 6 < 8, то есть, -6 > -8. Итоговый размер поля равен -8 пикселей.
* В случае, когда значения указаны в разных единицах CSS, они приводятся к одной, после чего сравниваются и выбирается бóльшее значение.
* Размер margin для дочерних элементов определяется еще более интересно: если у потомка поле margin больше, чем у родителя, то приоритет отдается ему. В этом случае размеры верхнего и нижнего полей родителя станут такими, как задано у потомка. При этом расстояния между родителем и потомком не будет.
## Блочные элементы
Блочные элементы являются основой, которая используется для верстки веб-страниц. Такой элемент представляет собой прямоугольник, который по умолчанию занимает всю доступную ширину страницы (если иное значение не указано в CSS), а длина элемента зависит от его содержимого. Такой элемент всегда начинается с новой строки, то есть, располагается под предыдущим элементом. Блочный элемент может содержать в себе другие блочные и строчные элементы.
Примеры блочных элементов: `<div>, <p>, <ul>, <ol>, <h1>` и другие.

## Строчные элементы
В отличие от блочного, строчный элемент не переносится на новую строку, а располагается на той же строке, что и предыдущий элемент. Такие элементы, как правило, находятся внутри блочных элементов и их ширина зависит лишь от содержимого и настроек CSS. Еще одно отличие строчного элемента от блочного заключается к том, что в нем может находиться только контент и другие строчные элементы. Блочные элементы в строчные вкладывать нельзя.
Примеры строчных элементов: `<a>, <span>, <strong>, <em>, <img>` и т. д.	

```
в HTML5 порядок вложения тегов такой роли не играет. Элементы уже не просто делятся на блочные и строчные, а группируются по смыслу и назначению, представляя собой категории контента.
```
## CSS-свойство display: меняем тип элемента
При помощи крайне полезного свойства display в CSS можно заставить блочный элемент выглядеть как строчный и наоборот. Чтобы блочный элемент вел себя как inline-элемент (т. е. не переводился на новую строку), для него необходимо записать правило:
```
display: inline;
```
Если же необходимо отобразить строчный элемент как block-элемент (чтобы до и после элемента происходил перенос строки), запишите следующее:
```
display: block;
```
Также можно сделать «гибрид» — блочный элемент с поведением, как у строчного. В этом случае всё содержимое таких блочных элементов будет отображаться, как обычно, но при этом блоки будут вести себя как строчные элементы, выстраиваясь в одной строке друг за другом и переносясь на новую строку лишь при необходимости. Схлопывание margin в таких случаях перестает действовать. Для превращения элемента в блочно-строчный запишите:
```
display: inline-block;
```
## Border-width: ширина границы
С помощью свойства border-width задается ширина границы. Наиболее часто этот размер указывается в пикселях. Можно задать одинаковую либо различную ширину для всех четырех границ, например:
```
/* все 4 границы имеют ширину 2px: */
border-width: 2px;

/* верхняя и нижняя границы имеют ширину 2px, левая и правая — 4px: */
border-width: 2px 4px;

/* верхняя граница — 2px, левая и правая — 6px, нижняя — 3px: */
border-width: 2px 6px 3px;

/* верхняя граница — 2px, правая — 3px, нижняя — 4px, левая — 5px: */
border-width: 2px 3px 4px 5px;
```
Кроме этого, существуют ключевые слова для обозначения ширины границы:
```
    thin — граница шириной 2px;
    medium — граница шириной 4px;
    thick — граница шириной 6px.
```
## Border-color: цвет границы
Свойство border-color задает цвет для границ. Цвета можно указывать в любом формате CSS: ключевыми словами, в шестнадцатеричном виде либо в RGB — зависит от того, как вам удобнее. По аналогии с предыдущим свойством, можно устанавливать как один цвет для всех границ, так и выбирать разные цвета для каждой границы.
```
border-color: #FFFF00;
```
Также можно задать прозрачный цвет, записав:
```
border-color: transparent;
```
## Border-style: стиль границы
```
    solid — сплошная граница;
    dotted — граница из точек;
    dashed — пунктирная граница;
    double — двойная граница;
    groove — объемная граница-выемка;
    ridge — объемная граница с толстой кромкой (по сути, инверсия предыдущего стиля);
    outset — выдавленная граница;
    inset — вдавленная граница (по сути, инверсия предыдущего стиля).
```
## Общее CSS-свойство border: 3 в 1
` border: 2px dotted #FF0000;`
## Как закруглить углы: свойство CSS3 border-radius
```
.borderElement {
  background-color: #EEDDFF;
  border: 6px solid #7922CC;
  border-radius: 25px;
}

.borderElement1 {
  background-color: #FFE8DB;
  border: 6px solid #FF5A00;
  border-radius: 15px 100px 15px 100px;
}
```
вместо простых круглых углов можно задавать эллиптическое скругление. Для этого понадобится указать два значения, разделенные косой чертой (для горизонтальной и вертикальной полуосей эллипса). Приведем пример на блоке размером 150×450 пикселей:
```
.borderElement {
  background-color: #EEDDFF;
  border: 6px solid #7922CC;
  border-radius: 280px/100px;
}
```
```
    border-top-left-radius — для верхнего левого угла;
    border-top-right-radius — для верхнего правого угла;
    border-bottom-left-radius — для нижнего левого угла;
    border-bottom-right-radius — для нижнего правого угла.
```
## Принцип скругления углов
На рисунке ниже показано, каким образом вычисляется скругление углов в CSS. Так, если для угла указано одно значение, — например, 20px, — это означает, что закругление будет происходить по окружности с радиусом 20 пикселей. В случае, когда задаются два значения через косую черту, например, 30px/20px, закругление углов будет происходить по эллипсу. Первое значение в таком случае является длиной горизонтальной полуоси эллипса — 30px, а второе — длиной вертикальной полуоси — 20px
## Свойство box-shadow: синтаксис
Данный стиль записывается следующим образом:
`box-shadow: inset 4px 4px 8px 5px #333333;`
Рассмотрим по порядку, за что отвечает каждый параметр (слева направо):
* Ключевое слово inset: параметр, который необязательно указывать; рисует тень внутри элемента.
* Сдвиг по оси X: указывает степень смещения тени по горизонтали относительно элемента. Положительное значение означает сдвиг вправо, отрицательное — влево. Значение 0 означает, что тень без сдвига.
* Сдвиг по оси Y: указывает степень смещения тени по вертикали. Положительное значение означает сдвиг вниз, отрицательное — вверх. Значение 0 — это тень без сдвига.
* Радиус размытия: это степень размытия тени. Чем больше значение, тем более размыта тень. Если параметр не указан, используется значение по умолчанию — 0. В таком случае тень будет идеально четкой.
* Расширение: необязательный параметр, отвечающий за растяжение тени по обеим осям; чем больше значение, тем больше растяжение. Расширение работает только при наличии предыдущего параметра. Значение по умолчанию — 0.
* Цвет тени: с этим параметром всё понятно — он задает цвет тени элемента. Цвет по умолчанию — черный.

Данное свойство может принимать несколько групп значений (делать несколько теней одновременно). Для этого понадобится перечислить эти группы параметров через запятую. Например:
```
box-shadow: 15px 15px 20px #8b0163,
            inset 15px 15px 20px #630046;
```
## Width и height: определяем размеры элемента
* В качестве значения ширины можно использовать и единицу em, которая является примерно тем же, чем и размер шрифта текста, но только в условных единицах. К примеру, вы установили размер для шрифта 24px. Тогда 1em для этого элемента будет равен 24 пикселам, а если вы зададите width: 2em, то ширина составит 2×24px = 48 пикселов. Если размер шрифта не задан, он будет унаследован.
* Высота height, заданная в процентах, вычисляется аналогичным образом, что и ширина, но расчет основывается уже на высоте родительского элемента, а не на его ширине. Если родитель отсутствует, высота будет зависеть от высоты окна браузера.
* Сразу стоит запомнить, что у свойств width и height есть особенность — они не включают в себя значения margin, padding и border. Значение, которое вы установите для width/height, будет означать лишь ширину/высоту области содержимого элемента.
* Таким образом, для того чтобы вычислить, например, фактическую ширину элемента (место, которое он в действительности займет на экране), понадобится немного арифметики. Фактическая ширина — это сумма значений, таких как width, padding, border и margin.
* Свойство height может быть удобным, если надо точно контролировать, например, высоту изображения. Однако, если в контейнере будет содержаться текст или любой другой контент, у которого может варьироваться высота, крайне не рекомендуется устанавливать фиксированную высоту для контейнера, так как подобная верстка может привести к неожиданному результату — контент будет отображаться поверх другого содержимого.
* Вместо фиксированной высоты использовать height: auto — эта запись означает, что высота объекта будет рассчитываться автоматически, в зависимости от содержимого, которое он содержит.
* Другой способ избежать развала верстки — использовать запись overflow: auto. В таком случае, если высота содержимого будет превышать значение height своего контейнера, браузер добавит к контейнеру полосу прокрутки.
## Box-sizing
1. В предыдущем уроке мы рассказывали, по какому принципу традиционно вычисляется ширина и высота элемента. Фактическую ширину/высоту образует сумма значений width/height, padding, border и margin.
2. Нередко в процессе верстки возникает необходимость управлять стандартным вычислением размеров элемента. Допустим, вы хотите, чтобы ширина определенного блока <div> составляла 50% от ширины веб-страницы. Для этого вы задаете свойству width значение 50%. И здесь возникает загвоздка: если у блока имеются отступы (padding), поля (margin) либо рамка (border), то они будут считаться отдельно. В итоге ширина блока будет более 50%, а это уже не входит в ваши планы.
3. Как же сделать так, чтобы браузер учитывал отступы, а иногда и рамку, вычисляя ширину блока? На помощь приходит свойство box-sizing, которое может принимать три значения, а именно:

* content-box — значение по умолчанию (поведение, описанное выше). Ширина и высота элемента определяется только свойствами width и height.
* border-box — в данном случае браузер включает отступы padding и рамку border в общую ширину/высоту элемента. Это значит, что если для блока задана ширина, скажем, width: 50%, отступы (например, padding-left: 10px и padding-right: 10px) и рамка (border-width: 1px), то браузер будет считать эти отступы и рамку частью ширины 50%. Ширина самого содержимого составит 50% минус 22 пикселя. Обратите внимание, что значения margin включены НЕ будут.
* padding-box — это значение похоже на предыдущее, только в ширину/высоту элемента будут включены только отступы padding, без рамки. Значения margin также не учитываются. Значение padding-box было исключено из спецификации CSS, однако оно все еще поддерживается браузером Firefox.

   Чтобы свойство box-sizing работало в браузерах Firefox, а также старых версиях Safari, Chrome и Android, следует записывать несколько его вариаций, используя соответствующие префиксы производителя:
```
-moz-box-sizing: border-box;
-webkit-box-sizing: border-box;
box-sizing: border-box;
```
Что же насчет поддержки браузером Internet Explorer? Хорошие новости: box-sizing работает в IE8 и выше.
## Overflow: управление переполненными элементами
* hidden — всё содержимое, выходящее за пределы контейнера, будет скрыто. Не подходит в случае с текстовым контентом, но очень часто используется на практике для решения других задач и предотвращения некоторых «казусов».
* scroll — к контейнеру будут добавлены вертикальные и горизонтальные полосы прокрутки (скролл). Внешне блок становится похож на фрейм. Скролл отображается постоянно.
* auto — также добавляются полосы скролла, но только тогда, когда они необходимы (т. е. если содержимое не влазит в контейнер).
* visible — значение, установленное по умолчанию в браузере. Контент виден, даже если блок переполнен. Можно использовать для сброса другого значения, заданного ранее.
##  Max-width, max-height, min-width, min-height: максимальные и минимальные размеры элемента
* min-width — с помощью этого свойства вы можете указать минимальную ширину элемента. Например, если вы зададите блоку стиль min-width: 50px, то ширина блока может стать больше, но она никогда не станет меньше, чем 50 пикселей. Это очень удобно, например, при создании адаптивной верстки, когда при определенных размерах экрана элемент с относительной шириной становится слишком узким. Свойство min-width позволяет предотвратить такие искажения.
* min-height — работает аналогично предыдущему свойству, но только по отношению к высоте элемента. Безусловно, это тоже очень полезное свойство в практике, которое позволяет задать минимальную высоту элемента.
* max-width — как вы уже догадались, это свойство позволяет задать максимально допустимую ширину элемента. Например, элемент со стилем max-width: 960px может иметь ширину меньше максимальной, но он никогда не станет больше, чем 960 пикселей. Данное свойство удобно использовать при создании адаптивной разметки, когда вам необходимо, чтобы элемент адаптировался под ширину экрана любого устройства, но при этом не слишком широко разъезжался на больших экранах.
* max-height — работает аналогично предыдущему свойству, только по отношению к высоте. Но, как мы уже говорили ранее, лучше не играть с ограничением высоты элемента без крайней надобности.
* auto — это значение можно использовать для отмены действия свойства.
## CSS float
* left — элемент выравнивается по левой стороне. Элементы, находящиеся ниже в потоке, обтекают его с правой стороны.
* right — значение, противоположное предыдущему. Элемент выравнивается по правой стороне, а элементы, находящиеся ниже в потоке, обтекают его слева по левому краю.
* none — элемент не обтекается и находится в своей обычной позиции.
## Отмена обтекания: свойство clear
* left — элемент, к которому применяется свойство clear:left, перестает обтекать элемент со свойством float:left, однако правое обтекание сохраняется.
* right — элемент, к которому применяется свойство clear:right, перестает обтекать элемент со свойством float:right, однако левое обтекание сохраняется.
* both — полностью отменяет обтекание со всех сторон. Элемент смещается вниз и образовывает стандартный поток. На следующие за ним элементы обтекание также перестает влиять.
* none — отменяет очистку clear. Элемент будет вести себя, как обычно, и на него будут влиять настройки float.
# Работа с графикой 
## CSS для тега img
Элемент <img> является стандартным тегом для добавления графических элементов на веб-страницу. Его используют для размещения фотографий, логотипов, графических элементов интерфейса и т. п. Для стилизации тега img можно пользоваться стандартными свойствами CSS, например, border, box-shadow, opacity, float и другими. Это позволяет определять вид и расположение изображения на веб-странице.
На практике, чаще всего к тегу img применяются следующие свойства:
* border — вы можете создать рамку для изображения (или даже для целой галереи фотографий), при этом указав любую ширину и цвет границ. Как вы помните, можно даже стилизовать рамку индивидуально для каждой стороны.
* padding — небольшие внутренние отступы между фотографией и рамкой помогут сымитировать эффект подложки. А с помощью свойства background-color можно изменить и сам цвет подложки.
* box-shadow
* float — применив это свойство ко всем миниатюрам фотографий и добавив еще несколько строк CSS-кода, можно легко создать многострочную галерею
## Background-image: установка фонового изображения
Свойство background-image устанавливает выбранное изображение в качестве фона элемента. В зависимости от цели, можно задать графический фон как для отдельного блока, так и для всей страницы. В качестве единственного значения принимается URL-адрес графического файла. Запись выглядит так:
```
div {
    background-image: url(/img/bg.jpg); /* в круглых скобках — URL картинки */
}
```
## Пути к файлу
* Абсолютный путь
`background-image: url(http://www.example.com/img/bg.png);`
* Относительный путь к файлу
`background-image: url(/img/bg.png);`
`background-image: url(../../bg.png); /* поднимаемся на два уровня */`
* Абсолютный адрес ссылки понадобится использовать, если файл, на который вы ссылаетесь, находится на другом сайте. В пределах одного сайта абсолютный путь практически не используется (хоть он и будет работать). Это связано с несколькими моментами: во-первых, такие ссылки могут быть весьма громоздкими, а во-вторых, если имя домена изменится, то возникнет проблема — все ссылки будут вести на старый домен, что может повлечь за собой множество ошибок и битых ссылок.
* Корневой относительный путь будет работать на веб-сервере, но он бесполезен при разработке на локальном компьютере. Но преимущество этого типа ссылок в том, что вы можете перемещать свою таблицу стилей в любую папку сайта и не бояться, что адреса фоновых изображений станут нерабочими.
* Относительный путь от документа — наилучший вариант при веб-разработке на локальной машине без использования сервера. В браузере вы сможете нормально просматривать веб-страницы, хранящиеся на вашем компьютере, и адреса файлов будут работать. Они будут работать и на живом сайте, но с одним условием — если не перемещать таблицу стилей в другое место (иначе придется корректировать пути).
## Background-repeat: повторение фоновой картинки
Если элементу задать свойство background-image, то фоновый рисунок будет по умолчанию повторяться в двух осях — по горизонтали (x) и по вертикали (y).
Свойство background-repeat предназначено для управления повтором фона, заданного через background-image. Принимает оно следующие значения:
* repeat — то же, что и значение по умолчанию — полностью заполняет элемент фоновым рисунком натурального размера, повторяя его сверху вниз и слева направо. Такой эффект хорошо смотрится только при правильном подборе фона, который в идеале должен быть бесшовным, не слишком ярким, малоконтрастным.
* no-repeat — заполняет элемент фоновым рисунком один раз. Размер фона остается натуральным (не сужается и не растягивается). Свойство с данным значением очень часто применяется на практике (мы рассмотрим это далее в книге).
* repeat-x — фон повторяется только по горизонтали (оси x), до полного заполнения элемента по ширине. Удобно использовать для оформления элементов интерфейса (графическая полоска вдоль шапки сайта и т. п.).
* repeat-y — фон повторяется только по вертикали (оси y), до полного заполнения элемента по высоте. Удобно использовать для оформления элементов интерфейса (графическая полоска по высоте сайдбара и т. п.).
* round — фон повторяется так, чтобы в область элемента поместилось целое число изображений. Если это не удается сделать, фон автоматически подгоняется (масштабируется), чтобы соответствовать условию.
* space — работает так же, как и предыдущее свойство, но с одним отличием: если целое число изображений не помещается в область, рисунки не масштабируются, а между ними добавляется пространство.
## Background-position: позиционирование фона
Свойство `background-position` позволяет указывать начальную позицию фонового рисунка сразу для двух осей — x и y. Впрочем, можно воспользоваться и отдельными свойствами для каждой оси — `background-position-x` и `background-position-y`.
* Горизонтальное позиционирование
```
    left — фоновый рисунок прилеплен к левой стороне элемента;
    center — фоновый рисунок расположен в центре оси x;
    right — фоновый рисунок прилеплен к правой стороне элемента.

div {
	background-position-x: left;
}
```
* Вертикальное позиционирование
```
    top — фоновый рисунок прилеплен к верхней стороне элемента;
    center — фоновый рисунок расположен в центре оси y;
    bottom — фоновый рисунок прилеплен к нижней стороне элемента.

div {
	background-position-y: bottom;
}
```
Если вы установили повтор фона с помощью свойства background-repeat, то background-position будет определять, от какой точки будет начинаться дублирование изображения.
```
background-position: top center; /* фон вверху по центру */
background-position: top right; /* фон в верхнем правом углу */
background-position: bottom left; /* фон в левом нижнем углу */
background-position: center right; /* фон справа по центру */

background-position: center; /* фон по центру */
background-position: left; /* фон слева по центру */
background-position: right; /* фон справа по центру */
background-position: top; /* фон вверху по центру */
background-position: bottom; /* фон внизу по центру */
```
* Точные значения в единицах измерения CSS
```
div {
background-position: 10px 25px;
}

div {
background-position: right 15px bottom 40px;
}
```
Обратите внимание: значение 50% идеально центрирует фоновое изображение (как по вертикали, так и по горизонтали), поскольку точка центра устанавливается в середине фона, а не в его начале или конце.
Как правило, при печати страницы фоновые изображения не отображаются. Учитывайте это при работе с важной графикой — например, логотип компании, карту проезда и другие иллюстрации, содержащие важную информацию, рекомендуется добавлять через тег <img>.
Запись background-position с двумя параметрами поддерживается всеми используемыми браузерами.
## Значения background-attachment
* scroll (значение по умолчанию) — фоновое изображение перемещается вместе с другими элементами при скролле веб-страницы.
* fixed — значение фиксирует фоновое изображение, делая его нечувствительным к скроллу. При прокручивании страницы фон на заднем плане останется неподвижным.
* local — данное значение было добавлено из-за того, что в случае с локальным скроллом фон со значением scroll ведет себя как fixed. При значении local фон прокручивается вместе с содержимым элемента, и не прокручивается, если содержимое не скроллится (но прокручивается вместе с самим элементом).
## Background-origin: позиционирование фонового рисунка
background-origin управляет его позицией относительно рамки (border), отступа (padding) или содержимого элемента. По умолчанию фоновый рисунок отображается, накладываясь на отступы элемента (если они есть), и не подкладывается под рамку. Это положение можно менять, используя следующие значения background-origin:
* padding-box (значение по умолчанию) — фоновое изображение располагается в верхнем левом углу элемента, который является областью отступов padding.
* border-box — фоновое изображение располагается в верхнем левом углу элемента, который является областью рамки (при этом рамка накладывается на фон, перекрывая его часть).
* content-box — фоновое изображение располагается в верхнем левом углу, который принадлежит содержимому элемента.
## Background-clip: свойство для обрезки фона
Свойство background-clip позволяет определять, какую область элемента фон заполняет, а какую — нет. Согласно спецификации, свойство принимает следующие значения:
* padding-box — фон заполняет элемент, включая его отступы, и не заполняет область границ, так что в просветах пунктирной или точечной рамки фон не будет виден.
* border-box (значение по умолчанию) — фон заполняет элемент, включая область рамки (при этом рамка накладывается поверх фона). В случае с фоновым рисунком эффект данного значения будет заметен только при условии, что он повторяется.
* content-box — фон заполняет элемент, включая его содержимое, и не заполняет область отступов и границ.
  Заметьте, что background-clip не меняет начальную точку позиционирования фона, поэтому верхняя и левая стороны фонового рисунка могут обрезаться, если позиционирование у него осталось по умолчанию (это видно на примере с background-clip:content-box).
  Используя background-origin и background-clip в паре, можно исправить проблему обрезки фонового рисунка, о которой мы только что говорили. Например, следующий код заполнит фоном элемент <div> в области контента, а также задаст соответствующую начальную точку позиционирования фонового рисунка:

```
div {
	background-clip: content-box;
	background-origin: content-box;
}
```
## Background-size: масштабирование фонового рисунка
* auto (значение по умолчанию) — если данное значение установлено для горизонтали и вертикали, т. е.:
`background-size: auto auto;`

…то размеры фона останутся оригинальными. Если значение auto задано лишь для одной из сторон, то размер фона будет автоматически подогнан под пропорции изображения. Например, если записать следующее:

`background-size: 250px auto;`

…то высота фоновой картинки будет вычисляться автоматически.

* contain — фоновое изображение масштабируется так, чтобы поместиться внутрь элемента целиком. В зависимости от своей формы и формы элемента, рисунок растягивается, чтобы поместиться полностью либо по ширине, либо по высоте. Пропорции картинки сохраняются.
* cover — фоновое изображение масштабируется так, чтобы полностью заполнить пространство элемента, при этом сохраняя свои пропорции. Если пропорции элемента не соответствуют пропорциям изображения, это может привести к тому, что часть рисунка будет скрыта.

Свойство background-size часто используется на практике. Например, его очень удобно использовать, когда размер элемента указан в процентах. Если задать блоку ширину 50% от ширины экрана, а его фону — ширину 100%, то при изменении размера окна фон всегда будет соответствовать ширине элемента.
##  Свойство background: все настройки фона в одном месте
мы пишем значения всех свойств через пробел как обычно. Исключением являются свойства background-position и background-size — их необходимо разделять знаком слэша /.

Ни одно значение не является обязательным: вы можете не указывать значений тех свойств, которые хотите оставить по умолчанию. К слову, настройки background по умолчанию следующие:
```
background-image: none;
background-position: 0% 0%;
background-size: auto;
background-repeat: repeat;
background-attachment: scroll;
background-origin: padding-box;
background-clip: border-box;
background-color: transparent;
```
Для примера запишем стиль через свойство background, определив только цвет фона (background-color) и порядок его обрезки (background-clip):
```
background: content-box #aaa;
```
Этот код эквивалентен такому коду:
```
background-image: none; /* осталось по умолчанию */
background-position: 0% 0%; /* осталось по умолчанию */
background-size: auto; /* осталось по умолчанию */
background-repeat: repeat; /* осталось по умолчанию */
background-attachment: scroll; /* осталось по умолчанию */
background-origin: content-box;
background-clip: content-box;
background-color: #aaa;
```
## Несколько фоновых рисунков для одного элемента
```
.frame {
  background-image: url(https://goo.gl/tKyzHt), /* верхняя часть рамки */
                    url(https://goo.gl/SUKymM), /* нижняя часть рамки */
                    url(https://goo.gl/Km7HVV); /* середина рамки */

  background-position: center top, /* позиция верха рамки */
                       center bottom, /* позиция низа рамки */
                       center top; /* позиция середины рамки */

  background-repeat: no-repeat, /* верх рамки не повторяется */
                     no-repeat, /* низ рамки не повторяется */
                     repeat-y; /* середина рамки повторяется по вертикали */

  background-size: contain; /* здесь для всех фонов одинаковое значение */
  height: auto; /* высота блока зависит от количества содержимого */
  width: 400px;  /* ширина блока фиксированная */
  padding: 30px; /* внутренние отступы блока */
}
```
```
background: url(https://goo.gl/tKyzHt) center top / contain no-repeat, /* верх рамки */
	         url(https://goo.gl/SUKymM) center bottom / contain no-repeat, /* низ рамки */
	         url(https://goo.gl/Km7HVV) center top / contain repeat-y; /* середина рамки */
```
Такой вариант выглядит менее громоздко и легче воспринимается.
## Linear-gradient(): линейный градиент в фоне
`background-image: linear-gradient(to left, violet, red);`
Цвета точек градиента можно записывать в любом формате, доступном в CSS, будь-то шестнадцатеричный код, формат RGB или другой. Направление градиента задается с помощью приставки to и затем ключевых слов left, right, top и bottom, которые можно комбинировать для изменения наклона. Например:
`background-image: linear-gradient(to bottom right, #ee82ee, #ff0000);`
При заданном угле 0º либо 360º градиентная линия будет идти снизу вверх. При увеличении угла наклона движение вектора происходит по часовой стрелке (при использовании отрицательного значения движение меняется на противоположное). 
`background-image: linear-gradient(-110deg, #ee82ee, #ff0000);`
Если вы хотите увеличить количество данных точек в градиенте, просто допишите их через запятую. Например:
`background-image: linear-gradient(145deg, #ee82ee, slateblue, #ffd86a, purple);`
По умолчанию браузер размещает точки на равном расстоянии, поэтому и градация получается равномерной. Но этим расстоянием можно управлять, используя единицы измерения CSS.
`background-image: linear-gradient(#92009b 20%, #f5e944 90%, #00ffa2);`
В нашем коде после цвета #92009b указано значение 20%. Поскольку оно стоит возле первой опорной точки, это означает, что указанным цветом будет закрашено 20% длины элемента. После чего уже начинается градиент: значение 90% говорит браузеру, что нужно достичь цвета #f5e944 к 90% длины элемента (начав на уровне 20%). После чего в оставшемся пространстве начинается переход к третьему цвету — #00ffa2.
Градиентный фон тоже требует использования данных префиксов, если есть необходимость в поддержке максимального количества браузеров. Для этого адаптируйте код следующим образом:
```
background-image: -webkit-linear-gradient(left, violet, red);
background-image: -moz-linear-gradient(left, violet, red);
background-image: -o-linear-gradient(left, violet, red);
background-image: linear-gradient(to left, violet, red);
```
Для добавления префикса требуется создавать отдельное объявление. Кроме того, как вы могли заметить, свойства с вендорными префиксами не требуют использования приставки to при указании направления градиента.
## Repeating-linear-gradient(): градиент с повторением
`background-image: repeating-linear-gradient(to top right, #034320 60px, #24d24a 120px, #012c13 121px);`
Если разобрать наш пример, то из нижнего левого угла по направлению к верхнему правому углу браузер сначала закрашивает 60 пикселей цветом #034320, затем генерирует градиентный переход к цвету #24d24a, достигая 120 пикселей, после чего, начиная со 121-го пикселя, закрашивает оставшееся пространство цветом #012c13. И, поскольку это не простой, а повторяющийся градиент, действие повторяется заново с самого начала, а градиенты накладываются слоями один на другой.
## Radial-gradient(): радиальный градиент
`background-image: radial-gradient(#5b4ffc, #df02cd);`
Начальная точка вектора радиального градиента находится в центре эллиптической формы (который в свою очередь по умолчанию размещается в центре стилизуемого элемента), откуда градиент расходится кругами. Центр можно смещать, пользуясь теми же значениями, которые принимает background-position. Перед указанием позиции следует использовать приставку at:
`background-image: radial-gradient(at top left, #5b4ffc, #df0253);`
Форма радиального градиента может быть круглой либо эллиптической. Определить форму можно с помощью указания радиуса либо одного из ключевых слов:
* ellipse — градиент эллиптической формы (значение по умолчанию);
* circle — градиент круглой формы.
`background-image: radial-gradient(circle, #5b4ffc, #df0253);`
Значение радиуса может быть указано в любых доступных единицах CSS. Если указать одно значение, то оно будет принято за радиус круга. Два значения интерпретируются как радиус эллипса по оси X и радиус по оси Y. По умолчанию радиальным градиентом полностью заполняется фон элемента.
`background-image: radial-gradient(ellipse 180px 90px, #a09af1, #000038);`
* closest-side — создается градиент, который расходится только до ближайшей стороны элемента:
`background-image: radial-gradient(circle closest-side at 75% 40%, #ffee0e, #2e0a9f);`
* closest-corner — градиент расходится только до ближайшего угла элемента:
`background-image: radial-gradient(circle closest-corner at 75% 40%, #ffee0e, #2e0a9f);`
* farthest-side — противоположно closest-side, градиент расходится до самой дальней стороны элемента:
`background-image: radial-gradient(circle farthest-side at 75% 40%, #ffee0e, #2e0a9f);`
* farthest-corner — противоположно closest-corner, градиент расходится до самого дальнего угла элемента:
`background-image: radial-gradient(circle farthest-corner at 75% 40%, #ffee0e, #2e0a9f);`
* В точности как и с линейным градиентом, для создания многоцветного радиального градиента можно добавлять несколько опорных цветовых точек с указанием расстояния:
`background-image: radial-gradient(#144bf1 30%, #3ee9ca 60%, #0a38e5);`
## Repeating-radial-gradient(): повторяющийся радиальный градиент
По аналогии с линейным градиентом, радиальный градиент также может быть повторяющимся. За это отвечает функция repeating-radial-gradient(). В ней можно указывать те же параметры, что и для просто радиального градиента. Чтобы градиент повторялся, необходимо перечислить не только цвета, но и размеры каждого градиента в подходящих единицах CSS:
`background-image: repeating-radial-gradient(#ff00ea 10px, #2417d7 20px);`
Если вы хотите, чтобы градиентные кольца были размытыми, а не резкими, то первый и последний цвета градиента должны быть одинаковыми:
`background-image: repeating-radial-gradient(circle,#ff00ea 10px, #2417d7 20px, #ff00ea 30px);`
# Ссылки и навигация
## Состояния ссылок в CSS. Псевдоклассы
```
    :hover — ссылка, на которую наведен курсор;
    :active — активная ссылка (та, по которой совершается клик, или на которой удерживается кнопка мыши);
    :link — ссылка, еще не посещенная пользователем;
    :visited — посещенная ссылка
```
> Для справки: из соображений безопасности набор стилей, которые можно использовать для ссылок :visited, ограничен. Посещенные ссылки принимают только свойства color, background-color, border-color (и его производные), column-rule-color, outline-color. При этом свойство к посещенной ссылке можно применить, только если это же свойство задано и для обычной. Прозрачность цвета, установленная через альфа-канал для элемента :visited, будет проигнорирована. JavaScript-метод getComputedStyle всегда возвращает значение цвета непосещенных ссылок, даже если у посещенных ссылок цвет иной.
   Если в ваши планы входит максимально детальная проработка дизайна ссылок, то желательно определить стили для всех четырех состояний. При этом очень важно соблюсти порядок, в котором будут записаны селекторы с псевдоклассами. Обязательно размещайте их в следующей последовательности:
```
a:link { color: red; }
a:visited { color: grey; }
a:hover { color: blue; }
a:active { background-color: yellow; }
```
Что будет, если поменять строки местами? В этом случае некоторые стили перестанут работать согласно правилам каскадности. Дело в том, что ссылка может находиться одновременно в двух состояниях, к примеру, в :visited и в :hover, и если расположить стиль для :hover выше, чем стиль для :visited, то первый перекроется.
Чтобы определить стили для всех состояний данных ссылок, запишите для каждого псевдокласса отдельное правило:
```
#main-menu .menu-link:link { color: red; }
#main-menu .menu-link:visited { color: grey; }
#main-menu .menu-link:hover { background-color: #a38beb; }
#main-menu .menu-link:active { background-color: yellow; }
```
## Варианты стилизации ссылок в CSS
Со ссылками работают самые разнообразные свойства: `color, background, border, border-radius, text-decoration, padding` и т. д
Чтобы иметь возможность подобным образом стилизовать ссылку, нужно заставить ее вести себя как блочный (block) либо строчно-блочный элемент (inline-block). Дело в том, что если вы будете добавлять отступы к строчному элементу (коим по умолчанию является ссылка), то не увидите никакого эффекта.
## Навигационные панели с помощью CSS
* Вертикальное меню
```
.menu {
    list-style-type: none;
    margin: 0;
    padding: 0;
}
```
> По сути, идентичные действия по отношению к спискам делает файл сброса стилей Reset.css, поэтому, если вы используете его на вашем сайте, то код выше можно не записывать.
Прежде всего нужно сделать все теги <a> блочными элементами:
	
`.menu a { display: block; }`
Следующее, что нам понадобится сделать — это задать ширину меню.
`.menu { width: 300px; }`
Чтобы визуально разделить пункты меню, можно задать каждому из них нижнюю или верхнюю границу. В зависимости от того, какую из них вы используете, у вас будет не хватать границы сверху или снизу меню. Это можно исправить, добавив еще одну границу к самому блоку .menu:
```
.menu a {
    border-top: 1px solid blue;
}
.menu {
    border-bottom: 1px solid blue;
}
```
Сейчас ссылки меню выглядят слишком низкими, расположенными близко друг к другу. Если текст каждой ссылки не будет занимать более одной строки, то увеличить их высоту и сохранить при этом текст вертикально по центру можно с помощью свойств height и line-height:
```
.menu a {
  height: 30px;
  line-height: 30px;
}
```
* Горизонтальное меню
1. Первый вариант — задать пунктам списка свойство display со значением inline либо inline-block:
```
.menu li {
  display: inline;
}
```
При этом теги `a` внутри li нельзя делать блочными, иначе пункты перестанут выстраиваться горизонтально и снова встанут в вертикальную позицию. Ссылкам можно также задать значение inline или inline-block. Выберите второе, если вы собираетесь в дальнейшем создавать отступы для ссылок.
После этого можно заняться оформлением ссылок. Например, можно сделать такой стиль:
	
```
.menu a {
  text-decoration: none;
  font-family: sans-serif;
  color: #5757a0;
  display: inline-block;
  padding: 10px 20px;
  background-color: lavender;
  border-bottom: 5px solid #5757a0;
}
```
```
.menu li {
  margin-right: -5px;
}
```
Этот код не убирает промежутки, а прикрывает их за счет сдвига элементов на пять пикселей влево. Данный способ нельзя назвать очень надежным, потому что размер промежутка может варьироваться в зависимости от других стилей.

Если промежутки между пунктами не запланированы в вашем дизайне, лучше воспользоваться вторым методом горизонтального выстраивания элементов.

2. Второй способ
Возможно, вы уже догадались, что второй вариант создания горизонтального меню заключается в использовании свойства float. Для этого добавьте стиль для тегов li:
	
```
.menu li {
  float: left;
}
```
Как видим, промежутков между пунктами уже нет. Все остальные стили работают, как и прежде. Но если вы добавите после навигации другой HTML-элемент (допустим, h1), то на него повлияет обтекание и он встанет в один ряд с пунктами меню. Отменить это действие можно, добавив заголовку свойство clear: left. Но при разработке сайта с большим количеством разных страниц может стать сложно следить за тем, нигде ли вы не забыли указать данное свойство. Гораздо легче отменить обтекание со стороны навигации. В этом поможет такая запись:
	
```
.menu {
  overflow: hidden;
}
```
Это также поможет вернуть нормальную высоту родителя плавающих элементов. Мы уже говорили об этой проблеме в предыдущих уроках, но тогда мы решали ее через специальный хак с использованием псевдоэлемента :after. Пример выше — это еще один способ решить вопрос с исчезнувшей высотой контейнера.
> Примечание: если вы установите фон для элемента .menu, то вы не увидите его до тех пор, пока не примените к нему overflow: hidden. Логично, ведь как можно увидеть фон элемента, чья высота равна нулю?
## Стили для особых ссылок
* Ссылки на e-mail и телефон
```
a[href^="tel:"] { ... }
a[href^="mailto:"] { /* ваш стиль для ссылок на электронную почту */ }
a[href^="tel:+44"] { ... }
a[href^="tel:+38067"] { ... }
```
* Ссылки на файлы
` a[href$=".zip"] { ... } `
* Ссылки с data- атрибутами
В HTML5 есть возможность добавлять пользовательские атрибуты к любому тегу. Эти атрибуты используются для хранения различных значений. Атрибут, который добавляется, обязательно должен начинаться с приставки data-, после чего может идти произвольное имя. Одним из практических вариантов применения таких атрибутов является создание всплывающих подсказок с текстом, который как раз и хранится в значении пользовательского атрибута.

Допустим, что у некоторых ссылок есть пользовательский атрибут data-description. Обратиться к ним можно следующим образом:

`a[data-description] { ... }`

Как вы догадываетесь, можно делать подобные выборки не только на основе data- атрибутов, а и на основе любых других — rel, title, target, class и т. д.

## CSS-спрайты
Переходим к CSS. Первым делом запишем общие стили для всех ссылок:
```
a {
  background-image: url(https://goo.gl/1t18Rz);
  background-repeat: no-repeat;
  height: 98px;
  width: 100px;
  display: inline-block;
  margin-right: 10px;
}
```
Первая строка содержит ссылку на спрайт. По факту, мы задали одно фоновое изображение для всех ссылок. Вторая строка отменяет дублирование фона — здесь оно не потребуется.

Следующие две строки — высота и ширина каждого элемента <a>. Каким образом определялись эти значения? Здесь мы отталкивались от размеров значков в спрайте. Высота каждой иконки равна 98 пикселям, а ширина — 100 пикселей. Далее мы будем позиционировать фоновую картинку для каждой ссылки, подстраивая фон таким образом, чтобы значок ровно вписался в «окошко» ссылки размером 98×100 пикселей.

Первая наша ссылка имеет класс .facebook. Зададим позиционирование для ее фона. Иконка Facebook находится точно в левом верхнем левом углу спрайта, поэтому определить ее позицию будет легко — left top:
```
a.facebook { background-position: left top; }
```
Идем дальше: позиционируем фон для ссылки на Twitter. Иконка Твиттера расположена справа от Facebook и примыкает к ней, не создавая пустых промежутков. Нам необходимо переместить спрайт влево на столько пикселей, чтобы скрыть иконку Facebook и полностью заполнить область ссылки иконкой Twitter. Поскольку ширина каждой иконки равна 100 пикселям, то мы и сдвигаем фон влево на 100 пикселей. Вертикальное позиционирование мы пока нигде не меняем, а оставляем значение top:
```
a.twitter { background-position: -100px top; }
```
Аналогичное действие мы проделаем для остальных ссылок, прибавляя к каждому последующему горизонтальному позиционированию еще 100 пикселей, тем самым сдвигая спрайт всё больше и больше влево. Получится такая картина:
```
a.youtube { background-position: -200px top; }
a.instagram { background-position: -300px top; }
a.linkedin { background-position: -400px top; }
a.tumblr { background-position: -500px top; }
a.google { background-position: -600px top; }
```
# Трансформирование и анимация
## Свойство transform: трансформация элементов
`transform` широко применяется в веб-анимации, но еще его нередко используют для позиционирования и центрирования элементов.
Следует учитывать, что трансформированные элементы не влияют на размещение своих соседей. Передвинутый, наклоненный, увеличенный элемент может перекрыть соседний, наложиться на него. Это работает так потому, что при рендеринге веб-страницы браузер резервирует для элемента то место, где он находился бы до трансформации, после чего применяет стили преобразования. Преобразованный элемент никак не затрагивает положение соседних элементов.
### Функция rotate()
Функция rotate() свойства transform позволяет вращать элемент в 2D-пространстве. В скобках задается угол от 0 до 360 градусов. К числу дописывается приставка deg. Пример:
`transform: rotate(90deg); /* поворот элемента на 90° по часовой стрелке */`
Если установлено значение 0deg, элемент останется в исходном положении. 360deg означает, что элемент совершит один полный оборот по часовой стрелке, 1080deg — три полных оборота, -720deg — два полных оборота против часовой стрелки и т. д.
* Свойство transform поддерживает дополнительные функции, которые позволяют совершать трансформации относительно осей трехмерного пространства:
```
rotateX() — поворот элемента по оси X;
rotateY() — поворот по оси Y;
rotateZ() — поворот элемента по оси Z.
```
* Изначально поворот элемента происходит относительно его центральной оси. Но центр вращения можно изменить, воспользовавшись свойством transform-origin. В качестве значения указываются координаты для трех осей — X, Y и Z.
Единицы измерения для X и Y могут быть любыми. Также принимаются ключевые слова left, center, right (для X) и top, center, bottom (для Y). Для оси Z позволительно использовать корректные единицы измерения длины, кроме процентов.
По умолчанию настройки transform-origin следующие:
`transform-origin: 50% 50% 0; /* x y z */`
### Функция scale()
С помощью функции scale() свойства transform можно увеличивать и уменьшать объекты на веб-странице. Принцип работы заключается в масштабировании элемента по горизонтали и вертикали с указанием коэффициента масштабирования. Пример:
```
transform: scale(3); /* пропорциональное увеличение элемента в 3 раза */
transform: scale(0.5); /* пропорциональное уменьшение элемента наполовину */
```
В качестве параметров функция scale() принимает целые и дробные числа. Для пропорционального масштабирования достаточно указать нужное число в скобках. Так, число выше единицы увеличит масштаб, а число в диапазоне от 0.01 до 0.99 уменьшит его. Число 1 никак не масштабирует элемент, а число 0 приведет к визуальному исчезновению элемента.

Для более произвольного масштабирования можно указать два параметра — для горизонтали и вертикали соответственно. Например, следующий код увеличит масштаб элемента в четыре раза по горизонтали и в полтора раза по вертикали:

`transform: scale(4, 1.5);`

* В CSS также имеется набор функций для управления масштабированием каждой из трех осей по отдельности — X, Y и Z. Называются они соответственно:
```
scaleX() — масштабирование по горизонтали X;
scaleY() — масштабирование по вертикали Y;
scaleZ() — масштабирование по оси Z.
```
В качестве параметра принимаются те же числа, что и для основной функции.
* Вы можете добиться эффекта «отражения в зеркале», если примените отрицательное число в качестве коэффициента масштабирования. При этом флип произойдет даже в том случае, если вы используете -1 (просто не будет эффекта масштабирования):
```
transform: scale(1, -1); /* флип по оси X */
transform: scale(-1, 1); /* флип по оси Y */
transform: scale(-1); /* флип по осям X и Y */
```
### Функция skew()
Функция наклона skew() хорошо подходит для создания эффекта 3D. Принцип ее работы заключается в наклоне всех горизонтальных либо вертикальных линий элемента на определенное количество градусов. Визуально элемент словно искажается, растягивается в определенные стороны. Наклон может производиться по осям X и Y.

Функция skew() принимает два параметра. Первый параметр отвечает за наклон по горизонтали, второй — за наклон по вертикали. В качестве значения указывается угол от 0 до 360 с приставкой deg. Например:
```
transform: skew(30deg, 0);
```
Второй параметр, соответственно, отвечает за наклон горизонтальных линий к оси Y. Направление движения — по часовой стрелке, начиная от правой стороны элемента:
```
transform: skew(0, 30deg);
```
* По аналогии с предыдущими рассмотренными функциями, в CSS есть отдельные функции skewX() и skewY() для управления наклоном от каждой оси по отдельности.

### Функция translate()
`translate(20px, 50px);`
Независимо от того, куда и на какое расстояние вы переместите элемент, место его изначального расположения в потоке документа будет зарезервировано за ним, и другие элементы не смогут его занять. На месте перемещаемого элемента останется пустое пространство, а сам элемент в смещенном состоянии может накладываться либо подкладываться под соседние элементы. Какой элемент будет находиться выше, а какой — ниже, можно определить с помощью свойства z-index 
* Вы также можете управлять перемещением элемента, используя отдельные функции translate для трех осей — translateX(), translateY(), translateZ(). Если в параметре translateZ() указано положительное число, перемещение элемента происходит вперед, если отрицательное — назад.
* Некоторые функции свойства transform имеют дополнительную 3D-версию себя, которая принимает три значения — для трех осей. Так, в расширенной функции translate3d() можно указать значения для X, Y и Z через запятую. Такие же вариации существуют и у некоторых ранее рассмотренных функций — rotate3d() и scale3d().
> Обратите внимание: если у вас не работает translateZ() или другая аналогичная функция, где затрагивается ось Z, не спешите паниковать. Дело в том, что движение по оси Z будет заметным лишь в том случае, если в CSS установлена перспектива.
### Несколько значений свойства transform
В качестве значений свойства transform можно перечислить сразу несколько функций, разделив их пробелом. При этом к элементу последовательно будет применено несколько трансформаций. Пример:

`transform: rotate(45deg) scale(1.2) skew(30deg, 0deg) translate(10px, 20px);`

Порядок записи функций имеет значение. От перестановки значений может измениться конечный результат. В нашем примере элемент сначала поворачивается на 45 градусов в двухмерном пространстве, затем масштабируется, наклоняется и в конце перемещается. Если первой функцией записать, к примеру, skew(), то элемент первым делом будет наклонен, после чего повернут на 45 градусов, масштабирован и перемещен.
### 3D-трансформации в CSS
С помощью 3D-трансформаций, появившихся в спецификации CSS3, есть возможность управлять поведением объекта по оси Z. Если говорить буквально, то данная ось расположена перпендикулярно экрану, т. е. по сути она смотрит зрителю в лицо.

Функции 3D-трансформации являются расширенными функциями двухмерных трансформаций, в которые добавлен параметр для оси Z. Этими функциями являются, например, translate3d(), rotate3d(), scale3d(), а также одиночные записи, такие как translateZ(), rotateZ(), scaleZ().

* Кроме всего прочего, в CSS3 была добавлена еще одна функция — perspective(), которая может быть использована для создания эффекта перспективы, глубины в сцене. Перемещая элемент по оси Z с установленной перспективой, можно наблюдать, как он приближается или отдаляется от зрителя.

Итак, данная функция задает расстояние между плоскостью экрана и точкой сходимости линий. Масштабирование элемента пропорционально d/(d – Z), где d (значение перспективы) — это расстояние от графической плоскости до предполагаемого положения глаз зрителя
* Для перспективы можно изменить точку отсчета при помощи свойства perspective-origin. Оно словно задает точку расположения зрителя при взгляде на перспективу. По умолчанию эта точка находится в центре элемента, но можно определить координаты точки по осям X и Y, из которой наблюдатель будет смотреть на дочерние элементы
* Свойство backface-visibility со значением visible не скрывает содержимое блока, и оно отображается зеркально.

Но если установить для свойства backface-visibility значение hidden, то содержимое элемента будет скрыто с его обратной стороны (включая фон блока). По сути, объект будет невидим на экране, пока он повернут обратной стороной к зрителю.

Но эта возможность может пригодиться, если вам необходимо создать впечатление, что у объекта имеется две стороны. На примере ниже показано, как можно создать игральную карту, используя два фоновых изображения и свойство backface-visibility: hidden. Повернув карту по оси Y на угол более 90 градусов, можно увидеть, как карта развернулась «рубашкой» к зрителю, а лицо карты при этом скрылось
## CSS3 transition: плавные переходы
Чтобы реализовать переход в CSS, необходимо записать два стиля для элемента — начальный и конечный. Также к начальному стилю дописывается свойство transition с необходимыми настройками для осуществления перехода. И, наконец, чтобы воспроизвести переход, понадобится «спусковой крючок», который запустит анимацию. Самый простой пример такого «спускового крючка» — это псевдокласс :hover. В этом случае переход от начального стиля к конечному будет происходить при наведении курсора на элемент. При снятии курсора с элемента конечный стиль будет преобразован обратно в начальный.
Во-первых, анимированию поддаются все трансформации (scale(), rotate(), skew() и т. д.). Во-вторых, можно создавать переходы между значениями таких свойств, как color, background, width, height, opacity и т. д. Весь перечень можно посмотреть на сайте W3.org
### Свойство transition-property
С помощью свойства transition-property можно определить, для каких стилей элемента будет действовать переход. Можно указать одно либо несколько свойств через запятую, а можно задать отслеживание значений всех свойств сразу.
```
/* имена свойств */ — например, если нужно плавно изменять значения свойств color и background-color, просто запишите их имена через запятую;
all — выбрать все свойства;
none — не выбирать никакое свойство.
```
Рассмотрим пример со стилизацией ссылки. Допустим, нам нужно, чтобы при наведении курсора цвет и фон ссылки плавно менялся. Запишем следующее:
```
a {
    display: inline-block;
    width: 200px;
    padding: 10px;
    text-align: center;
    text-decoration: none;
    background-color: #9b20ff;
    color: #fafafa;
    transition-property: color, background-color;
}
a:hover {
    color: #9b20ff;
    background-color: #c9ff20;
    letter-spacing: 2px;
}
```
Итак, мы указали стиль для двух состояний ссылки — начального и конечного (:hover).
Свойство transition-property добавлено к первому стилю, и в его значении содержатся названия свойств, которые мы хотим анимировать.

Но желаемого плавного перехода от цвета к цвету у нас не будет до тех пор, пока не указана длительность анимации.
### Свойство transition-duration
Свойство transition-duration определяет, сколько времени должен длиться переход от одного состояния к другому. Именно оно обеспечивает плавность анимации. По умолчанию переход происходит мгновенно.
Свойство transition-duration определяет, сколько времени должен длиться переход от одного состояния к другому. Именно оно обеспечивает плавность анимации. По умолчанию переход происходит мгновенно.

В качестве значения указывается время в секундах либо миллисекундах. Время записывается целым либо дробным числом, после которого следует приставка s (для секунд) или ms (для миллисекунд). Пробел между числом и приставкой не ставится.
```
transition-duration: 0.6s; /* эта запись эквивалентна нижней */
transition-duration: .6s; /* ноль перед точкой можно опускать */
```
Вернемся к нашему примеру из предыдущего урока. Нам необходимо добавить плавность для перехода между стилями ссылки. Предположим, мы хотим, чтобы переход длился одну секунду. Добавим одну строчку к уже готовому стилю:
```
a {
    display: inline-block;
    width: 200px;
    padding: 10px;
    text-align: center;
    text-decoration: none;
    background-color: #9b20ff;
    color: #fafafa;
    transition-property: color, background-color;
    transition-duration: 1s; /* добавляем длительность перехода */
}
a:hover {
    color: #9b20ff;
    background-color: #c9ff20;
    letter-spacing: 2px;
}
```
Если вы перечислили свойства в transition-property, вы можете указать соответствующую длительность перехода для каждого из них. Порядок указания значений длительности должен соответствовать порядку перечисления свойств. Например:
```
transition-property: color, background-color, letter-spacing;
transition-duration: 1s, .5s, 2s;
```
Такая запись будет означать, что свойство color перейдет от своего начального значения к конечному за одну секунду, background-color — за половину секунды, а letter-spacing — за две секунды.
### Свойство transition-timing-function
Свойство transition-timing-function устанавливает, как будет распределяться скорость движения анимации в течение ее длительности. Распределение скорости анимации происходит в рамках того интервала, который задан через transition-duration.
Скорость анимации можно изобразить в виде математической функции, которая показывает характер ее движения от начальной точки с координатами 0.0, 0.0 до конечной точки с координатами 1.0, 1.0.

В качестве значений можно использовать как предустановленные функции, так и создавать свои. Список ключевых слов, принимаемых свойством transition-timing-function, следующий:
* ease (значение по умолчанию) — начало анимации медленное, к середине скорость повышается и в конце вновь снижается.
* ease-in — начало анимации медленное, к концу она ускоряется.
* ease-out — начало анимации быстрое, к концу она замедляется.
* ease-in-out — начало и конец анимации медленные.
* linear — скорость равномерная на протяжении всей анимации.
* step-start — переход от одного стиля к другому происходит моментально и резко (анимации нет).
* step-end — по истечении заданного времени происходит резкий переход от одного стиля к другому (без анимации).
* steps() — анимация происходит ступенчато. В скобках сначала указывается число шагов, за которые должен осуществиться переход от одного стиля к другому, после чего ставится запятая и указывается параметр start или end, от которого зависит, когда будет начинаться анимация — в начале первого шага или в конце. Пример записи:
* transition-timing-function: steps(10, start);
* cubic-bezier() — значение, позволяющее задать свою функцию движения в виде кубической кривой Безье. Кубическая кривая строится по четырем координатам, которые указываются в скобках в следующем порядке: (x1, y1, x2, y2), где x1 и y1 — это координаты первой точки, а x2 и y2 — координаты второй точки. Аргументы x1 и x2 всегда должны быть в диапазоне от 0 до 1. Многие разработчики для экономии времени создают такие функции на специально созданных для этого онлайн-сервисах с удобным графическим интерфейсом.
### Свойство transition-delay
CSS-анимация не обязательно должна начинаться мгновенно после ее инициализации. Вы можете управлять ее началом с помощью свойства transition-delay. Чтобы отложить совершение перехода на определенное время, укажите его в значении свойства:
```
transition-delay: 1s; /* отложить начало анимации на одну секунду */
```
Данное свойство мало используется при реализации простой интерактивности на сайте, однако оно может быть весьма полезным, если вам предстоит создавать более сложные эффекты. По аналогии с transition-duration можно записать время задержки для каждого свойства, указанного в transition-property (при этом также важно придерживаться порядка перечисления):
```
transition-property: color, background-color, letter-spacing;
transition-duration: 1s, .5s, 2s;
transition-delay: 0s, 0s, 2s; /* задержка анимации letter-spacing на 2 секунды */
```
Не забывайте о кроссбраузерности — абсолютно все свойства семейства transition требуют использования вендорных префиксов:
```
-webkit-transition-delay: 1s;
-moz-transition-delay: 1s;
-o-transition-delay: 1s;
transition-delay: 1s;
```
Возможно, вы замечали, что на некоторых сайтах выпадающие подменю исчезают слишком быстро, при этом сложно поймать нужную ссылку и кликнуть по ней. Предотвратить такое поведение как раз и помогает свойство transition-delay, установленное для обычного элемента и для элемента с псевдоклассом :hover. Значения будут отличаться: для обычного состояния свойство transition-delay должно иметь значение больше нуля, а для состояния наведенного курсора оно должно равняться 0. Пример:
```
.submenu {
    opacity: 0;
    transition-property: all;
    transition-duration: .5s;
    transition-delay: 1s;
}
.menu:hover .submenu {
    opacity: 1;
    transition-delay: 0s;
}
```
Данный код приведет к тому, что появление меню при наведении курсора будет происходить без задержки, а исчезновение задержится на одну секунду. Такой трюк однозначно сделает меню более удобным для использования.
### Сокращенная запись transition
Порядок записи следующий: необходимо указать значения свойств transition-property, transition-duration, transition-timing-function и transition-delay, отделяя их пробелами. Пример:
```
transition: all 1s ease 0s;
```
В ситуации, когда необходимо записать несколько свойств transition-property и, соответственно, несколько значений transition-duration и т. д., запись будет выглядеть таким образом:
```
transition: color 1s ease-in 0s,
            background-color .5s step-end 0s,
            letter-spacing 2s ease-out 2s;
```
Проще говоря, значения для первого свойства вы записываете через пробел, после чего ставите запятую и указываете значения для второго свойства и так далее. В конце ставится точка с запятой.

Из четырех значений обязательно нужно указывать лишь два — transition-property и transition-duration. Для двух других свойств будут использованы значения по умолчанию, если вы не установите другие.
## Анимация CSS3
В отличие от обычного transition, расширенная CSS-анимация позволяет создавать цепочку переходов: от одного набора стилевых правил ко второму, от второго к третьему, от третьего к четвертому и так далее. Кроме этого, увеличивается и количество вариантов запуска анимации: вы можете сделать проигрывание сразу после загрузки веб-страницы, а не только при наведении курсора. Также можно заставить анимацию повториться несколько раз либо вообще сделать бесконечный цикл.
Порядок создания анимации можно разделить на два этапа:
1. Создание необходимого количества ключевых кадров через правило @keyframes. Запись стилей для каждого кадра.
2. Подключение анимации к одному либо нескольким элементам.
### Правило @keyframes
```
@keyframes changeBackgroundColor {
    from {
        background-color: red;
    }
    50% {
        background-color: yellow;
    }
    to {
        background-color: green;
    }
}
```
Запись 50% означает, что фон станет желтым ровно в середине анимации. По такому принципу можно добавлять сколько угодно ключевых кадров — просто используйте необходимое число в процентах (30%, 60%, 75% и так далее). Позже, когда будет задана длительность анимации, станет понятно, сколько времени пройдет до появления желтого цвета. К примеру, если вы установите длительность в размере 6 секунд, то желтый цвет фона появится через 3 секунды после старта анимации.
   Еще более интересно то, что можно создавать паузы в анимации, записывая один набор свойств для нескольких ключевых кадров сразу. Например, чтобы красный цвет сменился на желтый к 33% от длительности анимации, а переход от желтого к зеленому начался после 66%, запишите следующее:
```
@keyframes changeBackgroundColor {
    from {
        background-color: red;
    }
    33%, 66% {
        background-color: yellow;
        transform: translateY(50px);
    }
    to {
        background-color: green;
        transform: translateY(100px);
    }
}
```
Таким образом мы создадим эффект паузы на временном отрезке с 33% до 66%.

Ключевые слова from и to равнозначны процентным записям 0% и 100% соответственно. Вам не обязательно начинать анимацию с 0% и заканчивать на 100%. Ее можно запускать позже и завершать раньше, при этом добиваясь интересных эффектов.
### Запуск анимации: аnimation-name и animation-duration
После того, как будут созданы ключевые кадры @keyframes, вы можете применить анимацию к нужному элементу через CSS. Для этого понадобится добавить к стилю элемента как минимум два свойства группы animation — это animation-name и animation-duration
* Свойство animation-name позволяет привязать к элементу одну или больше анимаций. Для примера возьмем ту анимацию, которую мы создали на прошлом уроке. Мы задали ей имя changeBackgroundColor (оно указано сразу после слова @keyframes). Теперь, чтобы применить ее, например, к элементу <div> с классом .traffic-light, нужно написать такой код:

```
.traffic-light {
    animation-name: changeBackgroundColor;
}
```
Итак, мы сообщили браузеру, какую анимацию нужно применить к элементу .traffic-light, указав ее имя в качестве значения свойства animation-name. Но чтобы анимация выполнилась, потребуется задать еще и ее длительность.
* Данное свойство похоже на рассмотренное нами ранее свойство transition-duration. Оно принимает аналогичные значения времени и устанавливает продолжительность анимации для конкретного элемента. Предположим, мы хотим, чтобы анимация с именем changeBackgroundColor, примененная к элементу .traffic-light, длилась 6 секунд. Добавим к стилю еще одну строку:
```
.traffic-light {
    animation-name: changeBackgroundColor;
    animation-duration: 6s;
}
```
Рядом со свойствами для запуска анимации допускается записывать и другие стили элемента. Так, полный CSS-код для нашего блока выглядит следующим образом:
```
.traffic-light {
    animation-name: changeBackgroundColor;
    animation-duration: 6s;
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: red;
}
```
* К одному элементу можно применить сразу две или больше анимаций. Для этого следует перечислить их названия через запятую в свойстве animation-name. Если при этом вы хотите задать разную длительность для каждой анимации (animation-duration), то перечислите в таком же порядке время исполнения:
```
.traffic-light {
    animation-name: firstAnimation, secondAnimation;
    animation-duration: 3s, 1s;
}
```
Порядок расположения названий анимаций в свойстве animation-name влияет на последовательность их выполнения. В примере выше сначала будет воспроизведена анимация под названием firstAnimation длительностью 3 секунды, а затем запустится анимация secondAnimation с продолжительностью 1 секунда.
### Свойства animation-timing-function и animation-delay
В CSS помимо продолжительности анимации можно задать скорость перехода от одного ключевого кадра к другому, а также время задержки перед воспроизведением анимации. Для этого существуют два свойства – animation-timing-function и animation-delay. 
1. С помощью свойства animation-timing-function можно управлять как скоростью всей анимации, так и скоростью смены значений свойств между ключевыми кадрами анимации. Принцип работы свойства аналогичен свойству transition-timing-function, которое мы не так давно рассматривали.
В качестве значений принимаются те же самые ключевые слова и функции – ease, ease-in, cubic-bezier() и так далее. Мы не будем повторяться – список значений и их описание вы можете найти в уроке по transition-timing-function. Они полностью совместимы со свойством animation-timing-function. Там же объясняется тонкая разница между длительностью и скоростью анимации.

Чтобы задать функцию распределения скорости для всей анимации в целом, просто добавьте еще одну строку кода к вашему общему стилю для анимированного элемента:
```
.traffic-light {
    animation-name: changeBackgroundColor;
    animation-duration: 6s;
    animation-timing-function: ease;
}
```
Если же вы хотите установить разные значения animation-timing-function для каждого ключевого кадра анимации, тогда следует указать их в правиле @keyframes. Вернемся к нашему примеру: допустим, мы хотим, чтобы при переходе от первого ключевого кадра ко второму использовалась функция ease-in, а при переходе от второго кадра к третьему – функция ease-out. Запись будет выглядеть следующим образом:
```
@keyframes changeBackgroundColor {
    from {
        background-color: red;
        animation-timing-function: ease-in;
    }
    50% {
        background-color: yellow;
        transform: translateY(50px);
        animation-timing-function: ease-out;
    }
    to {
        background-color: green;
        transform: translateY(100px);
    }
}
```

2. Данное свойство аналогично свойству transition-delay. С помощью него можно отложить начало выполнения анимации, указав в качестве значения время в секундах либо миллисекундах:
```
.traffic-light {
        animation-name: changeBackgroundColor;
        animation-duration: 6s;
        animation-delay: 2s;
}
```
Оба рассмотренных здесь свойства нуждаются в указании префиксов производителей для обеспечения максимальной кроссбраузерности. Впрочем, как уже неоднократно говорилось, префиксы необходимо добавлять ко всем свойствам CSS-анимации.

### Свойство animation-iteration-count
По умолчанию анимация на веб-странице проигрывается один раз, после чего останавливается. К счастью, в CSS имеется инструмент, с помощью которого можно управлять количеством повторений анимации. Свойство называется animation-iteration-count и принимает следующие значения:
```
    число — вы указываете произвольное число, которое определяет, сколько раз повторится анимация. Кроме целых чисел можно использовать и дробные, в том числе меньше единицы. К примеру, число 0.25 означает, что будет воспроизведена четверть одного цикла анимации, а число 3 — что анимация повторится три раза.
    infinite — ключевое слово, которое означает бесконечное повторение анимации.
```
Свойство записывается рядом с другими стилями анимируемого элемента:
```
.traffic-light {
    animation-name: changeBackgroundColor;
    animation-duration: 6s;
    animation-iteration-count: infinite;
}
```
### Свойство animation-direction
В обычном состоянии анимация проигрывается от начала до конца, затем резко, в один момент возвращается в свое первоначальное состояние и, в зависимости от настроек animation-iteration-count, либо повторяется снова, либо больше не воспроизводится.

Резкий возврат анимации из конечного состояния в начальное часто выглядит некрасиво и бросается в глаза. И здесь на помощь приходит свойство animation-direction, которое управляет направлением движения анимации. Например, вы можете сделать так, чтобы по окончанию своего пути анимация возвращалась назад, но не резко, а плавно. Кроме этого, можно заставить анимацию воспроизводиться задом наперед.

Итак, рассмотрим поближе значения свойства animation-direction:
```
    normal — значение по умолчанию. Анимация воспроизводится от начала до конца, затем резко возвращается к первоначальному состоянию.
    alternate — анимация воспроизводится от начала до конца, после чего плавно возвращается к исходному состоянию, что напоминает перемотку назад. Эффект от этого значения не будет заметен, если анимация проигрывается всего один раз.
    reverse — анимация воспроизводится с конца в начало реверсом, затем резко возвращается в первоначальное состояние, т. е. к первому ключевому кадру.
    alternate-reverse — значение, объединяющее в себе два предыдущих. Анимация воспроизводится с конца в начало, после чего плавно возвращается в исходное состояние, т. е. к первому ключевому кадру. Эффект от этого значения не будет заметен, если анимация проигрывается всего один раз.
```
Чтобы указать направление анимации, добавьте правило к стилю элемента:
```
.traffic-light {
        animation-name: changeBackgroundColor;
        animation-duration: 6s;
        animation-direction: alternate-reverse;
}
```
### Свойство animation-fill-mode


Как уже говорилось в предыдущих уроках, после прохождения цикла анимация возвращается к своему исходному положению и стилю. Это поведение не всегда бывает уместным, поэтому в CSS для таких случаев имеется свойство animation-fill-mode. Оно определяет, какой стиль будет применен к анимированному элементу по окончанию анимации.

По правде говоря, выбор здесь небольшой – по окончанию анимации элемент может принять либо первоначальный стиль, либо остаться в том стиле, который он принял в конце цикла. Представим, что вы создали анимацию прямоугольного блока: он плавно увеличивается в течение анимации, и к ее концу становится в три раза больше первоначального размера. Когда анимация завершится, ваш блок вернется в исходное состояние, то есть уменьшится в три раза. Но вы можете сохранить размер увеличенного блока, воспользовавшись свойством animation-fill-mode. Оно принимает два значения:
```
    forwards — по окончанию анимации элемент сохраняет стиль последнего ключевого кадра.
    none — значение по умолчанию. Элемент возвращается к исходному стилю.
```
Итак, чтобы блок из вышеописанного примера остался увеличенным после завершения анимации, добавьте к его стилю следующую строку:
```
animation-fill-mode: forwards;
```
Стоит отметить, что на внешний вид последнего ключевого кадра влияют значения свойств animation-iteration-count и animation-direction. К примеру, если наряду с animation-fill-mode вы задали стиль animation-direction: reverse, то после завершения анимации элемент останется с тем стилем, который определен для первого, а не последнего ключевого кадра.
