# Основа
## Популярные псевдоклассы CSS
```
    :link – этот псевдокласс задает стиль ссылкам, по которым пользователь еще не перешел;
    :visited – этот же, наоборот, применяет стиль к уже посещенным ссылкам;
    :hover – определяет стиль элемента, когда на него наведен курсор (может применяться не только к ссылкам);
    :active – задает стиль активной ссылке (то есть, в момент клика по ней);
    :focus – применяет стиль к элементу при фокусировке на нем (например, при установке курсора в строку поиска);
    :not() – этот полезный псевдокласс позволяет выбрать и стилизовать только те элементы, которые не содержат селектор, указанный в скобках.
```
```
    ::after – используется вместе со свойством content и позволяет вывести необходимые данные после содержимого элемента;
    ::before – выполняет похожую функцию, что и предыдущий, только выводит данные перед содержимым элемента;
    ::selection – этот псевдоэлемент распознается браузерами только при использовании двух двоеточий и позволяет установить цвет и фон для текста, который выделен пользователем;
    ::first-letter – используется для изменения стиля первого символа в тексте элемента;
    ::first-line – используется для изменения стиля первой строки текста элемента.
```
## Дочерние селекторы CSS
```
body > p {
	color: #333;
}
```
Обратите внимание на символ > после body. С помощью него вы указываете, что стиль применяется исключительно для дочерних тегов <p> родителя <body>. Если символ убрать, то стиль применится абсолютно ко всем тегам <p>, которые находятся внутри тега <body>, хотя они могут и не являться для него дочерними.

## Дополнительные псевдоклассы
```
    :first-child – с помощью этого псевдокласса можно применить стиль к указанному элементу веб-страницы, при условии, что он является первым дочерним элементом своего родителя;
    :last-child – стиль применяется к указанному элементу веб-страницы при условии, что он является последним дочерним элементом своего родителя;
    :nth-child – позволяет выбрать четные (even) и нечетные (odd) дочерние элементы; также с помощью данного псевдокласса можно стилизовать чередующиеся дочерние элементы, используя выражения вида an+b и числа;
    :only-child – применяется к дочернему элементу при условии, что тот является единственным ребенком у родителя;
    :first-of-type – стиль применяется к первому элементу указанного типа (даже если этот элемент не является первым дочерним для своего родителя и над ним находятся другие дочерние элементы других типов);
    :last-of-type – работает точно так же, как и предыдущий псевдокласс, с той лишь разницей, что стиль применяется к последнему элементу указанного типа;
    :nth-of-type – по принципу работы похож на :nth-child, но ориентируется на тип элемента;
    :only-of-type – применяется к дочернему элементу указанного типа при условии, что тот является у родителя единственным ребенком своего типа.
```
## Соседние селекторы
```
h1+p {
font-style: italic;
}
```
Записывая это правило, в первую очередь необходимо указать имя первого соседа, затем добавить символ + и имя второго соседа (того, к которому мы желаем применить стиль). Можно создавать и более длинные комбинации. Схема написания селектора такая: selector1+selector2+…+selectorN {} (стиль применяется к selectorN).
Примеры написания:
```
/* Отступ от абзаца до картинки 30px */
p+img {
padding-top: 30px;
}
```
```
/* Зеленый цвет для абзаца, который следует после h3 в связке с h2 */
h2+h3+p {
color: green;
}
```
## Родственные селекторы
```
h1 ~ p {
  font-style: italic;
}
```
…и немного HTML для примера:
```
<div>
<p>Текст</p>
<h1>Заголовок 1</h1>
<p>Текст</p>
<p>Текст</p>
<h2>Заголовок 2</h2>
<p>Текст</p>
 </div>

<div>
<p>Текст</p>
 </div>
```
Взгляните на HTML-код: стиль применится ко всем тегам p, которые следуют после тега h1 и находятся до закрывающего тега родителя div. В нашем варианте насчитывается 3 элемента p, к которым применится стиль.
  Используя соседние (смежные) селекторы, вы можете применять стиль к элементу в случае, когда он следует сразу за другим элементом (или группой элементов). Это работает с элементами, которые находятся на одном уровне и имеют общего родителя.
  С помощью родственных селекторов можно применять стиль ко всем элементам выбранного типа в случае, когда они следуют сразу за другим элементом (или группой элементов). Это работает с элементами, которые находятся на одном уровне и имеют общего родителя.

## Селекторы атрибутов
С помощью CSS селекторов атрибутов (англ. attribute selectors) вы можете задавать стиль тем тегам, которые имеют указанные атрибуты. Пример: вы желаете присвоить определенный стиль всем фотографиям, которые имеют атрибут title, не затрагивая все остальные изображения. Делается это просто:
```
img[title] {
	width: auto;
	height: auto;
}
```
Как видим, атрибут title записан в квадратных скобках после названия img, затем идет блок объявлений. А что если вам понадобится создать стиль только для тех изображений с атрибутом title, которым присвоен определенный класс, скажем, .gallery? В таком случае это записывается так:
```
.gallery[title] {
	width: auto;
	height: auto;
}
```
## Атрибуты со значениями
```
img[title="portrait"] {
	border-style: solid;
}
```
## Выборка по началу текста
Селекторы атрибутов также могут пригодиться при оформлении ссылок. Представьте, что вам нужно особым образом выделить все адреса URL с протоколом https://. Для этого достаточно описать, как выглядит начало адреса URL:
```
a[href^="https://"] {
	color: green;
}
```
Обратите внимание на символ ^, который в переводе на наш язык означает «начинается с». Используя его, вы можете придавать свой стиль различным ссылкам (и не только им). Например, чтобы изменить цвет всех ссылок, которые ведут на главную или другие страницы https://google.com, нужно записать:
```
a[href^="https://google.com"] {
	color: green;
}
```
Обратите внимание на то, что наш стиль будет применен строго к тем ссылкам, которые начинаются так https://google.com. Другие варианты написания ссылок, например, https://www.google.com или http://google.com, необходимо записывать отдельно. Пример:
```
a[href^="https://google.com"] {
	color: green;
}

a[href^="https://www.google.com"] {
	color: green;
}


/* Или более короткий способ: */

a[href^="https://google.com"], [href^="https://www.google.com"] {
	color: green;
}
```
## Выборка по концу текста
А может быть вы желаете красиво оформить все ссылки на файлы с расширением .rar? Тогда вам понадобится описать, как выглядит окончание URL:
```
a[href$=".rar"] {
	color: #FFF;
	text-decoration: none;
	background-color: orange;
	padding: 5px 10px;
	cursor: pointer;
}
```
Не забудьте указать после названия атрибута символ $, который означает «заканчивается на».
## Наследование
С помощью inherit можно указать, чтобы элемент наследовал значение свойства у своего предка. Такое значение доступно практически для каждого свойства в CSS.

Для демонстрации используем предыдущий пример: чтобы всё-таки заставить теги p унаследовать рамку border от своего предка body, необходимо записать:
```
p {
	border: inherit;
}
```
## Сброс стилей 
* reset css
* normalize
# Работа с текстом
## Шрифт
Допустим, вы желаете оформить текст шрифтом Verdana, а в качестве запасных установить шрифты Trebuchet MS, Geneva и любой шрифт без засечек. Записывается это таким образом:
```
p  {
	font-family: Verdana, "Trebuchet MS", Geneva, sans-serif;
}
```
Обратите внимание: в коде мы записали название шрифта Trebuchet MS в кавычках. Необходимо брать название шрифта в двойные либо одинарные кавычки тогда, когда в нем содержатся пробелы.
## Подключаем веб-шрифт с помощью @font-face
Предположим, у вас есть свой уникальный шрифт под названием MyUniqueFont в формате TTF и вы желаете, чтобы основной текст веб-страницы отображался именно этим шрифтом. Первое, что нужно сделать, это скопировать файл шрифта в папку, где находятся все остальные файлы сайта. Чтобы не создавать беспорядок, вы можете создать отдельную папку специально для шрифтов, назвав ее, к примеру, fonts.
Далее нам необходимо дать команду браузеру загрузить шрифт MyUniqueFont. Записывается это с помощью директивы @font-face следующим образом:
```
@font-face {
	font-family: MyUniqueFont;
	src: url('fonts/MyUniqueFont.ttf');
}
```
Свойство font-family в данном случае играет другую роль: с помощью него мы присваиваем имя шрифту, чтобы потом использовать это имя при написании стиля:
```
p {
	font-family: MyUniqueFont;
}
```
Во второй строке указывается путь к файлу шрифта. В нашем примере файл MyUniqueFont.ttf находится в папке fonts. У вас URL-адрес может отличаться.
## Шрифты Google Fonts
```
<head>
<link href='http://fonts.googleapis.com/css?family=Roboto&subset=latin,cyrillic'
rel='stylesheet' type='text/css'>

...
</head>
```
Второй способ – подключение шрифта с помощью директивы @import. Готовый код находится во второй вкладке пункта 3 на странице выбранного Google-шрифта. Его нужно добавить в самое начало вашей таблицы стилей (в противном случае файл не импортируется). Выглядит код примерно так:
```
@import url(http://fonts.googleapis.com/css?family=Roboto&subset=latin,cyrillic);
```
После осуществления предыдущих шагов можно начать применять шрифт. Как записывается такое правило CSS, вы уже видели ранее:
```
p {
font-family: 'Roboto', sans-serif;
}
```
Если на первом шаге вы выбрали несколько вариантов начертания (к примеру, добавили вариант жирного шрифта Bold 700), тогда на третьем шаге код немного видоизменится:
```
<link href='http://fonts.googleapis.com/css?family=Roboto:700,400&subset=latin,cyrillic'
rel='stylesheet' type='text/css'>
```
Или:
```
@import url(http://fonts.googleapis.com/css?family=Roboto:700,400&subset=latin,cyrillic);
```
Чтобы затем придать шрифту жирное начертание, запишите CSS-стиль таким образом:
```
p {
font-family: 'Roboto', sans-serif;
font-weight: 700;
}
```
## Размер шрифта в процентах
Вы наверняка уже сталкивались с ситуацией, когда размер шрифта в CSS не задан, вследствие чего браузеру приходится определять размер шрифта «по своему усмотрению». Если точнее, берется предустановленное значение по умолчанию. Именно от него зависят установленные в процентах значения. Например, базовый размер основного текста p, как правило, равняется 16 пикселям. Значение 100% эквивалентно базовому размеру шрифта, который предустановлен в браузере. Поэтому:
```
p {
	font-size: 100%;
}
```
...то же самое, что и значение в браузере по умолчанию:
```
p {
	font-size: 16px;
}
```
Если же в этом случае задать размер шрифта 50%, то он будет равен половине базового размера. Значение 200%, наоборот, увеличит шрифт в два раза.
Важно: процентные значения размера шрифта наследуются. Например, если для родительского тега задан размер шрифта 150%, то все вложенные в него теги также унаследуют это значение.
## Единица измерения em
По принципу работы единица измерения em похожа на проценты. Значение 1em эквивалентно 100% и соответствует базовому размеру шрифта по умолчанию. Соответственно, 0.6em = 60%, 3em = 300% и так далее. Пример записи:
```
font-size: 0.9em;

/* перед точкой можно опустить ноль: */

font-size: .9em;
```
Значения размеров шрифтов, указанные в em, наследуются (как и проценты). Это создает некоторые трудности при работе с CSS. Например, если для родительского элемента div задан размер шрифта 2em, то для вложенного в него такого же элемента div шрифт будет увеличен еще в два раза. 
## Единица измерения rem
В качестве альтернативы можно воспользоваться новой единицей измерения, введенной в CSS3 – rem, которая всегда отталкивается от базового размера шрифта.
Недостатком единицы измерения rem является то, что она не поддерживается некоторыми браузерами, а именно Internet Explorer версии 8 (и ранее), а также Opera Mini 8.
## Ключевые слова
```
xx-small 9px
x-small  10px
small 	 13px
medium 	 16px
large 	 19px
x-large  24px
xx-large 32px
```
Как видим, значение medium соответствует базовому размеру шрифта 16px. Использование ключевых слов ограничивает возможности и лишает гибкости, поэтому профессиональные разработчики не применяют их.
## Жирный шрифт в CSS: свойство font-weight
```
bold 	                          Полужирный шрифт
normal 	                          Обычный шрифт
bolder 	                          Более жирный шрифт, чем у родителя
lighter 	                  Менее жирный шрифт, чем у родителя
inherit 	                  Наследует значение родителя
Числовое значение от 100 до 900   От очень тонкого до очень жирного шрифта
```
Пример записи:
```
p {
font-weight: bold;
}
```
## Курсив в CSS: свойство font-style
```
italic 	 Курсивный шрифт
oblique  Наклонный шрифт
normal 	 Обычный шрифт
inherit  Наследует значение родителя
```
Пример записи:
```
p {
font-style: italic;
}
```
## Прописные и строчные буквы в CSS: свойство text-transform
```
uppercase 	Делает заглавными (прописными) все буквы в тексте
lowercase 	Делает строчными все буквы в тексте
capitalize 	Делает заглавной первую букву каждого слова в тексте
none 	        Не делает изменений
inherit 	Наследует значение родителя
```
Пример записи стиля:
```
h3 {
	text-transform: uppercase;
}
```
## Подчеркивание, зачеркивание текста в CSS: свойство text-decoration
```
underline 	Нижнее подчеркивание текста
overline 	Верхнее подчеркивание текста
line-through 	Зачеркивание текста
blink 	        Мигание текста
none 	        Удаление всех эффектов
inherit 	Наследование значений родителя
```
Пример записи стиля:
```
p a {
	text-decoration: underline;
}
```
## Тень для текста: свойство CSS text-shadow
```
h1 {
	text-shadow: 3px 5px 6px #6C9;
}
```
Как видно, мы указали целых четыре значения через пробел. Пройдемся по порядку:
* 3px – первое значение отвечает за смещение тени по оси X (вправо, влево). Положительным значением тень сдвигается вправо, а отрицательным – влево.
* 5px – второе значение отвечает за смещение тени по оси Y (вниз, вверх). Положительным значением тень сдвигается вниз, а отрицательным – вверх.
* 6px – третье значение отвечает за радиус размытия тени. Этот параметр указывать необязательно. По умолчанию размытие равняется 0 пикселей, что делает тень четкой и неразмытой.
* #6c9 – четвертое значение отвечает за цвет тени. Этот параметр указывать необязательно. По умолчанию цвет тени устанавливается такой же, как у текста, к которому применяется стиль.
## Несколько теней CSS для текста
Можно установить более двух
```
h1 {
  text-shadow: 3px 5px 6px #6C9, -6px -7px 6px #D9FFA7;
}
```
## Межсимвольный интервал CSS: letter-spacing
Задать межсимвольный интервал можно с помощью свойства CSS letter-spacing. Помимо обычных значений (положительных и отрицательных) также можно использовать значения inherit (чтобы наследовать значение у родителя) и normal (если необходимо вернуть нормальное расстояние между символами).
Пример записи межсимвольного интервала:
```
p {
	letter-spacing: 2em;
}
```
## Интервал между словами: word-spacing
Свойство CSS word-spacing отличается от предыдущего тем, что устанавливает расстояние между словами, а не между символами. Для данного свойства тоже предусмотрены значения normal и inherit. Можно задавать отрицательные значения. Ниже показан пример записи стиля:
```
p {
	word-spacing: 6px;
}
```
## Межстрочный интервал: line-height
С помощью свойства CSS line-height можно задавать расстояние между строками текста. Как было сказано в начале темы, для установки интерлиньяжа, помимо других единиц измерения, допускается использовать проценты. Также разрешено записывать значение в виде множителя (числа больше 0): для вычисления расстояния браузер умножит размер шрифта на заданное число. Отрицательные значения не работают. Доступны значения normal и inherit.
Ниже – пример, как сделать межстрочный интервал CSS:
```
p {
	line-height: 180%;
}
```
## Выравнивание текста в CSS: свойство text-align
```
По левому краю 				left
По правому краю 			right
По центру страницы/блока 		center
По ширине страницы/блока 		justify
Выравнивание текста по тому краю,       start
с которого он начинается 
(то есть текст, идущий слева направо, 
выравнивается по левому краю) 				 	 
Выравнивание текста по противоположному end
краю (то есть текст, идущий слева 
направо, выравнивается по правому краю) 						
```
Пример записи стиля:
```
p {
text-align: left;
}
```
## List-style-type: изменение маркера / нумерации
```
Маркер-точка (по умолчанию) 					disc
Маркер-окружность 						circle
Маркер-квадрат 							square
Нумерация арабскими цифрами (по умолчанию) 			decimal
Нумерация арабскими цифрами (перед числами 1-9 добавляется 0) 	decimal-leading-zero
Нумерация прописными буквами латинского алфавита 		upper-latin
Нумерация строчными буквами латинского алфавита 		lower-latin
Наследование значений родителя 					inherit
Удаление маркеров / нумерации 					none
```
Примечание: в таблице приведены только основные значения. Существует более обширный список (грузинская и армянская нумерации, нумерация римскими числами, греческими буквами и т. д.)
## List-style-image: маркер-картинка
```
ul {
	list-style-image: url(images/star.png);
}
```
## List-style-position: расположение маркеров / нумерации
Для CSS свойства list-style-position, которое задает расположение маркеров / нумерации относительно текста, есть два значения – outside и inside. По умолчанию используется значение outside – это значит, что маркер / число отображается как бы отдельно от текста списка, тогда как при значении inside маркер / число располагается внутри текстового блока и обтекается текстом.
Ниже показан пример записи стиля:
```
ul {
	list-style-position: inside;
}
```
## List-style: все вместе
```
/* нумерация прописными латинскими буквами внутри текстового блока: */
ol {
	list-style: upper-latin inside;
}

/* графические маркеры снаружи текстового блока: */
ul {
	list-style: url(images/star.png) outside;
}
```
# Блоки
## Базовый набор
* padding (и производные padding-left, padding-right, padding-top, padding-bottom) – это внутренний отступ от края содержимого до границы блока. Можно устанавливать отступы либо от всех четырех сторон контента, либо только от нужных вам.
* margin (и производные margin-left, margin-right, margin-top, margin-bottom) – это поле, которое являет собой расстояние от границы одного блока до другого. Новички иногда путают свойство margin со свойством padding, поэтому для наглядности ниже показаны рисунки, где лучше понятна разница между этими свойствами. Поля можно задавать как для всех сторон блока одновременно, так и для отдельных.
* border (и производные border-left, border-right, border-top, border-bottom) – это рамка (граница), которую можно задать для блока. Поля margin остаются за пределами рамки, всё остальное находится внутри неё. Рамку можно установить на всех четырех сторонах или только на нужных вам.
* background-color – это цвет фона, заливка цветом, которая применяется к заднему фону блока и не выходит за его пределы. Поля этим цветом не закрашиваются, а контент и рамка располагаются поверх фона.
Также можно настраивать ширину width и высоту height блока (а точнее, контента, который содержится в блоке). Чтобы затем посчитать ширину или высоту всего блока (вместе с отступами, рамкой и полями), необходимо сложить все эти значения. Например:
`width + padding-left + border-left + margin-left + padding-right + border-right + margin-right = полная ширина блока`
## Поля и отступы CSS: отличия свойств margin и padding
Создавать промежутки между элементами можно и тем, и другим способом, но если padding – это отступ от содержимого до края блока, то margin – это расстояние от одного блока до другого, межблоковое пространство.
Значения могут быть указаны в любых единицах CSS – px, em, % и т. д.
Также существует очень удобная вещь как сокращенная запись margin и padding CSS. Если вам необходимо задать поля или отступы для всех четырех сторон элемента, совсем необязательно записывать свойство для каждой стороны по отдельности. Всё делается проще: для margin и padding можно указывать сразу 1, 2, 3 или 4 значения. От количества значений зависит, как распределяются настройки:
```
4 значения: задаются отступы для всех сторон элемента в такой последовательности: сверху, справа, снизу, слева:
padding: 2px 4px 5px 10px;
3 значения: задается отступ сначала для верхней стороны, потом одновременно для левой и правой, а затем – для нижней:
padding: 3px 6px 9px;
2 значения: задаются отступы сначала одновременно от верхней и нижней стороны, а затем – одновременно для левой и правой:
padding: 6px 12px;
1 значение: задаются одинаковые отступы для всех сторон элемента:
padding: 3px;
```
Те же правила касаются и свойства margin CSS. Обратите внимание на то, что для margin можно использовать и отрицательные значения (например, -3px), которые иногда бывают весьма полезными.
## Схлопывание margin
Схлопывание margin работает только для верхних и нижних полей элементов и не относится к полям с правой и левой сторон. Окончательная величина промежутка высчитывается в разных ситуациях по-разному:
* Когда оба значения margin положительные, итоговый размер поля будет равен бóльшему значению.
* Если одно из значений является отрицательным, то для вычисления размера поля нужно получить сумму значений. Например, при значениях 20px и -18px размер поля будет равен:
`20 + (-18) = 20 — 18 = 2 пикселя.`
* Если оба значения отрицательные, сравниваются модули этих чисел и выбирается число, бóльшее по модулю (следовательно, меньшее из отрицательных чисел). Пример: необходимо сравнить значения полей -6px и -8px. Модули сравниваемых чисел равны 6 и 8 соответственно. Отсюда следует, что 6 < 8, то есть, -6 > -8. Итоговый размер поля равен -8 пикселей.
* В случае, когда значения указаны в разных единицах CSS, они приводятся к одной, после чего сравниваются и выбирается бóльшее значение.
* Размер margin для дочерних элементов определяется еще более интересно: если у потомка поле margin больше, чем у родителя, то приоритет отдается ему. В этом случае размеры верхнего и нижнего полей родителя станут такими, как задано у потомка. При этом расстояния между родителем и потомком не будет.
## Блочные элементы
Блочные элементы являются основой, которая используется для верстки веб-страниц. Такой элемент представляет собой прямоугольник, который по умолчанию занимает всю доступную ширину страницы (если иное значение не указано в CSS), а длина элемента зависит от его содержимого. Такой элемент всегда начинается с новой строки, то есть, располагается под предыдущим элементом. Блочный элемент может содержать в себе другие блочные и строчные элементы.
Примеры блочных элементов: `<div>, <p>, <ul>, <ol>, <h1>` и другие.

## Строчные элементы
В отличие от блочного, строчный элемент не переносится на новую строку, а располагается на той же строке, что и предыдущий элемент. Такие элементы, как правило, находятся внутри блочных элементов и их ширина зависит лишь от содержимого и настроек CSS. Еще одно отличие строчного элемента от блочного заключается к том, что в нем может находиться только контент и другие строчные элементы. Блочные элементы в строчные вкладывать нельзя.
Примеры строчных элементов: `<a>, <span>, <strong>, <em>, <img>` и т. д.	

```
в HTML5 порядок вложения тегов такой роли не играет. Элементы уже не просто делятся на блочные и строчные, а группируются по смыслу и назначению, представляя собой категории контента.
```
## CSS-свойство display: меняем тип элемента
При помощи крайне полезного свойства display в CSS можно заставить блочный элемент выглядеть как строчный и наоборот. Чтобы блочный элемент вел себя как inline-элемент (т. е. не переводился на новую строку), для него необходимо записать правило:
```
display: inline;
```
Если же необходимо отобразить строчный элемент как block-элемент (чтобы до и после элемента происходил перенос строки), запишите следующее:
```
display: block;
```
Также можно сделать «гибрид» — блочный элемент с поведением, как у строчного. В этом случае всё содержимое таких блочных элементов будет отображаться, как обычно, но при этом блоки будут вести себя как строчные элементы, выстраиваясь в одной строке друг за другом и переносясь на новую строку лишь при необходимости. Схлопывание margin в таких случаях перестает действовать. Для превращения элемента в блочно-строчный запишите:
```
display: inline-block;
```
## Border-width: ширина границы
С помощью свойства border-width задается ширина границы. Наиболее часто этот размер указывается в пикселях. Можно задать одинаковую либо различную ширину для всех четырех границ, например:
```
/* все 4 границы имеют ширину 2px: */
border-width: 2px;

/* верхняя и нижняя границы имеют ширину 2px, левая и правая — 4px: */
border-width: 2px 4px;

/* верхняя граница — 2px, левая и правая — 6px, нижняя — 3px: */
border-width: 2px 6px 3px;

/* верхняя граница — 2px, правая — 3px, нижняя — 4px, левая — 5px: */
border-width: 2px 3px 4px 5px;
```
Кроме этого, существуют ключевые слова для обозначения ширины границы:
```
    thin — граница шириной 2px;
    medium — граница шириной 4px;
    thick — граница шириной 6px.
```
## Border-color: цвет границы
Свойство border-color задает цвет для границ. Цвета можно указывать в любом формате CSS: ключевыми словами, в шестнадцатеричном виде либо в RGB — зависит от того, как вам удобнее. По аналогии с предыдущим свойством, можно устанавливать как один цвет для всех границ, так и выбирать разные цвета для каждой границы.
```
border-color: #FFFF00;
```
Также можно задать прозрачный цвет, записав:
```
border-color: transparent;
```
## Border-style: стиль границы
```
    solid — сплошная граница;
    dotted — граница из точек;
    dashed — пунктирная граница;
    double — двойная граница;
    groove — объемная граница-выемка;
    ridge — объемная граница с толстой кромкой (по сути, инверсия предыдущего стиля);
    outset — выдавленная граница;
    inset — вдавленная граница (по сути, инверсия предыдущего стиля).
```
## Общее CSS-свойство border: 3 в 1
` border: 2px dotted #FF0000;`
## Как закруглить углы: свойство CSS3 border-radius
```
.borderElement {
  background-color: #EEDDFF;
  border: 6px solid #7922CC;
  border-radius: 25px;
}

.borderElement1 {
  background-color: #FFE8DB;
  border: 6px solid #FF5A00;
  border-radius: 15px 100px 15px 100px;
}
```
вместо простых круглых углов можно задавать эллиптическое скругление. Для этого понадобится указать два значения, разделенные косой чертой (для горизонтальной и вертикальной полуосей эллипса). Приведем пример на блоке размером 150×450 пикселей:
```
.borderElement {
  background-color: #EEDDFF;
  border: 6px solid #7922CC;
  border-radius: 280px/100px;
}
```
```
    border-top-left-radius — для верхнего левого угла;
    border-top-right-radius — для верхнего правого угла;
    border-bottom-left-radius — для нижнего левого угла;
    border-bottom-right-radius — для нижнего правого угла.
```
## Принцип скругления углов
На рисунке ниже показано, каким образом вычисляется скругление углов в CSS. Так, если для угла указано одно значение, — например, 20px, — это означает, что закругление будет происходить по окружности с радиусом 20 пикселей. В случае, когда задаются два значения через косую черту, например, 30px/20px, закругление углов будет происходить по эллипсу. Первое значение в таком случае является длиной горизонтальной полуоси эллипса — 30px, а второе — длиной вертикальной полуоси — 20px
## Свойство box-shadow: синтаксис
Данный стиль записывается следующим образом:
`box-shadow: inset 4px 4px 8px 5px #333333;`
Рассмотрим по порядку, за что отвечает каждый параметр (слева направо):
* Ключевое слово inset: параметр, который необязательно указывать; рисует тень внутри элемента.
* Сдвиг по оси X: указывает степень смещения тени по горизонтали относительно элемента. Положительное значение означает сдвиг вправо, отрицательное — влево. Значение 0 означает, что тень без сдвига.
* Сдвиг по оси Y: указывает степень смещения тени по вертикали. Положительное значение означает сдвиг вниз, отрицательное — вверх. Значение 0 — это тень без сдвига.
* Радиус размытия: это степень размытия тени. Чем больше значение, тем более размыта тень. Если параметр не указан, используется значение по умолчанию — 0. В таком случае тень будет идеально четкой.
* Расширение: необязательный параметр, отвечающий за растяжение тени по обеим осям; чем больше значение, тем больше растяжение. Расширение работает только при наличии предыдущего параметра. Значение по умолчанию — 0.
* Цвет тени: с этим параметром всё понятно — он задает цвет тени элемента. Цвет по умолчанию — черный.

Данное свойство может принимать несколько групп значений (делать несколько теней одновременно). Для этого понадобится перечислить эти группы параметров через запятую. Например:
```
box-shadow: 15px 15px 20px #8b0163,
            inset 15px 15px 20px #630046;
```
## Width и height: определяем размеры элемента
* В качестве значения ширины можно использовать и единицу em, которая является примерно тем же, чем и размер шрифта текста, но только в условных единицах. К примеру, вы установили размер для шрифта 24px. Тогда 1em для этого элемента будет равен 24 пикселам, а если вы зададите width: 2em, то ширина составит 2×24px = 48 пикселов. Если размер шрифта не задан, он будет унаследован.
* Высота height, заданная в процентах, вычисляется аналогичным образом, что и ширина, но расчет основывается уже на высоте родительского элемента, а не на его ширине. Если родитель отсутствует, высота будет зависеть от высоты окна браузера.
* Сразу стоит запомнить, что у свойств width и height есть особенность — они не включают в себя значения margin, padding и border. Значение, которое вы установите для width/height, будет означать лишь ширину/высоту области содержимого элемента.
* Таким образом, для того чтобы вычислить, например, фактическую ширину элемента (место, которое он в действительности займет на экране), понадобится немного арифметики. Фактическая ширина — это сумма значений, таких как width, padding, border и margin.
* Свойство height может быть удобным, если надо точно контролировать, например, высоту изображения. Однако, если в контейнере будет содержаться текст или любой другой контент, у которого может варьироваться высота, крайне не рекомендуется устанавливать фиксированную высоту для контейнера, так как подобная верстка может привести к неожиданному результату — контент будет отображаться поверх другого содержимого.
* Вместо фиксированной высоты использовать height: auto — эта запись означает, что высота объекта будет рассчитываться автоматически, в зависимости от содержимого, которое он содержит.
* Другой способ избежать развала верстки — использовать запись overflow: auto. В таком случае, если высота содержимого будет превышать значение height своего контейнера, браузер добавит к контейнеру полосу прокрутки.
## Box-sizing
1. В предыдущем уроке мы рассказывали, по какому принципу традиционно вычисляется ширина и высота элемента. Фактическую ширину/высоту образует сумма значений width/height, padding, border и margin.
2. Нередко в процессе верстки возникает необходимость управлять стандартным вычислением размеров элемента. Допустим, вы хотите, чтобы ширина определенного блока <div> составляла 50% от ширины веб-страницы. Для этого вы задаете свойству width значение 50%. И здесь возникает загвоздка: если у блока имеются отступы (padding), поля (margin) либо рамка (border), то они будут считаться отдельно. В итоге ширина блока будет более 50%, а это уже не входит в ваши планы.
3. Как же сделать так, чтобы браузер учитывал отступы, а иногда и рамку, вычисляя ширину блока? На помощь приходит свойство box-sizing, которое может принимать три значения, а именно:

* content-box — значение по умолчанию (поведение, описанное выше). Ширина и высота элемента определяется только свойствами width и height.
* border-box — в данном случае браузер включает отступы padding и рамку border в общую ширину/высоту элемента. Это значит, что если для блока задана ширина, скажем, width: 50%, отступы (например, padding-left: 10px и padding-right: 10px) и рамка (border-width: 1px), то браузер будет считать эти отступы и рамку частью ширины 50%. Ширина самого содержимого составит 50% минус 22 пикселя. Обратите внимание, что значения margin включены НЕ будут.
* padding-box — это значение похоже на предыдущее, только в ширину/высоту элемента будут включены только отступы padding, без рамки. Значения margin также не учитываются. Значение padding-box было исключено из спецификации CSS, однако оно все еще поддерживается браузером Firefox.

   Чтобы свойство box-sizing работало в браузерах Firefox, а также старых версиях Safari, Chrome и Android, следует записывать несколько его вариаций, используя соответствующие префиксы производителя:
```
-moz-box-sizing: border-box;
-webkit-box-sizing: border-box;
box-sizing: border-box;
```
Что же насчет поддержки браузером Internet Explorer? Хорошие новости: box-sizing работает в IE8 и выше.
## Overflow: управление переполненными элементами
* hidden — всё содержимое, выходящее за пределы контейнера, будет скрыто. Не подходит в случае с текстовым контентом, но очень часто используется на практике для решения других задач и предотвращения некоторых «казусов».
* scroll — к контейнеру будут добавлены вертикальные и горизонтальные полосы прокрутки (скролл). Внешне блок становится похож на фрейм. Скролл отображается постоянно.
* auto — также добавляются полосы скролла, но только тогда, когда они необходимы (т. е. если содержимое не влазит в контейнер).
* visible — значение, установленное по умолчанию в браузере. Контент виден, даже если блок переполнен. Можно использовать для сброса другого значения, заданного ранее.
##  Max-width, max-height, min-width, min-height: максимальные и минимальные размеры элемента
* min-width — с помощью этого свойства вы можете указать минимальную ширину элемента. Например, если вы зададите блоку стиль min-width: 50px, то ширина блока может стать больше, но она никогда не станет меньше, чем 50 пикселей. Это очень удобно, например, при создании адаптивной верстки, когда при определенных размерах экрана элемент с относительной шириной становится слишком узким. Свойство min-width позволяет предотвратить такие искажения.
* min-height — работает аналогично предыдущему свойству, но только по отношению к высоте элемента. Безусловно, это тоже очень полезное свойство в практике, которое позволяет задать минимальную высоту элемента.
* max-width — как вы уже догадались, это свойство позволяет задать максимально допустимую ширину элемента. Например, элемент со стилем max-width: 960px может иметь ширину меньше максимальной, но он никогда не станет больше, чем 960 пикселей. Данное свойство удобно использовать при создании адаптивной разметки, когда вам необходимо, чтобы элемент адаптировался под ширину экрана любого устройства, но при этом не слишком широко разъезжался на больших экранах.
* max-height — работает аналогично предыдущему свойству, только по отношению к высоте. Но, как мы уже говорили ранее, лучше не играть с ограничением высоты элемента без крайней надобности.
* auto — это значение можно использовать для отмены действия свойства.
## CSS float
* left — элемент выравнивается по левой стороне. Элементы, находящиеся ниже в потоке, обтекают его с правой стороны.
* right — значение, противоположное предыдущему. Элемент выравнивается по правой стороне, а элементы, находящиеся ниже в потоке, обтекают его слева по левому краю.
* none — элемент не обтекается и находится в своей обычной позиции.
## Отмена обтекания: свойство clear
* left — элемент, к которому применяется свойство clear:left, перестает обтекать элемент со свойством float:left, однако правое обтекание сохраняется.
* right — элемент, к которому применяется свойство clear:right, перестает обтекать элемент со свойством float:right, однако левое обтекание сохраняется.
* both — полностью отменяет обтекание со всех сторон. Элемент смещается вниз и образовывает стандартный поток. На следующие за ним элементы обтекание также перестает влиять.
* none — отменяет очистку clear. Элемент будет вести себя, как обычно, и на него будут влиять настройки float.
# Работа с графикой 
## CSS для тега img
Элемент <img> является стандартным тегом для добавления графических элементов на веб-страницу. Его используют для размещения фотографий, логотипов, графических элементов интерфейса и т. п. Для стилизации тега img можно пользоваться стандартными свойствами CSS, например, border, box-shadow, opacity, float и другими. Это позволяет определять вид и расположение изображения на веб-странице.
На практике, чаще всего к тегу img применяются следующие свойства:
* border — вы можете создать рамку для изображения (или даже для целой галереи фотографий), при этом указав любую ширину и цвет границ. Как вы помните, можно даже стилизовать рамку индивидуально для каждой стороны.
* padding — небольшие внутренние отступы между фотографией и рамкой помогут сымитировать эффект подложки. А с помощью свойства background-color можно изменить и сам цвет подложки.
* box-shadow
* float — применив это свойство ко всем миниатюрам фотографий и добавив еще несколько строк CSS-кода, можно легко создать многострочную галерею
## Background-image: установка фонового изображения
Свойство background-image устанавливает выбранное изображение в качестве фона элемента. В зависимости от цели, можно задать графический фон как для отдельного блока, так и для всей страницы. В качестве единственного значения принимается URL-адрес графического файла. Запись выглядит так:
```
div {
    background-image: url(/img/bg.jpg); /* в круглых скобках — URL картинки */
}
```
## Пути к файлу
* Абсолютный путь
`background-image: url(http://www.example.com/img/bg.png);`
* Относительный путь к файлу
`background-image: url(/img/bg.png);`
`background-image: url(../../bg.png); /* поднимаемся на два уровня */`
* Абсолютный адрес ссылки понадобится использовать, если файл, на который вы ссылаетесь, находится на другом сайте. В пределах одного сайта абсолютный путь практически не используется (хоть он и будет работать). Это связано с несколькими моментами: во-первых, такие ссылки могут быть весьма громоздкими, а во-вторых, если имя домена изменится, то возникнет проблема — все ссылки будут вести на старый домен, что может повлечь за собой множество ошибок и битых ссылок.
* Корневой относительный путь будет работать на веб-сервере, но он бесполезен при разработке на локальном компьютере. Но преимущество этого типа ссылок в том, что вы можете перемещать свою таблицу стилей в любую папку сайта и не бояться, что адреса фоновых изображений станут нерабочими.
* Относительный путь от документа — наилучший вариант при веб-разработке на локальной машине без использования сервера. В браузере вы сможете нормально просматривать веб-страницы, хранящиеся на вашем компьютере, и адреса файлов будут работать. Они будут работать и на живом сайте, но с одним условием — если не перемещать таблицу стилей в другое место (иначе придется корректировать пути).
## Background-repeat: повторение фоновой картинки
Если элементу задать свойство background-image, то фоновый рисунок будет по умолчанию повторяться в двух осях — по горизонтали (x) и по вертикали (y).
Свойство background-repeat предназначено для управления повтором фона, заданного через background-image. Принимает оно следующие значения:
* repeat — то же, что и значение по умолчанию — полностью заполняет элемент фоновым рисунком натурального размера, повторяя его сверху вниз и слева направо. Такой эффект хорошо смотрится только при правильном подборе фона, который в идеале должен быть бесшовным, не слишком ярким, малоконтрастным.
* no-repeat — заполняет элемент фоновым рисунком один раз. Размер фона остается натуральным (не сужается и не растягивается). Свойство с данным значением очень часто применяется на практике (мы рассмотрим это далее в книге).
* repeat-x — фон повторяется только по горизонтали (оси x), до полного заполнения элемента по ширине. Удобно использовать для оформления элементов интерфейса (графическая полоска вдоль шапки сайта и т. п.).
* repeat-y — фон повторяется только по вертикали (оси y), до полного заполнения элемента по высоте. Удобно использовать для оформления элементов интерфейса (графическая полоска по высоте сайдбара и т. п.).
* round — фон повторяется так, чтобы в область элемента поместилось целое число изображений. Если это не удается сделать, фон автоматически подгоняется (масштабируется), чтобы соответствовать условию.
* space — работает так же, как и предыдущее свойство, но с одним отличием: если целое число изображений не помещается в область, рисунки не масштабируются, а между ними добавляется пространство.
## Background-position: позиционирование фона
Свойство `background-position` позволяет указывать начальную позицию фонового рисунка сразу для двух осей — x и y. Впрочем, можно воспользоваться и отдельными свойствами для каждой оси — `background-position-x` и `background-position-y`.
* Горизонтальное позиционирование
```
    left — фоновый рисунок прилеплен к левой стороне элемента;
    center — фоновый рисунок расположен в центре оси x;
    right — фоновый рисунок прилеплен к правой стороне элемента.

div {
	background-position-x: left;
}
```
* Вертикальное позиционирование
```
    top — фоновый рисунок прилеплен к верхней стороне элемента;
    center — фоновый рисунок расположен в центре оси y;
    bottom — фоновый рисунок прилеплен к нижней стороне элемента.

div {
	background-position-y: bottom;
}
```
Если вы установили повтор фона с помощью свойства background-repeat, то background-position будет определять, от какой точки будет начинаться дублирование изображения.
```
background-position: top center; /* фон вверху по центру */
background-position: top right; /* фон в верхнем правом углу */
background-position: bottom left; /* фон в левом нижнем углу */
background-position: center right; /* фон справа по центру */

background-position: center; /* фон по центру */
background-position: left; /* фон слева по центру */
background-position: right; /* фон справа по центру */
background-position: top; /* фон вверху по центру */
background-position: bottom; /* фон внизу по центру */
```
* Точные значения в единицах измерения CSS
```
div {
background-position: 10px 25px;
}

div {
background-position: right 15px bottom 40px;
}
```
Обратите внимание: значение 50% идеально центрирует фоновое изображение (как по вертикали, так и по горизонтали), поскольку точка центра устанавливается в середине фона, а не в его начале или конце.
Как правило, при печати страницы фоновые изображения не отображаются. Учитывайте это при работе с важной графикой — например, логотип компании, карту проезда и другие иллюстрации, содержащие важную информацию, рекомендуется добавлять через тег <img>.
Запись background-position с двумя параметрами поддерживается всеми используемыми браузерами.
## Значения background-attachment
* scroll (значение по умолчанию) — фоновое изображение перемещается вместе с другими элементами при скролле веб-страницы.
* fixed — значение фиксирует фоновое изображение, делая его нечувствительным к скроллу. При прокручивании страницы фон на заднем плане останется неподвижным.
* local — данное значение было добавлено из-за того, что в случае с локальным скроллом фон со значением scroll ведет себя как fixed. При значении local фон прокручивается вместе с содержимым элемента, и не прокручивается, если содержимое не скроллится (но прокручивается вместе с самим элементом).
## Background-origin: позиционирование фонового рисунка
background-origin управляет его позицией относительно рамки (border), отступа (padding) или содержимого элемента. По умолчанию фоновый рисунок отображается, накладываясь на отступы элемента (если они есть), и не подкладывается под рамку. Это положение можно менять, используя следующие значения background-origin:
* padding-box (значение по умолчанию) — фоновое изображение располагается в верхнем левом углу элемента, который является областью отступов padding.
* border-box — фоновое изображение располагается в верхнем левом углу элемента, который является областью рамки (при этом рамка накладывается на фон, перекрывая его часть).
* content-box — фоновое изображение располагается в верхнем левом углу, который принадлежит содержимому элемента.
## Background-clip: свойство для обрезки фона
Свойство background-clip позволяет определять, какую область элемента фон заполняет, а какую — нет. Согласно спецификации, свойство принимает следующие значения:
* padding-box — фон заполняет элемент, включая его отступы, и не заполняет область границ, так что в просветах пунктирной или точечной рамки фон не будет виден.
* border-box (значение по умолчанию) — фон заполняет элемент, включая область рамки (при этом рамка накладывается поверх фона). В случае с фоновым рисунком эффект данного значения будет заметен только при условии, что он повторяется.
* content-box — фон заполняет элемент, включая его содержимое, и не заполняет область отступов и границ.
  Заметьте, что background-clip не меняет начальную точку позиционирования фона, поэтому верхняя и левая стороны фонового рисунка могут обрезаться, если позиционирование у него осталось по умолчанию (это видно на примере с background-clip:content-box).
  Используя background-origin и background-clip в паре, можно исправить проблему обрезки фонового рисунка, о которой мы только что говорили. Например, следующий код заполнит фоном элемент <div> в области контента, а также задаст соответствующую начальную точку позиционирования фонового рисунка:

```
div {
	background-clip: content-box;
	background-origin: content-box;
}
```
## Background-size: масштабирование фонового рисунка
* auto (значение по умолчанию) — если данное значение установлено для горизонтали и вертикали, т. е.:
`background-size: auto auto;`

…то размеры фона останутся оригинальными. Если значение auto задано лишь для одной из сторон, то размер фона будет автоматически подогнан под пропорции изображения. Например, если записать следующее:

`background-size: 250px auto;`

…то высота фоновой картинки будет вычисляться автоматически.

* contain — фоновое изображение масштабируется так, чтобы поместиться внутрь элемента целиком. В зависимости от своей формы и формы элемента, рисунок растягивается, чтобы поместиться полностью либо по ширине, либо по высоте. Пропорции картинки сохраняются.
* cover — фоновое изображение масштабируется так, чтобы полностью заполнить пространство элемента, при этом сохраняя свои пропорции. Если пропорции элемента не соответствуют пропорциям изображения, это может привести к тому, что часть рисунка будет скрыта.

Свойство background-size часто используется на практике. Например, его очень удобно использовать, когда размер элемента указан в процентах. Если задать блоку ширину 50% от ширины экрана, а его фону — ширину 100%, то при изменении размера окна фон всегда будет соответствовать ширине элемента.
##  Свойство background: все настройки фона в одном месте
мы пишем значения всех свойств через пробел как обычно. Исключением являются свойства background-position и background-size — их необходимо разделять знаком слэша /.

Ни одно значение не является обязательным: вы можете не указывать значений тех свойств, которые хотите оставить по умолчанию. К слову, настройки background по умолчанию следующие:
```
background-image: none;
background-position: 0% 0%;
background-size: auto;
background-repeat: repeat;
background-attachment: scroll;
background-origin: padding-box;
background-clip: border-box;
background-color: transparent;
```
Для примера запишем стиль через свойство background, определив только цвет фона (background-color) и порядок его обрезки (background-clip):
```
background: content-box #aaa;
```
Этот код эквивалентен такому коду:
```
background-image: none; /* осталось по умолчанию */
background-position: 0% 0%; /* осталось по умолчанию */
background-size: auto; /* осталось по умолчанию */
background-repeat: repeat; /* осталось по умолчанию */
background-attachment: scroll; /* осталось по умолчанию */
background-origin: content-box;
background-clip: content-box;
background-color: #aaa;
```
## Несколько фоновых рисунков для одного элемента
```
.frame {
  background-image: url(https://goo.gl/tKyzHt), /* верхняя часть рамки */
                    url(https://goo.gl/SUKymM), /* нижняя часть рамки */
                    url(https://goo.gl/Km7HVV); /* середина рамки */

  background-position: center top, /* позиция верха рамки */
                       center bottom, /* позиция низа рамки */
                       center top; /* позиция середины рамки */

  background-repeat: no-repeat, /* верх рамки не повторяется */
                     no-repeat, /* низ рамки не повторяется */
                     repeat-y; /* середина рамки повторяется по вертикали */

  background-size: contain; /* здесь для всех фонов одинаковое значение */
  height: auto; /* высота блока зависит от количества содержимого */
  width: 400px;  /* ширина блока фиксированная */
  padding: 30px; /* внутренние отступы блока */
}
```
```
background: url(https://goo.gl/tKyzHt) center top / contain no-repeat, /* верх рамки */
	         url(https://goo.gl/SUKymM) center bottom / contain no-repeat, /* низ рамки */
	         url(https://goo.gl/Km7HVV) center top / contain repeat-y; /* середина рамки */
```
Такой вариант выглядит менее громоздко и легче воспринимается.
## Linear-gradient(): линейный градиент в фоне
`background-image: linear-gradient(to left, violet, red);`
Цвета точек градиента можно записывать в любом формате, доступном в CSS, будь-то шестнадцатеричный код, формат RGB или другой. Направление градиента задается с помощью приставки to и затем ключевых слов left, right, top и bottom, которые можно комбинировать для изменения наклона. Например:
`background-image: linear-gradient(to bottom right, #ee82ee, #ff0000);`
При заданном угле 0º либо 360º градиентная линия будет идти снизу вверх. При увеличении угла наклона движение вектора происходит по часовой стрелке (при использовании отрицательного значения движение меняется на противоположное). 
`background-image: linear-gradient(-110deg, #ee82ee, #ff0000);`
Если вы хотите увеличить количество данных точек в градиенте, просто допишите их через запятую. Например:
`background-image: linear-gradient(145deg, #ee82ee, slateblue, #ffd86a, purple);`
По умолчанию браузер размещает точки на равном расстоянии, поэтому и градация получается равномерной. Но этим расстоянием можно управлять, используя единицы измерения CSS.
`background-image: linear-gradient(#92009b 20%, #f5e944 90%, #00ffa2);`
В нашем коде после цвета #92009b указано значение 20%. Поскольку оно стоит возле первой опорной точки, это означает, что указанным цветом будет закрашено 20% длины элемента. После чего уже начинается градиент: значение 90% говорит браузеру, что нужно достичь цвета #f5e944 к 90% длины элемента (начав на уровне 20%). После чего в оставшемся пространстве начинается переход к третьему цвету — #00ffa2.
Градиентный фон тоже требует использования данных префиксов, если есть необходимость в поддержке максимального количества браузеров. Для этого адаптируйте код следующим образом:
```
background-image: -webkit-linear-gradient(left, violet, red);
background-image: -moz-linear-gradient(left, violet, red);
background-image: -o-linear-gradient(left, violet, red);
background-image: linear-gradient(to left, violet, red);
```
Для добавления префикса требуется создавать отдельное объявление. Кроме того, как вы могли заметить, свойства с вендорными префиксами не требуют использования приставки to при указании направления градиента.
## Repeating-linear-gradient(): градиент с повторением
`background-image: repeating-linear-gradient(to top right, #034320 60px, #24d24a 120px, #012c13 121px);`
Если разобрать наш пример, то из нижнего левого угла по направлению к верхнему правому углу браузер сначала закрашивает 60 пикселей цветом #034320, затем генерирует градиентный переход к цвету #24d24a, достигая 120 пикселей, после чего, начиная со 121-го пикселя, закрашивает оставшееся пространство цветом #012c13. И, поскольку это не простой, а повторяющийся градиент, действие повторяется заново с самого начала, а градиенты накладываются слоями один на другой.
## Radial-gradient(): радиальный градиент
`background-image: radial-gradient(#5b4ffc, #df02cd);`
Начальная точка вектора радиального градиента находится в центре эллиптической формы (который в свою очередь по умолчанию размещается в центре стилизуемого элемента), откуда градиент расходится кругами. Центр можно смещать, пользуясь теми же значениями, которые принимает background-position. Перед указанием позиции следует использовать приставку at:
`background-image: radial-gradient(at top left, #5b4ffc, #df0253);`
Форма радиального градиента может быть круглой либо эллиптической. Определить форму можно с помощью указания радиуса либо одного из ключевых слов:
* ellipse — градиент эллиптической формы (значение по умолчанию);
* circle — градиент круглой формы.
`background-image: radial-gradient(circle, #5b4ffc, #df0253);`
Значение радиуса может быть указано в любых доступных единицах CSS. Если указать одно значение, то оно будет принято за радиус круга. Два значения интерпретируются как радиус эллипса по оси X и радиус по оси Y. По умолчанию радиальным градиентом полностью заполняется фон элемента.
`background-image: radial-gradient(ellipse 180px 90px, #a09af1, #000038);`
* closest-side — создается градиент, который расходится только до ближайшей стороны элемента:
`background-image: radial-gradient(circle closest-side at 75% 40%, #ffee0e, #2e0a9f);`
* closest-corner — градиент расходится только до ближайшего угла элемента:
`background-image: radial-gradient(circle closest-corner at 75% 40%, #ffee0e, #2e0a9f);`
* farthest-side — противоположно closest-side, градиент расходится до самой дальней стороны элемента:
`background-image: radial-gradient(circle farthest-side at 75% 40%, #ffee0e, #2e0a9f);`
* farthest-corner — противоположно closest-corner, градиент расходится до самого дальнего угла элемента:
`background-image: radial-gradient(circle farthest-corner at 75% 40%, #ffee0e, #2e0a9f);`
* В точности как и с линейным градиентом, для создания многоцветного радиального градиента можно добавлять несколько опорных цветовых точек с указанием расстояния:
`background-image: radial-gradient(#144bf1 30%, #3ee9ca 60%, #0a38e5);`
## Repeating-radial-gradient(): повторяющийся радиальный градиент
По аналогии с линейным градиентом, радиальный градиент также может быть повторяющимся. За это отвечает функция repeating-radial-gradient(). В ней можно указывать те же параметры, что и для просто радиального градиента. Чтобы градиент повторялся, необходимо перечислить не только цвета, но и размеры каждого градиента в подходящих единицах CSS:
`background-image: repeating-radial-gradient(#ff00ea 10px, #2417d7 20px);`
Если вы хотите, чтобы градиентные кольца были размытыми, а не резкими, то первый и последний цвета градиента должны быть одинаковыми:
`background-image: repeating-radial-gradient(circle,#ff00ea 10px, #2417d7 20px, #ff00ea 30px);`
# Ссылки и навигация
## Состояния ссылок в CSS. Псевдоклассы
```
    :hover — ссылка, на которую наведен курсор;
    :active — активная ссылка (та, по которой совершается клик, или на которой удерживается кнопка мыши);
    :link — ссылка, еще не посещенная пользователем;
    :visited — посещенная ссылка
```
> Для справки: из соображений безопасности набор стилей, которые можно использовать для ссылок :visited, ограничен. Посещенные ссылки принимают только свойства color, background-color, border-color (и его производные), column-rule-color, outline-color. При этом свойство к посещенной ссылке можно применить, только если это же свойство задано и для обычной. Прозрачность цвета, установленная через альфа-канал для элемента :visited, будет проигнорирована. JavaScript-метод getComputedStyle всегда возвращает значение цвета непосещенных ссылок, даже если у посещенных ссылок цвет иной.
   Если в ваши планы входит максимально детальная проработка дизайна ссылок, то желательно определить стили для всех четырех состояний. При этом очень важно соблюсти порядок, в котором будут записаны селекторы с псевдоклассами. Обязательно размещайте их в следующей последовательности:
```
a:link { color: red; }
a:visited { color: grey; }
a:hover { color: blue; }
a:active { background-color: yellow; }
```
Что будет, если поменять строки местами? В этом случае некоторые стили перестанут работать согласно правилам каскадности. Дело в том, что ссылка может находиться одновременно в двух состояниях, к примеру, в :visited и в :hover, и если расположить стиль для :hover выше, чем стиль для :visited, то первый перекроется.
Чтобы определить стили для всех состояний данных ссылок, запишите для каждого псевдокласса отдельное правило:
```
#main-menu .menu-link:link { color: red; }
#main-menu .menu-link:visited { color: grey; }
#main-menu .menu-link:hover { background-color: #a38beb; }
#main-menu .menu-link:active { background-color: yellow; }
```
## Варианты стилизации ссылок в CSS
Со ссылками работают самые разнообразные свойства: `color, background, border, border-radius, text-decoration, padding` и т. д
Чтобы иметь возможность подобным образом стилизовать ссылку, нужно заставить ее вести себя как блочный (block) либо строчно-блочный элемент (inline-block). Дело в том, что если вы будете добавлять отступы к строчному элементу (коим по умолчанию является ссылка), то не увидите никакого эффекта.
## Навигационные панели с помощью CSS
* Вертикальное меню
```
.menu {
    list-style-type: none;
    margin: 0;
    padding: 0;
}
```
> По сути, идентичные действия по отношению к спискам делает файл сброса стилей Reset.css, поэтому, если вы используете его на вашем сайте, то код выше можно не записывать.
Прежде всего нужно сделать все теги <a> блочными элементами:
	
`.menu a { display: block; }`
Следующее, что нам понадобится сделать — это задать ширину меню.
`.menu { width: 300px; }`
Чтобы визуально разделить пункты меню, можно задать каждому из них нижнюю или верхнюю границу. В зависимости от того, какую из них вы используете, у вас будет не хватать границы сверху или снизу меню. Это можно исправить, добавив еще одну границу к самому блоку .menu:
```
.menu a {
    border-top: 1px solid blue;
}
.menu {
    border-bottom: 1px solid blue;
}
```
Сейчас ссылки меню выглядят слишком низкими, расположенными близко друг к другу. Если текст каждой ссылки не будет занимать более одной строки, то увеличить их высоту и сохранить при этом текст вертикально по центру можно с помощью свойств height и line-height:
```
.menu a {
  height: 30px;
  line-height: 30px;
}
```
* Горизонтальное меню
1. Первый вариант — задать пунктам списка свойство display со значением inline либо inline-block:
```
.menu li {
  display: inline;
}
```
При этом теги `a` внутри li нельзя делать блочными, иначе пункты перестанут выстраиваться горизонтально и снова встанут в вертикальную позицию. Ссылкам можно также задать значение inline или inline-block. Выберите второе, если вы собираетесь в дальнейшем создавать отступы для ссылок.
После этого можно заняться оформлением ссылок. Например, можно сделать такой стиль:
	
```
.menu a {
  text-decoration: none;
  font-family: sans-serif;
  color: #5757a0;
  display: inline-block;
  padding: 10px 20px;
  background-color: lavender;
  border-bottom: 5px solid #5757a0;
}
```
```
.menu li {
  margin-right: -5px;
}
```
Этот код не убирает промежутки, а прикрывает их за счет сдвига элементов на пять пикселей влево. Данный способ нельзя назвать очень надежным, потому что размер промежутка может варьироваться в зависимости от других стилей.

Если промежутки между пунктами не запланированы в вашем дизайне, лучше воспользоваться вторым методом горизонтального выстраивания элементов.

2. Второй способ
Возможно, вы уже догадались, что второй вариант создания горизонтального меню заключается в использовании свойства float. Для этого добавьте стиль для тегов li:
	
```
.menu li {
  float: left;
}
```
Как видим, промежутков между пунктами уже нет. Все остальные стили работают, как и прежде. Но если вы добавите после навигации другой HTML-элемент (допустим, h1), то на него повлияет обтекание и он встанет в один ряд с пунктами меню. Отменить это действие можно, добавив заголовку свойство clear: left. Но при разработке сайта с большим количеством разных страниц может стать сложно следить за тем, нигде ли вы не забыли указать данное свойство. Гораздо легче отменить обтекание со стороны навигации. В этом поможет такая запись:
	
```
.menu {
  overflow: hidden;
}
```
Это также поможет вернуть нормальную высоту родителя плавающих элементов. Мы уже говорили об этой проблеме в предыдущих уроках, но тогда мы решали ее через специальный хак с использованием псевдоэлемента :after. Пример выше — это еще один способ решить вопрос с исчезнувшей высотой контейнера.
> Примечание: если вы установите фон для элемента .menu, то вы не увидите его до тех пор, пока не примените к нему overflow: hidden. Логично, ведь как можно увидеть фон элемента, чья высота равна нулю?


