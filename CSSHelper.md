# Основа
## Популярные псевдоклассы CSS
```
    :link – этот псевдокласс задает стиль ссылкам, по которым пользователь еще не перешел;
    :visited – этот же, наоборот, применяет стиль к уже посещенным ссылкам;
    :hover – определяет стиль элемента, когда на него наведен курсор (может применяться не только к ссылкам);
    :active – задает стиль активной ссылке (то есть, в момент клика по ней);
    :focus – применяет стиль к элементу при фокусировке на нем (например, при установке курсора в строку поиска);
    :not() – этот полезный псевдокласс позволяет выбрать и стилизовать только те элементы, которые не содержат селектор, указанный в скобках.
```
```
    ::after – используется вместе со свойством content и позволяет вывести необходимые данные после содержимого элемента;
    ::before – выполняет похожую функцию, что и предыдущий, только выводит данные перед содержимым элемента;
    ::selection – этот псевдоэлемент распознается браузерами только при использовании двух двоеточий и позволяет установить цвет и фон для текста, который выделен пользователем;
    ::first-letter – используется для изменения стиля первого символа в тексте элемента;
    ::first-line – используется для изменения стиля первой строки текста элемента.
```
## Дочерние селекторы CSS
```
body > p {
	color: #333;
}
```
Обратите внимание на символ > после body. С помощью него вы указываете, что стиль применяется исключительно для дочерних тегов <p> родителя <body>. Если символ убрать, то стиль применится абсолютно ко всем тегам <p>, которые находятся внутри тега <body>, хотя они могут и не являться для него дочерними.

## Дополнительные псевдоклассы
```
    :first-child – с помощью этого псевдокласса можно применить стиль к указанному элементу веб-страницы, при условии, что он является первым дочерним элементом своего родителя;
    :last-child – стиль применяется к указанному элементу веб-страницы при условии, что он является последним дочерним элементом своего родителя;
    :nth-child – позволяет выбрать четные (even) и нечетные (odd) дочерние элементы; также с помощью данного псевдокласса можно стилизовать чередующиеся дочерние элементы, используя выражения вида an+b и числа;
    :only-child – применяется к дочернему элементу при условии, что тот является единственным ребенком у родителя;
    :first-of-type – стиль применяется к первому элементу указанного типа (даже если этот элемент не является первым дочерним для своего родителя и над ним находятся другие дочерние элементы других типов);
    :last-of-type – работает точно так же, как и предыдущий псевдокласс, с той лишь разницей, что стиль применяется к последнему элементу указанного типа;
    :nth-of-type – по принципу работы похож на :nth-child, но ориентируется на тип элемента;
    :only-of-type – применяется к дочернему элементу указанного типа при условии, что тот является у родителя единственным ребенком своего типа.
```
## Соседние селекторы
```
h1+p {
font-style: italic;
}
```
Записывая это правило, в первую очередь необходимо указать имя первого соседа, затем добавить символ + и имя второго соседа (того, к которому мы желаем применить стиль). Можно создавать и более длинные комбинации. Схема написания селектора такая: selector1+selector2+…+selectorN {} (стиль применяется к selectorN).
Примеры написания:
```
/* Отступ от абзаца до картинки 30px */
p+img {
padding-top: 30px;
}
```
```
/* Зеленый цвет для абзаца, который следует после h3 в связке с h2 */
h2+h3+p {
color: green;
}
```
## Родственные селекторы
```
h1 ~ p {
  font-style: italic;
}
```
…и немного HTML для примера:
```
<div>
<p>Текст</p>
<h1>Заголовок 1</h1>
<p>Текст</p>
<p>Текст</p>
<h2>Заголовок 2</h2>
<p>Текст</p>
 </div>

<div>
<p>Текст</p>
 </div>
```
Взгляните на HTML-код: стиль применится ко всем тегам p, которые следуют после тега h1 и находятся до закрывающего тега родителя div. В нашем варианте насчитывается 3 элемента p, к которым применится стиль.
  Используя соседние (смежные) селекторы, вы можете применять стиль к элементу в случае, когда он следует сразу за другим элементом (или группой элементов). Это работает с элементами, которые находятся на одном уровне и имеют общего родителя.
  С помощью родственных селекторов можно применять стиль ко всем элементам выбранного типа в случае, когда они следуют сразу за другим элементом (или группой элементов). Это работает с элементами, которые находятся на одном уровне и имеют общего родителя.

## Селекторы атрибутов
С помощью CSS селекторов атрибутов (англ. attribute selectors) вы можете задавать стиль тем тегам, которые имеют указанные атрибуты. Пример: вы желаете присвоить определенный стиль всем фотографиям, которые имеют атрибут title, не затрагивая все остальные изображения. Делается это просто:
```
img[title] {
	width: auto;
	height: auto;
}
```
Как видим, атрибут title записан в квадратных скобках после названия img, затем идет блок объявлений. А что если вам понадобится создать стиль только для тех изображений с атрибутом title, которым присвоен определенный класс, скажем, .gallery? В таком случае это записывается так:
```
.gallery[title] {
	width: auto;
	height: auto;
}
```
## Атрибуты со значениями
```
img[title="portrait"] {
	border-style: solid;
}
```
## Выборка по началу текста
Селекторы атрибутов также могут пригодиться при оформлении ссылок. Представьте, что вам нужно особым образом выделить все адреса URL с протоколом https://. Для этого достаточно описать, как выглядит начало адреса URL:
```
a[href^="https://"] {
	color: green;
}
```
Обратите внимание на символ ^, который в переводе на наш язык означает «начинается с». Используя его, вы можете придавать свой стиль различным ссылкам (и не только им). Например, чтобы изменить цвет всех ссылок, которые ведут на главную или другие страницы https://google.com, нужно записать:
```
a[href^="https://google.com"] {
	color: green;
}
```
Обратите внимание на то, что наш стиль будет применен строго к тем ссылкам, которые начинаются так https://google.com. Другие варианты написания ссылок, например, https://www.google.com или http://google.com, необходимо записывать отдельно. Пример:
```
a[href^="https://google.com"] {
	color: green;
}

a[href^="https://www.google.com"] {
	color: green;
}


/* Или более короткий способ: */

a[href^="https://google.com"], [href^="https://www.google.com"] {
	color: green;
}
```
## Выборка по концу текста
А может быть вы желаете красиво оформить все ссылки на файлы с расширением .rar? Тогда вам понадобится описать, как выглядит окончание URL:
```
a[href$=".rar"] {
	color: #FFF;
	text-decoration: none;
	background-color: orange;
	padding: 5px 10px;
	cursor: pointer;
}
```
Не забудьте указать после названия атрибута символ $, который означает «заканчивается на».
## Наследование
С помощью inherit можно указать, чтобы элемент наследовал значение свойства у своего предка. Такое значение доступно практически для каждого свойства в CSS.

Для демонстрации используем предыдущий пример: чтобы всё-таки заставить теги p унаследовать рамку border от своего предка body, необходимо записать:
```
p {
	border: inherit;
}
```
## Сброс стилей 
* reset css
* normalize
# Работа с текстом
## Шрифт
Допустим, вы желаете оформить текст шрифтом Verdana, а в качестве запасных установить шрифты Trebuchet MS, Geneva и любой шрифт без засечек. Записывается это таким образом:
```
p  {
	font-family: Verdana, "Trebuchet MS", Geneva, sans-serif;
}
```
Обратите внимание: в коде мы записали название шрифта Trebuchet MS в кавычках. Необходимо брать название шрифта в двойные либо одинарные кавычки тогда, когда в нем содержатся пробелы.
## Подключаем веб-шрифт с помощью @font-face
Предположим, у вас есть свой уникальный шрифт под названием MyUniqueFont в формате TTF и вы желаете, чтобы основной текст веб-страницы отображался именно этим шрифтом. Первое, что нужно сделать, это скопировать файл шрифта в папку, где находятся все остальные файлы сайта. Чтобы не создавать беспорядок, вы можете создать отдельную папку специально для шрифтов, назвав ее, к примеру, fonts.
Далее нам необходимо дать команду браузеру загрузить шрифт MyUniqueFont. Записывается это с помощью директивы @font-face следующим образом:
```
@font-face {
	font-family: MyUniqueFont;
	src: url('fonts/MyUniqueFont.ttf');
}
```
Свойство font-family в данном случае играет другую роль: с помощью него мы присваиваем имя шрифту, чтобы потом использовать это имя при написании стиля:
```
p {
	font-family: MyUniqueFont;
}
```
Во второй строке указывается путь к файлу шрифта. В нашем примере файл MyUniqueFont.ttf находится в папке fonts. У вас URL-адрес может отличаться.
## Шрифты Google Fonts
```
<head>
<link href='http://fonts.googleapis.com/css?family=Roboto&subset=latin,cyrillic'
rel='stylesheet' type='text/css'>

...
</head>
```
Второй способ – подключение шрифта с помощью директивы @import. Готовый код находится во второй вкладке пункта 3 на странице выбранного Google-шрифта. Его нужно добавить в самое начало вашей таблицы стилей (в противном случае файл не импортируется). Выглядит код примерно так:
```
@import url(http://fonts.googleapis.com/css?family=Roboto&subset=latin,cyrillic);
```
После осуществления предыдущих шагов можно начать применять шрифт. Как записывается такое правило CSS, вы уже видели ранее:
```
p {
font-family: 'Roboto', sans-serif;
}
```
Если на первом шаге вы выбрали несколько вариантов начертания (к примеру, добавили вариант жирного шрифта Bold 700), тогда на третьем шаге код немного видоизменится:
```
<link href='http://fonts.googleapis.com/css?family=Roboto:700,400&subset=latin,cyrillic'
rel='stylesheet' type='text/css'>
```
Или:
```
@import url(http://fonts.googleapis.com/css?family=Roboto:700,400&subset=latin,cyrillic);
```
Чтобы затем придать шрифту жирное начертание, запишите CSS-стиль таким образом:
```
p {
font-family: 'Roboto', sans-serif;
font-weight: 700;
}
```
## Размер шрифта в процентах
Вы наверняка уже сталкивались с ситуацией, когда размер шрифта в CSS не задан, вследствие чего браузеру приходится определять размер шрифта «по своему усмотрению». Если точнее, берется предустановленное значение по умолчанию. Именно от него зависят установленные в процентах значения. Например, базовый размер основного текста p, как правило, равняется 16 пикселям. Значение 100% эквивалентно базовому размеру шрифта, который предустановлен в браузере. Поэтому:
```
p {
	font-size: 100%;
}
```
...то же самое, что и значение в браузере по умолчанию:
```
p {
	font-size: 16px;
}
```
Если же в этом случае задать размер шрифта 50%, то он будет равен половине базового размера. Значение 200%, наоборот, увеличит шрифт в два раза.
Важно: процентные значения размера шрифта наследуются. Например, если для родительского тега задан размер шрифта 150%, то все вложенные в него теги также унаследуют это значение.
## Единица измерения em
По принципу работы единица измерения em похожа на проценты. Значение 1em эквивалентно 100% и соответствует базовому размеру шрифта по умолчанию. Соответственно, 0.6em = 60%, 3em = 300% и так далее. Пример записи:
```
font-size: 0.9em;

/* перед точкой можно опустить ноль: */

font-size: .9em;
```
Значения размеров шрифтов, указанные в em, наследуются (как и проценты). Это создает некоторые трудности при работе с CSS. Например, если для родительского элемента div задан размер шрифта 2em, то для вложенного в него такого же элемента div шрифт будет увеличен еще в два раза. 
## Единица измерения rem
В качестве альтернативы можно воспользоваться новой единицей измерения, введенной в CSS3 – rem, которая всегда отталкивается от базового размера шрифта.
Недостатком единицы измерения rem является то, что она не поддерживается некоторыми браузерами, а именно Internet Explorer версии 8 (и ранее), а также Opera Mini 8.
## Ключевые слова
```
xx-small 9px
x-small  10px
small 	 13px
medium 	 16px
large 	 19px
x-large  24px
xx-large 32px
```
Как видим, значение medium соответствует базовому размеру шрифта 16px. Использование ключевых слов ограничивает возможности и лишает гибкости, поэтому профессиональные разработчики не применяют их.
## Жирный шрифт в CSS: свойство font-weight
```
bold 	                          Полужирный шрифт
normal 	                          Обычный шрифт
bolder 	                          Более жирный шрифт, чем у родителя
lighter 	                  Менее жирный шрифт, чем у родителя
inherit 	                  Наследует значение родителя
Числовое значение от 100 до 900   От очень тонкого до очень жирного шрифта
```
Пример записи:
```
p {
font-weight: bold;
}
```
## Курсив в CSS: свойство font-style
```
italic 	 Курсивный шрифт
oblique  Наклонный шрифт
normal 	 Обычный шрифт
inherit  Наследует значение родителя
```
Пример записи:
```
p {
font-style: italic;
}
```
## Прописные и строчные буквы в CSS: свойство text-transform
```
uppercase 	Делает заглавными (прописными) все буквы в тексте
lowercase 	Делает строчными все буквы в тексте
capitalize 	Делает заглавной первую букву каждого слова в тексте
none 	        Не делает изменений
inherit 	Наследует значение родителя
```
Пример записи стиля:
```
h3 {
	text-transform: uppercase;
}
```
## Подчеркивание, зачеркивание текста в CSS: свойство text-decoration
```
underline 	Нижнее подчеркивание текста
overline 	Верхнее подчеркивание текста
line-through 	Зачеркивание текста
blink 	        Мигание текста
none 	        Удаление всех эффектов
inherit 	Наследование значений родителя
```
Пример записи стиля:
```
p a {
	text-decoration: underline;
}
```
## Тень для текста: свойство CSS text-shadow
```
h1 {
	text-shadow: 3px 5px 6px #6C9;
}
```
Как видно, мы указали целых четыре значения через пробел. Пройдемся по порядку:
* 3px – первое значение отвечает за смещение тени по оси X (вправо, влево). Положительным значением тень сдвигается вправо, а отрицательным – влево.
* 5px – второе значение отвечает за смещение тени по оси Y (вниз, вверх). Положительным значением тень сдвигается вниз, а отрицательным – вверх.
* 6px – третье значение отвечает за радиус размытия тени. Этот параметр указывать необязательно. По умолчанию размытие равняется 0 пикселей, что делает тень четкой и неразмытой.
* #6c9 – четвертое значение отвечает за цвет тени. Этот параметр указывать необязательно. По умолчанию цвет тени устанавливается такой же, как у текста, к которому применяется стиль.
## Несколько теней CSS для текста
Можно установить более двух
```
h1 {
  text-shadow: 3px 5px 6px #6C9, -6px -7px 6px #D9FFA7;
}
```
## Межсимвольный интервал CSS: letter-spacing
Задать межсимвольный интервал можно с помощью свойства CSS letter-spacing. Помимо обычных значений (положительных и отрицательных) также можно использовать значения inherit (чтобы наследовать значение у родителя) и normal (если необходимо вернуть нормальное расстояние между символами).
Пример записи межсимвольного интервала:
```
p {
	letter-spacing: 2em;
}
```
## Интервал между словами: word-spacing
Свойство CSS word-spacing отличается от предыдущего тем, что устанавливает расстояние между словами, а не между символами. Для данного свойства тоже предусмотрены значения normal и inherit. Можно задавать отрицательные значения. Ниже показан пример записи стиля:
```
p {
	word-spacing: 6px;
}
```
## Межстрочный интервал: line-height
С помощью свойства CSS line-height можно задавать расстояние между строками текста. Как было сказано в начале темы, для установки интерлиньяжа, помимо других единиц измерения, допускается использовать проценты. Также разрешено записывать значение в виде множителя (числа больше 0): для вычисления расстояния браузер умножит размер шрифта на заданное число. Отрицательные значения не работают. Доступны значения normal и inherit.
Ниже – пример, как сделать межстрочный интервал CSS:
```
p {
	line-height: 180%;
}
```
## Выравнивание текста в CSS: свойство text-align
```
По левому краю 				left
По правому краю 			right
По центру страницы/блока 		center
По ширине страницы/блока 		justify
Выравнивание текста по тому краю,       start
с которого он начинается 
(то есть текст, идущий слева направо, 
выравнивается по левому краю) 				 	 
Выравнивание текста по противоположному end
краю (то есть текст, идущий слева 
направо, выравнивается по правому краю) 						
```
Пример записи стиля:
```
p {
text-align: left;
}
```
## List-style-type: изменение маркера / нумерации
```
Маркер-точка (по умолчанию) 					disc
Маркер-окружность 						circle
Маркер-квадрат 							square
Нумерация арабскими цифрами (по умолчанию) 			decimal
Нумерация арабскими цифрами (перед числами 1-9 добавляется 0) 	decimal-leading-zero
Нумерация прописными буквами латинского алфавита 		upper-latin
Нумерация строчными буквами латинского алфавита 		lower-latin
Наследование значений родителя 					inherit
Удаление маркеров / нумерации 					none
```
Примечание: в таблице приведены только основные значения. Существует более обширный список (грузинская и армянская нумерации, нумерация римскими числами, греческими буквами и т. д.)
## List-style-image: маркер-картинка
```
ul {
	list-style-image: url(images/star.png);
}
```
## List-style-position: расположение маркеров / нумерации
Для CSS свойства list-style-position, которое задает расположение маркеров / нумерации относительно текста, есть два значения – outside и inside. По умолчанию используется значение outside – это значит, что маркер / число отображается как бы отдельно от текста списка, тогда как при значении inside маркер / число располагается внутри текстового блока и обтекается текстом.
Ниже показан пример записи стиля:
```
ul {
	list-style-position: inside;
}
```
## List-style: все вместе
```
/* нумерация прописными латинскими буквами внутри текстового блока: */
ol {
	list-style: upper-latin inside;
}

/* графические маркеры снаружи текстового блока: */
ul {
	list-style: url(images/star.png) outside;
}
```
# Блоки
## Базовый набор
* padding (и производные padding-left, padding-right, padding-top, padding-bottom) – это внутренний отступ от края содержимого до границы блока. Можно устанавливать отступы либо от всех четырех сторон контента, либо только от нужных вам.
* margin (и производные margin-left, margin-right, margin-top, margin-bottom) – это поле, которое являет собой расстояние от границы одного блока до другого. Новички иногда путают свойство margin со свойством padding, поэтому для наглядности ниже показаны рисунки, где лучше понятна разница между этими свойствами. Поля можно задавать как для всех сторон блока одновременно, так и для отдельных.
* border (и производные border-left, border-right, border-top, border-bottom) – это рамка (граница), которую можно задать для блока. Поля margin остаются за пределами рамки, всё остальное находится внутри неё. Рамку можно установить на всех четырех сторонах или только на нужных вам.
* background-color – это цвет фона, заливка цветом, которая применяется к заднему фону блока и не выходит за его пределы. Поля этим цветом не закрашиваются, а контент и рамка располагаются поверх фона.
Также можно настраивать ширину width и высоту height блока (а точнее, контента, который содержится в блоке). Чтобы затем посчитать ширину или высоту всего блока (вместе с отступами, рамкой и полями), необходимо сложить все эти значения. Например:
`width + padding-left + border-left + margin-left + padding-right + border-right + margin-right = полная ширина блока`
## Поля и отступы CSS: отличия свойств margin и padding
Создавать промежутки между элементами можно и тем, и другим способом, но если padding – это отступ от содержимого до края блока, то margin – это расстояние от одного блока до другого, межблоковое пространство.
Значения могут быть указаны в любых единицах CSS – px, em, % и т. д.
Также существует очень удобная вещь как сокращенная запись margin и padding CSS. Если вам необходимо задать поля или отступы для всех четырех сторон элемента, совсем необязательно записывать свойство для каждой стороны по отдельности. Всё делается проще: для margin и padding можно указывать сразу 1, 2, 3 или 4 значения. От количества значений зависит, как распределяются настройки:
```
4 значения: задаются отступы для всех сторон элемента в такой последовательности: сверху, справа, снизу, слева:
padding: 2px 4px 5px 10px;
3 значения: задается отступ сначала для верхней стороны, потом одновременно для левой и правой, а затем – для нижней:
padding: 3px 6px 9px;
2 значения: задаются отступы сначала одновременно от верхней и нижней стороны, а затем – одновременно для левой и правой:
padding: 6px 12px;
1 значение: задаются одинаковые отступы для всех сторон элемента:
padding: 3px;
```
Те же правила касаются и свойства margin CSS. Обратите внимание на то, что для margin можно использовать и отрицательные значения (например, -3px), которые иногда бывают весьма полезными.
## Схлопывание margin
Схлопывание margin работает только для верхних и нижних полей элементов и не относится к полям с правой и левой сторон. Окончательная величина промежутка высчитывается в разных ситуациях по-разному:
* Когда оба значения margin положительные, итоговый размер поля будет равен бóльшему значению.
* Если одно из значений является отрицательным, то для вычисления размера поля нужно получить сумму значений. Например, при значениях 20px и -18px размер поля будет равен:
`20 + (-18) = 20 — 18 = 2 пикселя.`
* Если оба значения отрицательные, сравниваются модули этих чисел и выбирается число, бóльшее по модулю (следовательно, меньшее из отрицательных чисел). Пример: необходимо сравнить значения полей -6px и -8px. Модули сравниваемых чисел равны 6 и 8 соответственно. Отсюда следует, что 6 < 8, то есть, -6 > -8. Итоговый размер поля равен -8 пикселей.
* В случае, когда значения указаны в разных единицах CSS, они приводятся к одной, после чего сравниваются и выбирается бóльшее значение.
* Размер margin для дочерних элементов определяется еще более интересно: если у потомка поле margin больше, чем у родителя, то приоритет отдается ему. В этом случае размеры верхнего и нижнего полей родителя станут такими, как задано у потомка. При этом расстояния между родителем и потомком не будет.
## Блочные элементы
Блочные элементы являются основой, которая используется для верстки веб-страниц. Такой элемент представляет собой прямоугольник, который по умолчанию занимает всю доступную ширину страницы (если иное значение не указано в CSS), а длина элемента зависит от его содержимого. Такой элемент всегда начинается с новой строки, то есть, располагается под предыдущим элементом. Блочный элемент может содержать в себе другие блочные и строчные элементы.
Примеры блочных элементов: `<div>, <p>, <ul>, <ol>, <h1>` и другие.

## Строчные элементы
В отличие от блочного, строчный элемент не переносится на новую строку, а располагается на той же строке, что и предыдущий элемент. Такие элементы, как правило, находятся внутри блочных элементов и их ширина зависит лишь от содержимого и настроек CSS. Еще одно отличие строчного элемента от блочного заключается к том, что в нем может находиться только контент и другие строчные элементы. Блочные элементы в строчные вкладывать нельзя.
Примеры строчных элементов: `<a>, <span>, <strong>, <em>, <img>` и т. д.	

```
в HTML5 порядок вложения тегов такой роли не играет. Элементы уже не просто делятся на блочные и строчные, а группируются по смыслу и назначению, представляя собой категории контента.
```
## CSS-свойство display: меняем тип элемента
При помощи крайне полезного свойства display в CSS можно заставить блочный элемент выглядеть как строчный и наоборот. Чтобы блочный элемент вел себя как inline-элемент (т. е. не переводился на новую строку), для него необходимо записать правило:
```
display: inline;
```
Если же необходимо отобразить строчный элемент как block-элемент (чтобы до и после элемента происходил перенос строки), запишите следующее:
```
display: block;
```
Также можно сделать «гибрид» — блочный элемент с поведением, как у строчного. В этом случае всё содержимое таких блочных элементов будет отображаться, как обычно, но при этом блоки будут вести себя как строчные элементы, выстраиваясь в одной строке друг за другом и переносясь на новую строку лишь при необходимости. Схлопывание margin в таких случаях перестает действовать. Для превращения элемента в блочно-строчный запишите:
```
display: inline-block;
```
## Border-width: ширина границы
С помощью свойства border-width задается ширина границы. Наиболее часто этот размер указывается в пикселях. Можно задать одинаковую либо различную ширину для всех четырех границ, например:
```
/* все 4 границы имеют ширину 2px: */
border-width: 2px;

/* верхняя и нижняя границы имеют ширину 2px, левая и правая — 4px: */
border-width: 2px 4px;

/* верхняя граница — 2px, левая и правая — 6px, нижняя — 3px: */
border-width: 2px 6px 3px;

/* верхняя граница — 2px, правая — 3px, нижняя — 4px, левая — 5px: */
border-width: 2px 3px 4px 5px;
```
Кроме этого, существуют ключевые слова для обозначения ширины границы:
```
    thin — граница шириной 2px;
    medium — граница шириной 4px;
    thick — граница шириной 6px.
```
## Border-color: цвет границы
Свойство border-color задает цвет для границ. Цвета можно указывать в любом формате CSS: ключевыми словами, в шестнадцатеричном виде либо в RGB — зависит от того, как вам удобнее. По аналогии с предыдущим свойством, можно устанавливать как один цвет для всех границ, так и выбирать разные цвета для каждой границы.
```
border-color: #FFFF00;
```
Также можно задать прозрачный цвет, записав:
```
border-color: transparent;
```
## Border-style: стиль границы
```
    solid — сплошная граница;
    dotted — граница из точек;
    dashed — пунктирная граница;
    double — двойная граница;
    groove — объемная граница-выемка;
    ridge — объемная граница с толстой кромкой (по сути, инверсия предыдущего стиля);
    outset — выдавленная граница;
    inset — вдавленная граница (по сути, инверсия предыдущего стиля).
```
## Общее CSS-свойство border: 3 в 1
` border: 2px dotted #FF0000;`
## Как закруглить углы: свойство CSS3 border-radius
```
.borderElement {
  background-color: #EEDDFF;
  border: 6px solid #7922CC;
  border-radius: 25px;
}

.borderElement1 {
  background-color: #FFE8DB;
  border: 6px solid #FF5A00;
  border-radius: 15px 100px 15px 100px;
}
```
вместо простых круглых углов можно задавать эллиптическое скругление. Для этого понадобится указать два значения, разделенные косой чертой (для горизонтальной и вертикальной полуосей эллипса). Приведем пример на блоке размером 150×450 пикселей:
```
.borderElement {
  background-color: #EEDDFF;
  border: 6px solid #7922CC;
  border-radius: 280px/100px;
}
```
```
    border-top-left-radius — для верхнего левого угла;
    border-top-right-radius — для верхнего правого угла;
    border-bottom-left-radius — для нижнего левого угла;
    border-bottom-right-radius — для нижнего правого угла.
```
## Принцип скругления углов
На рисунке ниже показано, каким образом вычисляется скругление углов в CSS. Так, если для угла указано одно значение, — например, 20px, — это означает, что закругление будет происходить по окружности с радиусом 20 пикселей. В случае, когда задаются два значения через косую черту, например, 30px/20px, закругление углов будет происходить по эллипсу. Первое значение в таком случае является длиной горизонтальной полуоси эллипса — 30px, а второе — длиной вертикальной полуоси — 20px
## Свойство box-shadow: синтаксис
Данный стиль записывается следующим образом:
`box-shadow: inset 4px 4px 8px 5px #333333;`
Рассмотрим по порядку, за что отвечает каждый параметр (слева направо):
* Ключевое слово inset: параметр, который необязательно указывать; рисует тень внутри элемента.
* Сдвиг по оси X: указывает степень смещения тени по горизонтали относительно элемента. Положительное значение означает сдвиг вправо, отрицательное — влево. Значение 0 означает, что тень без сдвига.
* Сдвиг по оси Y: указывает степень смещения тени по вертикали. Положительное значение означает сдвиг вниз, отрицательное — вверх. Значение 0 — это тень без сдвига.
* Радиус размытия: это степень размытия тени. Чем больше значение, тем более размыта тень. Если параметр не указан, используется значение по умолчанию — 0. В таком случае тень будет идеально четкой.
* Расширение: необязательный параметр, отвечающий за растяжение тени по обеим осям; чем больше значение, тем больше растяжение. Расширение работает только при наличии предыдущего параметра. Значение по умолчанию — 0.
* Цвет тени: с этим параметром всё понятно — он задает цвет тени элемента. Цвет по умолчанию — черный.

Данное свойство может принимать несколько групп значений (делать несколько теней одновременно). Для этого понадобится перечислить эти группы параметров через запятую. Например:
```
box-shadow: 15px 15px 20px #8b0163,
            inset 15px 15px 20px #630046;
```
## Width и height: определяем размеры элемента
* В качестве значения ширины можно использовать и единицу em, которая является примерно тем же, чем и размер шрифта текста, но только в условных единицах. К примеру, вы установили размер для шрифта 24px. Тогда 1em для этого элемента будет равен 24 пикселам, а если вы зададите width: 2em, то ширина составит 2×24px = 48 пикселов. Если размер шрифта не задан, он будет унаследован.
* Высота height, заданная в процентах, вычисляется аналогичным образом, что и ширина, но расчет основывается уже на высоте родительского элемента, а не на его ширине. Если родитель отсутствует, высота будет зависеть от высоты окна браузера.
* Сразу стоит запомнить, что у свойств width и height есть особенность — они не включают в себя значения margin, padding и border. Значение, которое вы установите для width/height, будет означать лишь ширину/высоту области содержимого элемента.
* Таким образом, для того чтобы вычислить, например, фактическую ширину элемента (место, которое он в действительности займет на экране), понадобится немного арифметики. Фактическая ширина — это сумма значений, таких как width, padding, border и margin.
* Свойство height может быть удобным, если надо точно контролировать, например, высоту изображения. Однако, если в контейнере будет содержаться текст или любой другой контент, у которого может варьироваться высота, крайне не рекомендуется устанавливать фиксированную высоту для контейнера, так как подобная верстка может привести к неожиданному результату — контент будет отображаться поверх другого содержимого.
* Вместо фиксированной высоты использовать height: auto — эта запись означает, что высота объекта будет рассчитываться автоматически, в зависимости от содержимого, которое он содержит.
* Другой способ избежать развала верстки — использовать запись overflow: auto. В таком случае, если высота содержимого будет превышать значение height своего контейнера, браузер добавит к контейнеру полосу прокрутки.
## Box-sizing
1. В предыдущем уроке мы рассказывали, по какому принципу традиционно вычисляется ширина и высота элемента. Фактическую ширину/высоту образует сумма значений width/height, padding, border и margin.
2. Нередко в процессе верстки возникает необходимость управлять стандартным вычислением размеров элемента. Допустим, вы хотите, чтобы ширина определенного блока <div> составляла 50% от ширины веб-страницы. Для этого вы задаете свойству width значение 50%. И здесь возникает загвоздка: если у блока имеются отступы (padding), поля (margin) либо рамка (border), то они будут считаться отдельно. В итоге ширина блока будет более 50%, а это уже не входит в ваши планы.
3. Как же сделать так, чтобы браузер учитывал отступы, а иногда и рамку, вычисляя ширину блока? На помощь приходит свойство box-sizing, которое может принимать три значения, а именно:

* content-box — значение по умолчанию (поведение, описанное выше). Ширина и высота элемента определяется только свойствами width и height.
* border-box — в данном случае браузер включает отступы padding и рамку border в общую ширину/высоту элемента. Это значит, что если для блока задана ширина, скажем, width: 50%, отступы (например, padding-left: 10px и padding-right: 10px) и рамка (border-width: 1px), то браузер будет считать эти отступы и рамку частью ширины 50%. Ширина самого содержимого составит 50% минус 22 пикселя. Обратите внимание, что значения margin включены НЕ будут.
* padding-box — это значение похоже на предыдущее, только в ширину/высоту элемента будут включены только отступы padding, без рамки. Значения margin также не учитываются. Значение padding-box было исключено из спецификации CSS, однако оно все еще поддерживается браузером Firefox.

   Чтобы свойство box-sizing работало в браузерах Firefox, а также старых версиях Safari, Chrome и Android, следует записывать несколько его вариаций, используя соответствующие префиксы производителя:
```
-moz-box-sizing: border-box;
-webkit-box-sizing: border-box;
box-sizing: border-box;
```
Что же насчет поддержки браузером Internet Explorer? Хорошие новости: box-sizing работает в IE8 и выше.
## Overflow: управление переполненными элементами
* hidden — всё содержимое, выходящее за пределы контейнера, будет скрыто. Не подходит в случае с текстовым контентом, но очень часто используется на практике для решения других задач и предотвращения некоторых «казусов».
* scroll — к контейнеру будут добавлены вертикальные и горизонтальные полосы прокрутки (скролл). Внешне блок становится похож на фрейм. Скролл отображается постоянно.
* auto — также добавляются полосы скролла, но только тогда, когда они необходимы (т. е. если содержимое не влазит в контейнер).
* visible — значение, установленное по умолчанию в браузере. Контент виден, даже если блок переполнен. Можно использовать для сброса другого значения, заданного ранее.
##  Max-width, max-height, min-width, min-height: максимальные и минимальные размеры элемента
* min-width — с помощью этого свойства вы можете указать минимальную ширину элемента. Например, если вы зададите блоку стиль min-width: 50px, то ширина блока может стать больше, но она никогда не станет меньше, чем 50 пикселей. Это очень удобно, например, при создании адаптивной верстки, когда при определенных размерах экрана элемент с относительной шириной становится слишком узким. Свойство min-width позволяет предотвратить такие искажения.
* min-height — работает аналогично предыдущему свойству, но только по отношению к высоте элемента. Безусловно, это тоже очень полезное свойство в практике, которое позволяет задать минимальную высоту элемента.
* max-width — как вы уже догадались, это свойство позволяет задать максимально допустимую ширину элемента. Например, элемент со стилем max-width: 960px может иметь ширину меньше максимальной, но он никогда не станет больше, чем 960 пикселей. Данное свойство удобно использовать при создании адаптивной разметки, когда вам необходимо, чтобы элемент адаптировался под ширину экрана любого устройства, но при этом не слишком широко разъезжался на больших экранах.
* max-height — работает аналогично предыдущему свойству, только по отношению к высоте. Но, как мы уже говорили ранее, лучше не играть с ограничением высоты элемента без крайней надобности.
* auto — это значение можно использовать для отмены действия свойства.
## CSS float
* left — элемент выравнивается по левой стороне. Элементы, находящиеся ниже в потоке, обтекают его с правой стороны.
* right — значение, противоположное предыдущему. Элемент выравнивается по правой стороне, а элементы, находящиеся ниже в потоке, обтекают его слева по левому краю.
* none — элемент не обтекается и находится в своей обычной позиции.
## Отмена обтекания: свойство clear
* left — элемент, к которому применяется свойство clear:left, перестает обтекать элемент со свойством float:left, однако правое обтекание сохраняется.
* right — элемент, к которому применяется свойство clear:right, перестает обтекать элемент со свойством float:right, однако левое обтекание сохраняется.
* both — полностью отменяет обтекание со всех сторон. Элемент смещается вниз и образовывает стандартный поток. На следующие за ним элементы обтекание также перестает влиять.
* none — отменяет очистку clear. Элемент будет вести себя, как обычно, и на него будут влиять настройки float.


