# Содержание
1. [С чего начать](#1)
* 1.1 [Rails для начинающих](#1.1)
* * 1.1.1 [Что такое Rails](#1.1.1)
* * 1.1.2 [Создание Rails приложения](#1.1.2)
* * 1.1.3 [Hello Rails](#1.1.3)
* * 1.1.4 [Безопасность Rails](#1.1.4)
* * 1.1.5 [Что дальше](#1.1.5)
2. [Модели](#2)
* 2.1 [Основы Active Record](#2.1)
* * 2.1.1 [Что такое Active record](#2.1.1)
* * 2.1.2 [Соглашения над конфигурацией](#2.1.2)
* * 2.1.3 [Создание моделей Active record](#2.1.3)
* * 2.1.4 [Переопределение соглашений о конфигурации](#2.1.4)
* * 2.1.5 [CRUD операции](#2.1.5)
* * 2.1.6 [Валидации](#2.1.6)
* * 2.1.7 [Колбэки](#2.1.7)
* * 2.1.8 [Миграции](#2.1.8)
* 2.2 [Миграции Active Record](#2.2)
* * 2.2.1 [Обзор миграции](#2.2.1)
* * 2.2.2 [Создание миграции](#2.2.2)
* * 2.2.3 [Написание миграции](#2.2.3)
* * 2.2.4 [Запуск миграции](#2.2.4)
* * 2.2.5 [Изменение существующих миграций](#2.2.5)
* * 2.2.6 [Выгрузка схемы](#2.2.6)
* * 2.2.7 [Active Record и ссылочная целостность](#2.2.7)
* * 2.2.8 [Миграции и сиды](#2.2.8)
* * 2.2.9 [Старые миграции](#2.2.9)
* 2.3 [Валидации](#2.3)
* * 2.3.1 [Обзор валидаций](#2.3.1)
* * 2.3.2 [Валидационные хелперы](#2.3.2)
* * 2.3.3 [Общие опции валидаций](#2.3.3)
* * 2.3.4 [Строгие валидации](#2.3.4)
* * 2.3.5 [Условная валидация](#2.3.5)
* * 2.3.6 [Выполнение собственных валидаций](#2.3.6)
* * 2.3.7 [Работаем с ошибками валидации](#2.3.7)
* * 2.3.8 [Отображение ошибок валидации во вьюхах](#2.3.8)
* 2.4 [Колбэки](#2.4)
* * 2.4.1 [Жизненный цикл объекта](#2.4.1)
* * 2.4.2 [Обзор колбэков](#2.4.2)
* * 2.4.3 [Доступные колбэки](#2.4.3)
* * 2.4.4 [Запуск колбэков](#2.4.4)
* * 2.4.5 [Пропуск колбэков](#2.4.5)
* * 2.4.6 [Прерывание выполнения](#2.4.6)
* * 2.4.7 [Колбэки для отношений](#2.4.7)
* * 2.4.8 [Условные колбэки](#2.4.8)
* * 2.4.9 [Классы колбэков](#2.4.9)
* * 2.4.10 [Транзакционные колбэки](#2.4.10)
* 2.5 [Связи (ассоциации)](#2.5)
* * 2.5.1 [Зачем нужны связи?](#2.5.1)
* * 2.5.2 [Типы связей](#2.5.2)
* * 2.5.3 [Полезные советы и предупреждения](#2.5.3)
* * 2.5.4 [Подробная информация по связи belongs_to](#2.5.4)
* * 2.5.5 [Подробная информация по связи has_one](#2.5.5)
* * 2.5.6 [Подробная информация по связи has_many](#2.5.6)
* * 2.5.7 [Подробная информация по связи has_and_belongs_to_many](#2.5.7)
* * 2.5.8 [Подробная информация по колбэкам и расширениям связи](#2.5.8)
* * 2.5.9 [Наследование с единой таблицей (STI)](#2.5.9)
* 2.6 [Интерфейс запросов](#2.6)
* * 2.6.1 [Получение объектов из базы данных](#2.6.1)
* * 2.6.2 [Условия](#2.6.2)
* * 2.6.3 [Сортировка](#2.6.3)
* * 2.6.4 [Выбор определенных полей](#2.6.4)
* * 2.6.5 [Ограничение и смещение](#2.6.5)
* * 2.6.6 [Группировка](#2.6.6)
* * 2.6.7 [Having](#2.6.7)
* * 2.6.8 [Переопределяющие условия](#2.6.8)
* * 2.6.9 [Нулевой Relation](#2.6.9)
* * 2.6.10 [Объекты только для чтения](#2.6.10)
* * 2.6.11 [Блокировка записей для обновления](#2.6.11)
* * 2.6.12 [Соединительные таблицы](#2.6.12)
* * 2.6.13 [Нетерпеливая загрузка связей](#2.6.13)
* * 2.6.14 [Скоупы](#2.6.14)
* * 2.6.15 [Динамический поиск](#2.6.15)
* * 2.6.16 [Enum](#2.6.16)
* * 2.6.17 [Цепочки методов](#2.6.17)
* * 2.6.18 [Поиск или создание нового объекта](#2.6.18)
* * 2.6.19 [Поиск с помощью SQL](#2.6.19)
* * 2.6.20 [Существование объектов](#2.6.20)
* * 2.6.21 [Вычисления](#2.6.21)
* * 2.6.22 [Запуск EXPLAIN](#2.6.22)
* 2.7 [Active Record для PostgreSQL](#2.7)
* * 2.7.1 [Типы данных](#2.7.1)
* * 2.7.2 [Первичные ключи UUID](#2.7.2)
* * 2.7.3 [Полнотекстовый поиск](#2.7.3)
* * 2.7.4 [Представление базы данных](#2.7.4)
* 2.8 [Основы Active Model](#2.8)
* * 2.8.1 [Введение](#2.8.1)

3. [Вьюхи](#3)
* 3.1 [Обзор Action View](#3.1)
* * 3.1.1 [Что такое Action View?](#3.1.1)
* * 3.1.2 [Использование Action View с Rails](#3.1.2)
* * 3.1.3 [Шаблоны, партиалы и макеты](#3.1.3)
* * 3.1.4 [Макеты партиалов](#3.1.4)
* * 3.1.5 [Пути вьюх](#3.1.5)
* * 3.1.6 [Обзор хелперов, предоставленных Action View](#3.1.6)
* * 3.1.7 [Локализованные вьюхи](#3.1.7)
* 3.2 [Макеты и рендеринг в Rails](#3.2)
* * 3.2.1 [Обзор: как кусочки складываются вместе](#3.2.1)
* * 3.2.2 [Создание откликов](#3.2.2)
* * 3.2.3 [Структурирование макетов](#3.2.3)
* 3.3 [Макеты и рендеринг в Rails](#3.3)
* * 3.3.1 [Разбираемся с простыми формами](#3.3.1)
* * 3.3.2 [Работаем с объектами модели](#3.3.2)
* * 3.3.3 [Легкое создание списков выбора](#3.3.3)
* * 3.3.4 [Использование хелперов даты и времени](#3.3.4)
* * 3.3.5 [Загрузка файлов](#3.3.5)
* * 3.3.6 [Настройка Form Builder](#3.3.6)
* * 3.3.7 [Понимание соглашений по именованию параметров](#3.3.7)
* * 3.3.8 [Формы к внешним ресурсам](#3.3.8)
* * 3.3.9 [Создание сложных форм](#3.3.9)
* * 3.3.10 [Использование form_for и form_tag](#3.3.10)




4. [Контроллеры](#4)
5. [Копаем глубже](#5)
* 5.1 [Безопасность приложений на Rails](#5.1)
* 5.11 [Командная строка Rails](#5.11)
6. [Расширяем Rails](#6)
* 6.5 [Rails для API приложений](#6.5)
7. [Вносим вклад](#7)
8. [Дополнительно](#8)

> В rus rails имеется множество ссылок, на ресурсы по связанным темам прямо в тексте, которые здесь не отображены.

# C чего начать <a name="1"></a>
## Rails для начинающих <a name="1.1"></a>
### Что такое Rails <a name="1.1.1"></a>
Если изучите "The Rails Way", то, возможно, откроете в себе значительное увеличение производительности. Если будете упорствовать и переносить старые привычки с других языков в разработку на Rails, и попытаетесь использовать шаблоны, изученные где-то еще, ваш опыт разработки будет менее счастливым.

Философия Rails включает два важных ведущих принципов:
* Don't Repeat Yourself: DRY — это принцип разработки ПО, который гласит, что "Каждый кусочек информации должен иметь единственное, неизбыточное, авторитетное представление в системе". Не пишите одну и ту же информацию снова и снова, код будет легче поддерживать, и он будет более расширяемым и менее ошибочным.
* Convention Over Configuration: у Rails есть мнения о наилучших способах делать множество вещей в веб-приложении, и по умолчанию выставлены эти соглашения, вместо того, чтобы заставлять вас по мелочам править многочисленные конфигурационные файлы. 
### Создание Rails приложения <a name="1.1.2"></a>
Для установки Rails используйте команду `gem install`, представленную RubyGems:
```
gem install rails
```
Создание приложения:
```
rails new blog
```
Это создаст приложение на Rails с именем Blog в директории blog и установит гемы, зависимости от которых упомянуты в Gemfile при использовании `bundle install`.
> При использовании Windows Subsystem for Linux, имеются некоторые ограничения на сообщения файловой системы, означающие, что следует отключить гемы spring и listen, что можно сделать, запустив `rails new blog --skip-spring --skip-listen`.

Можно посмотреть все возможные опции командной строки, которые принимает билдер приложения на Rails, запустив rails new -h.

Директория
| Файл/Папка | Назначение |
|------------|------------|
| app/ | Содержит контроллеры, модели, вьюхи, хелперы, рассыльщики, каналы, задания и ассеты вашего приложения. Мы рассмотрим эту папку подробнее далее. |
| bin/ | Содержит Rails скрипты которые стартуют ваше приложение, также директория может содержать другие скрипты которые вы используете для настройки, обновления, деплоя или запуска. |
| config/ | Конфигурации маршрутов, базы данных вашего приложения, и т.д. Более подробно это раскрыто в Конфигурирование приложений на Rails |
| config.ru | Конфигурация Rack для серверов, основанных на Rack, используемых для запуска приложения. Подробнее о Rack смотрите на сайте Rack. |
| db/ | Содержит текущую схему вашей базы данных, а также миграции базы данных. |
| Gemfile Gemfile.lock | Эти файлы позволяют указать, какие зависимости от гемов нужны для вашего приложения на Rails. Эти файлы используются гемом Bundler. Подробнее о Bundler смотрите на сайте Bundler. |
| lib/ | Внешние модули для вашего приложения. |
| log/ | Файлы логов приложения. |
| package.json | Этот файл позволяет указать, какие зависимости npm необходимы для приложения Rails. Этот файл используется Yarn. Подробнее о Yarn смотрите на сайте Yarn. |
| public/ | Единственная папка, которая доступна извне как есть. Содержит статичные файлы и скомпилированные ассеты. |
| Rakefile | Этот файл находит и загружает задачи, которые могут быть запущены в командной строке. Определенная задача доступна во всех компонентах Rails. Вместо изменения Rakefile, можно добавить свои собственные задачи, добавив файлы в директорию lib/tasks приложения. |
| README.md | Это вводный мануал для вашего приложения. Его следует отредактировать, чтобы рассказать остальным, что ваше приложение делает, как его настроить, и т.п. |
| storage/ | Файлы Active Storage для сервиса Disk. Это раскрывается в руководстве Обзор Active Storage. |
| test/ | Юнит-тесты, фикстуры и прочий аппарат тестирования. Это раскрывается в руководстве Тестирование приложений на Rails |
| tmp/ | Временные файлы (такие как файлы кэша и pid) |
| vendor/ | Место для кода сторонних разработчиков. В типичном приложении на Rails включает внешние гемы. |
| .gitignore | Этот файл сообщает git, какие файлы (явно или по шаблону) ему следует игнорировать. Подробнее об игнорировании файлов смотрите GitHub - Ignoring files. |
| .ruby-version | Этот файл содержит дефолтную версию Ruby |
### Hello rails <a name="1.1.3"></a>
Запуск `rails server`
> Если вы используете Windows, вы должны передавать скрипты из папки bin непосредственно в интерпретатор Ruby, то есть ruby bin\rails server.

Веб сервер по умолчанию - puma

> Сжатие ассетов JavaScript требует среды выполнения JavaScript в вашей системе, и его отсутствие приведет к ошибке execjs во время сжатия ассетов. Обычно macOS и Windows поставляются с установленной средой выполнения JavaScript. therubyrhino - рекомендованная среда выполнения для пользователей JRuby, она добавляется в Gemfile, если приложение генерируется под JRuby. Можно узнать все о поддерживаемых средах выполнения в ExecJS

`Ctrl + C` - остановка сервера
В режиме development, Rails в основном не требует остановки сервера; все изменения, которые Вы делаете в файлах, автоматически подхватываются сервером.

`rails routes` - выводит в терминал все пути 
Основной form builder для Rails представлен методом хелпера по имени `form_with`
```
<%= form_with scope: :article, url: articles_path, local: true do |form| %>
<%= form_with scope: :article, local: true do |form| %>
```
ПРИМЕЧАНИЕ: По умолчанию form_with отправляет формы с использованием Ajax, тем самым не осуществляя редирект всей страницы. Чтобы облегчить чтение данного руководства, мы отключили это с помощью `local: true`.
#### Создание статей
При отправке формы, ее поля будут посланы в Rails как параметры. К этим параметрам можно обратиться из экшнов контроллера, как правило, для выполнения определенных задач. Чтобы увидеть, на что похожи эти параметры, измените экшн create так:
```
def create
  render plain: params[:article].inspect
end
```
Метод params возвращает объект ActionController::Parameters, позволяющий получать доступ к ключам хэша с использованием или строк, или символов.
> Давайте рассмотрим в качестве примера URL: http://www.example.com/?username=dhh&email=dhh@email.com. В этом URL, params[:username] будет равен "dhh" и params[:email] будет равен "dhh@email.com".

Если еще раз отправить форму, вы увидите что-то вроде следующего:
`<ActionController::Parameters {"title"=>"First Article!", "text"=>"This is my first article."} permitted: false>`

#### Создание модели Article
`rails generate model Article title:string text:text`
создаст:
```
class CreateArticles < ActiveRecord::Migration[6.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :text

      t.timestamps
    end
  end
end
```
Миграция в бд `rails db:migrate`
Если хотите выполнить миграции в другой среде, например в production, следует явно передать ее при вызове команды: `rails db:migrate RAILS_ENV=production`

Rails имеет ряд защитных мер, помогающих писать безопасные приложения, и вы только что столкнулись с одной из них. Она называется strong parameters и требует, чтобы мы указали Rails, какие именно параметры разрешено передавать в экшны нашего контроллера.

Нам нужно определить разрешенные параметры нашего контроллера, чтобы предотвратить ошибочное массовое назначение. В этом случае, мы хотим и разрешить, и затребовать параметры title и text для правильного использования в create. Синтаксис для этого представлен методами `require` и `permit`. Изменение затрагивает одну строчку в экшне create:
```
private
  def article_params
    params.require(:article).permit(:title, :text)
  end
```
> Если вам нужна ссылка на экшн того же контроллера, не нужно определять опцию :controller, так как Rails по умолчанию использует текущий контроллер.

В режиме development (с которым вы работаете по умолчанию), Rails перегружает ваше приложение с каждым запросом браузера, так что не нужно останавливать и перезапускать веб-сервер при внесении изменений.
`pluralize` это хелпер rails, принимающий число и строку как аргументы. Если число больше одного, строка будет автоматически склонено во множественном числе.
Rails автоматически оборачивает поля, содержащие ошибку, в div с классом `field_with_errors`. Можно определить правило CSS, чтобы сделать их выделяющимися.
Передача объекта статьи в метод `form_with` автоматически установит URL для отправки формы отредактированной статьи. Эта опция сообщает Rails, что мы хотим, чтобы эта форма была отправлена с помощью PATCH, метода HTTP, от которого ожидается, что он используется для обновления ресурсов в соответствии с протоколом REST.
Также, передача объекта модели в `form_with`, наподобие `model: @article` во вьюхе редактирования выше, заставит хелпер формы заполнить поля формы соответствующими значениями объекта. Передача в пространство имен символа, такая как `scope: :article`, что было сделано во вьюхе new, только создаст пустые поля формы.
> Не обязательно передавать все атрибуты в update. К примеру, если был вызван `@article.update(title: 'A new title')`, Rails обновит только атрибут title, оставив все другие атрибуты нетронутыми.
Хелперы, в том числе `form with` https://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with-label-Resource-oriented+style
`rails generate model Comment commenter:string body:text article:references`
Ключевое слово `(:references)`, использованное в команде bash, это специальный тип данных для моделей. Он создает новый столбец в вашей базе данных с именем представленной модели с добавленным _id, который может содержать числовые значения. Чтобы лучше понять, проанализируйте файл db/schema.rb после выполнения миграции.

В дополнение к модели, Rails также сделал миграцию для создания соответствующей таблицы базы данных:
```
class CreateComments < ActiveRecord::Migration[6.0]
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :article, null: false, foreign_key: true

      t.timestamps
    end

  end
end
```
Строчка `t.references` создает числовой столбец с именем `article_id`, индекс для него, и ограничение внешнего ключа, указывающего на столбец id таблицы `articles`.

#### Добавляем маршрут для комментариев
```
resources :articles do
  resources :comments
end
```
`<%= form_with(model: [ @article, @article.comments.build ], local: true) do |form| %>`
```
<%= link_to 'Destroy Comment', [comment.article, comment],
               method: :delete,
               data: { confirm: 'Are you sure?' } %>
```
#### Удаление связанных объектов
`has_many :comments, dependent: :destroy`
### Безопасность <a name="1.1.4"></a>
Если вы опубликуете свой блог онлайн, любой сможет добавлять, редактировать и удалять статьи или удалять комментарии.

Rails предоставляет базовую аутентификационную систему HTTP, которая хорошо работает в этой ситуации.

В ArticlesController нам нужен способ блокировать доступ к различным экшнам, если пользователь не аутентифицирован. Тут мы можем использовать метод Rails `http_basic_authenticate_with`, разрешающий доступ к требуемым экшнам, если метод позволит это.

Чтобы использовать систему аутентификации, мы определим ее вверху нашего ArticlesController в app/controllers/articles_controller.rb. В нашем случае, мы хотим, чтобы пользователь был аутентифицирован для каждого экшна, кроме index и show, поэтому напишем так:
```
class ArticlesController < ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", except: [:index, :show]

  def index
    @articles = Article.all
  end
```
Мы также хотим позволить только аутентифицированным пользователям удалять комментарии, поэтому в CommentsController (app/controllers/comments_controller.rb) мы напишем:
```
class CommentsController < ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", only: :destroy

  def create
    @article = Article.find(params[:article_id])
    # ...
  end
```
Теперь, если попытаетесь создать новую статью, то встретитесь с вызовом базовой аутентификации HTTP.
### Что дальше? <a name="1.1.5"></a>
тут ссылки на ресурсы в оригинале на RusRails 

# Модели <a name="2"></a>
## Основы Active record <a name="2.1"></a>
<a href="https://api.rubyonrails.org/classes/ActiveRecord/Base.html#class-ActiveRecord::Base-label-Single+table+inheritance">Active Record Documentation</a>
### Что такое Active record <a name="2.1.1"></a>
Active Record это M в MVC - модель - которая является слоем в системе, ответственным за представление бизнес-логики и данных. Active Record упрощает создание и использование бизнес-объектов, данные которых требуют персистентного хранения в базе данных. Сама по себе эта реализация паттерна Active Record является описанием системы ORM (Object Relational Mapping).

Active Record был описан Martin Fowler в его книге Patterns of Enterprise Application Architecture. В Active Record объекты содержат и персистентные данные, и поведение, которое работает с этими данными. Active Record исходит из мнения, что обеспечение логики доступа к данным как части объекта покажет пользователям этого объекта то, как читать и писать в базу данных

Object Relational Mapping (объектно-реляционное отображение), обычно упоминающееся как аббревиатура ORM, это техника, соединяющая сложные объекты приложения с таблицами в системе управления реляционными базами данных.

Active Record предоставляет нам несколько механизмов, наиболее важными из которых являются способности для:
* Представления моделей и их данных.
* Представления связей между этими моделями.
* Представления иерархий наследования с помощью связанных моделей.
* Валидации моделей до того, как они станут персистентными в базе данных.
* Выполнения операций с базой данных в объектно-ориентированном стиле. 
### Соглашения над конфигурацией <a name="2.1.2"></a>
Идея в том, что в большинстве случаев вы настраиваете свои приложения одинаковым образом, и этот способ должен быть способом по умолчанию. Таким образом, явная конфигурация потребуется только тогда, когда вы не следуете соглашениям по какой-то причине.
* Таблица базы данных - Множественная форма со словами, разделенными знаком подчеркивания (т.е., book_clubs).
* Класс модели - Единственное число с первой прописной буквой в каждом слове (т.е., BookClub).

| Модель / Класс | Таблица / Схема |
|----------------|-----------------|
| Article        |	articles       | 
| LineItem       |  line_items     |
| Deer           |  deers          |
| Mouse          |	mice           |
| Person         |  people         |

#### Cоглашения схемы
Active Record использует соглашения о именовании для столбцов в таблицах базы данных, зависящих от назначения этих столбцов.
* Внешние ключи - Эти поля должны именоваться по образцу singularized_table_name_id (т.е., item_id, order_id). Это поля, которые ищет Active Record при создании связей между вашими моделями.
* Первичные ключи - По умолчанию Active Record использует числовой столбец с именем id как первичный ключ таблицы. Этот столбец будет автоматически создан при использовании миграций Active Record для создания таблиц. 

Также имеются некоторые опциональные имена столбцов, добавляющие дополнительные особенности для экземпляров Active Record:
* created_at - Автоматически будут установлены текущие дата и время при изначальном создании записи.
* updated_at - Автоматически будут установлены текущие дата и время всякий раз, когда обновляется запись.
* lock_version - Добавляет оптимистическую блокировку к модели.
* type - Указывает, что модель использует Single Table Inheritance.
* (association_name)_type - Хранит тип для полиморфных связей.
* **(table_name)_count - Используется для кэширования количества принадлежащих по связи объектов. Например, столбец comments_count в классе Article, у которого может быть несколько связанных экземпляров Comment, закэширует количество существующих комментариев для каждой статьи.**

> Хотя эти имена столбцов опциональны, фактически они зарезервированы Active Record. Избегайте зарезервированных ключевых слов, если вы не желаете дополнительной функциональности. Например, type - это зарезервированное слово для определения таблицы, использующей наследование с единой таблицей (STI). Если вы не используете STI, попытайтесь использовать аналогичное слово, такое как "context", которое также может аккуратно описать данные, которые вы моделируете

### Создание моделей Active Record <a name="2.1.3"></a>
Создавать модели Active Record очень просто. Все, что необходимо сделать, - это создать подкласс ApplicationRecord, и готово:
```
class Product < ApplicationRecord
end
```
Это создаст модель Product, **связав ее с таблицей products в базе данных**. Сделав так, также появится способность связать столбцы каждой строки этой таблицы с атрибутами экземпляров вашей модели. Допустим, что таблица products была создана с использованием такого выражения SQL (или одно из его расширений):
```
CREATE TABLE products (
   id int(11) NOT NULL auto_increment,
   name varchar(255),
   PRIMARY KEY  (id)
);
```
Вышеуказанная схема объявляет таблицу с двумя столбцами: id и name. Каждая строка этой таблицы представляет собой определенный продукт с этими двумя параметрами. Таким образом, можно написать подобный код:
```
p = Product.new
p.name = "Some Book"
puts p.name # "Some Book"
```
### Переопределение соглашений об именовании <a name="2.1.4"></a>
Но что, если вы следуете другому соглашению по именованию или используете новое приложение Rails со старой базой данных? Не проблема, можно просто переопределить соглашения по умолчанию.

ApplicationRecord наследуется от `ActiveRecord::Base`, который определяет ряд полезных методов. Можно использовать метод `ActiveRecord::Base.table_name=` для указания имени таблицы, которая должна быть использована:
```
class Product < ApplicationRecord
  self.table_name = "my_products"
end
```
Если так сделать, нужно вручную определить имя класса, содержащего фикстуры (my_products.yml), используя метод set_fixture_class в определении теста:
```
class ProductTest < ActiveSupport::TestCase
  set_fixture_class my_products: Product
  fixtures :my_products
  ...
end
```
Также возможно переопределить столбец, который должен быть использован как первичный ключ таблицы, с помощью метода `ActiveRecord::Base.primary_key=`:
```
class Product < ApplicationRecord
  self.primary_key = "product_id"
end
```
### CRUD: Чтение и запись данных <a name="2.1.5"></a>
CRUD это сокращение для четырех глаголов, используемых для описания операций с данными: Create (создать), Read (прочесть), Update (обновить) и Delete (удалить). Active Record автоматически создает методы, позволяющие приложению читать и воздействовать на данные, хранимые в своих таблицах.
Если предоставлен блок и `create`, и `new` передадут новый объект в этот блок для инициализации:
```
user = User.new do |u|
  u.name = "David"
  u.occupation = "Code Artist"
end
```
Возвратит первого пользователя с именем David
```
david = User.find_by(name: 'David')
```
Найдет всех пользователей с именем David, которые Code Artists, и сортирует их по created_at в обратном хронологическом порядке:
```
users = User.where(name: 'David', occupation: 'Code Artist').order(created_at: :desc)
```
<a href="http://rusrails.ru/active-record-query-interface">Подробнее в интерфейсе запросов Active Record</a>

Обновление:
```
user = User.find_by(name: 'David')
user.update(name: 'Dave')
```
Это наиболее полезно, когда необходимо обновить несколько атрибутов за раз. Если, с другой стороны, необходимо обновить несколько записей за раз, полезен метод класса update_all:
```
User.update_all "max_login_attempts = 3, must_change_password = 'true'"
```
Более того, после получения, объект Active Record может быть уничтожен, что уберет его из базы данных.
```
user = User.find_by(name: 'David')
user.destroy
```
Если необходимо удалить сразу несколько записей, можно использовать метод destroy_all:
```
# найти и удалить всех пользователей с именем David
User.where(name: 'David').destroy_all

# удалить всех пользователей
User.destroy_all
```
### Валидации <a name="2.1.6"></a>
Active Record позволяет проверять состояние модели до того, как она будет записана в базу данных.
Валидация - это очень важный вопрос, который нужно рассмотреть при сохранении в базу данных, поэтому методы `save` и `update` учитывают ее при запуске: они возвращают `false`, когда валидация проваливается, и фактически они не выполняют каких-либо операций с базой данных. Каждый из этих методов имеет пару с восклицательным знаком (`save!` и `update!`), которые строже в том, что они вызывают исключение `ActiveRecord::RecordInvalid` если валидация провалится. Краткий пример:
```
class User < ApplicationRecord
  validates :name, presence: true
end

user = User.new
user.save  # => false
user.save! # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
```
<a href="http://rusrails.ru/active-record-validations">Валидации Active record</a>
### Колбэки <a name="2.1.7"></a>
Колбэки Active Record разрешают присоединить код к определенным событиям в жизненном цикле ваших моделей. Это позволяет добавить поведение модели, прозрачно выполнив код, когда эти события произойдут, например, когда вы создадите новую запись, обновите его, удалите его и так далее. Подробнее о колбэках можно прочитать в руководстве <a href="http://rusrails.ru/active-record-callbacks">Колбэки Active Record</a>.
### Миграции <a name="2.1.8"></a>
Rails предоставляет DSL для управления схемой базы данных, называемый миграциями. Миграции хранятся в файлах, выполняемых для любой базы данных, которую **поддерживает Active Record, с использованием `rake`**. Вот миграция, создающая таблицу:
```
class CreatePublications < ActiveRecord::Migration[5.0]
  def change
    create_table :publications do |t|
      t.string :title
      t.text :description
      t.references :publication_type
      t.integer :publisher_id
      t.string :publisher_type
      t.boolean :single_issue

      t.timestamps
    end
    add_index :publications, :publication_type_id
  end
end
```
Rails отслеживает, какие файлы переданы в базу данных, и представляет возможность отката. Чтобы фактически создать таблицу, нужно запустить rails `db:migrate`, **а чтобы ее откатить rails `db:rollback`**.
> Отметьте, что вышеприведенный код не зависит от базы данных: он выполнится в MySQL, PostgreSQL, Oracle и иных. 

## Миграции Active Record <a name="2.2"></a>
Миграции - это особенность Active Record, позволяющая изменять схему вашей базы данных время от времени.
### Обзор миграций <a name="2.2.1"></a>
В базах данных, поддерживающих транзакции с выражениями, изменяющими схему, миграции оборачиваются в транзакцию. Если база данных это не поддерживает, и миграция проваливается, части, которые прошли успешно, не будут откачены назад. Вам нужно произвести откат вручную.
> Некоторые запросы не могут быть запущены в транзакции. Если ваш адаптер поддерживает транзакции DDL, можно использовать `disable_ddl_transaction!` для их отключения для отдельной миграции.

Если хотите миграцию для чего-то, что Active Record не знает, как обратить, вы можете использовать `reversible`
```
class ChangeProductsPrice < ActiveRecord::Migration[5.0]
  def change
    reversible do |dir|
      change_table :products do |t|
        dir.up   { t.change :price, :string }
        dir.down { t.change :price, :integer }
      end
    end
  end
end
```
С другой стороны, можно использовать `up` и `down` вместо `change`:
```
class ChangeProductsPrice < ActiveRecord::Migration[5.0]
  def up
    change_table :products do |t|
      t.change :price, :string
    end
  end

  def down
    change_table :products do |t|
      t.change :price, :integer
    end
  end
end
```
### Создание миграции <a name="2.2.2"></a>
#### Создание автономной миграции
Миграции хранятся как файлы в директории `db/migrate`, один файл на каждый класс. Имя файла имеет вид `YYYYMMDDHHMMSS_create_products.rb`, это означает, что временная метка UTC идентифицирует миграцию, затем идет знак подчеркивания, затем идет имя миграции, где слова разделены подчеркиваниями. Имя класса миграции содержит буквенную часть названия файла, но уже в формате `CamelCase` (т.е. слова пишутся слитно, каждое слово начинается с большой буквы). Например, `20080906120000_create_products.rb` должен определять класс `CreateProducts`, а `20080906120001_add_details_to_products.rb` должен определять `AddDetailsToProducts`. Rails использует эту метку, чтобы определить, какая миграция должна быть запущена и в каком порядке, так что если вы копируете миграции из другого приложения или генерируете файл сами, будьте более бдительны.

**Пустая миграция**:
```
rails generate migration AddPartNumberToProducts
```
Это создаст правильно названную пустую миграцию:
```
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
  end
end
```
**Обычное поле столбец**.
```
rails generate migration AddPartNumberToProducts part_number:string
или
rails generate migration AddDetailsToProducts part_number:string price:decimal
```
генерирует
```
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
  end
end

и

class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end
```
**Индекс** на новый столбец, вы можете сделать это так
```
rails generate migration AddPartNumberToProducts part_number:string:index
```
генерирует
```
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_index :products, :part_number
  end
end
```
**Удаление столбца**
```
rails generate migration RemovePartNumberFromProducts part_number:string
```
генерирует
```
class RemovePartNumberFromProducts < ActiveRecord::Migration[5.0]
  def change
    remove_column :products, :part_number, :string
  end
end
```
**Cоздание таблицы** 
```
rails generate migration CreateProducts name:string part_number:string
```
генерирует
```
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.string :part_number

      t.timestamps
    end
  end
end
```
**Столбец references** <a href="https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_reference">Документация</a>
```
rails generate migration AddUserRefToProducts user:references
```
генерирует 
```
class AddUserRefToProducts < ActiveRecord::Migration[5.0]
  def change
    add_reference :products, :user, foreign_key: true
  end
end
```
**Соединительная таблица**
```
rails generate migration CreateJoinTableCustomerProduct customer product
```
генерирует
```
class CreateJoinTableCustomerProduct < ActiveRecord::Migration[5.0]
  def change
    create_join_table :customers, :products do |t|
      # t.index [:customer_id, :product_id]
      # t.index [:product_id, :customer_id]
    end
  end
end
```
> Как всегда, то, что было сгенерировано, является всего лишь стартовой точкой. Вы можете добавлять и убирать строки, как считаете нужным, отредактировав файл `db/migrate/YYYYMMDDHHMMSS_add_details_to_products.rb`.
#### Генераторы модели
Генераторы модели и скаффолда создадут миграции, подходящие для создания новой модели.
```
rails generate model Product name:string description:text
```
-> 
```
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
```
#### Передача модификаторов
```
rails generate migration AddDetailsToProducts 'price:decimal{5,2}' supplier:references{polymorphic}
```
->
```
class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :price, :decimal, precision: 5, scale: 2
    add_reference :products, :supplier, polymorphic: true
  end
end
```
### Написание миграции <a name="2.2.3"></a>
#### Создание таблицы
По умолчанию `create_table` создаст первичный ключ, названный `id`. Вы можете изменить имя первичного ключа с помощью опции `:primary_key` (не забудьте также обновить соответствующую модель), или, если вы вообще не хотите первичный ключ, можно указать опцию `id: false`. Если нужно передать базе данных специфичные опции, вы можете поместить фрагмент SQL в опцию `:options`. Например:
```
create_table :products, options: "ENGINE=BLACKHOLE" do |t|
  t.string :name, null: false
end
```
добавит `ENGINE=BLACKHOLE` к SQL выражению, используемому для создания таблицы.
Также можно передать опцию `:comment` с любым описанием для таблицы, которое будет сохранено в самой базе данных, и может быть просмотрено с помощью инструментов администрирования базы данных
#### Создание соединительной таблицы
**Миграционный метод** `create_join_table` создает соединительную таблицу HABTM (has and belongs to many, многие ко многим).
```
create_join_table :products, :categories
```
что создаст таблицу categories_products с двумя столбцами по имени `category_id` и `product_id`. У этих столбцов есть опция `:null`, установленная в `false` по умолчанию. Это может быть переопределено опцией `:column_options:`
```
create_join_table :products, :categories, column_options: { null: true }
```

**По умолчанию**, имя соединительной таблицы получается как соединение первых двух аргументов, переданных в `create_join_table`, в алфавитном порядке. Чтобы настроить имя таблицы, передайте опцию `:table_name:`
```
create_join_table :products, :categories, table_name: :categorization
```
создает таблицу `categorization`

**По умолчанию** `create_join_table` создаст два столбца без опций, но можно определить эти опции с использованием опции `:column_options`. Например,
```
create_join_table :products, :categories, column_options: { null: true }
```
создаст `product_id` и `category_id` с опцией `:null` равной `true`.
`create_join_table` также принимает блок, который можно использовать для добавления индексов (которые по умолчанию не создаются) или дополнительных столбцов:
```
create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end
```
#### Изменение таблиц
```
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
```
удаляет столбцы `description` и `name`, создает строковый столбец `part_number` и добавляет индекс на него. Наконец, он переименовывает столбец `upccode`.
#### Изменение столбцов
```
change_column :products, :part_number, :text
```
Он меняет тип столбца `part_number` в таблице products на `:text`. Отметьте, что команда `change_column` — необратима.

**Кроме** `change_column`, методы `change_column_null` и `change_column_default` используются чтобы изменить ограничение не-null или значение столбца по умолчанию.
```
change_column_null :products, :name, false
change_column_default :products, :approved, from: true, to: false
```
Это настроит поле `:name` в products быть NOT NULL столбцом и изменит значение по умолчанию для поля `:approved` с `true` на `false`.

Также можно написать предыдущую миграцию `change_column_default` как `change_column_default :products, :approved, false`, но, в отличие от предыдущего примера, это сделало бы вашу миграцию необратимой
#### Модификаторы столбца
Модификаторы столбца могут быть применены при создании или изменении столбца:
* `limit` Устанавливает максимальный размер полей `string/text/binary/integer`.
* `precision` Определяет точность для полей `decimal`, определяющую общее количество цифр в числе.
* `scale` Определяет масштаб для полей `decimal`, определяющий количество цифр после запятой.
* `polymorphic` Добавляет столбец `type` для связей `belongs_to`.
* `null` Позволяет или запрещает значения `NULL` в столбце.
* `default` Позволяет установить значение по умолчанию для столбца. Отметьте, что если вы используете динамическое значение (такое как дату), значение по умолчанию будет вычислено лишь один раз (т.е. на дату, когда миграция будет применена).
* `comment` Добавляет комментарий для столбца.
Некоторые адаптеры могут поддерживать дополнительные опции; за подробностями обратитесь к документации API конкретных адаптеров.
> С помощью командной строки нельзя указать null и default
#### Внешние ключи
Хотя это и не требуется, вы можете захотеть добавить ограничения внешнего ключа для обеспечения ссылочной целостности.
```
add_foreign_key :articles, :authors
```
Это добавит новый внешний ключ к столбцу `author_id` таблицы `articles`. Ключ ссылается на столбец `id` таблицы `authors`. Если имена столбцов не могут быть произведены из имен таблиц, можно использовать опции `:column` и `:primary_key`.
Rails сгенерирует имя для каждого внешнего ключа, начинающееся с `fk_rails_` плюс 10 символов, которые детерминировано генерируются на основе `from_table` и `column`. Также есть опция `:name`, если хотите указать другое имя.

> Active Record поддерживает внешние ключи только для отдельных столбцов. Чтобы использовать составные внешние ключи, требуются `execute` и `structure.sql`.

**Убрать внешний ключ** также просто:
```
# позволим Active Record выяснить имя столбца
remove_foreign_key :accounts, :branches

# уберем внешний ключ для определенного столбца
remove_foreign_key :accounts, column: :owner_id

# уберем внешний ключ по имени
remove_foreign_key :accounts, name: :special_fk_name
```
#### Когда хелперов недостаточно
Если хелперов, предоставленных Active Record, недостаточно, можно использовать метод `execute` для выполнения произвольного SQL:
```
Product.connection.execute("UPDATE products SET price = 'free' WHERE 1=1")
```
Больше подробностей и примеров отдельных методов содержится в документации по API. В частности, документация для `ActiveRecord::ConnectionAdapters::SchemaStatements` (который обеспечивает методы, доступные в методах `up`, `down` и `change`), `ActiveRecord::ConnectionAdapters::TableDefinition` (который обеспечивает методы, доступные у объекта, переданного методом `create_table`) и `ActiveRecord::ConnectionAdapters::Table` (который обеспечивает методы, доступные у объекта, переданного методом `change_table`).
#### Использование метода change
Метод `change` это основной метод написания миграций. Он работает в большинстве случаев, когда `Active Record` знает, как обратить миграцию автоматически. На текущий момент метод change поддерживает только эти определения миграции:
* `add_column`
* `add_foreign_key`
* `add_index`
* `add_reference`
* `add_timestamps`
* `change_column_default` (необходимо указать опции :from и :to)
* `change_column_null`
* `create_join_table`
* `create_table`
* `disable_extension`
* `drop_join_table`
* `drop_table` (необходимо указать блок)
* `enable_extension`
* `remove_column` (необходимо указать тип)
* `remove_foreign_key` (необходимо указать вторую таблицу)
* `remove_index`
* `remove_reference`
* `remove_timestamps`
* `rename_column`
* `rename_index`
* `rename_table` 

`change_table` также является обратимым, пока блок не вызывает `change`, `change_default` или `remove`.

`remove_column` обратима, если предоставить тип столбца третьим аргументом. Также предоставьте опции оригинального столбца, иначе Rails не сможет в точности пересоздать этот столбец при откате:
```
remove_column :posts, :slug, :string, null: false, default: ''
```
**Если вы нуждаетесь в использовании иных методов**, следует использовать `reversible` или писать методы `up` и `down` вместо метода `change`.
#### Использование `reversible`
 Вы можете использовать reversible, чтобы указать что делать когда запускается миграция и когда она требует отката.
 ```
 class ExampleMigration < ActiveRecord::Migration
  def change
    create_table :distributors do |t|
      t.string :zipcode
    end

    reversible do |dir|
      dir.up do
        # добавим ограничение CHECK
        execute <<-SQL
          ALTER TABLE distributors
            ADD CONSTRAINT zipchk
              CHECK (char_length(zipcode) = 5) NO INHERIT;
        SQL
      end
      dir.down do
        execute <<-SQL
          ALTER TABLE distributors
            DROP CONSTRAINT zipchk
        SQL
      end
    end

    add_column :users, :home_page_url, :string
    rename_column :users, :email, :email_address
  end
end
```
Использование `reversible` гарантирует, что инструкции выполнятся в правильном порядке. Если предыдущий пример миграции откатывается, `down` блок начнёт выполнятся после того как столбец `home_page_url` будет удалён и перед перед тем как произойдёт удаление таблицы `distributors`.

Иногда миграция будет делать то, что просто необратимо; например, она может уничтожить некоторые данные. В таких случаях, вы можете вызвать `ActiveRecord::IrreversibleMigration` в вашем `down` блоке. Если кто-либо попытается отменить вашу миграцию, будет отображена ошибка, что это не может быть выполнено.
#### Использование методов `up/down`
По аналогии с верхним примером 
```
class ExampleMigration < ActiveRecord::Migration[5.0]
  def up
    create_table :distributors do |t|
      t.string :zipcode
    end

    #добавляем ограничение CHECK
    execute <<-SQL
      ALTER TABLE distributors
        ADD CONSTRAINT zipchk
        CHECK (char_length(zipcode) = 5);
    SQL

    add_column :users, :home_page_url, :string
    rename_column :users, :email, :email_address
  end

  def down
    rename_column :users, :email_address, :email
    remove_column :users, :home_page_url

    execute <<-SQL
      ALTER TABLE distributors
        DROP CONSTRAINT zipchk
    SQL

    drop_table :distributors
  end
end
```
#### Возвращение к предыдущим миграциям
```
require_relative '20121212123456_example_migration'

class FixupExampleMigration < ActiveRecord::Migration[5.0]
  def change
    revert ExampleMigration

    create_table(:apples) do |t|
      t.string :variety
    end
  end
end
```
Метод `revert` также может принимать блок. Это может быть полезно для отката выбранной части предыдущих миграций. Для примера, давайте представим, что `ExampleMigration` закоммичена, а позже мы решили, что было бы лучше использовать валидации `Active Record`, вместо ограничения `CHECK`, для проверки `zipcode`.
```
class DontUseConstraintForZipcodeValidationMigration < ActiveRecord::Migration[5.0]
  def change
    revert do
      reversible do |dir|
        dir.up do
          # добавим ограничение CHECK
          execute <<-SQL
            ALTER TABLE distributors
              ADD CONSTRAINT zipchk
                CHECK (char_length(zipcode) = 5);
          SQL
        end
        dir.down do
          execute <<-SQL
            ALTER TABLE distributors
              DROP CONSTRAINT zipchk
          SQL
        end
      end

      # The rest of the migration was ok
    end
  end
end
```
Подобная миграция также может быть написана без использования `revert`, но это бы привело к ещё нескольким шагам: изменение порядка (следования) `create table` и `reversible`, замена `create_table` на `drop_table` и в конечном итоге изменение `up` на `down` и наоборот. Обо всём этом уже позаботился `revert`.

> Если необходимо добавить ограничения `CHECK`, как в вышеуказанных примерах, нужно использовать `structure.sql` в качестве метода для выгрузки.
### Запуск миграций <a name="2.2.4"></a>
`rails db:migrate` запускает метод `change` или `up` для всех миграций, которые еще не были запущены. 3апуск команды `db:migrate` также вызывает команду `db:schema:dump`, которая обновляет ваш файл `db/schema.rb` в соответствии со структурой вашей базы данных.
Если вы определите целевую версию, `Active Record` запустит требуемые миграции (методы `up`, `down` или `change`), пока не достигнет требуемой версии. Версия это числовой префикс у файла миграции. Например, чтобы мигрировать к версии `20080906120000`, запустите:
```
$ rails db:migrate VERSION=20080906120000
```
Если миграция назад, это запустит метод `down` для всех миграций до, но не включая, `20080906120000`.
#### Откат
```
$ rails db:rollback
```
Если нужно отменить несколько миграций, можно указать параметр `STEP`:
```
$ rails db:rollback STEP=3
```
Команда `db:migrate:redo` это ярлык для выполнения отката, а затем запуска миграции снова.
```
rails db:migrate:redo STEP=3
```
#### Установка базы данных
Команда `rails db:setup` создаст базу данных, загрузит схему и инициализирует ее с помощью данных `seed`.
#### Сброс базы данных
Команда `rails db:reset` удалит базу данных и установит ее заново. Функционально это эквивалентно `rails db:drop db:setup`.
> Это не то же самое, что запуск всех миграций. Будет использовано только текущее содержимое файла `db/schema.rb` или `db/structure.sql`. Если миграцию откатить невозможно, `rails db:reset` может не помочь вам.
#### Запуск определенных миграций
Если необходимо запустить определённую миграцию вверх или вниз, это делают команды `db:migrate:up` и `db:migrate:down`. Просто укажите подходящую версию и у соответствующей миграции будет вызван метод `change`, `up` или `down`, например:
```
$ rails db:migrate:up VERSION=20080906120000
```
#### Запуск миграций в различных средах
По умолчанию запуск `rails db:migrate` запустится в окружении `development`.
```
rails db:migrate RAILS_ENV=test
```
#### Изменение вывода результата запущенных миграций
Метод             |	Назначение
------------------|---------------
suppress_messages | Принимает блок как аргумент и запрещает любой вывод, сгенерированный этим блоком.
say 	            | Принимает сообщение как аргумент и выводит его как есть. Может быть передан второй булевый аргумент для указания, нужен отступ или нет.
say_with_time     | Выводит текст вместе с продолжительностью выполнения блока. Если блок возвращает число, предполагается, что это количество затронутых строк.

Например, эта миграция:
```
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end

    say "Created a table"

    suppress_messages {add_index :products, :name}
    say "and an index!", true

    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end
end
```
сгенерирует следующий результат
```
==  CreateProducts: migrating =================================================
-- Created a table
   -> and an index!
-- Waiting for a while
   -> 10.0013s
   -> 250 rows
==  CreateProducts: migrated (10.0054s) =======================================
```
Если хотите, чтобы Active Record ничего не выводил, запуск `rails db:migrate VERBOSE=false` запретит любой вывод.

### Изменение существующих миграций <a name="2.2.5"></a>
Периодически вы будете делать ошибки при написании миграции. Если вы уже запустили миграцию, вы не сможете просто отредактировать миграцию и запустить ее снова: Rails посчитает, что он уже выполнял миграцию, и ничего не сделает при запуске `rails db:migrate`. Вы должны откатить миграцию (например, с помощью `rails db:rollback`), отредактировать миграцию и затем запустить `rails db:migrate` для запуска исправленной версии.

В целом, редактирование существующих миграций не хорошая идея. Вы создадите дополнительную работу себе и своим коллегам, и вызовете море головной боли, если существующая версия миграции уже была запущена в `production`. Вместо этого, следует написать новую миграцию, выполняющую требуемые изменения. Редактирование только что сгенерированные миграции, которая еще не была закоммичена в систему контроля версий (или, хотя бы, не ушла дальше вашей рабочей машины) относительно безвредно.

Метод `revert` может быть очень полезным при написании новой миграции для возвращения предыдущей в целом или какой то части.

### Выгрузка схемы <a name="2.2.6"></a>
#### Для чего нужны файлы схемы?
Миграции, какими бы не были они мощными, не являются авторитетным источником для схемы базы данных. База данных остается авторитетным источником. По умолчанию Rails генерирует `db/schema.rb`, которая пытается охватить текущее состояние схемы базы данных.

Она имеет тенденцию быть более быстрой и менее подверженной ошибкам, связанным с созданием нового экземпляра базы данных приложения, загружая файл схемы через `rails db:schema:load`, чем при повторном воспроизведении всей истории миграций. Старые миграции могут работать неправильно, если эти миграции используют изменения внешних зависимостей или полагаются на код приложения, который развивается отдельно от этих миграций.

Файлы схемы также полезны, если необходимо быстро посмотреть, какие атрибуты есть у объекта Active Record. Эта информация не содержится в коде модели и часто распределена по нескольким миграциям, но собрана воедино в файле схемы.
#### Типы выгрузок схемы
Формат выгрузки схемы, сгенерированный Rails, управляется настройкой `config.active_record.schema_format` в `config/application.rb`. Форматом по умолчанию является `:ruby`, но также он может быть установлен в `:sql`.

Если выбрано `:ruby`, тогда схема хранится в `db/schema.rb`. Посмотрев в этот файл, можно увидеть, что он очень похож на одну большую миграцию:
```
ActiveRecord::Schema.define(version: 2008_09_06_171750) do
  create_table "authors", force: true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  create_table "products", force: true do |t|
    t.string   "name"
    t.text     "description"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "part_number"
  end
end
```
Во многих случаях этого достаточно. Этот файл создается путем проверки базы данных и описывает свою структуру, используя `create_table`, `add_index` и так далее.

`db/schema.rb` не может описать все, что может поддерживать база данных, например триггеры, последовательности, хранимые процедуры, ограничения `CHECK` и так далее. Отметьте, в то время как в миграциях можно выполнить произвольные выражения SQL, эти выражения не смогут быть воспроизведены выгрузчиком схемы. Если используете подобные особенности, необходимо установить формат схемы как `:sql`, чтобы получить точный файл схемы, который будет полезен для создания новых экземпляров базы данных.

Когда формат схемы установлен в `:sql`, структура базы данных будет выгружена с помощью инструмента, предназначенного для этой базы данных в `db/structure.sql`. Например, для PostgreSQL используется утилита `pg_dump`. Для MySQL и MariaDB этот файл будет содержать результат SHOW CREATE TABLE для разных таблиц.

Чтобы загрузить схему из `db/structure.sql`, запустите `rails db:structure:load`. Загрузка этого файла осуществляется путем выполнения содержащихся в нем выражений SQL. По определению создастся точная копия структуры базы данных.
#### Выгрузки схем и управление версиями
Поскольку файлы схемы обычно используются для создания новых баз данных, настоятельно рекомендуется проверять файл схемы в системе управления версиями.

Конфликты слияния могут возникать в файле схемы, когда две ветки модифицируют схему. Для разрешения этих конфликтов, запустите `rails db:migrate`, чтобы восстановить файл схемы.
### Active Record и ссылочная целостность <a name="2.2.7"></a>
Способ Active Record требует, чтобы логика была в моделях, а не в базе данных. По большому счету, функции, такие как триггеры или ограничения, которые переносят часть логики обратно в базу данных, не используются активно.

Валидации, такие как `validates :foreign_key, uniqueness: true`, это один из способов, которым ваши модели могут соблюдать ссылочную целостность. Опция :dependent в связях позволяет моделям автоматически уничтожать дочерние объекты при уничтожении родителя. Подобно всему, что работает на уровне приложения, это не может гарантировать ссылочной целостности, таким образом кто-то может добавить еще и внешние ключи как ограничители ссылочной целостности в базе данных.

Хотя Active Record не предоставляет каких-либо инструментов для работы напрямую с этими функциями, метод `execute` может использоваться для выполнения произвольного SQL.
### Миграции и сиды <a name="2.2.8"></a>
Основным назначением миграции Rails является запуск команд, последовательно модифицирующих схему. Миграции также могут быть использованы для добавления или модифицирования данных. Это полезно для существующей базы данных, которую нельзя удалить и пересоздать, такой как база данных на `production`.
```
class AddInitialProducts < ActiveRecord::Migration[5.0]
  def up
    5.times do |i|
      Product.create(name: "Product ##{i}", description: "A product.")
    end
  end

  def down
    Product.delete_all
  end
end
```
Чтобы добавить изначальные данные в базу данных после создания, в Rails имеется встроенная особенность 'seeds', которая делает процесс быстрым и простым. Это особенно полезно при частой перезагрузке базы данных в средах разработки и тестирования. Этой особенностью легко начать пользоваться: просто заполните `db/seeds.rb` некоторым кодом Ruby и запустите `rails db:seed`:
```
5.times do |i|
  Product.create(name: "Product ##{i}", description: "A product.")
end
```
В основном, это более чистый способ настроить базу данных для пустого приложения.
### Старые миграции <a name="2.2.9"></a>
`db/schema.rb` или `db/structure.sql` это снимок текущего состояния вашей базы данных и авторитетный источник для восстановления этой базы данных. Поэтому возможно удалить старые файлы миграций.

Когда вы удалите файлы миграций в директории `db/migrate/`, любая среда, в которой `rails db:migrate` была запущена, когда эти файлы еще существовали, будет хранить ссылки на временные метки миграций во внутренней таблице Rails по имени `schema_migrations`. Эта таблица используется для отслеживания, была ли миграция выполнена в указанной среде.

Если вы запустите команду `rails db:migrate:status`, которая отображает статус (`up` или `down`) каждой миграции, вы увидите `********** NO FILE **********`, отображенный рядом с каждым удаленным файлом миграции, который однажды был запущен в указанной среде, но больше не найден в директории db/migrate/.
## Валидации <a name="2.3"></a>
### Обзор валидаций <a name="2.3.1"></a>
```
class Person < ApplicationRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false
```
#### Зачем использовать валидации?
Есть несколько способов валидации данных, прежде чем они будут сохранены в вашу базу данных, включая ограничения, встроенные в базу данных, валидации на клиентской части и валидации на уровне контроллера. Вкратце о плюсах и минусах:
* Ограничения базы данных и/или хранимые процедуры делают механизмы валидации зависимыми от базы данных, что делает тестирование и поддержку более трудными. Однако, если ваша база данных используется другими приложениями, валидация на уровне базы данных может безопасно обрабатывать некоторые вещи (такие как уникальность в нагруженных таблицах), которые затруднительно выполнять по-другому.
* Валидации на клиентской части могут быть очень полезны, но в целом ненадежны, если используются в одиночку. Если они используют JavaScript, они могут быть пропущены, если JavaScript отключен в клиентском браузере. Однако, если этот способ комбинировать с другими, валидации на клиентской части могут быть удобным способом предоставить пользователям немедленную обратную связь при использовании вашего сайта.
* Валидации на уровне контроллера заманчиво делать, но это часто приводит к громоздкости и трудности тестирования и поддержки. Во всех случаях, когда это возможно, держите свои контроллеры 'тощими', тогда с вашим приложением будет приятно работать в долгосрочной перспективе. 

Выбирайте их под свои определенные специфичные задачи. Общее мнение команды Rails состоит в том, что валидации на уровне модели - наиболее подходящий вариант во многих случаях.
#### Когда происходит валидация?
Создание и сохранение новой записи посылает операцию `SQL INSERT` базе данных. Обновление существующей записи вместо этого посылает операцию `SQL UPDATE`. Валидации обычно запускаются до того, как эти команды посылаются базе данных. Если любая из валидаций проваливается, объект помечается как недействительный и Active Record не выполняет операцию `INSERT` или `UPDATE`. Это помогает избежать хранения невалидного объекта в базе данных. Можно выбирать запуск специфичных валидаций, когда объект создается, сохраняется или обновляется.

Есть разные методы изменения состояния объекта в базе данных. Некоторые методы вызывают валидации, некоторые нет. Это означает, что возможно сохранить в базу данных объект с недействительным статусом, если вы будете не внимательны.

Следующие методы вызывают валидацию, и сохраняют объект в базу данных только если он валиден:
* `create`
* `create!`
* `save`
* `save!`
* `update`
* `update!`

Версии с восклицательным знаком (т.е. `save!`) **вызывают исключение**, если запись недействительна. Невосклицательные версии не вызывают: `save` и `update` возвращают `false`, `create` **возвращает объект**.
#### Пропуск валидаций
Следующие методы пропускают валидации, и сохраняют объект в базу данных, независимо от его валидности. Их нужно использовать осторожно.
* `decrement!`
* `decrement_counter`
* `increment!`
* `increment_counter`
* `toggle!`
* `touch`
* `update_all`
* `update_attribute`
* `update_column`
* `update_columns`
* `update_counters`

Заметьте, что `save` также имеет способность пропустить валидации, если передать `validate: false` как аргумент. Этот способ нужно использовать осторожно.
```
save(validate: false) 
```
#### `valid?` или `invalid?`
Вы также можете запускать эти валидации самостоятельно. `valid?` вызывает ваши валидации и возвращает `true`, если ни одной ошибки не было найдено у объекта, иначе `false`.
```
class Person < ApplicationRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false
```
После того, как Active Record выполнит валидации, все найденные ошибки будут доступны в методе экземпляра `errors.messages`, возвращающем коллекцию ошибок.
`invalid?` это просто антипод `valid?`.
#### `errors[]`
Чтобы проверить, является или нет конкретный атрибут объекта валидным, можно использовать `errors[:attribute]`, который возвращает массив со всеми ошибками атрибута, когда нет ошибок по определенному атрибуту, возвращается пустой массив.
#### `errors.details`
Чтобы проверить, какие валидации упали на невалидном атрибуте, можно использовать `errors.details[:attribute]`. Он возвращает массив хэшей с ключом `:error`, чтобы получить символ валидатора:
```
class Person < ApplicationRecord
  validates :name, presence: true
end

>> person = Person.new
>> person.valid?
>> person.errors.details[:name] # => [{error: :blank}]
```
### Валидационные хелперы <a name="2.3.2"></a>
Каждый хелпер принимает произвольное количество имен атрибутов, поэтому в одной строчке кода можно добавить валидации одинакового вида для нескольких атрибутов.

Они все принимают опции `:on` и `:message`, которые определяют, когда валидация должна быть запущена, и какое сообщение должно быть добавлено в коллекцию `errors`, если она провалится. Опция `:on` принимает одно из значений `:create` или `:update`. Для каждого валидационного хелпера есть свое сообщение об ошибке по умолчанию. Эти сообщения используются, если не определена опция `:message`.
#### `acceptance`
Этот метод проверяет, что чекбокс в пользовательском интерфейсе был нажат, когда форма была подтверждена.
```
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: true
end
```
Эта проверка выполнится, только если `terms_of_service` не `nil`.
Можно передать произвольное сообщение с помощью опции `message`.
```
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: { message: 'must be abided' }
end
```
Также он может получать опцию `:accept`, которая определяет допустимые значения, которые будут считаться принятыми. По умолчанию это "1", но его можно изменить.
```
class Person < ApplicationRecord
  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }
end
```
Эта валидация очень специфична для веб-приложений, и ее принятие не нужно записывать куда-либо в базу данных. Если у вас нет поля для него, хелпер всего лишь создаст виртуальный атрибут. Если поле существует в базе данных, опция `accept` должна быть установлена или включать `true`, а иначе эта валидация не будет выполнена.
#### `validates_associated`
Этот хелпер можно использовать, когда у вашей модели есть связи с другими моделями, и их также нужно проверить на валидность. Когда вы пытаетесь сохранить свой объект, будет вызван метод `valid?` для каждого из связанных объектов.
```
class Library < ApplicationRecord
  has_many :books
  validates_associated :books
end
```
Эта валидация работает со всеми типами связей.

> Не используйте `validates_associated` на обоих концах ваших связей, они будут вызывать друг друга в бесконечном цикле.

Для `validates_associated` сообщение об ошибке по умолчанию следующее "is invalid". Заметьте, что каждый связанный объект имеет свою собственную коллекцию `errors`; ошибки не добавляются к вызывающей модели.
#### `confirmation`
Этот хелпер можно использовать, если у вас есть два текстовых поля, из которых нужно получить полностью идентичное содержание.
Например, вы хотите подтверждение адреса электронной почты или пароля. Эта валидация создает виртуальный атрибут, имя которого равно имени подтверждаемого поля с добавлением "confirmation".
```
class Person < ApplicationRecord
  validates :email, confirmation: true
end
```
В вашем шаблоне вьюхи нужно использовать что-то вроде этого:
```
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
```
Эта проверка выполняется, только если `email_confirmation` не равно `nil`. Чтобы требовать подтверждение, нужно добавить еще проверку на существование проверяемого атрибута (мы рассмотрим presence чуть позже):
```
class Person < ApplicationRecord
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end
```
Также имеется опция `:case_sensitive`, которую используют, чтобы определить, должно ли ограничение подтверждения быть чувствительным к регистру. Эта опция по умолчанию `true`.
```
class Person < ApplicationRecord
  validates :email, confirmation: { case_sensitive: false }
end
```
#### `exclusion`
Этот хелпер проводит валидацию того, что значения атрибутов не включены в указанный набор. Фактически, этот набор может быть любым перечисляемым объектом.
```
class Account < ApplicationRecord
  validates :subdomain, exclusion: { in: %w(www us ca jp),
    message: "%{value} is reserved." }
end
```
Хелпер exclusion имеет опцию `:in`, которая получает набор значений, которые не должны приниматься проверяемыми атрибутами. Опция `:in` имеет псевдоним `:within`, который используется для тех же целей. Этот пример использует опцию `:message`, чтобы показать вам, как можно включать значение атрибута.
#### `format`
Этот хелпер проводит валидацию значений атрибутов, тестируя их на соответствие указанному регулярному выражению, которое определяется с помощью опции `:with`.
```
class Product < ApplicationRecord
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,
    message: "only allows letters" }
end
```
В качестве альтернативы можно потребовать, чтобы указанный атрибут не соответствовал регулярному выражению, используя опцию `:without`.
#### `inclusion`
Этот хелпер проводит валидацию значений атрибутов на включение в указанный набор. Фактически этот набор может быть любым перечисляемым объектом.
```
class Coffee < ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }
end
```
#### `length`
```
class Person < ApplicationRecord
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end
```
Возможные опции ограничения длины такие:
* `:minimum` - атрибут не может быть меньше определенной длины.
* `:maximum` - атрибут не может быть больше определенной длины.
* `:in` (или `:within`) - длина атрибута должна находиться в указанном интервале. Значение этой опции должно быть интервалом.
* `:is` - длина атрибута должна быть равной указанному значению. 

Значение сообщения об ошибке по умолчанию зависит от типа выполняемой валидации длины. Можно переопределить эти сообщения, используя опции `:wrong_length`, `:too_long` и `:too_short`, и `%{count}` как местозаполнитель (placeholder) числа, соответствующего длине используемого ограничения. Можете использовать опцию `:message` для определения сообщения об ошибке.
```
class Person < ApplicationRecord
  validates :bio, length: { maximum: 1000,
    too_long: "%{count} characters is the maximum allowed" }
end
```
Отметьте, что сообщения об ошибке по умолчанию во множественном числе (т.е., "is too short (minimum is %{count} characters)"). По этой причине, когда `:minimum` равно 1, следует предоставить собственное сообщение или использовать вместо него `presence: true`. Когда `:in` или `:within` имеют как нижнюю границу 1, следует или предоставить собственное сообщение, или вызвать `presence` перед `length`.
#### `numericality`
Этот хелпер проводит валидацию того, что ваши атрибуты имеют только числовые значения. По умолчанию, этому будет соответствовать возможный знак первым символом, и следующее за ним целочисленное или с плавающей запятой число. Чтобы определить, что допустимы только целочисленные значения, установите `:only_integer` в `true`.

Если установить `:only_integer` в `true`, тогда будет использоваться регулярное выражение
```
/\A[+-]?\d+\z/
```
для проведения валидации значения атрибута. В противном случае, он будет пытаться конвертировать значение в число, используя `Float`.
```
class Player < ApplicationRecord
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
end
```

Кроме `:only_integer`, хелпер `validates_numericality_of` также принимает следующие опции для добавления ограничений к приемлемым значениям:
* `:greater_than` - определяет, что значение должно быть больше, чем значение опции.
* `:greater_than_or_equal_to` - определяет, что значение должно быть больше или равно значению опции.
* `:equal_to` - определяет, что значение должно быть равно значению опции.
* `:less_than` - определяет, что значение должно быть меньше, чем значение опции. 
* `:less_than_or_equal_to` - определяет, что значение должно быть меньше или равно значению опции.
* `:other_than` - определяет, что значение должно отличаться от представленного значения.
* `:odd` - определяет, что значение должно быть нечетным, если установлено true.
* `:even` - определяет, что значение должно быть четным, если установлено true.

> По умолчанию `numericality` не допускает значения `nil`. Чтобы их разрешить, можно использовать опцию `allow_nil: true`.
#### `presence`
Этот хелпер проводит валидацию того, что определенные атрибуты не пустые. Он использует метод `blank?` для проверки того, является ли значение или `nil`, или пустой строкой (это строка, которая или пуста, или состоит из пробелов).
```
class Person < ApplicationRecord
  validates :name, :login, :email, presence: true
end
```
Если хотите быть уверенным, **что связь существует**, нужно проверить, существует ли сам связанный объект, а не внешний ключ, используемый для связи.
```
class LineItem < ApplicationRecord
  belongs_to :order
  validates :order, presence: true
end
```
Для того, чтобы **проверять связанные записи**, чье присутствие необходимо, нужно определить опцию `:inverse_of` для связи:
```
class Order < ApplicationRecord
  has_many :line_items, inverse_of: :order
end
```
При проведении валидации существования объекта, связанного отношением `has_one` или `has_many`, будет проверено, что объект ни `blank?`, ни `marked_for_destruction?`.

Так как `false.blank?` это `true`, если хотите **провести валидацию существования булева поля**, нужно использовать одну из следующих валидаций:
```
validates :boolean_field_name, inclusion: { in: [true, false] }
validates :boolean_field_name, exclusion: { in: [nil] }
```
При использовании одной из этих валидаций, вы можете быть уверены, что значение не будет `nil`, которое в большинстве случаев преобразуется в `NULL` значение.
#### `absence`
Этот хелпер проверяет, что указанные атрибуты отсутствуют. Он использует метод `present?` для проверки, что значение является либо `nil`, либо пустой строкой (то есть либо нулевой длины, либо состоящей из пробелов).
```
class Person < ApplicationRecord
  validates :name, :login, :email, absence: true
end
```
Если хотите **убедиться, что отсутствует связь**, необходимо проверить, что отсутствует сам связанный объект, а не внешний ключ, используемый для связи.
```
class LineItem < ApplicationRecord
  belongs_to :order
  validates :order, absence: true
end
```
Чтобы проверять связанные объекты, отсутствие которых требуется, для связи необходимо указать опцию `:inverse_of`:
```
class Order < ApplicationRecord
  has_many :line_items, inverse_of: :order
end
```
Если проверяете отсутствие объекта, связанного отношением `has_one` или `has_many`, он проверит, что объект и не `present?`, и не `marked_for_destruction?`.

Поскольку `false.present?` является `false`, если хотите проверить отсутствие булева поля, следует использовать `validates :field_name, exclusion: { in: [true, false] }`
#### `uniqueness`
Этот хелпер проводит валидацию того, что значение атрибута уникально, перед тем, как объект будет сохранен. Он не создает условие уникальности в базе данных, следовательно, может произойти так, что два разных подключения к базе данных создадут две записи с одинаковым значением для столбца, который вы подразумеваете уникальным. Чтобы этого избежать, нужно создать индекс `unique` на оба столбцах в вашей базе данных.
```
class Account < ApplicationRecord
  validates :email, uniqueness: true
end
```
Валидация производится путем SQL-запроса в таблицу модели, поиска существующей записи с тем же значением атрибута.

Имеется опция `:scope`, которую можно использовать для определения одного и более атрибутов, используемых для ограничения проверки уникальности:
```
class Holiday < ApplicationRecord
  validates :name, uniqueness: { scope: :year,
    message: "should happen once per year" }
end
```
Если хотите создать ограничение на уровне базы данных, чтобы предотвратить возможные нарушения валидации уникальности с помощью опции `:scope`, необходимо создать индекс уникальности на обоих столбцах базы данных.
Также имеется опция `:case_sensitive`, которой можно определить, будет ли ограничение уникальности чувствительно к регистру или нет. Опция по умолчанию равна `true`.
```
class Person < ApplicationRecord
  validates :name, uniqueness: { case_sensitive: false }
end
```
> Отметьте, что некоторые базы данных настроены на выполнение чувствительного к регистру поиска в любом случае.
#### `validates_with`
```
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end

class Person < ApplicationRecord
  validates_with GoodnessValidator
end
```
> Ошибки, добавляемые в `record.errors[:base]` относятся к состоянию записи в целом, а не к определенному атрибуту.
Хелпер `validates_with` принимает класс или список классов для использования в валидации. Для `validates_with` нет сообщения об ошибке по умолчанию. Следует вручную добавлять ошибки в коллекцию errors записи в классе валидатора.

Для применения метода validate, необходимо иметь определенным параметр record, который является записью, проходящей валидацию.

Подобно всем другим валидациям, `validates_with` принимает опции `:if`, `:unless` и `:on`. Если передадите любые другие опции, они будут переданы в класс валидатора как `options`:
```
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end

class Person < ApplicationRecord
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
end
```
Отметьте, что валидатор будет инициализирован только один раз на протяжении всего жизненного цикла приложения, а не при каждом запуске валидации, поэтому будьте аккуратнее с использованием переменных экземпляра в нем.

Если ваш валидатор настолько сложный, что вы хотите использовать переменные экземпляра, вместо него проще использовать обычные объекты Ruby:
```
class Person < ApplicationRecord
  validate do |person|
    GoodnessValidator.new(person).validate
  end
end

class GoodnessValidator
  def initialize(person)
    @person = person
  end

  def validate
    if some_complex_condition_involving_ivars_and_private_methods?
      @person.errors[:base] << "This person is evil"
    end
  end

  # ...
end
```
#### `validates_each`
Этот хелпер помогает провести валидацию атрибутов с помощью блока кода. Он не имеет предопределенной валидационной функции. Вы должны создать ее, используя блок, и каждый атрибут, указанный в `validates_each`, будет протестирован в нем. В следующем примере нам не нужны имена и фамилии, начинающиеся с маленькой буквы.
```
class Person < ApplicationRecord
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[[:lower:]]/
  end
end
```
Блок получает запись, имя атрибута и значение атрибута. Вы можете делать что угодно для проверки валидности данных внутри блока. Если валидация проваливается, следует добавить сообщение об ошибке в модель, которое делает ее невалидной.
### Общие опции валидаций <a name="2.3.3"></a>
#### `:allow_nil`
Опция `:allow_nil` пропускает валидацию, когда проверяемое значение равно `nil`.
```
class Coffee < ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }, allow_nil: true
end
```
#### `:allow_blank`

Опция `:allow_blank` подобна опции `:allow_nil`. Эта опция пропускает валидацию, если значение атрибута `blank?`, например `nil` или пустая строка.
```
class Topic < ApplicationRecord
  validates :title, length: { is: 5 }, allow_blank: true
end

Topic.create(title: "").valid?  # => true
Topic.create(title: nil).valid? # => true
```
#### `:message`
Значение `String` в `:message` может опционально содержать любые из `%{value}`, `%{attribute}` и `%{model}`, которые будут динамически заменены, когда валидация провалится. Эта замена выполняется, если используется гем `I18n`, и местозаполнитель должен полностью совпадать, пробелы не допускаются.

Значение `Proc` в `:message` задается с двумя аргументами: проверяемым объектом и хэшем с ключами `:model`, `:attribute` и `:value`.
```
class Person < ApplicationRecord
  # Жестко закодированное сообщение
  validates :name, presence: { message: "must be given please" }

  # Сообщение со значением с динамическим атрибутом. %{value} будет заменено
  # фактическим значением атрибута. Также доступны %{attribute} и %{model}.
  validates :age, numericality: { message: "%{value} seems wrong" }

  # Proc
  validates :username,
    uniqueness: {
      # object = person object being validated
      # data = { model: "Person", attribute: "Username", value: <username> }
      message: ->(object, data) do
        "Hey #{object.name}!, #{data[:value]} is taken already! Try again #{Time.zone.tomorrow}"
      end
    }
end
```
#### `:on`
Используйте `on: :create`, для запуска валидации только когда создается новая запись, или `on: :update`, для запуска валидации когда запись обновляется.
```
class Person < ApplicationRecord
  # будет возможно обновить email с дублирующим значением
  validates :email, uniqueness: true, on: :create

  # будет возможно создать запись с нечисловым возрастом
  validates :age, numericality: true, on: :update

  # по умолчанию (проверяет и при создании, и при обновлении)
  validates :name, presence: true
end
```
`on:` также можно использовать для **определения пользовательского контекста**. Пользовательские контексты должны быть явно включены с помощью передачи имени контекста в `valid?`, `invalid?` или `save`.
```
class Person < ApplicationRecord
  validates :email, uniqueness: true, on: :account_setup
  validates :age, numericality: true, on: :account_setup
end

person = Person.new
```
`person.valid?(:account_setup)` выполнит обе валидации без сохранения модели. И `person.save(context: :account_setup)` перед сохранением валидирует `person` в контексте `account_setup`. При явном включении модель валидируется только валидациями только этого контекста и валидациями без контекста.

### Строгие валидации <a name="2.3.4"></a>
Также можно определить валидации строгими, чтобы они вызывали `ActiveModel::StrictValidationFailed`, когда объект невалиден.
```
class Person < ApplicationRecord
  validates :name, presence: { strict: true }
end

Person.new.valid?  # => ActiveModel::StrictValidationFailed: Name can't be blank
```
Также возможно передать собственное исключение в опцию `:strict`.
```
class Person < ApplicationRecord
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
end

Person.new.valid?  # => TokenGenerationException: Token can't be blank
```
### Условная валидация <a name="2.3.5"></a>
#### Использование символа с `:if` и `:unless`
```
class Order < ApplicationRecord
  validates :card_number, presence: true, if: :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end
```
#### Использование `Proc` с `:if` и `:unless`
Использование объекта `Proc` дает возможность написать встроенное условие вместо отдельного метода. Этот вариант лучше всего подходит для однострочного кода.
```
class Account < ApplicationRecord
  validates :password, confirmation: true,
    unless: Proc.new { |a| a.password.blank? }
end
```
#### Группировка условных валидаций `with_options`
```
class User < ApplicationRecord
  with_options if: :is_admin? do |admin|
    admin.validates :password, length: { minimum: 10 }
    admin.validates :email, presence: true
  end
end
````
Во все валидации внутри `with_options` будет автоматически передано условие `if: :is_admin?`
#### Объединение условий валидации
С другой стороны, может использоваться массив, когда несколько условий определяют, должна ли произойти валидация. Более того, в одной и той же валидации можно применить и `:if:`, и `:unless`.
```
class Computer < ApplicationRecord
  validates :mouse, presence: true,
                    if: [Proc.new { |c| c.market.retail? }, :desktop?],
                    unless: Proc.new { |c| c.trackpad.present? }
end
```
Валидация выполнится только тогда, когда все условия `:if` и ни одно из условий `:unless` будут вычислены со значением `true`.
### Выполнение собственных валидаций <a name="2.3.6"></a>
#### Собственные валидаторы
Собственные валидаторы это классы, наследуемые от `ActiveModel::Validator`. Эти классы должны реализовать метод `validate`, принимающий запись как аргумент и выполняющий валидацию на ней. Собственный валидатор вызывается с использованием метода `validates_with`
```
class MyValidator < ActiveModel::Validator
  def validate(record)
    unless record.name.starts_with? 'X'
      record.errors[:name] << 'Need a name starting with X please!'
    end
  end
end
 
class Person
  include ActiveModel::Validations
  validates_with MyValidator
end
```
Простейшим способом добавить собственные валидаторы для валидации отдельных атрибутов является наследуемость от `ActiveModel::EachValidator`. В этом случае класс собственного валидатора должен реализовать метод `validate_each`, принимающий три аргумента: запись, атрибут и значение. Это будут соответствующие экземпляр, атрибут, который будет проверяться и значение атрибута в переданном экземпляре:
```
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)`[a-z]{2,})\z/i
      record.errors[attribute] << (options[:message] || "is not an email")
    end
  end
end

class Person < ApplicationRecord
  validates :email, presence: true, email: true
end
```
Как показано в примере, можно объединять стандартные валидации со своими произвольными валидаторами.
#### Собственные методы
Метод `valid?` проверит, что коллекция ошибок пуста. поэтому ваши собственные методы валидации должны добавить ошибки в нее, когда вы хотите, чтобы валидация провалилась:
```
class Invoice < ApplicationRecord
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    if expiration_date.present? && expiration_date < Date.today
      errors.add(:expiration_date, "can't be in the past")
    end
  end

  def discount_cannot_be_greater_than_total_value
    errors.add(:discount, "can't be greater than total value") if
      discount > total_value
  end
end
```
По умолчанию такие валидации будут выполнены каждый раз при вызове `valid?` или сохранении объекта. Но также возможно контролировать, когда выполнять собственные валидации, передав опцию `:on` в метод `validate`, с ключами: `:create` или `:update`.
```
class Invoice < ApplicationRecord
  validate :active_customer, on: :create

  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
  end
end
```
### Работаем с ошибками валидации <a name="2.3.7"></a>
#### `errors`
Возвращает экземпляр класса `ActiveModel::Errors`, содержащий все ошибки. Каждый ключ это имя атрибута и значение это массив строк со всеми ошибками.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors.messages
 # => {:name=>["can't be blank", "is too short (minimum is 3 characters)"]}

person = Person.new(name: "John Doe")
person.valid? # => true
person.errors.messages # => []
```
#### `errors[]`
Он возвращает массив строк со всеми сообщениями об ошибке для заданного атрибута, каждая строка с одним сообщением об ошибке. Если нет ошибок, относящихся к атрибуту, возвратится пустой массив.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new(name: "John Doe")
person.valid? # => true
person.errors[:name] # => []

person = Person.new(name: "JD")
person.valid? # => false
person.errors[:name] # => ["is too short (minimum is 3 characters)"]

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
```
#### `errors.add`
Метод add позволяет добавлять сообщение об ошибке, относящейся к определенному атрибуту. Он принимает в качестве аргументов атрибут и сообщение об ошибке.

Метод `errors.full_messages` (или его эквивалент `errors.to_a`) возвращает сообщения об ошибках в дружелюбном формате с именем атрибута с прописной буквы, предшествующим каждому сообщению, как показано в следующем примере.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
  end
end

person = Person.create(name: "!@#")

person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]

person.errors.full_messages
 # => ["Name cannot contain the characters !@#%*()_-+="]
```
Эквивалентом `errors#add` является использование `<<` для добавления сообщения к массиву `errors.messages` атрибута:
```
  class Person < ApplicationRecord
    def a_method_used_for_validation_purposes
      errors.messages[:name] << "cannot contain the characters !@#%*()_-+="
    end
  end

  person = Person.create(name: "!@#")

  person.errors[:name]
   # => ["cannot contain the characters !@#%*()_-+="]

  person.errors.to_a
   # => ["Name cannot contain the characters !@#%*()_-+="]
```
#### `errors.details`
Можно указать тип валидатора в возвращаемом хэше подробностей об ошибке `detail` с помощью метода `errors.add`.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors.add(:name, :invalid_characters)
  end
end

person = Person.create(name: "!@#")

person.errors.details[:name]
# => [{error: :invalid_characters}]
```
Чтобы расширить хэш подробностей об ошибке `details`, добавив, к примеру, недопустимые символы, можно передать дополнительные ключи в `errors.add`.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors.add(:name, :invalid_characters, not_allowed: "!@#%*()_-+=")
  end
end

person = Person.create(name: "!@#")

person.errors.details[:name]
# => [{error: :invalid_characters, not_allowed: "!@#%*()_-+="}]
```
Все встроенные в Rails валидаторы заполняют хэш details соответствующим типом валидатора.
#### `errors[:base]`
Можете добавлять сообщения об ошибках, которые относятся к состоянию объекта в целом, а не к отдельному атрибуту. Этот метод можно использовать, если вы хотите сказать, что объект невалиден, независимо от значений его атрибутов. Поскольку `errors[:base]` массив, можете просто добавить строку к нему, и она будет использована как сообщение об ошибке.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors[:base] << "This person is invalid because ..."
  end
end
```
#### `errors.clear`
Метод `clear` используется, когда вы намеренно хотите очистить все сообщения в коллекции errors. Естественно, вызов `errors.clear` для невалидного объекта фактически не сделает его валидным: сейчас коллекция `errors` будет пуста, но в следующий раз, когда вы вызовете `valid?` или любой метод, который пытается сохранить этот объект в базу данных, валидации выполнятся снова. Если любая из валидаций провалится, коллекция errors будет заполнена снова.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]

person.errors.clear
person.errors.empty? # => true

person.save # => false

person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
```
#### `errors.size`
Метод `size` возвращает количество сообщений об ошибке для объекта.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors.size # => 2

person = Person.new(name: "Andrea", email: "andrea@example.com")
person.valid? # => true
person.errors.size # => 0
```
### Отображение ошибок валидации во вьюхах <a name="2.3.8"></a>
Как только вы создали модель и добавили валидации, если эта модель создается с помощью веб-формы, то вы, возможно хотите отображать сообщение об ошибке, когда одна из валидаций проваливается.

Поскольку каждое приложение обрабатывает подобные вещи по-разному, в Rails нет какого-то хелпера вьюхи для непосредственной генерации этих сообщений. Однако, благодаря богатому набору методов, Rails в целом дает способ взаимодействия с валидациями, очень просто создать свой собственный. Кроме того, при генерации скаффолда, Rails поместит некоторый ERB в `_form.html.erb`, генерируемый для отображения полного списка ошибок этой модели.

Допустим, у нас имеется модель, сохраненная в переменную экземпляра @article, это выглядит следующим образом:
```
<% if @article.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@article.errors.count, "error") %> prohibited this article from being saved:</h2>
    <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
```
Более того, при использовании хелперов форм Rails для создания форм, когда у поля происходит ошибка валидации, генерируется дополнительный `<div>` вокруг содержимого.
```
<div class="field_with_errors">
 <input id="article_title" name="article[title]" size="30" type="text" value="">
</div>
```
Этот `div` можно стилизовать по желанию. К примеру, дефолтный скаффолд, который генерирует Rails, добавляет это правило CSS:
```
.field_with_errors {
  padding: 2px;
  background-color: red;
  display: table;
}
```
## Колбэки Active Record <a name="2.4"></a>
### Жизненный цикл объекта <a name="2.4.1"></a>
В результате обычных операций приложения на Rails, объекты могут быть созданы, обновлены и уничтожены. Active Record дает возможность вмешаться в этот жизненный цикл объекта, таким образом, вы можете контролировать свое приложение и его данные.

Валидации позволяют вам быть уверенными, что только валидные данные хранятся в вашей базе данных. Колбэки позволяют вам переключать логику до или после изменения состояния объекта.
### Обзор колбэков <a name="2.4.2"></a>
#### Регистрация колбэков 
Для того, чтобы использовать доступные колбэки, их нужно зарегистрировать. Можно реализовать колбэки как обычные методы, а затем использовать макро-методы класса для их регистрации в качестве колбэков.
```
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_validation :ensure_login_has_a_value

  private
    def ensure_login_has_a_value
      if login.nil?
        self.login = email unless email.blank?
      end
    end
end
```
**Макро-методы** класса также могут получать блок. Их следует использовать, если код внутри блока такой короткий, что помещается в одну строчку.
```
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_create do
    self.name = login.capitalize if name.blank?
  end
end
```
Колбэки также могут быть зарегистрированы на выполнение **при определенных событиях жизненного цикла**:
```
class User < ApplicationRecord
  before_validation :normalize_name, on: :create

  # :on также принимает массив
  after_validation :set_location, on: [ :create, :update ]

  private
    def normalize_name
      self.name = name.downcase.titleize
    end

    def set_location
      self.location = LocationService.query(self)
    end
end
```
Считается **хорошей практикой** объявлять методы колбэков как `private`. Если их оставить `public`, они могут быть вызваны извне модели и нарушить принципы инкапсуляции объекта.
### Доступные колбэки <a name="2.4.3"></a>
Вот список всех доступных колбэков Active Record, перечисленных в том порядке, в котором они вызываются в течение соответствующих операций:
#### Создание объекта
* `before_validation`
* `after_validation`
* `before_save`
* `around_save`
* `before_create`
* `around_create`
* `after_create`
* `after_save`
* `after_commit/after_rollback` 
#### Обновление объекта
* `before_validation`
* `after_validation`
* `before_save`
* `around_save`
* `before_update`
* `around_update`
* `after_update`
* `after_save`
* `after_commit/after_rollback` 
#### Уничтожение объекта
* `before_destroy`
* `around_destroy`
* `after_destroy`
* `after_commit/after_rollback` 
> `after_save` запускается и при создании, и при обновлении, но всегда после более специфичных колбэков `after_create` и `after_update`, независимо от порядка, в котором выполняются макро-вызовы.
> Колбэк `before_destroy` должен быть размещен перед связями `dependent: :destroy` (или использовать опцию `prepend: true`), чтобы убедиться, что они выполняются до того, как записи будут удалены с помощью `dependent: :destroy`.

#### `after_initialize` и `after_find`
**Колбэк `after_initialize`** вызывается всякий раз, когда возникает экземпляр объекта Active Record, или непосредственно при использовании new, или когда запись загружается из базы данных. Он может быть полезен, чтобы избежать необходимости напрямую переопределять метод Active Record `initialize`.
**Колбэк `after_find`** будет вызван всякий раз, когда Active Record загружает запись из базы данных. `after_find` вызывается перед `after_initialize`, если они оба определены.
У колбэков `after_initialize` и `after_find` **нет пары `before_*`**, но они могут быть зарегистрированы подобно другим колбэкам Active Record.
```
class User < ApplicationRecord
  after_initialize do |user|
    puts "You have initialized an object!"
  end

  after_find do |user|
    puts "You have found an object!"
  end
end

>> User.new
You have initialized an object!
=> #<User id: nil>

>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
```
#### `after_touch`
Колбэк `after_touch` будет вызван, когда на объекте Active Record вызван `touch`.
```
class User < ApplicationRecord
  after_touch do |user|
    puts "You have touched an object"
  end
end

>> u = User.create(name: 'Kuldeep')
=> #<User id: 1, name: "Kuldeep", created_at: "2013-11-25 12:17:49", updated_at: "2013-11-25 12:17:49">

>> u.touch
You have touched an object
=> true
```
Он может быть **использован совместно с `belongs_to`**:
```
class Employee < ApplicationRecord
  belongs_to :company, touch: true
  after_touch do
    puts 'An Employee was touched'
  end
end

class Company < ApplicationRecord
  has_many :employees
  after_touch :log_when_employees_or_company_touched

  private
  def log_when_employees_or_company_touched
    puts 'Employee/Company was touched'
  end
end

>> @employee = Employee.last
=> #<Employee id: 1, company_id: 1, created_at: "2013-11-25 17:04:22", updated_at: "2013-11-25 17:05:05">

# вызывает @employee.company.touch
>> @employee.touch
Employee/Company was touched
An Employee was touched
=> true
```
### Запуск колбэков <a name="2.4.4"></a>
Следующие методы запускают колбэки:
* `create`
* `create!`
* `destroy`
* `destroy!`
* `destroy_all`
* `save`
* `save!`
* `save(validate: false)`
* `toggle!`
* `touch`
* `update_attribute`
* `update`
* `update!`
* `valid?` 

Дополнительно, **колбэк `after_find` запускается** следующими поисковыми методами:
* `all`
* `first`
* `find`
* `find_by`
* `find_by_*`
* `find_by_*!`
* `find_by_sql`
* `last` 

Колбэк **`after_initialize` запускается** всякий раз, **когда инициализируется** новый объект класса.

> Методы `find_by_*` и `find_by_*!` это динамические методы поиска, генерируемые автоматически для каждого атрибута.
### Пропуск колбэков <a name="2.4.5"></a>

Подобно валидациям, также возможно пропустить колбэки, используя следующие методы.
* `decrement`
* `decrement_counter`
* `delete`
* `delete_all`
* `increment`
* `increment_counter`
* `toggle`
* `update_column`
* `update_columns`
* `update_all`
* `update_counters` 

Однако, эти методы нужно использовать осторожно, поскольку важные бизнес-правила и логика приложения могут содержаться в колбэках. Пропуск их без понимания возможных последствий может привести к невалидным данным.
### Прерывание выполнения <a name="2.4.6"></a>
Как только вы зарегистрировали новые колбэки в своих моделях, они будут поставлены в очередь на выполнение. Эта очередь включает все валидации вашей модели, зарегистрированные колбэки и операции с базой данных для выполнения.

Вся цепочка колбэков упаковывается в операцию. **Если любой колбэк вызывает исключение, выполняемая цепочка прерывается** и запускается `ROLLBACK`. Чтобы преднамеренно остановить цепочку, используйте:
```
throw :abort
```
> Вызов произвольного исключения может прервать код, который предполагает, что save и тому подобное не будут провалены подобным образом. Исключение `ActiveRecord::Rollback` чуть точнее сообщает Active Record, что происходит откат. Он подхватывается изнутри, но не перевызывает исключение.
> Любое исключение, кроме `ActiveRecord::Rollback` или `ActiveRecord::RecordInvalid`, будет перевызвано Rails после того, как прервется цепочка колбэков. Вызов исключения, отличного от `ActiveRecord::Rollback` или `ActiveRecord::RecordInvalid`, может сломать код, который не ожидает, что методы, такие как `save` и `update` (которые обычно пытаются вернуть `true` или `false`) вызовут исключение.

### Колбэки для отношений <a name="2.4.7"></a>
Колбэки работают с отношениями между моделями, и даже могут быть определены ими. Представим пример, где пользователь имеет много статей. Статьи пользователя должны быть уничтожены, если уничтожается пользователь. Давайте добавим колбэк `after_destroy` в модель `User` через ее отношения с моделью `Article`.
```
class User < ApplicationRecord
  has_many :articles, dependent: :destroy
end

class Article < ActiveRecord::Base
  after_destroy :log_destroy_action

  def log_destroy_action
    puts 'Article destroyed'
  end
end

>> user = User.first
=> #<User id: 1>
>> user.articles.create!
=> #<Article id: 1, user_id: 1>
>> user.destroy
Article destroyed
=> #<User id: 1>
```
### Условные колбэки <a name="2.4.8"></a>
#### Использование `:if` и `:unless` с `Symbol`
При использовании такой формы регистрации, также возможно зарегистрировать несколько различных предикатов, которые будут вызваны, чтобы проверить, должен ли выполняться колбэк.
```
class Order < ApplicationRecord
  before_save :normalize_card_number, if: :paid_with_card?
end
```
#### Использование `:if` и `:unless` с `Proc`
Этот вариант больше всего подходит при написании коротких методов, обычно однострочных.
```
class Order < ApplicationRecord
  before_save :normalize_card_number,
    if: Proc.new { |order| order.paid_with_card? }
end
```
#### Составные условия для колбэков
```
class Comment < ApplicationRecord
  after_create :send_email_to_author, if: :author_wants_emails?,
    unless: Proc.new { |comment| comment.article.ignore_comments? }
end
```
### Классы колбэков <a name="2.4.9"></a>
Вот пример, где создается класс с колбэком `after_destroy` для модели `PictureFile`:
```
class PictureFileCallbacks
  def after_destroy(picture_file)
    if File.exist?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
```
При объявлении внутри класса, как выше, методы колбэка получают объект модели как параметр. Теперь можем использовать класс колбэка в модели:
```
class PictureFile < ApplicationRecord
  after_destroy PictureFileCallbacks.new
end
```
Заметьте, что нам нужно создать экземпляр нового объекта `PictureFileCallbacks`, после того, как объявили наш колбэк как отдельный метод. Это особенно полезно, если колбэки используют состояние экземпляра объекта. Часто, однако, более подходящим является объявление его в качестве метода класса.
```
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    if File.exist?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
```
Если метод колбэка объявляется таким образом, нет необходимости создавать экземпляр объекта `PictureFileCallbacks`.
```
class PictureFile < ApplicationRecord
  after_destroy PictureFileCallbacks
end
```
Внутри своего колбэк-класса можно создать сколько угодно колбэков.
### Транзакционные колбэки <a name="2.4.10"></a>
Имеются два дополнительных колбэка, которые включаются по завершению транзакции базы данных: `after_commit` и `after_rollback`. Эти колбэки очень похожи на колбэк `after_save`, за исключением того, что они не выполняются пока изменения в базе данных не будут подтверждены или обращены. Они наиболее полезны, когда вашим моделям Active Record необходимо взаимодействовать с внешними системами, не являющимися частью транзакции базы данных.

Рассмотрим, допустим, предыдущий пример, где модели `PictureFile` необходимо удалить файл после того, как запись уничтожена. Если что-либо вызовет исключение после того, как был вызван колбэк `after_destroy`, и транзакция откатывается, файл будет удален и модель останется в противоречивом состоянии. Например, предположим, что `picture_file_2` в следующем коде не валидна, и метод `save!` вызовет ошибку.
```
PictureFile.transaction do
  picture_file_1.destroy
  picture_file_2.save!
end
```
Используя колбэк `after_commit`, можно учесть этот случай.
```
class PictureFile < ApplicationRecord
  after_commit :delete_picture_file_from_disk, on: :destroy

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
```
> Опция `:on` определяет, когда будет запущен колбэк. Если не предоставить опцию `:on`, колбэк будет запущен для каждого экшна.

Так как принято использовать колбэк `after_commit` только при создании, обновлении или удалении, есть псевдонимы для этих операций:
* `after_create_commit`
* `after_update_commit`
* `after_destroy_commit` 
```
class PictureFile < ApplicationRecord
  after_destroy_commit :delete_picture_file_from_disk

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
```
> Колбэки `after_commit` и `after_rollback` вызываются для всех созданных, обновленных или удаленных моделей внутри блока транзакции. Однако, если какое-либо исключение вызовется в одном из этих колбэков, это исключение всплывет, и любые оставшиеся методы `after_commit` или `after_rollback` не будут выполнены. По сути, если код вашего колбэка может вызвать исключение, нужно для него вызвать `rescue`, и обработать его в колбэке, чтобы позволить запуститься другим колбэкам.

> При одновременном **использовании `after_create_commit` и `after_update_commit`** в одной и той же модели сработает только колбэк, **определенный последним**, переопределив все остальные.

```
class User < ApplicationRecord
  after_create_commit :log_user_saved_to_db
  after_update_commit :log_user_saved_to_db

  private
  def log_user_saved_to_db
    puts 'User was saved to database'
  end
end

# ничего не выводит
>> @user = User.create

# обновление @user
>> @user.save
=> User was saved to database
```
Чтобы зарегистрировать **колбэки как для create, так и для update** экшнов, используйте **`after_commit`**.
```
class User < ApplicationRecord
  after_commit :log_user_saved_to_db, on: [:create, :update]
end
```


## Связи (ассоциации) <a name="2.5"></a>
### Зачем нужны связи <a name="2.5.1"></a>
```
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end
```
С этими изменениями создание новой книги для определенного автора проще:
```
@book = @author.books.create(published_at: Time.now)
```
Удаление автора и всех его книг намного проще:
```
@author.destroy
```
### Типы связей <a name="2.5.2"></a>
Rails поддерживает шесть типов связей:
* `belongs_to`
* `has_one`
* `has_many`
* `has_many :through`
* `has_one :through`
* `has_and_belongs_to_many` 
Связи реализуются с использованием макро-вызовов (macro-style calls), и, таким образом, вы можете декларативно добавлять возможности для своих моделей. Например, объявляя, что одна модель принадлежит (`belongs_to`) другой, вы указываете Rails сохранять информацию о первичном-внешнем ключах между экземплярами двух моделей, а также получаете несколько полезных методов, добавленных в модель.

#### Связь `belongs_to`
Связь belongs_to устанавливает соединение один-к-одному с другой моделью, когда один экземпляр объявляющей модели "принадлежит" одному экземпляру другой модели. Например, если в приложении есть авторы и книги, и одна книга может быть связана только с одним автором, нужно объявить модель book следующим образом:
```
class Book < ApplicationRecord
  belongs_to :author
end
```
> связи `belongs_to` обязаны использовать единственное число. Если использовать множественное число в вышеприведенном примере для связи `author` в модели `Book` и создать экземпляр с помощью `Book.create(authors: @author)`, будет сообщено "uninitialized constant `Book::Authors`". Это так, потому что Rails автоматически получает имя класса из имени связи. Если в имени связи неправильно использовано число, то получаемый класс также будет неправильного числа.

Соответствующая миграция может выглядеть так:
```
class CreateOrders < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```
#### Связь `has_one`
Связь `has_one` также устанавливает соединение один-к-одному с другой моделью, но в несколько ином смысле (и с другими последствиями). Эта связь показывает, что каждый экземпляр модели содержит или обладает одним экземпляром другой модели. Например, если каждый поставщик имеет только один аккаунт, можете объявить модель supplier подобно этому:
```
class Supplier < ApplicationRecord
  has_one :account
end
```
Соответствующая миграция может выглядеть так:
```
class CreateSuppliers < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
```
В зависимости от применения, возможно потребуется создать индекс уникальности и/или ограничение внешнего ключа на указанный столбец таблицы `accounts`. В этом случае определение столбца может выглядеть так:
```
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
  # ...
end
```
#### Связь `has_many`
Связь has_many указывает на соединение один-ко-многим с другой моделью. Эта связь часто бывает на "другой стороне" связи `belongs_to`. Эта связь указывает на то, что каждый экземпляр модели имеет ноль или более экземпляров другой модели. Например, в приложении, содержащем авторов и книги, модель `author` может быть объявлена следующим образом:
```
class Author < ApplicationRecord
  has_many :books
end
```
Имя другой модели указывается во множественном числе при объявлении связи `has_many`.
Соответствующая миграция может выглядеть так:
```
class CreateAuthors < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```
####  Связь `has_many :through`
Связь `has_many :through` часто используется для настройки соединения многие-ко-многим с другой моделью. Эта связь указывает, что объявляющая модель может соответствовать нулю или более экземплярам другой модели через третью модель. Например, рассмотрим поликлинику, где пациентам (patients) дают направления (appointments) к врачам (physicians). Соответствующие объявления связей будут выглядеть следующим образом:
```
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end

class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
```
Соответствующая миграция может выглядеть так:
```
class CreateAppointments < ActiveRecord::Migration[5.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
```
Коллекция соединительных моделей может управляться с помощью методов связи `has_many`. Например, если вы присвоите:
```
physician.patients = patients
```
Тогда будут автоматически созданы новые соединительные модели для вновь связанных объектов. Если некоторые из ранее существующих сейчас отсутствуют, их соединительные строки автоматически удаляются.

> Автоматическое удаление соединительных моделей прямое, ни один из колбэков на уничтожение не включается.

Связь **`has_many :through` также полезна для настройки "ярлыков" через вложенные связи `has_many`**. Например, если документ имеет много секций, а секция имеет много параграфов, иногда хочется получить просто коллекцию всех параграфов в документе. Это можно настроить следующим образом:
```
class Document < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end
```
С определенным `through: :sections` Rails теперь понимает:
```
@document.paragraphs
```
#### Связь `has_one :through`
Связь `has_one :through` настраивает соединение один-к-одному с другой моделью. Эта связь показывает, что объявляющая модель может быть связана с одним экземпляром другой модели через третью модель. Например, если каждый поставщик имеет один аккаунт, и каждый аккаунт связан с одной историей аккаунта, тогда модели могут выглядеть так:
```
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end
```
Соответствующая миграция может выглядеть так:
```
class CreateAccountHistories < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
```
#### Связь `has_and_belongs_to_many`
Связь `has_and_belongs_to_many` создает прямое соединение многие-ко-многим с другой моделью, без промежуточной модели. Например, если ваше приложение включает сборки (assemblies) и детали (parts), где каждый узел имеет много деталей, и каждая деталь встречается во многих сборках, модели можно объявить таким образом:
```
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```
Соответствующая миграция может выглядеть так:
```
class CreateAssembliesAndParts < ActiveRecord::Migration[5.0]
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
```
#### Выбор между `belongs_to` и `has_one`

Если хотите настроить отношение один-к-одному между двумя моделями, необходимо добавить `belongs_to` к одной и `has_one` к другой. Как узнать что к какой?

Различие в том, где помещен внешний ключ (он должен быть в таблице для класса, объявляющего связь `belongs_to`), но вы также должны думать о реальном значении данных. Отношение `has_one` говорит, что что-то принадлежит вам - то есть что что-то указывает на вас. Например, больше смысла в том, что поставщик владеет аккаунтом, чем в том, что аккаунт владеет поставщиком. Это означает, что правильные отношения подобны этому:
```
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```
Соответствующая миграция может выглядеть так:
```
class CreateSuppliers < ActiveRecord::Migration[5.2]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.bigint  :supplier_id
      t.string  :account_number
      t.timestamps
    end

    add_index :accounts, :supplier_id
  end
end
```
> Использование `t.bigint :supplier_id` указывает имя внешнего ключа очевидно и явно. В современных версиях Rails можно абстрагироваться от деталей реализации используя `t.references :supplier`

#### Выбор между `has_many :through` и `has_and_belongs_to_many`
Rails предлагает два разных способа объявления отношения многие-ко-многим между моделями. Простейший способ - использовать `has_and_belongs_to_many`, который позволяет создать связь напрямую:
```
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```
Второй способ объявить отношение многие-ко-многим - использование `has_many :through`. Это осуществляет связь не напрямую, а через соединяющую модель:
```
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end

class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
```
Простейший признак того, что нужно настраивать отношение `has_many :through` - если необходимо работать с моделью отношений как с независимым объектом. Если вам не нужно ничего делать с моделью отношений, проще настроить связь `has_and_belongs_to_many` (хотя нужно не забыть создать соединяющую таблицу в базе данных).

Вы должны использовать `has_many :through`, если нужны валидации, колбэки или дополнительные атрибуты для соединительной модели.

#### Полиморфные связи
Полиморфные связи - это немного более "навороченный" вид связей. С полиморфными связями модель может принадлежать более чем одной модели, на одиночной связи. Например, имеется модель изображения, которая принадлежит или модели работника, или модели продукта. Вот как это объявляется:
```
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end

class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end

class Product < ApplicationRecord
  has_many :pictures, as: :imageable
end
```
Можно считать полиморфное объявление `belongs_to` как настройку интерфейса, которую может использовать любая другая модель. Из экземпляра модели `Employee` можно получить коллекцию изображений:` @employee.pictures`.

Подобным образом можно получить `@product.pictures`.

Если имеется экземпляр модели `Picture`, можно получить его родителя посредством `@picture.imageable`. Чтобы это работало, необходимо объявить столбец внешнего ключа и столбец типа в модели, объявляющей полиморфный интерфейс:
```
class CreatePictures < ActiveRecord::Migration[5.2]
  def change
    create_table :pictures do |t|
      t.string  :name
      t.bigint  :imageable_id
      t.string  :imageable_type
      t.timestamps
    end

    add_index :pictures, [:imageable_type, :imageable_id]
  end
end
```
Эта миграция может быть упрощена при использовании формы `t.references`:
```
class CreatePictures < ActiveRecord::Migration[5.0]
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end
```
#### Присоединение к себе
При разработке модели данных иногда находится модель, которая может иметь отношение сама к себе. Например, мы хотим хранить всех работников в одной модели базы данных, но нам нужно отслеживать отношения начальник-подчиненный. Эта ситуация может быть смоделирована с помощью связей, присоединяемых к себе:
```
class Employee < ApplicationRecord
  has_many :subordinates, class_name: "Employee",
                          foreign_key: "manager_id"

  belongs_to :manager, class_name: "Employee", optional: true
end
```
С такой настройкой, вы можете получить `@employee.subordinates` и `@employee.manager`.

В миграциях/схеме следует добавить столбец ссылки модели на саму себя.
```
class CreateEmployees < ActiveRecord::Migration[5.0]
  def change
    create_table :employees do |t|
      t.references :manager
      t.timestamps
    end
  end
end
```

### Полезные советы и предупреждения <a name="2.5.3"></a>
Вот некоторые вещи, которые необходимо знать для эффективного использования связей Active Record в вашем приложении на Rails:
* Управление кэшированием
* Предотвращение коллизий имен
* Обновление схемы
* Управление областью видимости связей
* Двусторонние связи 

#### Управление кэшированием
Все методы связи построены вокруг кэширования, которое хранит результаты последних запросов доступными для будущих операций. Кэш является общим для разных методов. Например:
```
author.books                 # получаем книги из базы данных
author.books.size            # используем кэшированную копию книг
author.books.empty?          # используем кэшированную копию книг
```
Но что если вы хотите перезагрузить кэш, так как данные могли быть изменены другой частью приложения? Всего лишь вызовите `reload` на связи:
```
author.books                 # получаем книги из базы данных
author.books.size            # используем кэшированную копию книг
author.books.reload.empty?   # отказываемся от кэшированной копии книг
                             # и снова обращаемся к базе данных
```
#### Предотвращение коллизий имен
Вы не свободны в выборе любого имени для своих связей. Поскольку создание связи добавляет метод с таким именем в модель, будет плохой идеей дать связи имя, уже используемое как метод экземпляра `ActiveRecord::Base`. Метод связи тогда переопределит базовый метод, и что-нибудь перестанет работать. Например, `attributes` или `connection` плохие имена для связей.

#### Обновление схемы
Связи очень полезные, но не волшебные. Вы ответственны за содержание вашей схемы базы данных в соответствии со связями. На практике это означает две вещи, в зависимости от того, какой тип связей создаете. Для связей `belongs_to` нужно создать внешние ключи, а для связей `has_and_belongs_to_many` нужно создать подходящую соединительную таблицу.

##### Создание внешних ключей для связей `belongs_to`
Когда объявляете связь `belongs_to`, нужно создать внешние ключи, при необходимости. Например, рассмотрим эту модель:
```
class Book < ApplicationRecord
  belongs_to :author
end
```
Это объявление нуждается в поддержке соответствующим столбцом внешнего ключа в таблице `books`. Для совершенно новой таблицы миграция может выглядеть примерно так:
```
class CreateBooks < ActiveRecord::Migration[5.0]
  def change
    create_table :books do |t|
      t.datetime   :published_at
      t.string     :book_number
      t.references :author
    end
  end
end
```
В то время как для существующей таблицы, это может выглядеть следующим образом:
```
class AddAuthorToBooks < ActiveRecord::Migration[5.0]
  def change
    add_reference :books, :author
  end
end
```
Если необходимо принудительно использовать ссылочную целостность на уровне базы данных, добавьте опцию `foreign_key: true` в вышеприведенное объявление 'reference' столбца

##### Создание соединительных таблиц для связей `has_and_belongs_to_many`
Если вы создали связь `has_and_belongs_to_many`, необходимо обязательно создать соединительную таблицу. Если имя соединительной таблицы явно не указано с использованием опции `:join_table`, `Active Record` создает имя, используя алфавитный порядок имен классов. Поэтому соединение между моделями author и book по умолчанию даст значение имени таблицы "authors_books", так как "a" идет перед "b" в алфавитном порядке.

> Приоритет между именами модели рассчитывается с использованием оператора `<=>` для `String`. Это означает, что если строки имеют разную длину и в своей короткой части они равны, тогда более длинная строка рассматривается как с более высоким лексическим приоритетом, по сравнению с короткой. Например, кто-то ожидает, что таблицы "paper_boxes" и "papers" создадут соединительную таблицу "papers_paper_boxes" поскольку имя "paper_boxes" длиннее, но фактически будет сгенерирована таблица с именем "paper_boxes_papers" (поскольку знак подчеркивания "`_`" лексикографически меньше, чем "s" в обычной кодировке).

Какое бы ни было имя, вы должны вручную сгенерировать соединительную таблицу в соответствующей миграции. Например, рассмотрим эти связи:
```
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```
Теперь нужно написать миграцию для создания таблицы `assemblies_parts`. Эта таблица должна быть создана без первичного ключа:
```
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.2]
  def change
    create_table :assemblies_parts, id: false do |t|
      t.bigint :assembly_id
      t.bigint :part_id
    end

    add_index :assemblies_parts, :assembly_id
    add_index :assemblies_parts, :part_id
  end
end
```
Мы передаем `id: false в create_table`, так как эта таблица не представляет модель. Это необходимо, чтобы связь работала правильно. Если вы видите странное поведение в связи `has_and_belongs_to_many`, например, искаженные ID моделей, или исключения в связи с конфликтом ID, скорее всего вы забыли убрать первичный ключ.

Также можно использовать метод `create_join_table`
```
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.0]
  def change
    create_join_table :assemblies, :parts do |t|
      t.index :assembly_id
      t.index :part_id
    end
  end
end
```
#### Управление областью видимости связей
По умолчанию связи ищут объекты только в пределах области видимости текущего модуля. Это важно, когда вы объявляете модели Active Record внутри модуля. Например:
```
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end

    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```
Это будет работать, так как оба класса `Supplier` и `Account` определены в пределах одной области видимости. Но нижеследующее не будет работать, потому что `Supplier` и `Account` определены в разных областях видимости:
```
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```
Для связи модели с моделью в другом пространстве имен, необходимо указать полное имя класса в объявлении связи:
```
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end
```
#### Двусторонние связи
Для связей нормально работать в двух направлениях, затребовав объявление в двух различных моделях:
```
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
```
Active Record попытается автоматически определить, что эти две модели образуют двунаправленную связь, основываясь на имени связи. Таким образом, Active Record загрузит только одну копию объекта `Author`, делая ваше приложение более эффективным и предотвращая несогласованные данные:
```
a = Author.first
b = a.books.first
a.first_name == b.author.first_name # => true
a.first_name = 'David'
a.first_name == b.author.first_name # => true
```
Active Record **поддерживает автоматическое определение для большинства связей** со стандартными именами. Однако, Active Record **не будет автоматически определять двунаправленные связи**, содержащие область видимости или любые из следующих опций:
* `:through`
* `:foreign_key` 

Например, рассмотрим следующие объявления моделей:
```
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```
Active Record больше не будет автоматически распознавать двунаправленную связь:
```
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => false
```
Active Record представляет опцию `:inverse_of`, таким образом можно явно объявить двунаправленные связи:
```
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```
Включив опцию `:inverse_of` в объявлении связи `has_many`, Active Record будет распознавать двунаправленную связь:
```
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => true
```
### Подробная информация по связи `belongs_to` <a name="2.5.4"></a>
Связь `belongs_to` создает соответствие один-к-одному с другой моделью. В терминах базы данных эта связь сообщает, что этот класс содержит внешний ключ. Если внешний ключ содержит другой класс, вместо этого следует использовать `has_one`.
#### Методы, добавляемые `belongs_to`
Когда объявляете связь `belongs_to`, объявляющий класс автоматически получает 6 методов, относящихся к связи:
* `association`
* `association=(associate)`
* `build_association(attributes = {})`
* `create_association(attributes = {})`
* `create_association!(attributes = {})`
* `reload_association` 
Во всех четырех методах association заменяется символом, переданным как первый аргумент в `belongs_to`. Например, имеем объявление:
```
class Book < ApplicationRecord
  belongs_to :author
end
```
Каждый экземпляр модели `Book` будет иметь эти методы:
* `author`
* `author=`
* `build_author`
* `create_author`
* `create_author!`
* `reload_author`
> Когда устанавливаете новую связь `has_one` или `belongs_to`, следует использовать префикс `build_` для построения связи, в отличие от метода `association.build`, используемый для связей `has_many или has_and_belongs_to_many`. Чтобы создать связь, используйте префикс `create_`.
##### `association`
Метод `association` возвращает связанный объект, если он есть. Если объекта нет, возвращает `nil`.
```
@author = @book.author
```
Если связанный объект уже был получен из базы данных для этого объекта, возвращается кэшированная версия. Чтобы переопределить это поведение (и заставить прочитать из базы данных), вызовите `#reload_association` на родительском объекте.
```
@author = @book.reload_author
```
##### `association=(associate)`

Метод `association=` привязывает связанный объект к этому объекту. Фактически это означает извлечение первичного ключа из связанного объекта и присвоение его значения внешнему ключу.
```
@book.author = @author
```
##### `build_association(attributes = {})`

Метод `build_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, будет установлена связь с внешним ключом этого объекта, но связанный объект пока не будет сохранен.
```
@author = @book.build_author(author_number: 123,
                                  author_name: "John Doe")
```
##### `create_association(attributes = {})`

Метод `create_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, будет установлена связь с внешним ключом этого объекта, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен.
```
@author = @book.create_author(author_number: 123, author_name: "John Doe")
```
##### `create_association!(attributes = {})`

Работает так же, как и вышеприведенный `create_association`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

#### Опции для `belongs_to`
Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `belongs_to`. Такая настройка легко выполнима с помощью передачи опций и блоков со скоупом при создании связи. Например, эта связь использует две такие опции:
```
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at,
    counter_cache: true
end
```
Связь `belongs_to` поддерживает эти опции:
* `:autosave`
* `:class_name`
* `:counter_cache`
* `:dependent`
* `:foreign_key`
* `:primary_key`
* `:inverse_of`
* `:polymorphic`
* `:touch`
* `:validate`
* `:optional` 

##### `:autosave`
Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave в false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosave` отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.
##### `:class_name`
Если имя другой модели не может быть получено из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если книга принадлежит автору, но фактическое имя модели, содержащей авторов, `Patron`, можете установить это следующим образом:
```
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron"
end
```
##### `:counter_cache`
Опция `:counter_cache` может быть использована, чтобы сделать поиск количества принадлежащих объектов более эффективным. Рассмотрим эти модели:
```
class Book < ApplicationRecord
  belongs_to :author
end
class Author < ApplicationRecord
  has_many :books
end
```
С этими объявлениями запрос значения `@author.books.size` требует обращения к базе данных для выполнения запроса `COUNT(*)`. Чтобы этого избежать, можете добавить кэш счетчика в принадлежащую модель:
```
class Book < ApplicationRecord
  belongs_to :author, counter_cache: true
end
class Author < ApplicationRecord
  has_many :books
end
```
С этим объявлением, Rails будет хранить в кэше актуальное значение и затем возвращать это значение в отклик на метод `size`.

Хотя опция `:counter_cache` определяется в модели, включающей определение `belongs_to`, фактический столбец должен быть добавлен в связанную (`has_many`) модель. В вышеописанном случае, необходимо добавить столбец, названный `books_count` в модель `Author`.

Имя столбца по умолчанию можно переопределить, указав произвольное имя столбца в объявлении `counter_cache` вместо `true`. Например, для использования `count_of_books` вместо `books_count`:
```
class Book < ApplicationRecord
  belongs_to :author, counter_cache: :count_of_books
end
class Author < ApplicationRecord
  has_many :books
end
```
> Опцию `:counter_cache` необходимо указывать только на стороне `belongs_to` связи. Столбцы кэша счетчика добавляются в список атрибутов модели только для чтения посредством `attr_readonly`.

##### `:dependent`

Если установить опцию `:dependent` в:
* `:destroy`, когда объект будет уничтожен, `destroy` будет вызван на его связанных объектах.
* `:delete`, когда объект будет уничтожен, все его связанные объекты будут удалены прямо из базы данных без вызова метода `destroy`. 

> Не следует определять эту опцию в связи `belongs_to`, которая соединена со связью `has_many` в другом классе. Это приведет к "битым" связям в записях вашей базы данных.

##### `:foreign_key`

По соглашению Rails предполагает, что столбец, используемый для хранения внешнего ключа в этой модели, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron", foreign_key: "patron_id"
end
```
> В любом случае, Rails не создаст столбцы внешнего ключа за вас. Вам необходимо явно определить их в своих миграциях.

##### `:primary_key`

По соглашению Rails предполагает, что для первичного ключа используется столбец `id` в таблице. Опция `:primary_key` позволяет указать иной столбец.

Например, имеется таблица `users` с `guid` в качестве первичного ключа. Если мы хотим отдельную таблицу `todos`, содержащую внешний ключ `user_id` из столбца `guid`, для этого можно использовать `primary_key` следующим образом:
```
class User < ApplicationRecord
  self.primary_key = 'guid' # primary key is guid and not id
end

class Todo < ApplicationRecord
  belongs_to :user, primary_key: 'guid'
end
```
При выполнении `@user.todos.create`, у записи `@todo` будет значение `user_id` таким же, как значение `guid` у `@user`.

##### `:inverse_of`

Опция `:inverse_of` определяет имя связи `has_many` или `has_one`, являющейся противоположностью для этой связи.
```
class Author < ApplicationRecord
  has_many :books, inverse_of: :author # книга имеет автора book.author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books # автор имеет книги author.books
end
```
##### `:polymorphic`

Передача `true` для опции `:polymorphic` показывает, что это полиморфная связь.

##### `:touch`

Если установите опцию `:touch` в `true`, то временные метки `updated_at` или `updated_on` на связанном объекте будут установлены в текущее время всякий раз, когда этот объект будет сохранен или уничтожен:
```
class Book < ApplicationRecord
  belongs_to :author, touch: true
end

class Author < ApplicationRecord
  has_many :books
end
```
В этом случае, сохранение или уничтожение книги обновит временную метку на связанном авторе. **Также можно определить конкретный атрибут** временной метки для обновления:
```
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at
end
```
##### `:validate`

Если установите опцию `:validate` в `true`, тогда связанные объекты будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `false`: связанные объекты не проходят валидацию, когда этот объект сохраняется.

##### `:optional`

Если установить `:optional` в `true`, тогда наличие связанных объектов не будет валидироваться. По умолчанию установлено в `false`.

#### Скоупы для `belongs_to`
Иногда хочется настроить запрос, используемый `belongs_to`. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `includes`
* `readonly`
* `select` 

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
```
##### `includes`

Метод `includes` можно использовать для определения связей второго порядка, которые должны быть лениво загружены при использовании этой связи. Например, рассмотрим эти модели:
```
class Chapter < ApplicationRecord
  belongs_to :book
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```
Если вы часто получаете авторов непосредственно из глав (`@chapter.book.author`), то можно улучшить эффективность кода, включив авторов в связь между книгой и ее главами:
```
class Chapter < ApplicationRecord
  belongs_to :book, -> { includes :author }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```
> Нет необходимости в использовании `includes` для ближайших связей - то есть, если есть `Book belongs_to :author`, то `author` автоматически лениво загружается при необходимости.

##### `readonly`

При использовании `readonly`, связанный объект будет только для чтения при получении через связь.

##### `select`

Метод `select` позволяет переопределить SQL выражение SELECT, используемое для получения данных о связанном объекте. **По умолчанию Rails получает все столбцы**.

> При использовании метода `select` на связи `belongs_to`, следует также установить опцию `:foreign_key` для гарантии правильных результатов.

#### Существуют ли связанные объекты?

Можно увидеть, существует ли какой-либо связанный объект, при использовании метода `association.nil?`:
```
if @book.author.nil?
  @msg = "No author found for this book"
end
```
#### Когда сохраняются объекты?

Присвоение связи `belongs_to` не приводит к автоматическому сохранению ни самого объекта, ни связанного объекта.

### Подробная информация по связи `has_one` <a name="2.5.5"></a>
Связь `has_one` создает соответствие один-к-одному с другой моделью. В терминах базы данных эта связь сообщает, что другой класс содержит внешний ключ. Если этот класс содержит внешний ключ, следует использовать `belongs_to`.

#### Методы, добавляемые `has_one`
Когда объявляете связь `has_one`, объявляющий класс автоматически получает 6 методов, относящихся к связи:
* `association`
* `association=(associate)`
* `build_association(attributes = {})`
* `create_association(attributes = {})`
* `create_association!(attributes = {})`
* `reload_association`

> При установлении новой связи `has_one` или `belongs_to`, следует использовать префикс `build_` для построения связи, в отличие от метода `association.build`, используемого для связей `has_many` или `has_and_belongs_to_many`. Чтобы создать связь, используйте префикс `create_`.

##### `association`
Метод `association` возвращает связанный объект, если таковой имеется. Если связанный объект не найден, возвращает `nil`.
```
@account = @supplier.account
```
Если связанный объект уже был получен из базы данных для этого объекта, возвращается кэшированная версия. Чтобы переопределить это поведение (и заставить прочитать из базы данных), вызовите `#reload_association` на родительском объекте.
```
@account = @supplier.reload_account
```
##### `association=(associate)`

Метод `association=` привязывает связанный объект к этому объекту. Фактически это означает извлечение первичного ключа этого объекта и присвоение его значения внешнему ключу связанного объекта.
```
@supplier.account = @account
```

##### `build_association(attributes = {})`

Метод `build_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, и будет установлена связь через внешний ключ, но связанный объект пока не будет сохранен.
```
@account = @supplier.build_account(terms: "Net 30")
```

##### `create_association(attributes = {})`

Метод `create_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, будет установлена связь через внешний ключ, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен
```
@account = @supplier.create_account(terms: "Net 30")
```

##### `create_association!(attributes = {})`

Работает так же, как и вышеприведенный `create_association`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

#### Опции для `has_one`
Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `has_one`. Такая настройка легко выполнима с помощью передачи опции при создании связи. Например, эта связь использует две такие опции:
```
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing", dependent: :nullify
end
```
Связь has_one поддерживает эти опции:
* `:as`
* `:autosave`
* `:class_name`
* `:dependent`
* `:foreign_key`
* `:inverse_of`
* `:primary_key`
* `:source`
* `:source_type`
* `:through`
* `:touch`
* `:validate`

##### `:as`
Установка опции `:as` показывает, что это полиморфная связь.

##### `:autosave`

Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave` в `false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosave` отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.

##### `:class_name`

Если имя другой модели не может быть образовано из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если поставщик имеет аккаунт, но фактическое имя модели, содержащей аккаунты, это `Billing`, можете установить это следующим образом:
```
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing"
end
```

##### `:dependent`

Управляет тем, что произойдет со связанным объектом, когда его владелец будет уничтожен:
* `:destroy` приведет к тому, что связанный объект также будет уничтожен
* `:delete` приведет к тому, что связанный объект будет удален из базы данных напрямую (таким образом не будут выполнены колбэки)
* `:nullify` приведет к тому, что внешний ключ будет установлен NULL. Столбцы полиморфного типа на полиморфных связях также обнуляются. Колбэки не выполняются.
* `:restrict_with_exception` приведет к вызову исключения `ActiveRecord::DeleteRestrictionError`, если есть связанный объект
* `:restrict_with_error` приведет к ошибке, добавляемой к владельцу, если есть связанный объект 

Нельзя устанавливать или оставлять опцию `:nullify` для связей, имеющих ограничение NOT NULL. Если не установить `dependent` для уничтожения таких связей, вы не сможете изменить связанный объект, так как внешнему ключу изначально связанного объекта будет назначено недопустимое значение NULL.

##### `:foreign_key`

По соглашению Rails предполагает, что столбец, используемый для хранения внешнего ключа в этой модели, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class Supplier < ApplicationRecord
  has_one :account, foreign_key: "supp_id"
end
```
> В любом случае, Rails не создаст столбцы внешнего ключа за вас. Вам необходимо явно определить их в своих миграциях.

##### `:inverse_of`

Опция `:inverse_of` определяет имя связи `belongs_to`, являющейся обратной для этой связи.
```
class Supplier < ApplicationRecord
  has_one :account, inverse_of: :supplier
end

class Account < ApplicationRecord
  belongs_to :supplier, inverse_of: :account
end
```

##### `:primary_key`

По соглашению, Rails предполагает, что столбец, используемый для хранения первичного ключа, это `id`. Вы можете переопределить это и явно определить первичный ключ с помощью опции `:primary_key`

##### `:source`

Опция `:source` определяет имя источника связи для связи `has_one :through`

##### `:source_type`

Опция `:source_type` определяет тип источника связи для связи `has_one :through`, который действует при полиморфной связи.
```
class Book < ApplicationRecord
  has_one :format, polymorphic: true
  has_one :dust_jacket, through: :format, source: :dust_jacket, source_type: "Hardback"
end

class Paperback < ApplicationRecord; end

class Hardback < ApplicationRecord
  has_one :dust_jacket
end

class DustJacket < ApplicationRecord; end
```

##### `:through`

Опция `:through` определяет соединительную модель, через которую выполняется запрос. 

##### `:touch`

Если опция `:touch` установлена `true`, тогда временные метки `updated_at` или `updated_on` у связанного объекта будут установлены в текущее время всякий раз, когда этот объект будет сохранен или уничтожен:
```
class Supplier < ApplicationRecord
  has_one :account, touch: true
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```
В этом случае, сохранение или удаление поставщика обновит временную метку у связанного счета. Также можно указать конкретный атрибут временной метки для обновления:
```
class Supplier < ApplicationRecord
  has_one :account, touch: :suppliers_updated_at
end
```

##### `:validate`

Если установите опцию `:validate` в `true`, тогда связанные объекты будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `false`: связанные объекты не проходят валидацию, когда этот объект сохраняется.

#### Скоупы для `has_one`
Иногда хочется настроить запрос, используемый `has_one`. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Supplier < ApplicationRecord
  has_one :account, -> { where active: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `includes`
* `readonly`
* `select`

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Supplier < ApplicationRecord
  has_one :account, -> { where "confirmed = 1" }
end
```

##### `includes`

Метод `includes` позволяет определить связи второго порядка, которые должны быть лениво загружены при использовании этой связи. Например, рассмотрим эти модели:
```
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end

class Representative < ApplicationRecord
  has_many :accounts
end
```
Если вы часто получаете `representatives` непосредственно из `suppliers` (`@supplier.account.representative`), то можно улучшить эффективность кода, включив `representatives` в связь между `suppliers` и `accounts`:
```
class Supplier < ApplicationRecord
  has_one :account, -> { includes :representative }
end

class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end

class Representative < ApplicationRecord
  has_many :accounts
end
```
##### `readonly`

При использовании `readonly`, связанный объект будет только для чтения при получении через связь

##### `select`

Метод `select` позволяет переопределить SQL выражение SELECT, используемое для получения данных о связанном объекте. По умолчанию Rails получает все столбцы.

#### Существуют ли связанные объекты?
Можно увидеть, существует ли какой-либо связанный объект, при использовании метода `association.nil?`:
```
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
```

#### Когда сохраняются объекты?

Когда вы назначаете объект связью `has_one`, этот объект автоматически сохраняется (для того, чтобы обновить его внешний ключ). Кроме того, любой заменяемый объект также автоматически сохраняется, поскольку его внешний ключ также изменяется.

Если одно из этих сохранений проваливается из-за ошибок валидации, тогда выражение назначения возвращает `false`, и само назначение отменяется.

Если родительский объект (который объявляет связь `has_one`) является несохраненным (то есть `new_record?` возвращает `true`), тогда дочерние объекты не сохраняются. Они сохранятся автоматически, когда сохранится родительский объект.

Если вы хотите назначить объект связью has_one без сохранения объекта, используйте метод `build_association`.

### Подробная информация по связи `has_many` <a name="2.5.6"></a>
Связь `has_many` создает отношение один-ко-многим с другой моделью. В терминах базы данных эта связь говорит, что другой класс будет иметь внешний ключ, относящийся к экземплярам этого класса.

#### Методы, добавляемые `has_many`
Когда объявляете связь `has_many`, объявляющий класс автоматически получает 17 методов, относящихся к связи:
* `collection`
* `collection<<(object, ...)`
* `collection.delete(object, ...)`
* `collection.destroy(object, ...)`
* `collection=(objects)`
* `collection_singular_ids`
* `collection_singular_ids=(ids)`
* `collection.clear`
* `collection.empty?`
* `collection.size`
* `collection.find(...)`
* `collection.where(...)`
* `collection.exists?(...)`
* `collection.build(attributes = {}, ...)`
* `collection.create(attributes = {})`
* `collection.create!(attributes = {})`
* `collection.reload` 
Во всех этих методах `collection` заменяется символом, переданным как первый аргумент в `has_many`, и `collection_singular` заменяется версией в единственном числе этого символа. Например, имеем объявление:
```
class Author < ApplicationRecord
  has_many :books
end
```
Каждый экземпляр модели `Author` будет иметь эти методы:
* `books`
* `books<<(object, ...)`
* `books.delete(object, ...)`
* `books.destroy(object, ...)`
* `books=(objects)`
* `book_ids`
* `book_ids=(ids)`
* `books.clear`
* `books.empty?`
* `books.size`
* `books.find(...)`
* `books.where(...)`
* `books.exists?(...)`
* `books.build(attributes = {}, ...)`
* `books.create(attributes = {})`
* `books.create!(attributes = {})`
* `books.reload`

##### `collection`

Метод `collection` возвращает Relation всех связанных объектов. Если нет связанных объектов, он возвращает пустой Relation.
```
@books = @author.books
```

##### `collection<<(object, ...)`

Метод `collection<<` добавляет один или более объектов в коллекцию, устанавливая их внешние ключи равными первичному ключу вызывающей модели.
```
@author.books << @book1
```
##### `collection.delete(object, ...)`

Метод `collection.delete` убирает один или более объектов из коллекции, установив их внешние ключи в NULL.
```
@author.books.delete(@book1)
```
> Объекты будут в дополнение уничтожены, если связаны с `dependent: :destroy`, и удалены, если они связаны с `dependent: :delete_all`.

##### `collection.destroy(object, ...)`

Метод `collection.destroy` убирает один или более объектов из коллекции, выполняя `destroy` для каждого объекта.
```
@author.books.destroy(@book1)
```
> Объекты будут всегда удаляться из базы данных, игнорируя опцию `:dependent`.

##### `collection=(objects)`

Метод `collection=` делает коллекцию содержащей только представленные объекты, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных

##### `collection_singular_ids`

Метод `collection_singular_ids` возвращает массив `id` объектов в коллекции.
```
@book_ids = @author.book_ids
```

##### `collection_singular_ids=(ids)`

Метод `collection_singular_ids=` делает коллекцию содержащей только объекты, идентифицированные представленными значениями первичного ключа, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных.

##### `collection.clear`

Метод `collection.clear` убирает каждый объект из коллекции в соответствии со стратегией, определенной опцией `dependent`. Если опция не указана, он следует стратегии по умолчанию. Стратегия по умолчанию для `has_many :through` это `delete_all`, а для связей `has_many` — установить их внешние ключи в NULL.
```
@author.books.clear
```
Объекты будут удалены, если они связаны с помощью `dependent: :destroy`, как и с помощью `dependent: :delete_all`.

##### `collection.empty?`

Метод `collection.empty?` возвращает `true`, если коллекция не содержит каких-либо связанных объектов.
```
<% if @author.books.empty? %>
  No Books Found
<% end %>
```

##### `collection.size`

Метод `collection.size` возвращает количество объектов в коллекции.
```
@book_count = @author.books.size
```

##### `collection.find(...)`

Метод `collection.find` ищет объекты в коллекции. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.find`.
```
@available_book = @author.books.find(1)
```

##### `collection.where(...)`

Метод `collection.where` ищет объекты в коллекции, основываясь на переданных условиях, но объекты загружаются лениво, что означает, что база данных запрашивается только когда происходит доступ к объекту(-там).
```
@available_books = @author.books.where(available: true) # Пока нет запроса
@available_book = @available_books.first # Теперь база данных будет запрошена
```

##### `collection.exists?(...)`

Метод `collection.exists?` проверяет, существует ли в коллекции объект, отвечающий представленным условиям. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.exists?`.

##### `collection.build(attributes = {}, ...)`

Метод `collection.build` возвращает один или массив объектов связанного типа. Объект(ы) будут экземплярами с переданными атрибутами, будет создана ссылка через их внешние ключи, но связанные объекты не будут пока сохранены.
```
@book = @author.books.build(published_at: Time.now,
                                book_number: "A12345")

@books = @author.books.build([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }])
```

##### `collection.create(attributes = {})`

Метод `collection.create` возвращает один или массив новых объектов связанного типа. Объект(ы) будут экземплярами с переданными атрибутами, будет создана ссылка через его внешний ключ, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен
```
@book = @author.books.create(published_at: Time.now,
                                 book_number: "A12345")

@books = @author.books.create([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }])
```

##### `collection.create!(attributes = {})`

Работает так же, как вышеприведенный `collection.create`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

##### `collection.reload`

Метод `collection.reload` возвращает Relation всех связанных объектов, принудительно читая базу данных. Если нет связанных объектов, он возвращает пустой Relation.
```
@books = @author.books.reload
```

#### Опции для `has_many`

Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `has_many`. Такая настройка легко выполнима с помощью передачи опций при создании связи. Например, эта связь использует две такие опции:
```
class Author < ApplicationRecord
  has_many :books, dependent: :delete_all, validate: false
end
```
Связь `has_many` поддерживает эти опции:
* `:as`
* `:autosave`
* `:class_name`
* `:counter_cache`
* `:dependent`
* `:foreign_key`
* `:inverse_of`
* `:primary_key`
* `:source`
* `:source_type`
* `:through`
* `:validate` 

##### `:as`

Установка опции `:as` показывает, что это полиморфная связь. 

##### `:autosave`

Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave` в `false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosav`e отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.

##### `:class_name`

Если имя другой модели не может быть произведено из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если автор имеет много книг, но фактическое имя модели, содержащей книги, это `Transaction`, можете установить это следующим образом:
```
class Author < ApplicationRecord
  has_many :books, class_name: "Transaction"
end
```

##### `:counter_cache`

Эта опция используется для настройки произвольно названного `:counter_cache`. Эту опцию нужно использовать, только если вы изменили имя вашего `:counter_cache` у связи `belongs_to`.

##### `:dependent`

Управляет тем, что произойдет со связанными объектами, когда его владелец будет уничтожен:
* `:destroy` приведет к тому, что связанные объекты также будут уничтожены
* `:delete_all` приведет к тому, что связанные объекты будут удалены из базы данных напрямую (таким образом не будут выполнены колбэки)
* `:nullify` приведет к тому, что внешние ключи будет установлен NULL. Столбцы полиморфного типа на полиморфных связях также обнуляются. Колбэки не выполняются.
* `:restrict_with_exception` приведет к вызову исключения `ActiveRecord::DeleteRestrictionError`, если есть какой-нибудь связанный объект
* `:restrict_with_error` приведет к ошибке, добавляемой к владельцу, если есть какой-нибудь связанный объект 

> Опции `:destroy` и `:delete_all` также влияют на семантику методов `collection.delete` и `collection=`, вынуждая их удалять связанные объекты при удалении из коллекции.

##### `:foreign_key`

По соглашению Rails предполагает, что столбец, используемый для хранения внешнего ключа в этой модели, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class Author < ActiveRecord::Base
  has_many :books, foreign_key: "cust_id"
end
```
##### `:inverse_of`

Опция `:inverse_of` определяет имя связи `belongs_to`, являющейся обратной для этой связи.
```
class Author < ApplicationRecord
  has_many :books, inverse_of: :author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books
end
```

##### `:primary_key`

По соглашению, Rails предполагает, что столбец, используемый для хранения первичного ключа, это `id`. Вы можете переопределить это и явно определить первичный ключ с помощью опции `:primary_key`.

Допустим, в таблице `users` есть `id` в качестве `primary_key`, но также имеется столбец `guid`. Имеется требование, что таблица `todos` должна содержать значение столбца `guid`, а не значение `id`. Это достигается следующим образом:
```
class User < ApplicationRecord
  has_many :todos, primary_key: :guid
end
```
Теперь, если выполнить `@todo = @user.todos.create`, то в запись `@todo` значение `user_id` будет таким же, как значение `guid` в `@user`.

##### `:source`

Опция `:source` определяет имя источника связи для связи `has_many :through`. Эту опцию нужно использовать, только если имя источника связи не может быть автоматически выведено из имени связи.
```
class Author < ApplicationRecord
  has_many :books
  has_many :paperbacks, through: :books, source: :format, source_type: "Paperback"
end

class Book < ApplicationRecord
  has_one :format, polymorphic: true
end

class Hardback < ApplicationRecord; end
class Paperback < ApplicationRecord; end
```

##### `:source_type`

Опция `:source_type` определяет тип источника связи для связи `has_many :through`, который действует при полиморфной связи

##### `:through`

Опция `:through` определяет соединительную модель, через которую выполняется запрос. Связи `has_many :through` предоставляют способ осуществления отношений многие-ко-многим

##### `:validate`

Если установите опцию `:validate` в `false`, тогда связанные объекты не будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `true`: связанные объекты проходят валидацию, когда этот объект сохраняется.

#### Скоупы для `has_many`

Иногда хочется настроить запрос, используемый has_many. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Author < ApplicationRecord
  has_many :books, -> { where processed: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `extending`
* `group`
* `includes`
* `limit`
* `offset`
* `order`
* `readonly`
* `select`
* `distinct` 

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Author < ApplicationRecord
  has_many :confirmed_books, -> { where "confirmed = 1" },
    class_name: "Book"
end

Также можно задать условия хэшем:

class Author < ApplicationRecord
  has_many :confirmed_books, -> { where confirmed: true },
                              class_name: "Book"
end
```
> При использовании опции `where` хэшем, при создании записи через эту связь будет автоматически применен скоуп с использованием хэша. В этом случае при использовании` @author.confirmed_books.create` или `@author.confirmed_books.build` будут созданы книги, в которых столбец `confirmed` будет иметь значение `true`.

##### `extending`

Метод `extending` определяет именованный модуль для расширения прокси связи.

##### `group`

Метод `group` предоставляет имя атрибута, по которому группируется результирующий набор, используя выражение GROUP BY в поисковом SQL.
```
class Author < ApplicationRecord
  has_many :chapters, -> { group 'books.id' },
                      through: :books
end
```

##### `includes`

Можете использовать метод `includes` для определения связей второго порядка, которые должны быть нетерпеливо загружены, когда эта связь используется. Например, рассмотрим эти модели:
```
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Chapter < ApplicationRecord
  belongs_to :book
end
```
Если вы часто получаете главы прямо из авторов (`@author.books.chapters`), тогда можете сделать свой код более эффективным, включив главы в связь от авторов к книгам:
```
class Author < ApplicationRecord
  has_many :books, -> { includes :chapters }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Chapter < ApplicationRecord
  belongs_to :book
end
```
##### `limit`

Метод `limit` позволяет ограничить общее количество объектов, которые будут выбраны через связь.
```
class Author < ApplicationRecord
  has_many :recent_books,
    -> { order('published_at desc').limit(100) },
    class_name: "Book"
end
```

##### `offset`

Метод `offset` позволяет определить начальное смещение для выбора объектов через связь. Например, -> { offset(11) } пропустит первые 11 записей.

##### `order`

Метод `order` предписывает порядок, в котором связанные объекты будут получены (в синтаксисе SQL, используемом в условии ORDER BY).
```
class Author < ApplicationRecord
  has_many :books, -> { order "date_confirmed DESC" }
end
```

##### `readonly`

При использовании метода `readonly`, связанные объекты будут доступны только для чтения, когда получены посредством связи.

##### `select`

Метод `select` позволяет переопределить SQL условие SELECT, которое используется для получения данных о связанном объекте. По умолчанию Rails получает все столбцы.

> Если укажете свой собственный select, не забудьте включить столбцы первичного ключа и внешнего ключа в связанной модели. Если так не сделать, Rails выдаст ошибку.

##### `distinct`

Используйте метод `distinct`, чтобы убирать дубликаты из коллекции. Это полезно в сочетании с опцией `:through`.
```
class Person < ApplicationRecord
  has_many :readings
  has_many :articles, through: :readings
end

article   = Article.create(name: 'a1')
person.articles << article
person.articles << article
person.articles.inspect # => [#<Article id: 5, name: "a1">, #<Article id: 5, name: "a1">]
Reading.all.inspect     # => [#<Reading id: 12, person_id: 5, article_id: 5>, #<Reading id: 13, person_id: 5, article_id: 5>]
```
В вышеописанной задаче два `reading`, и `person.articles` выявляет их оба, даже если эти записи указывают на одну и ту же статью.

Давайте установим `distinct`:
```
class Person
  has_many :readings
  has_many :articles, -> { distinct }, through: :readings
end

person = Person.create(name: 'Honda')
article   = Article.create(name: 'a1')
person.articles << article
person.articles << article
person.articles.inspect # => [#<Article id: 7, name: "a1">]
Reading.all.inspect     # => [#<Reading id: 16, person_id: 7, article_id: 7>, #<Reading id: 17, person_id: 7, article_id: 7>]
```
В вышеописанной задаче все еще два `reading`. Однако `person.articles` показывает только одну статью, поскольку коллекция загружает только уникальные записи.

Если вы хотите быть уверенными, что **после вставки все записи персистентной связи различны** (и, таким образом, убедиться, что при просмотре связи никогда не будет дублирующихся записей), следует добавить уникальный индекс для самой таблицы. Например, если таблица называется `readings`, и вы хотите убедиться, что все публикации могут быть добавлены к персоне один раз, следует добавить в миграцию:
```
add_index :readings, [:person_id, :article_id], unique: true
```
Как только у вас появится этот индекс уникальности, попытка добавить статью к персоне дважды вызовет ошибку `ActiveRecord::RecordNotUnique`:
```
person = Person.create(name: 'Honda')
article = Article.create(name: 'a1')
person.articles << article
person.articles << article # => ActiveRecord::RecordNotUnique
```
Отметьте, что проверка уникальности при использовании чего-то, наподобие `include?`, подвержено состояниям гонки. Не пытайтесь использовать `include?` для соблюдения уникальности в связи. Используя вышеприведенный пример со статьёй, нижеследующий код вызовет гонку, поскольку несколько пользователей могут использовать его одновременно:
```
person.articles << article unless person.articles.include?(post)
```
#### Когда сохраняются объекты? 
Когда вы назначаете объект связью `has_many`, этот объект автоматически сохраняется (для того, чтобы обновить его внешний ключ). Если назначаете несколько объектов в одном выражении, они все будут сохранены.

Если одно из этих сохранений проваливается из-за ошибок валидации, тогда выражение назначения возвращает `false`, и само назначение отменяется.

Если родительский объект (который объявляет связь `has_many`) является несохраненным (то есть `new_record?` возвращает `true`), тогда дочерние объекты не сохраняются при добавлении. Все несохраненные члены связи сохранятся автоматически, когда сохранится родительский объект.

Если вы хотите назначить объект связью `has_many` без сохранения объекта, используйте метод `collection.build`.

### Подробная информация по связи `has_and_belongs_to_many` <a name="2.5.7"></a>
Связь `has_and_belongs_to_many` создает отношение многие-ко-многим с другой моделью. В терминах базы данных это связывает два класса через промежуточную соединительную таблицу, которая включает внешние ключи, относящиеся к каждому классу.

#### Методы, добавляемые `has_and_belongs_to_many`

Когда объявляете связь `has_and_belongs_to_many`, объявляющий класс автоматически получает 17 методов, относящихся к связи:
* `collection`
* `collection<<(object, ...)`
* `collection.delete(object, ...)`
* `collection.destroy(object, ...)`
* `collection=(objects)`
* `collection_singular_ids`
* `collection_singular_ids=(ids)`
* `collection.clear`
* `collection.empty?`
* `collection.size`
* `collection.find(...)`
* `collection.where(...)`
* `collection.exists?(...)`
* `collection.build(attributes = {})`
* `collection.create(attributes = {})`
* `collection.create!(attributes = {})`
* `collection.reload `
Во всех этих методах collection заменяется символом, переданным как первый аргумент в has_and_belongs_to_many, а collection_singular заменяется версией в единственном числе этого символа.

##### Дополнительные методы столбцов

Если соединительная таблица для связи `has_and_belongs_to_many` имеет дополнительные столбцы, кроме двух внешних ключей, эти столбцы будут добавлены как атрибуты к записям, получаемым посредством связи. Записи, возвращаемые с дополнительными атрибутами, будут всегда только для чтения, поскольку Rails не может сохранить значения этих атрибутов.

> Использование дополнительных атрибутов в соединительной таблице в связи `has_and_belongs_to_many` **устарело**. Если требуется этот тип сложного поведения таблицы, соединяющей две модели в отношениях многие-ко-многим, следует использовать связь `has_many :through` вместо `has_and_belongs_to_many`.

##### `collection`

Метод `collection` возвращает Relation всех связанных объектов. Если нет связанных объектов, он возвращает пустой Relation.
```
@assemblies = @part.assemblies
```

##### `collection<<(object, ...)`

Метод `collection<<` добавляет один или более объектов в коллекцию, создавая записи в соединительной таблице.
```
@part.assemblies << @assembly1
```
> Этот метод - просто псевдоним к `collection.concat` и `collection.push`.

##### `collection.delete(object, ...)`

Метод `collection.delete` убирает один или более объектов из коллекции, удаляя записи в соединительной таблице. Это не уничтожает объекты.
```
@part.assemblies.delete(@assembly1)
```

##### `collection.destroy(object, ...)`

Метод `collection.destroy` убирает один или более объектов из коллекции, удаляя записи в соединительной таблице. Это не уничтожает объекты.
```
@part.assemblies.destroy(@assembly1)
```

##### `collection=(objects)`

Метод `collection=` делает коллекцию содержащей только представленные объекты, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных.

##### `collection_singular_ids`

Метод `collection_singular_ids` возвращает массив `id` объектов в коллекции.
```
@assembly_ids = @part.assembly_ids
```

##### `collection_singular_ids=(ids)`

Метод `collection_singular_ids=` делает коллекцию содержащей только объекты, идентифицированные представленными значениями первичного ключа, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных.

##### `collection.clear`

Метод `collection.clear` убирает каждый объект из коллекции, удаляя строки из соединительной таблицы. Это не уничтожает связанные объекты.

##### `collection.empty?`

Метод `collection.empty?` возвращает `true`, если коллекция не содержит каких-либо связанных объектов.
```
<% if @part.assemblies.empty? %>
  This part is not used in any assemblies
<% end %>
```

##### `collection.size`

Метод `collection.size` возвращает количество объектов в коллекции.
```
@assembly_count = @part.assemblies.size
```

##### `collection.find(...)`

Метод `collection.find` ищет объекты в коллекции. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.find`. А также добавляет дополнительное условие, что объект должен быть в коллекции.
```
@assembly = @part.assemblies.find(1)
```

##### `collection.where(...)`

Метод `collection.where` ищет объекты в коллекции, основываясь на переданных условиях, но объекты загружаются лениво, что означает, что база данных запрашивается только когда происходит доступ к объекту(-там).
```
@new_assemblies = @part.assemblies.where("created_at > ?", 2.days.ago)
```

##### `collection.exists?(...)`

Метод `collection.exists?` проверяет, существует ли в коллекции объект, отвечающий представленным условиям. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.exists?`.

##### `collection.build(attributes = {})`

Метод `collection.build` возвращает один или более объектов связанного типа. Эти объекты будут экземплярами с переданными атрибутами, и будет создана связь через соединительную таблицу, но связанный объект пока не будет сохранен.
```
@assembly = @part.assemblies.build({assembly_name: "Transmission housing"})
```

##### `collection.create(attributes = {})`

Метод `collection.create` возвращает один или более объектов связанного типа. Эти объекты будут экземплярами с переданными атрибутами, будет создана связь через соединительную таблицу, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен.
```
@assembly = @part.assemblies.create({assembly_name: "Transmission housing"})
```

##### `collection.create!(attributes = {})`

Работает так же, как вышеприведенный `collection.create`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

##### `collection.reload`

Метод `collection.reload` возвращает Relation всех связанных объектов, принудительно читая базу данных. Если нет связанных объектов, он возвращает пустой Relation.
```
@assemblies = @part.assemblies.reload
```

#### Опции для `has_and_belongs_to_many`

Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `has_and_belongs_to_many`. Такая настройка легко выполнима с помощью передачи опции при создании связи. Например, эта связь использует две такие опции:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { readonly },
                                       autosave: true
end
```
Связь `has_and_belongs_to_many` поддерживает эти опции:
* `:association_foreign_key`
* `:autosave`
* `:class_name`
* `:foreign_key`
* `:join_table`
* `:validate`

##### `:association_foreign_key`

По соглашению Rails предполагает, что столбец в соединительной таблице, используемый для хранения внешнего ключа, указываемого на другую модель, является именем этой модели с добавленным суффиксом `_id`. Опция `:association_foreign_key` позволяет установить имя внешнего ключа явно:

> Опции `:foreign_key` и `:association_foreign_key` полезны при настройке присоединения к себе многие-ко-многим. Например:

```
class User < ApplicationRecord
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id", # типа твой айди
      association_foreign_key: "other_user_id" # типа айди друга
end
```

##### `:autosave`

Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave` в `false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosave` отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.

##### `:class_name`

Если имя другой модели не может быть произведено из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если часть имеет много сборок, но фактическое имя модели, содержащей сборки - это `Gadget`, можете установить это следующим образом:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, class_name: "Gadget"
end
```

##### `:foreign_key`

По соглашению Rails предполагает, что столбец в соединительной таблице, используемый для хранения внешнего ключа, указываемого на эту модель, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class User < ApplicationRecord
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
end
```

##### `:join_table`

Если имя соединительной таблицы по умолчанию, основанное на алфавитном порядке, - это не то, что вам нужно, используйте опцию `:join_table`, чтобы переопределить его.

##### `:validate`

Если установите опцию `:validate` в `false`, тогда связанные объекты не будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `true:` связанные объекты проходят валидацию, когда этот объект сохраняется.

#### Скоупы для `has_and_belongs_to_many`

Иногда хочется настроить запрос, используемый `has_many`. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { where active: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `extending`
* `group`
* `includes`
* `limit`
* `offset`
* `order`
* `readonly`
* `select`
* `distinct`

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { where "factory = 'Seattle'" }
end
```
Также можно задать условия хэшем:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { where factory: 'Seattle' }
end
```
При использовании опции `where` хэшем, при создание записи через эту связь будет автоматически применен скоуп с использованием хэша. В этом случае при использовании `@parts.assemblies.create` или `@parts.assemblies.build` будут созданы заказы, в которых столбец `factory` будет иметь значение `Seattle`.

##### `extending`

Метод `extending` определяет именованный модуль для расширения прокси связи. 

##### `group`

Метод `group` предоставляет имя атрибута, по которому группируется результирующий набор, используя выражение GROUP BY в поисковом запросе SQL.
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { group "factory" }
end
```

##### `includes`

Можете использовать метод `includes` для определения связей второго порядка, которые должны быть нетерпеливо загружены, когда эта связь используется.

##### `limit`

Метод `limit` позволяет ограничить общее количество объектов, которые будут выбраны через связь.
```
class Customer < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { order("created_at DESC").limit(50) }
end
```

##### `offset`

Метод `offset` позволяет определить начальное смещение для выбора объектов через связь. Например, `-> { offset(11) }` пропустит первые 11 записей.

##### `order`

Метод `order` предписывает порядок, в котором связанные объекты будут получены (в синтаксисе SQL, используемом в условии ORDER BY).
```
class Customer < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { order "assembly_name ASC" }
end
```

##### `readonly`

При использовании метода `:readonly`, связанные объекты будут доступны только для чтения, когда получены посредством связи

##### `select`

Метод `select` позволяет переопределить SQL условие SELECT, которое используется для получения данных о связанном объекте. По умолчанию Rails получает все столбцы.

##### `distinct`

Используйте метод `distinct`, чтобы убирать дубликаты из коллекции.

#### Когда сохраняются объекты?

Когда вы назначаете объект связью `has_and_belongs_to_many`, этот объект автоматически сохраняется (в порядке обновления соединительной таблицы). Если назначаете несколько объектов в одном выражении, они все будут сохранены.

Если одно из этих сохранений проваливается из-за ошибок валидации, тогда выражение назначения возвращает `false`, a само назначение отменяется.

Если родительский объект (который объявляет связь has_and_belongs_to_many) является несохраненным (то есть `new_record?` возвращает `true`), тогда дочерние объекты не сохраняются при добавлении. Все несохраненные члены связи сохранятся автоматически, когда сохранится родительский объект.

Если вы хотите назначить объект связью `has_and_belongs_to_many` без сохранения объекта, используйте метод `collection.build`.

### Подробная информация по колбэкам и расширениям связи <a name="2.5.8"></a>
Обычно колбэки прицепляются к жизненному циклу объектов Active Record, позволяя вам работать с этими объектами в различных точках. Например, можете использовать колбэк `:before_save`, чтобы вызвать что-то перед тем, как объект будет сохранен.

Колбэки связи похожи на обычные колбэки, но они включаются событиями в жизненном цикле коллекции. Доступны четыре колбэка связи:
* `before_add`
* `after_add`
* `before_remove`
* `after_remove`

Колбэки связи объявляются с помощью добавления опций в объявление связи. Например:
```
class Author < ApplicationRecord
  has_many :books, before_add: :check_credit_limit

  def check_credit_limit(book)
    ...
  end
end
```
Rails передает добавляемый или удаляемый объект в колбэк.

Можете помещать колбэки в очередь на отдельное событие, передав их как массив:
```
class Author < ApplicationRecord
  has_many :books,
    before_add: [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(book)
    ...
  end

  def calculate_shipping_charges(book)
    ...
  end
end
```
Если колбэк `before_add` вызывает исключение, объект не будет добавлен в коллекцию. Подобным образом, если колбэк `before_remove` вызывает исключение, объект не убирается из коллекции.

Эти колбэки вызываются только когда связанные объекты добавляются или убираются через коллекцию связи:
```
# Вызывает колбэк `before_add`
author.books << book
author.books = [book, book2]

# Не вызывает колбэк `before_add`
book.update(author_id: 1)
```

#### Расширения связи
Вы не ограничены функциональностью, которую Rails автоматически встраивает в выданные по связи объекты. Можно расширить эти объекты с помощью анонимных модулей, добавив новые методы поиска, методы создания и иные методы. Например:
```
class Author < ApplicationRecord
  has_many :books do
    def find_by_book_prefix(book_number)
      find_by(category_id: book_number[0..2])
    end
  end
end
```
Если имеется расширение, которое должно быть общим для нескольких связей, можно использовать именованный модуль расширения. Например:
```
module FindRecentExtension
  def find_recent
    where("created_at > ?", 5.days.ago)
  end
end

class Author < ApplicationRecord
  has_many :books, -> { extending FindRecentExtension }
end

class Supplier < ApplicationRecord
  has_many :deliveries, -> { extending FindRecentExtension }
end
```
Расширения могут ссылаться на внутренние методы выданных по связи объектов, используя следующие три атрибута акцессора `proxy_association`:
* `proxy_association.owner` возвращает объект, в котором объявлена связь.
* `proxy_association.reflection` возвращает объект reflection, описывающий связь.
* `proxy_association.target` возвращает связанный объект для `belongs_to` или `has_one`, или коллекцию связанных объектов для `has_many` или `has_and_belongs_to_many`.

### Наследование с единой таблицей (STI) <a name="2.5.9"></a>
Иногда можно делиться полями и поведением между различными моделями. Скажем, у нас есть модели `Car`, `Motorcycle` и `Bicycle`. Мы хотим совместно использовать поля `color` и `price` и некоторые методы всеми из них, но иметь некоторое специфичное поведение для каждого, а также различные контроллеры.

Rails позволяет сделать это достаточно просто. Сначала нужно сгенерировать базовую модель `Vehicle`:
```
$ rails generate model vehicle type:string color:string price:decimal{10.2}
```
Вы заметили, что мы добавили поле "type"? Так как все модели будут сохранены в одну таблицу базы данных, Rails сохранит в этот столбец имя модели, которая сохраняется. В нашем примере это может быть "Car", "Motorcycle" или "Bicycle." STI не работает без поля "type" в таблице.

Затем мы сгенерируем три модели, унаследованные от `Vehicle`. Для этого можно использовать опцию `--parent=PARENT`, которая сгенерирует модель, унаследованную от указанного родителя и без эквивалентной миграции (так как таблица уже существует).

Например, чтобы сгенерировать модель `Car`:
```
$ rails generate model car --parent=Vehicle
```
Сгенерированная модель будет выглядеть так:
```
class Car < Vehicle
end
```
Это означает, что все поведение, такое как связи, публичные методы и так далее, добавленное в `Vehicle`, доступно также для `Car`.

Создание автомобиля сохранит его в таблице `vehicles` со значением "Car" в поле `type`:
```
Car.create(color: 'Red', price: 10000)
```
сгенерирует следующий SQL:
```
INSERT INTO "vehicles" ("type", "color", "price") VALUES ('Car', 'Red', 10000)
```
Запрос записей автомобилей будет просто искать среди транспортных средств, которые являются автомобилями:
```
Car.all
```
запустит подобный запрос:
```
SELECT "vehicles".* FROM "vehicles" WHERE "vehicles"."type" IN ('Car')
```

## Интерфейс запрососв <a name="2.6"></a>
Если вы использовали чистый SQL для поиска записей в базе данных, то скорее всего обнаружите, что в Rails есть лучшие способы выполнения тех же операций. Active Record ограждает вас от необходимости использования SQL во многих случаях.

Примеры кода далее в этом руководстве будут относиться к некоторым из этих моделей:

Все модели используют `id` как первичный ключ, если не указано иное.
```
class Client < ApplicationRecord
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end

class Address < ApplicationRecord
  belongs_to :client
end

class Order < ApplicationRecord
  belongs_to :client, counter_cache: true
end

class Role < ApplicationRecord
  has_and_belongs_to_many :clients
end
```
Active Record выполнит запросы в базу данных за вас, он совместим с большинством СУБД, включая MySQL, MariaDB, PostgreSQL и SQLite. Независимо от того, какая используется СУБД, формат методов Active Record будет всегда одинаковый.

### Получение объектов из базы данных <a name="2.6.1"></a>
Для получения объектов из базы данных Active Record предоставляет несколько методов поиска. В каждый метод поиска можно передавать аргументы для выполнения определенных запросов в базу данных без необходимости писать на чистом SQL.

Методы следующие:
* `find`
* `create_with`
* `distinct`
* `eager_load`
* `extending`
* `from`
* `group`
* `having`
* `includes`
* `joins`
* `left_outer_joins`
* `limit`
* `lock`
* `none`
* `offset`
* `order`
* `preload`
* `readonly`
* `references`
* `reorder`
* `reverse_order`
* `select`
* `where `

Методы поиска, возвращающие коллекцию, такие как where и group, возвращают экземпляр `ActiveRecord::Relation`. Методы, ищущие отдельную сущность, такие как `find` и `first`, возвращают отдельный экземпляр модели.

Вкратце основные операции `Model.find(options)` таковы:
* Преобразовать предоставленные опции в эквивалентный запрос SQL.
* Выполнить запрос SQL и получить соответствующие результаты из базы данных.
* Создать экземпляр эквивалентного объекта Ruby подходящей модели для каждой строки результата запроса.
* Запустить колбэки `after_find` и далее `after_initialize`, если таковые имеются. 

#### Получение одиночного объекта
##### `find`
Используя метод `find`, можно получить объект, соответствующий определенному первичному ключу (`primary key`) и предоставленным опциям. Например:
```
# Ищет клиента с первичным ключом (id) 10.
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
```
Метод `find` вызывает исключение `ActiveRecord::RecordNotFound`, если соответствующей записи не было найдено.

Этот метод также можно использовать для получения нескольких объектов. Вызовите метод find и передайте в него массив первичных ключей. Возвращенным результатом будет массив, содержащий все записи, соответствующие представленным первичным ключам. Например:
```
# Найдем клиентов с первичными ключами 1 и 10.
clients = Client.find([1, 10]) # Или даже Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients WHERE (clients.id IN (1,10))
```
##### `take`
Метод `take` получает запись без какого-либо явного упорядочивания. Например:
```
client = Client.take
# => #<Client id: 1, first_name: "Lifo">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients LIMIT 1
```
Метод `take` возвращает `nil`, если ни одной записи не найдено, и исключение не будет вызвано.

В метод take можно передать числовой аргумент, чтобы вернуть это количество результатов. Например
```
clients = Client.take(2)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 220, first_name: "Sara">
# ]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients LIMIT 2
```
Метод `take!` ведет себя подобно `take`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи.

> Получаемая запись может отличаться в зависимости от подсистемы хранения СУБД.

##### `first`

Метод `first` находит первую запись, упорядоченную по первичному ключу (по умолчанию). Например:
```
client = Client.first
# => #<Client id: 1, first_name: "Lifo">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
```
Метод `first` возвращает `nil`, если не найдено соответствующей записи, и исключение не вызывается.

Если скоуп по умолчанию содержит метод `order`, `first` возвратит первую запись в соответствии с этим упорядочиванием.

В метод `first` можно передать числовой аргумент, чтобы вернуть это количество результатов. Например
```
clients = Client.first(3)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 2, first_name: "Fifo">,
#   #<Client id: 3, first_name: "Filo">
# ]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3
```
На коллекции, упорядоченной с помощью `order`, `first` вернет первую запись, упорядоченную по указанному в order атрибуту.
```
client = Client.order(:first_name).first
# => #<Client id: 2, first_name: "Fifo">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.first_name ASC LIMIT 1
```
Метод `first!` ведет себя подобно `first`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи.

##### `last`

Метод `last` находит последнюю запись, упорядоченную по первичному ключу (по умолчанию). Например:
```
client = Client.last
# => #<Client id: 221, first_name: "Russel">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
```
Метод `last` возвращает `nil`, если не найдено соответствующей записи, и исключение не вызывается.

Если скоуп по умолчанию содержит метод `order`, `last` возвратит последнюю запись в соответствии с этим упорядочиванием.

В метод `last` можно передать числовой аргумент, чтобы вернуть это количество результатов. Например
```
clients = Client.last(3)
# => [
#   #<Client id: 219, first_name: "James">,
#   #<Client id: 220, first_name: "Sara">,
#   #<Client id: 221, first_name: "Russel">
# ]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3
```
На коллекции, упорядоченной с помощью `order`, `last` вернет последнюю запись, упорядоченную по указанному в `order` атрибуту.
```
client = Client.order(:first_name).last
# => #<Client id: 220, first_name: "Sara">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.first_name DESC LIMIT 1
```
Метод `last!` ведет себя подобно `last`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи.

##### `find_by`

Метод `find_by` ищет первую запись, соответствующую некоторым условиям. Например:
```
Client.find_by first_name: 'Lifo'
# => #<Client id: 1, first_name: "Lifo">

Client.find_by first_name: 'Jon'
# => nil
```
Это эквивалент записи:
```
Client.where(first_name: 'Lifo').take
```
SQL эквивалент выражения выше, следующий:
```
SELECT * FROM clients WHERE (clients.first_name = 'Lifo') LIMIT 1
```
Метод `find_by!` ведет себя подобно `find_by`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи. Например:
```
Client.find_by! first_name: 'does not exist'
# => ActiveRecord::RecordNotFound
```
Это эквивалент записи:
```
Client.where(first_name: 'does not exist').take!
```

#### Получение нескольких объектов пакетами

Часто необходимо перебрать огромный набор записей, например, когда рассылаем письма всем пользователям или импортируем некоторые данные.

Это может показаться простым:
```
# Это может потребить слишком много памяти, если таблица большая.
User.all.each do |user|
  NewsMailer.weekly(user).deliver_now
end
```
Но этот подход становится очень непрактичным с увеличением размера таблицы, поскольку `User.all.each` говорит Active Record извлечь таблицу полностью за один проход, создать объект модели для каждой строки и держать этот массив в памяти. В реальности, если имеется огромное количество записей, полная коллекция может превысить количество доступной памяти.

Rails предоставляет два метода, которые решают эту проблему путем разделения записей на дружелюбные к памяти пакеты для обработки. Первый метод, `find_each`, получает пакет записей и затем вкладывает каждую запись в блок отдельно как модель. Второй метод, `find_in_batches`, получает пакет записей и затем вкладывает весь пакет в блок как массив моделей.

> Методы `find_each` и `find_in_batches` предназначены для пакетной обработки большого числа записей, которые не поместятся в памяти за раз. Если нужно просто перебрать тысячу записей, более предпочтителен вариант обычных методов поиска.

##### `find_each`

Метод `find_each` получает пакет записей и затем передает каждую запись в блок. В следующем примере `find_each` получает пользователей пакетами по 1000 записей, а затем передает их в блок один за другим:
```
User.find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
```
Этот процесс повторяется, извлекая больше пакетов при необходимости, пока не будут обработаны все записи.

`find_each` работает на классах модели, как показано выше, а также на relation:
```
User.where(weekly_subscriber: true).find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
```
только у них нет упорядочивания, так как методу необходимо собственное упорядочивание для работы.

Если у получателя есть упорядочивание, то поведение зависит от флажка `config.active_record.error_on_ignored_order`. Если `true`, вызывается `ArgumentError`, в противном случае упорядочивание игнорируется, что является поведением по умолчанию. Это можно переопределить с помощью опции `:error_on_ignore`, описанной ниже.

#### Опции для `find_each`

##### `:batch_size`

Опция `:batch_size` позволяет определить число записей, подлежащих получению в одном пакете, до передачи отдельной записи в блок. Например, для получения 5000 записей в пакете:
```
User.find_each(batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end
```
##### `:start`

По умолчанию записи извлекаются в порядке увеличения первичного ключа, который должен быть числом. Опция `:start` позволяет вам настроить первый ID последовательности, когда наименьший ID не тот, что вам нужен. Это может быть полезно, например, если хотите возобновить прерванный процесс пакетирования, предоставив последний обработанный ID как контрольную точку.

Например, чтобы выслать письма только пользователям с первичным ключом, начинающимся от 2000:
```
User.find_each(start: 2000) do |user|
  NewsMailer.weekly(user).deliver_now
end
```
##### `:finish`

Подобно опции `:start`, `:finish` позволяет указать последний ID последовательности, когда наибольший ID не тот, что вам нужен. Это может быть полезно, например, если хотите запустить процесс пакетирования, используя подмножество записей на основании `:start` и `:finish`

Например, чтобы выслать письма только пользователям с первичным ключом от 2000 до 10000:
```
User.find_each(start: 2000, finish: 10000) do |user|
  NewsMailer.weekly(user).deliver_now
end
```
Другим примером является наличие нескольких воркеров, работающих с одной и той же очередью обработки. Можно было бы обрабатывать каждым воркером 10000 записей, установив подходящие опции `:start` и `:finish` в каждом воркере.

##### `:error_on_ignore`

Переопределяет настройку приложения, указывающую, должна ли быть вызвана ошибка, если в relation присутствует упорядочивание.


#### `find_in_batches`

Метод `find_in_batches` похож на `find_each` тем, что они оба получают пакеты записей. Различие в том, что `find_in_batches` передает в блок пакеты как массив моделей, вместо отдельной модели. Следующий пример передаст в представленный блок массив из 1000 счетов за раз, а в последний блок содержащий все оставшиеся счета:
```
# Передает в add_invoices массив из 1000 счетов за раз.
Invoice.find_in_batches do |invoices|
  export.add_invoices(invoices)
end
```
`find_in_batches` работает на классах модели, как показано выше, а также на relation:
```
Invoice.pending.find_in_batches do |invoices|
  pending_invoices_export.add_invoices(invoices)
end
```
только у них нет упорядочивания, так как методу необходимо собственное упорядочивание для работы.

#### Опции для `find_in_batches`

Метод `find_in_batches` принимает те же опции, что и `find_each`.

### `Условия`<a name="2.6.2"></a>

Метод `where` позволяет определить условия для ограничения возвращаемых записей, которые представляют `WHERE`-часть выражения SQL. Условия могут быть заданы как строка, массив или хэш.

#### Чисто строковые условия

Если вы хотите добавить условия в свой поиск, можете просто определить их там, подобно `Client.where("orders_count = '2'")`. Это найдет всех клиентов, где значение поля `orders_count` равно 2.

> Создание условий в чистой строке подвергает вас риску SQL-инъекций. Например, `Client.where("first_name LIKE '%#{params[:first_name]}%'")` не безопасно.

#### Условия с использованием массива

Что если количество может изменяться, скажем, как аргумент откуда-то извне, возможно даже от пользователя? Поиск тогда принимает такую форму:
```
Client.where("orders_count = ?", params[:orders])
```
Active Record примет первый аргумент в качестве строки условия, а все остальные элементы подставит вместо знаков вопроса `(?)` в ней.

Если хотите определить несколько условий:
```
Client.where("orders_count = ? AND locked = ?", params[:orders], false)
```
В этом примере первый знак вопроса будет заменен на значение в `params[:orders]` и второй будет заменен SQL аналогом `false`, который зависит от адаптера.

Этот код значительно предпочтительнее:
```
Client.where("orders_count = ?", params[:orders])
```
чем такой код:
```
Client.where("orders_count = #{params[:orders]}")
```
по причине безопасности аргумента. Помещение переменной прямо в строку условий передает переменную в базу данных как есть. Это означает, что неэкранированная переменная, переданная пользователем, может иметь злой умысел. Если так сделать, вы подвергаете базу данных риску, так как если пользователь обнаружит, что он может использовать вашу базу данных, то он сможет сделать с ней что угодно. Никогда не помещайте аргументы прямо в строку условий!

##### Местозаполнители в условиях

Подобно тому, как `(?)` заменяют параметры, можно использовать ключи в условиях совместно с соответствующим хэшем ключей/значений:
```
Client.where("created_at >= :start_date AND created_at <= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
```
Читаемость улучшится, в случае если вы используете большое количество переменных в условиях.

#### Условия с использованием хэша

Active Record также позволяет передавать условия в хэше, что улучшает читаемость синтаксиса условий. В этом случае передается хэш с ключами, соответствующими полям, которые хотите уточнить, и с значениями, которые вы хотите к ним применить:

> Хэшем можно передать условия проверки только равенства, интервала и подмножества.


#### Условия с использованием хэша

Active Record также позволяет передавать условия в хэше, что улучшает читаемость синтаксиса условий. В этом случае передается хэш с ключами, соответствующими полям, которые хотите уточнить, и с значениями, которые вы хотите к ним применить:

Хэшем можно передать условия проверки только равенства, интервала и подмножества.

##### Условия равенства
```
Client.where(locked: true)
```
Это сгенерирует такой SQL:
```
SELECT * FROM clients WHERE (clients.locked = 1)
```
Имя поля также может быть строкой, а не символом:
```
Client.where('locked' => true)
```
В случае отношений `belongs_to`, может быть использован ключ связи для указания модели, если как значение используется объект Active Record. Этот метод также работает с полиморфными отношениями.
```
Article.where(author: author)
Author.joins(:articles).where(articles: { author: author })
```
##### Интервальные условия
```
Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
```
Это найдет всех клиентов, созданных вчера, с использованием SQL выражения `BETWEEN`:
```
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
```
Это была демонстрация более короткого синтаксиса для примеров в Условия с использованием массива

##### Условия подмножества

Если хотите найти записи, используя выражение `IN`, можете передать массив в хэш условий:
```
Client.where(orders_count: [1,3,5])
```
Этот код сгенерирует подобный SQL:
```
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
```

#### Условия `NOT`

Запросы `NOT` в SQL могут быть созданы с помощью `where.not`:
```
Client.where.not(locked: true)
```
Другими словами, этот запрос может быть сгенерирован с помощью вызова where без аргументов и далее присоединенным `not` с переданными условиями для `where`. Это сгенерирует такой SQL:
```
SELECT * FROM clients WHERE (clients.locked != 1)
```

#### Условия `OR`

Условия `OR` между двумя отношениями могут быть построены путем вызова or на первом отношении и передачи второго в качестве аргумента.
```
Client.where(locked: true).or(Client.where(orders_count: [1,3,5]))
```
```
SELECT * FROM clients WHERE (clients.locked = 1 OR clients.orders_count IN (1,3,5))
```

### `Сортировка` <a name="2.6.3"></a>

Чтобы получить записи из базы данных в определенном порядке, можете использовать метод `order`.

Например, если вы получаете ряд записей и хотите упорядочить их в порядке возрастания поля `created_at` в таблице:
```
Client.order(:created_at)
# ИЛИ
Client.order("created_at")
```
Также можете определить `ASC` или `DESC`:
```
Client.order(created_at: :desc)
# ИЛИ
Client.order(created_at: :asc)
# ИЛИ
Client.order("created_at DESC")
# ИЛИ
Client.order("created_at ASC")
```
Или сортировку по нескольким полям:
```
Client.order(orders_count: :asc, created_at: :desc)
# ИЛИ
Client.order(:orders_count, created_at: :desc)
# ИЛИ
Client.order("orders_count ASC, created_at DESC")
# ИЛИ
Client.order("orders_count ASC", "created_at DESC")
```
**Если хотите вызвать `order` несколько раз, последующие сортировки будут добавлены к первой**:
```
Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC
```
> Если используется MySQL 5.7.5 и выше, то при выборе полей из результирующей выборки с помощью методов, таких как `select`, `pluck` и `ids`; метод `order` вызовет исключение `ActiveRecord::StatementInvalid`, если поля, используемые в выражении `order`, не включены в список выбора.

### Выбор определенных полей <a name="2.6.4"></a>

По умолчанию `Model.find` выбирает все множество полей результата, используя `select *`.

Чтобы выбрать подмножество полей из всего множества, можете определить его, используя метод `select`.

Например, чтобы выбрать только столбцы `viewable_by` и `locked`:
```
Client.select("viewable_by, locked")
```
Используемый для этого запрос SQL будет иметь подобный вид:
```
SELECT viewable_by, locked FROM clients
```
Будьте осторожны, поскольку это также означает, что будет инициализирован объект модели только с теми полями, которые вы выбрали. Если вы попытаетесь обратиться к полям, которых нет в инициализированной записи, то получите:
```
ActiveModel::MissingAttributeError: missing attribute: <attribute>
```
Где <attribute> это атрибут, который был запрошен. Метод `id` не вызывает `ActiveRecord::MissingAttributeError`, поэтому будьте аккуратны при работе со связями, так как они нуждаются в методе `id` для правильной работы.

Если хотите вытащить только по одной записи для каждого уникального значения в определенном поле, можно использовать `distinct`:
```
Client.select(:name).distinct
```
Это сгенерирует такой SQL:
```
SELECT DISTINCT name FROM clients
```
Также можно убрать ограничение уникальности:
```
query = Client.select(:name).distinct
# => Возвратит уникальные имена

query.distinct(false)
# => Возвратит все имена, даже если есть дубликаты
```
### Ограничение и смещение <a name="2.6.5"></a>
Чтобы применить `LIMIT` к SQL, запущенному с помощью `Model.find`, нужно определить LIMIT, используя методы `limit` и `offset` на relation.

Используйте `limit` для определения количества записей, которые будут получены, и `offset` - для числа записей, которые будут пропущены до начала возврата записей. Например:
```
Client.limit(5)
```
возвратит максимум 5 клиентов, и, поскольку не определено смещение, будут возвращены первые 5 клиентов в таблице. Выполняемый SQL будет выглядеть подобным образом:
```
SELECT * FROM clients LIMIT 5
```
Добавление `offset` к этому
```
Client.limit(5).offset(30)
```
Возвратит максимум 5 клиентов, начиная с 31-го. SQL выглядит так:
```
SELECT * FROM clients LIMIT 5 OFFSET 30
```

### Группировка <a name="2.6.6"></a>
Чтобы применить условие `GROUP BY` к SQL, можно использовать метод `group`.

Например, если хотите найти коллекцию дат, в которые были созданы заказы:
```
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
```
Это выдаст вам отдельный объект `Order` на каждую дату, для которой были заказы в базе данных.

SQL, который будет выполнен, будет выглядеть так:
```
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
```

#### Общее количество сгруппированных элементов

Чтобы получить общее количество сгруппированных элементов одним запросом, вызовите `count` после `group`.
```
Order.group(:status).count
# => { 'awaiting_approval' => 7, 'paid' => 12 }
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT COUNT (*) AS count_all, status AS status
FROM "orders"
GROUP BY status
```
### `Having` <a name="2.6.7"></a>

SQL использует условие `HAVING` для определения условий для полей, указанных в `GROUP BY`. Условие `HAVING`, определенное в SQL, запускается в `Model.find` с использованием метода `having` для поиска.

Например:
```
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)").having("sum(price) > ?", 100)
```
SQL, который будет выполнен, выглядит так:
```
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) > 100
```
Это возвращает дату и итоговую цену для каждого объекта заказа, сгруппированные по дню, когда они были заказаны, и где цена больше $100.

### Переопределяющие условия<a name="2.6.8"></a>
#### `unscope`

Можете указать определенные условия, которые будут убраны, используя метод `unscope`. Например:
```
Article.where('id > 10').limit(20).order('id asc').unscope(:order)
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE id > 10 LIMIT 20

# Оригинальный запрос без `unscope`
SELECT * FROM articles WHERE id > 10 ORDER BY id asc LIMIT 20
```

Также можно убрать определенные условия `where`. Например:
```
Article.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "articles".* FROM "articles" WHERE trashed = 0
```
Relation, использующий unscope повлияет на любой relation, в который он слит:
```
Article.order('id asc').merge(Article.unscope(:order))
# SELECT "articles".* FROM "articles"
```

#### `only`

Также можно переопределить условия, используя метод `only`. Например:
```
Article.where('id > 10').limit(20).order('id desc').only(:order, :where)
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE id > 10 ORDER BY id DESC

# Оригинальный запрос без `only`
SELECT * FROM articles WHERE id > 10 ORDER BY id DESC LIMIT 20
```

#### `reorder`

Метод `reorder` переопределяет сортировку скоупа по умолчанию. Например:
```
class Article < ApplicationRecord
  ..
  ..
  has_many :comments, -> { order('posted_at DESC') }
end

Article.find(10).comments.reorder('name')
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY name
```
В случае, когда условие reorder не было использовано, выполненный SQL будет:
```
SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY posted_at DESC
```

#### `reverse_order`

Метод `reverse_order` меняет направление условия сортировки, если оно определено:
```
Client.where("orders_count > 10").order(:name).reverse_order
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM clients WHERE orders_count > 10 ORDER BY name DESC
```
Если условие сортировки не было определено в запросе, `reverse_order` сортирует по первичному ключу в обратном порядке:
```
Client.where("orders_count > 10").reverse_order
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM clients WHERE orders_count > 10 ORDER BY clients.id DESC
```
Этот метод не принимает аргументы.

#### `rewhere`

Метод `rewhere` переопределяет существующее именованное условие `where`. Например:
```
Article.where(trashed: true).rewhere(trashed: false)
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE `trashed` = 0
```
В случае, когда не используется условие `rewhere`,
```
Article.where(trashed: true).where(trashed: false)
```
выполненный SQL будет следующий:
```
SELECT * FROM articles WHERE `trashed` = 1 AND `trashed` = 0
```

### Нулевой Relation <a name="2.6.9"></a>

Метод none возвращает сцепляемый `relation` без записей. Любые последующие условия, сцепленные с возвращенным `relation`, продолжат генерировать пустые `relation`. Это полезно в случаях, когда необходим сцепляемый отклик на метод или скоуп, который может вернуть пустые результаты.
```
Article.none # возвращает пустой Relation и не вызывает запросов.

# От метода visible_articles ожидается, что он вернет Relation.
@articles = current_user.visible_articles.where(name: params[:name])

def visible_articles
  case role
  when 'Country Manager'
    Article.where(country: country)
  when 'Reviewer'
    Article.published
  when 'Bad User'
    Article.none # => если бы вернули [] или nil, код поломался бы в этом случае
  end
end
```

### Объекты только для чтения <a name="2.6.10"></a>

Active Record предоставляет relation метод `readonly` для явного запрета на модификацию любого из возвращаемых объектов. Любая попытка изменить запись, доступную только для чтения, не удастся, вызвав исключение `ActiveRecord::ReadOnlyRecord`.
```
client = Client.readonly.first
client.visits += 1
client.save
```
Так как `client` явно указан как объект доступный только для чтения, выполнение вышеуказанного кода выдаст исключение `ActiveRecord::ReadOnlyRecord` при вызове `client.save` с обновленным значением `visits`.


### `Блокировка записей для обновления` <a name="2.6.11"></a>

Блокировка полезна для предотвращения состояния гонки при обновлении записей в базе данных и обеспечения атомарного обновления.

Active Record предоставляет два механизма блокировки:
* Оптимистическая блокировка
* Пессимистическая блокировка 

#### Оптимистическая блокировка

Оптимистическая блокировка позволяет нескольким пользователям обращаться к одной и той же записи для редактирования и предполагает минимум конфликтов с данными. Она осуществляет это с помощью проверки, внес ли другой процесс изменения в записи, с тех пор как она была открыта. Если это происходит, вызывается исключение `ActiveRecord::StaleObjectError`, и обновление игнорируется.

**Столбец оптимистической блокировки**

Чтобы начать использовать оптимистическую блокировку, таблица должна иметь столбец, называющийся `lock_version`, с типом `integer`. Каждый раз, когда запись обновляется, Active Record увеличивает значение `lock_version`, и средства блокирования обеспечивают, что для записи, вызванной дважды, та, которая первая успеет, будет сохранена, а для второй будет вызвано исключение `ActiveRecord::StaleObjectError`. Пример:
```
c1 = Client.find(1)
c2 = Client.find(1)

c1.first_name = "Michael"
c1.save

c2.name = "should fail"
c2.save # вызывает исключение ActiveRecord::StaleObjectError
```
Вы ответственны за разрешение конфликта с помощью обработки исключения и либо отката, либо объединения, либо применения бизнес-логики, необходимой для разрешения конфликта.

Это поведение может быть отключено, если установить `ActiveRecord::Base.lock_optimistically = false`.

Для переопределения имени столбца `lock_version`, `ActiveRecord::Base` предоставляет атрибут класса `locking_column`:
```
class Client < ApplicationRecord
  self.locking_column = :lock_client_column
end
```
#### Пессимистическая блокировка

Пессимистическая блокировка использует механизм блокировки, предоставленный лежащей в основе базой данных. Использование `lock` при построении relation применяет эксклюзивную блокировку для выбранных строк. Relations, которые используют `lock`, обычно упакованы внутри `transaction` для предотвращения условий взаимной блокировки (дедлока).

Например:
```
Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save!
end
```
Вышеописанная сессия осуществляет следующие SQL для бэкенда MySQL:
```
SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT
```
Также можно передать чистый SQL в опцию `lock` для разрешения различных типов блокировок. Например, в MySQL есть выражение, называющееся `LOCK IN SHARE MODE`, которым можно заблокировать запись, но все же разрешить другим запросам читать ее. Чтобы указать это выражения, просто передайте его как опцию блокировки:
```
Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
end
```
Если у вас уже имеется экземпляр модели, можно одновременно начать транзакцию и затребовать блокировку, используя следующий код:
```
item = Item.first
item.with_lock do
  # Этот блок вызывается в транзакции,
  # элемент уже заблокирован.
  item.increment!(:views)
end
```

### Соединительные таблицы <a name="2.6.12"></a>

Active Record предоставляет два метода поиска для определения условия `JOIN` в результирующем SQL: `joins` и `left_outer_joins`. В то время, как `joins` следует использовать для `INNER JOIN` или пользовательских запросов, `left_outer_joins` используется для запросов с помощью `LEFT OUTER JOIN`.

#### `joins`

Существует несколько способов использования метода `joins`

##### Использование строкового фрагмента SQL

Можно просто передать чистый SQL, определяющий условие `JOIN` в `joins`.
```
Author.joins("INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'")
```
Это приведет к следующему SQL:
```
SELECT authors.* FROM authors INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'
```

##### Использование массива/хэша именованных связей

Active Record позволяет использовать имена связей, определенных в модели, как ярлыки для определения условия `JOIN` этих связей при использовании метода `joins`.

Например, рассмотрим следующие модели `Category`, `Article`, `Comment`, `Guest` и `Tag`:
```
class Category < ApplicationRecord
  has_many :articles
end

class Article < ApplicationRecord
  belongs_to :category
  has_many :comments
  has_many :tags
end

class Comment < ApplicationRecord
  belongs_to :article
  has_one :guest
end

class Guest < ApplicationRecord
  belongs_to :comment
end

class Tag < ApplicationRecord
  belongs_to :article
end
```
Сейчас все нижеследующее создаст ожидаемые соединительные запросы с использованием `INNER JOIN`:

###### Соединение одиночной связи
```
Category.joins(:articles)
```
Это создаст:
```
SELECT categories.* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id
```
Или, по-русски, "возвратить объект Category для всех категорий со статьями". Обратите внимание, что будут дублирующиеся категории, если более одной статьи имеют одинаковые категорию. Если нужны уникальные категории, можно использовать 
```
Category.joins(:articles).distinct.
```
###### Соединение нескольких связей
```
Article.joins(:category, :comments)
```
Это создаст:
```
SELECT articles.* FROM articles
  INNER JOIN categories ON categories.id = articles.category_id
  INNER JOIN comments ON comments.article_id = articles.id
```
Или, по-русски, "возвратить все статьи, у которых есть категория и как минимум один комментарий". Отметьте, что статьи с несколькими комментариями будут показаны несколько раз.

###### Соединение вложенных связей (одного уровня)
```
Article.joins(comments: :guest)
```
Это создаст:
```
SELECT articles.* FROM articles
  INNER JOIN comments ON comments.article_id = articles.id
  INNER JOIN guests ON guests.comment_id = comments.id
```
Или, по-русски, "возвратить все статьи, в которых есть комментарий, оставленный гостем".

##### Определение условий в соединительных таблицах

В соединительных таблицах можно определить условия, используя обычные массивные и строковые условия. Условия с использованием хэша предоставляют специальный синтаксис для определения условий в соединительных таблицах:
```
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where('orders.created_at' => time_range)
```
Альтернативный и более чистый синтаксис для этого - вложенные хэш-условия:
```
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where(orders: { created_at: time_range })
```
Будут найдены все клиенты, имеющие созданные вчера заказы, снова используя выражение SQL `BETWEEN`.

#### `left_outer_joins`

Если хотите выбрать ряд записей, независимо от того, имеют ли они связанные записи, можно использовать метод `left_outer_joins`.
```
Author.left_outer_joins(:posts).distinct.select('authors.*, COUNT(posts.*) AS posts_count').group('authors.id')
```
Который создаст:
```
SELECT DISTINCT authors.*, COUNT(posts.*) AS posts_count FROM "authors"
LEFT OUTER JOIN posts ON posts.author_id = authors.id GROUP BY authors.id
```
### Нетерпеливая загрузка связей <a name="2.6.13"></a>

Нетерпеливая загрузка - это механизм загрузки связанных записей объекта, возвращаемых `Model.find`, с использованием как можно меньшего количества запросов.

Проблема N + 1 запроса

Рассмотрим следующий код, который находит 10 клиентов и выводит их почтовые индексы:
```
clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end
```
На первый взгляд выглядит хорошо. Но проблема лежит в общем количестве выполненных запросов. Вышеупомянутый код выполняет 1 (чтобы найти 10 клиентов) + 10 (каждый на одного клиента для загрузки адреса) = итого 11 запросов.
Что означает: "возвратить всех авторов и количество их публикаций, независимо от того, имеются ли у них вообще публикации".

**Решение проблемы N + 1 запроса**

Active Record позволяет заранее указать все связи, которые должны быть загружены. Это возможно с помощью указания метода `includes` на вызове `Model.find`. Посредством `includes`, Active Record обеспечивает то, что все указанные связи загружаются с использованием минимально возможного количества запросов.

Пересмотрев вышеупомянутую задачу, можно переписать `Client.limit(10)`, чтобы нетерпеливо загрузить адреса:
```
clients = Client.includes(:address).limit(10)

clients.each do |client|
  puts client.address.postcode
end
```
Этот код выполнит всего 2 запроса, вместо 11 запросов из прошлого примера:
```
SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
```

#### Нетерпеливая загрузка нескольких связей
Массив нескольких связей
```
Article.includes(:category, :comments)
```
Это загрузит все статьи и связанные категорию, и комментарии для каждой статьи.

#### Вложенный хэш связей
```
Category.includes(articles: [{ comments: :guest }, :tags]).find(1)
```
Вышеприведенный код находит категории с `id 1` и нетерпеливо загружает все связанные статьи, теги и комментарии каждой статьи, а также гостей, связанных с комментариями.

#### Определение условий для нетерпеливой загрузки связей

Хотя Active Record и позволяет определить условия для нетерпеливой загрузки связей точно так же, как и в `joins`, рекомендуем использовать вместо этого `joins`.

Однако, если сделать так, то можно использовать `where` как обычно.
```
Article.includes(:comments).where(comments: { visible: true })
```
Это сгенерирует запрос с ограничением `LEFT OUTER JOIN`, в то время как метод `joins` сгенерировал бы его с использованием функции `INNER JOIN`.
```
  SELECT "articles"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "articles"
    LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE (comments.visible = 1)
```
Если бы не было условия `where`, то сгенерировался бы обычный набор из двух запросов.

> Использование where подобным образом будет работать только, если передавать в него хэш. Для фрагментов SQL необходимо использовать `references` для принуждения соединения таблиц:
```
Article.includes(:comments).where("comments.visible = true").references(:comments)
```
Если, в случае с этим запросом `includes`, не будет ни одного комментария ни для одной статьи, все статьи все равно будут загружены. При использовании `joins` (`INNER JOIN`), соединительные условия должны соответствовать, иначе ни одной записи не будет возвращено.

> Если связь нетерпеливо загружена как часть `join`, любые поля из произвольного выражения `select` не будут присутствовать в загруженных моделях. Это так, потому что это избыточность, которая должна появиться или в родительской модели, или в дочерней.

### Скоупы <a name="2.6.14"></a>
Скоупы позволяют задавать часто используемые запросы, к которым можно обращаться как к вызовам метода в связанных объектах или моделях. С помощью этих скоупов можно использовать каждый ранее раскрытый метод, такой как `where`, `joins` и `includes`. Все методы скоупов возвращают объект `ActiveRecord::Relation`, который позволяет вызывать на нем дополнительные методы (такие как другие скоупы).

Для определения простого скоупа мы используем метод scope внутри класса, передав запрос, который хотим запустить при вызове этого скоупа:
```
class Article < ApplicationRecord
  scope :published, -> { where(published: true) }
end
```
Это в точности то же самое, что определение метода класса, и то, что именно вы используете, является вопросом профессионального предпочтения:
```
class Article < ApplicationRecord
  def self.published
    where(published: true)
  end
end
```
Скоупы также сцепляются с другими скоупами:
```
class Article < ApplicationRecord
  scope :published,               -> { where(published: true) }
  scope :published_and_commented, -> { published.where("comments_count > 0") }
end
```
Для вызова скоупа `published`, можно вызвать его либо на классе:
```
Article.published # => [опубликованные статьи]
```
Либо на связи, состоящей из объектов `Article`:
```
category = Category.first
category.articles.published # => [опубликованные статьи, принадлежащие этой категории]
```

#### Передача аргумента

Скоуп может принимать аргументы:
```
class Article < ApplicationRecord
  scope :created_before, ->(time) { where("created_at < ?", time) }
end
```
Вызывайте скоуп, как будто это метод класса:
```
Article.created_before(Time.zone.now)
```
Однако, это всего лишь дублирование функциональности, которая должна быть предоставлена методом класса.
```
class Article < ApplicationRecord
  def self.created_before(time)
    where("created_at < ?", time)
  end
end
```
Использование метода класса - более предпочтительный способ принятию аргументов скоупом. Эти методы также будут доступны на связанных объектах:
```
category.articles.created_before(time)
```

#### Использование условий

Ваши скоупы могут использовать условия:
```
class Article < ApplicationRecord
  scope :created_before, ->(time) { where("created_at < ?", time) if time.present? }
end
```
Подобно остальным примерам, это ведет себя подобно методу класса.
```
class Article < ApplicationRecord
  def self.created_before(time)
    where("created_at < ?", time) if time.present?
  end
end
```
Однако, имеется одно важное предостережение: скоуп всегда должен возвращать объект `ActiveRecord::Relation`, даже если условие вычисляется `false`, в отличие от метода класса, возвращающего `nil`. Это может вызвать `NoMethodError` при сцеплении методов класса с условиями, если одно из условий вернет `false`.

#### Применение скоупа по умолчанию

Если хотите, чтобы скоуп был применен ко всем запросам модели, можно использовать метод `default_scope` в самой модели.
```
class Client < ApplicationRecord
  default_scope { where("removed_at IS NULL") }
end
```
Когда запросы для этой модели будут выполняться, запрос SQL теперь будет выглядеть примерно так:
```
SELECT * FROM clients WHERE removed_at IS NULL
```
Если необходимо сделать более сложные вещи со скоупом по умолчанию, альтернативно его можно определить как метод класса:
```
class Client < ApplicationRecord
  def self.default_scope
    # Должен возвращать ActiveRecord::Relation.
  end
end
```
`default_scope` также применяется при создании записи, когда аргументы скоупа передаются как Hash. Он не применяется при обновлении записи. То есть:
```
class Client < ApplicationRecord
  default_scope { where(active: true) }
end

Client.new          # => #<Client id: nil, active: true>
Client.unscoped.new # => #<Client id: nil, active: nil>
```
Имейте в виду, что когда передаются в формате Array, аргументы запроса `default_scope` не могут быть преобразованы в Hash для назначения атрибутов по умолчанию. То есть:
```
class Client < ApplicationRecord
  default_scope { where("active = ?", true) }
end

Client.new # => #<Client id: nil, active: nil>
```

#### Объединение скоупов

Подобно условиям where, скоупы объединяются с использованием `AND`.
```
class User < ApplicationRecord
  scope :active, -> { where state: 'active' }
  scope :inactive, -> { where state: 'inactive' }
end

User.active.inactive
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'
```
Можно комбинировать условия `scope` и `where`, и результирующий sql будет содержать все условия, соединенные с помощью `AND`.
```
User.active.where(state: 'finished')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'
```
Если необходимо, чтобы сработало только **последнее условие where**, тогда можно использовать `Relation#merge`.
```
User.active.merge(User.inactive)
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
```
Важным предостережением является то, что `default_scope` **переопределяется условиями `scope` и `where`**.
```
class User < ApplicationRecord
  default_scope { where state: 'pending' }
  scope :active, -> { where state: 'active' }
  scope :inactive, -> { where state: 'inactive' }
end

User.all
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'

User.active
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active'

User.where(state: 'inactive')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
```
Как видите, `default_scope` объединяется как со `scope`, так и с `where` условиями.

#### Удаление всех скоупов

Если хотите удалить скоупы по какой-то причине, можете использовать метод `unscoped`. Это особенно полезно, если в модели определен `default_scope`, и он не должен быть применен для конкретно этого запроса.
```
Client.unscoped.load
```
Этот метод удаляет все скоупы и выполняет обычный запрос к таблице.
```
Client.unscoped.all
# SELECT "clients".* FROM "clients"

Client.where(published: false).unscoped.all
# SELECT "clients".* FROM "clients"
```
`unscoped` также может принимать блок.
```
Client.unscoped {
  Client.created_before(Time.zone.now)
}
```
### Динамический поиск <a name="2.6.15"></a>

Для каждого поля (также называемого атрибутом), определенного в вашей таблице, Active Record предоставляет метод поиска. Например, если есть поле `first_name` в вашей модели `Client`, вы автоматически получаете `find_by_first_name` от Active Record. Если также есть поле `locked` в модели `Client`, вы также получаете `find_by_locked` метод.

Можете определить восклицательный знак (`!`) в конце динамического поиска, чтобы он вызвал ошибку `ActiveRecord::RecordNotFound`, если не возвратит ни одной записи, например так `Client.find_by_name!("Ryan")`

Если хотите искать и по `first_name`, и по `locked`, можете сцепить эти поиски вместе, просто написав "`and`" между полями, например, `Client.find_by_first_name_and_locked("Ryan", true)`.

### `Enum` <a name="2.6.16"></a>

Макрос `enum` связывает числовой столбец с набором возможных значений.
```
class Book < ApplicationRecord
  enum availability: [:available, :unavailable]
end
```
Это автоматически создаст соответствующие скоупы для запроса модели. Также добавляются методы для перехода между состояниями и запроса текущего состояния.
```
# Оба примера ниже запрашивают только доступные книги.
Book.available
# или
Book.where(availability: :available)

book = Book.new(availability: :available)
book.available?   # => true
book.unavailable! # => true
book.available?   # => false
```
Полную документацию об `enum` можно прочитать в <a href="https://api.rubyonrails.org/classes/ActiveRecord/Enum.html">документации Rails API</a>.

### Цепочки методов <a name="2.6.17"></a>

В Active Record есть полезный приём программирования Method Chaining, который позволяет нам комбинировать множество Active Record методов.

Можно сцепить несколько методов в единое выражение, если предыдущий вызываемый метод возвращает `ActiveRecord::Relation`, такие как `all`, `where` и `joins`. Методы, которые возвращают одиночный объект (смотрите раздел Получение одиночного объекта) должны вызываться в конце.

Ниже представлены несколько примеров. Это руководство не покрывает все возможности, а только некоторые, для ознакомления. Когда вызывается Active Record метод, запрос не сразу генерируется и отправляется в базу, это происходит только тогда, когда данные реально необходимы. Таким образом, каждый пример ниже генерирует только один запрос.

#### Получение отфильтрованных данных из нескольких таблиц
```
Person
  .select('people.id, people.name, comments.text')
  .joins(:comments)
  .where('comments.created_at > ?', 1.week.ago)
```
Результат должен быть примерно следующим:
```
SELECT people.id, people.name, comments.text
FROM people
INNER JOIN comments
  ON comments.person_id = people.id
WHERE comments.created_at > '2015-01-01'
```

#### Получение определённых данных из нескольких таблиц
```
Person
  .select('people.id, people.name, companies.name')
  .joins(:company)
  .find_by('people.name' => 'John') # это должно быть в конце
```
Выражение выше, сгенерирует следующий SQL-запрос:
```
SELECT people.id, people.name, companies.name
FROM people
INNER JOIN companies
  ON companies.person_id = people.id
WHERE people.name = 'John'
LIMIT 1
```
> Обратите внимание, что если запросу соответствует несколько записей, `find_by` вернет только первую запись и проигнорирует остальные (смотрите `LIMIT 1` выше).

### Поиск или создание нового объекта <a name="2.6.18"></a>

Часто бывает, что вам нужно найти запись или создать ее, если она не существует. Вы можете сделать это с помощью методов `find_or_create_by` и `find_or_create_by!`.

#### `find_or_create_by`

Метод `find_or_create_by` проверяет, существует ли запись с определенными атрибутами. Если нет, то вызывается `create`. Давайте рассмотрим пример.

Предположим, вы хотите найти клиента по имени 'Andy', и, если такого нет, создать его. Это можно сделать, выполнив:
```
Client.find_or_create_by(first_name: 'Andy')
# => #<Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">
```
SQL, генерируемый этим методом, будет выглядеть так:
```
SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT
```
`find_or_create_by` возвращает либо уже существующую запись, либо новую запись. В нашем случае, у нас еще нет клиента с именем Andy, поэтому запись будет создана и возвращена.

Новая запись может быть не сохранена в базу данных; это зависит от того, прошли валидации или нет (подобно `create`).

Предположим, мы хотим установить атрибут `'locked'` как `false`, если создаем новую запись, но не хотим включать его в запрос. Таким образом, мы хотим найти клиента по имени "Andy" или, если этот клиент не существует, создать клиента по имени "Andy", который не заблокирован.

Этого можно достичь двумя способами. Первый - это использование `create_with`:
```
Client.create_with(locked: false).find_or_create_by(first_name: 'Andy')
```
Второй способ - это использование блока:
```
Client.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end
```
Блок будет выполнен, только если клиент был создан. Во второй раз, при запуске этого кода, блок будет проигнорирован.

#### `find_or_create_by!`

Можно также использовать `find_or_create_by!`, чтобы вызвать исключение, если новая запись невалидна. Валидации не раскрываются в этом руководстве, но давайте на момент предположим, что вы временно добавили
```
validates :orders_count, presence: true
```
в модель `Client`. Если попытаетесь создать нового `Client` без передачи `orders_count`, запись будет невалидной и будет вызвано исключение:
```
Client.find_or_create_by!(first_name: 'Andy')
# => ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank
```
#### `find_or_initialize_by`

Метод `find_or_initialize_by` работает похоже на `find_or_create_by`, но он вызывает не `create`, а `new`. Это означает, что новый экземпляр модели будет создан в памяти, но не будет сохранен в базу данных. Продолжая пример с `find_or_create_by`, теперь нам нужен клиент по имени 'Nick':
```
nick = Client.find_or_initialize_by(first_name: 'Nick')
# => #<Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">

nick.persisted?
# => false

nick.new_record?
# => true
```
Поскольку объект еще не сохранен в базу данных, сгенерированный SQL выглядит так:
```
SELECT * FROM clients WHERE (clients.first_name = 'Nick') LIMIT 1
```
Когда захотите сохранить его в базу данных, просто вызовите `save`:
```
nick.save
# => true
```
### Поиск с помощью SQL <a name="2.6.19"></a>

Если вы предпочитаете использовать собственные запросы SQL для поиска записей в таблице, можете использовать `find_by_sql`. Метод `find_by_sql` возвратит массив объектов, даже если лежащий в основе запрос вернет всего лишь одну запись. Например, можете запустить такой запрос:
```
Client.find_by_sql("SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc")
# =>  [
#   #<Client id: 1, first_name: "Lucas" >,
#   #<Client id: 2, first_name: "Jan" >,
#   ...
# ]
```
`find_by_sql` предоставляет простой способ создания произвольных запросов к базе данных и получения экземпляров объектов.

#### `select_all`

У `find_by_sql` есть близкий родственник, называемый `connection#select_all`. `select_all` получит объекты из базы данных, используя произвольный SQL, как и в `find_by_sql`, но не создаст их экземпляры. Этот метод вернет экземпляр класса `ActiveRecord::Result` и вызвав `to_hash` на этом объекте вернет массив хэшей, где каждый хэш указывает на запись.
```
Client.connection.select_all("SELECT first_name, created_at FROM clients WHERE id = '1'").to_hash
# => [
#   {"first_name"=>"Rafael", "created_at"=>"2012-11-10 23:23:45.281189"},
#   {"first_name"=>"Eileen", "created_at"=>"2013-12-09 11:22:35.221282"}
# ]
```

#### `pluck`

`pluck` может быть использован для запроса с одним или несколькими столбцами из таблицы, лежащей в основе модели. Он принимает список имен столбцов как аргумент и возвращает массив значений определенных столбцов соответствующего типа данных.
```
Client.where(active: true).pluck(:id)
# SELECT id FROM clients WHERE active = 1
# => [1, 2, 3]

Client.distinct.pluck(:role)
# SELECT DISTINCT role FROM clients
# => ['admin', 'member', 'guest']

Client.pluck(:id, :name)
# SELECT clients.id, clients.name FROM clients
# => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
```
`pluck` позволяет заменить такой код:
```
Client.select(:id).map { |c| c.id }
# или
Client.select(:id).map(&:id)
# или
Client.select(:id, :name).map { |c| [c.id, c.name] }
```
на:
```
Client.pluck(:id)
# или
Client.pluck(:id, :name)
```
В отличие от `select`, `pluck` непосредственно конвертирует результат запроса в массив Ruby, без создания объектов ActiveRecord. Это может означать лучшую производительность для больших или часто используемых запросов. Однако, любые **переопределения методов в модели будут недоступны**. Например:
```
class Client < ApplicationRecord
  def name
    "I am #{super}"
  end
end

Client.select(:name).map &:name
# => ["I am David", "I am Jeremy", "I am Jose"]

Client.pluck(:name)
# => ["David", "Jeremy", "Jose"]
```
Более того, в отличие от `select` и других скоупов Relation, `pluck` вызывает немедленный запрос, и поэтому **не может быть соединен с любыми последующими скоупами, хотя он может работать со скоупами, подключенными ранее**:
```
Client.pluck(:name).limit(1)
# => NoMethodError: undefined method `limit' for #<Array:0x007ff34d3ad6d8>

Client.limit(1).pluck(:name)
# => ["David"]
```

#### `ids`

`ids` может быть использован для сбора всех ID для relation, используя первичный ключ таблицы.
```
Person.ids
# SELECT id FROM people
```
```
class Person < ApplicationRecord
  self.primary_key = "person_id"
end

Person.ids
# SELECT person_id FROM people
```

### Существование объектов <a name="2.6.20"></a>

Если вы просто хотите проверить существование объекта, есть метод, называемый `exists?`. Этот метод запрашивает базу данных, используя тот же запрос, что и `find`, но вместо возврата объекта или коллекции объектов, он возвращает или `true`, или `false`.
```
Client.exists?(1)
```

Метод `exists?` также принимает несколько значений, при этом возвращает `true`, если хотя бы одна из этих записей существует.
```
Client.exists?(id: [1,2,3])
# или
Client.exists?(name: ['John', 'Sergei'])
```
Даже возможно использовать `exists?` без аргументов на модели или `relation`:
```
Client.where(first_name: 'Ryan').exists?
```
Пример выше вернет `true`, если есть хотя бы один клиент с `first_name 'Ryan'`, и `false` в противном случае.
```
Client.exists?
```
Это возвратит `false`, если таблица `clients` пустая, и `true` в противном случае.

Для проверки на существование также можно использовать `any?` и `many?` на модели или relation.
```
# на модели
Article.any?
Article.many?

# на именованном скоупе
Article.recent.any?
Article.recent.many?

# на relation
Article.where(published: true).any?
Article.where(published: true).many?

# на связи
Article.first.categories.any?
Article.first.categories.many?
```

### Вычисления <a name="2.6.21"></a>

Этот раздел использует count для примера в этой преамбуле, но описанные опции применяются ко всем подразделам.

Все методы вычисления работают прямо на модели:
```
Client.count
# SELECT COUNT(*) FROM clients
```
Или на relation:
```
Client.where(first_name: 'Ryan').count
# SELECT COUNT(*) FROM clients WHERE (first_name = 'Ryan')
```
Можно также использовать различные методы поиска на relation для выполнения сложных вычислений:
```
Client.includes("orders").where(first_name: 'Ryan', orders: { status: 'received' }).count
```
Что выполнит:
```
SELECT COUNT(DISTINCT clients.id) FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = clients.id
  WHERE (clients.first_name = 'Ryan' AND orders.status = 'received')
```

#### Количество

Если хотите увидеть, сколько записей есть в таблице модели, можете вызвать `Client.count`, и он возвратит число. Если хотите быть более определенным и найти всех клиентов с присутствующим в базе данных возрастом, используйте `Client.count(:age)`.

#### Среднее

Если хотите увидеть среднее значение определенного показателя в одной из ваших таблиц, можно вызвать метод `average` для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.average("orders_count")
```
Это возвратит число (возможно, с плавающей запятой, такое как 3.14159265), представляющее среднее значение поля.

#### Минимум

Если хотите найти минимальное значение поля в таблице, можете вызвать метод minimum для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.minimum("age")
```

#### Максимум

Если хотите найти максимальное значение поля в таблице, можете вызвать метод maximum для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.maximum("age")
```

#### Сумма

Если хотите найти сумму полей для всех записей в таблице, можете вызвать метод sum для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.sum("orders_count")
```

### Запуск EXPLAIN <a name="2.6.22"></a>

Можно запустить `EXPLAIN` на запросах, вызываемых в relations. Например,
```
User.where(id: 1).joins(:articles).explain
```

может выдать
```
EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+----------+-------+---------------+
| id | select_type | table    | type  | possible_keys |
+----+-------------+----------+-------+---------------+
|  1 | SIMPLE      | users    | const | PRIMARY       |
|  1 | SIMPLE      | articles | ALL   | NULL          |
+----+-------------+----------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)
```
для MySQL и MariaDB.

Active Record применяет красивое форматирование, эмулирующее работу соответствующей оболочки базы данных. Таким образом, запуск того же запроса с адаптером PostgreSQL выдаст вместо этого
```
EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "articles" ON "articles"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (articles.user_id = users.id)
   ->  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   ->  Seq Scan on articles  (cost=0.00..28.88 rows=8 width=4)
         Filter: (articles.user_id = 1)
(6 rows)
```
Нетерпеливая загрузка может вызвать более одного запроса за раз, и некоторым запросам могут потребоваться результаты предыдущих. Поэтому `explain` фактически выполняет запрос, а затем запрашивает планы запросов. Например,
```
User.where(id: 1).includes(:articles).explain
```
выдаст
```
EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+
| id | select_type | table | type  | possible_keys |
+----+-------------+-------+-------+---------------+
|  1 | SIMPLE      | users | const | PRIMARY       |
+----+-------------+-------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `articles`.* FROM `articles`  WHERE `articles`.`user_id` IN (1)
+----+-------------+----------+------+---------------+
| id | select_type | table    | type | possible_keys |
+----+-------------+----------+------+---------------+
|  1 | SIMPLE      | articles | ALL  | NULL          |
+----+-------------+----------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+
```

1 row in set (0.00 sec)

для MySQL и MariaDB

## Active Record для PostgreSQL <a name="2.7"></a>
### Типы данных <a name="2.7.1"></a>
PostgreSQL предлагает достаточное количество специфичных типов данных. Далее представлен список типов, которые поддерживаются адаптером PostgreSQL.
#### Двоичные типы данных
```
# db/migrate/20140207133952_create_documents.rb
create_table :documents do |t|
  t.binary 'payload'
end

# app/models/document.rb
class Document < ApplicationRecord
end

# Использование
data = File.read(Rails.root + "tmp/output.pdf")
Document.create payload: data
```
#### Массивы
```
# db/migrate/20140207133952_create_books.rb
create_table :books do |t|
  t.string 'title'
  t.string 'tags', array: true
  t.integer 'ratings', array: true
end
add_index :books, :tags, using: 'gin'
add_index :books, :ratings, using: 'gin'

# app/models/book.rb
class Book < ApplicationRecord
end

# Использование
Book.create title: "Brave New World",
            tags: ["fantasy", "fiction"],
            ratings: [4, 5]

## Книги с одним тегом
Book.where("'fantasy' = ANY (tags)")

## Книги с несколькими тегами
Book.where("tags @> ARRAY[?]::varchar[]", ["fantasy", "fiction"])

## Книги с рейтингом 3 и более
Book.where("array_length(ratings, 1) >= 3")
```
#### `Hstore`
> Чтобы использовать `hstore`, необходимо включить расширение `hstore`.
```
# db/migrate/20131009135255_create_profiles.rb
ActiveRecord::Schema.define do
  enable_extension 'hstore' unless extension_enabled?('hstore')
  create_table :profiles do |t|
    t.hstore 'settings'
  end
end

# app/models/profile.rb
class Profile < ApplicationRecord
end

# Использование
Profile.create(settings: { "color" => "blue", "resolution" => "800x600" })

profile = Profile.first
profile.settings # => {"color"=>"blue", "resolution"=>"800x600"}

profile.settings = {"color" => "yellow", "resolution" => "1280x1024"}
profile.save!

Profile.where("settings->'color' = ?", "yellow")
# => #<ActiveRecord::Relation [#<Profile id: 1, settings: {"color"=>"yellow", "resolution"=>"1280x1024"}>]>
```
#### `JSON` и `JSONB`
```
# db/migrate/20131220144913_create_events.rb
# ... для типа данных json:
create_table :events do |t|
  t.json 'payload'
end
# ... или для типа данных jsonb:
create_table :events do |t|
  t.jsonb 'payload'
end

# app/models/event.rb
class Event < ApplicationRecord
end

# Использование
Event.create(payload: { kind: "user_renamed", change: ["jack", "john"]})

event = Event.first
event.payload # => {"kind"=>"user_renamed", "change"=>["jack", "john"]}

## Запрос, основанный на JSON документе
# Оператор -> возвращает исходный JSON тип (который может быть объектом), где ->> возвращает текст
Event.where("payload->>'kind' = ?", "user_renamed")
```
#### Диапазонные типы
Этот тип преобразуется в `Ruby Range` объекты.
```
# db/migrate/20130923065404_create_events.rb
create_table :events do |t|
  t.daterange 'duration'
end

# app/models/event.rb
class Event < ApplicationRecord
end

# Использование
Event.create(duration: Date.new(2014, 2, 11)..Date.new(2014, 2, 12))

event = Event.first
event.duration # => Tue, 11 Feb 2014...Thu, 13 Feb 2014

## Все события в заданную дату
Event.where("duration @> ?::date", Date.new(2014, 2, 12))

## Работает с границами диапазона
event = Event.
  select("lower(duration) AS starts_at").
  select("upper(duration) AS ends_at").first

event.starts_at # => Tue, 11 Feb 2014
event.ends_at # => Thu, 13 Feb 2014
```
#### Составные типы
На данный момент нет специальной поддержки для составных типов. Они преобразуются к обычным текстовым столбцам:
```
CREATE TYPE full_address AS
(
  city VARCHAR(90),
  street VARCHAR(90)
);
```
```
# db/migrate/20140207133952_create_contacts.rb
execute <<-SQL
 CREATE TYPE full_address AS
 (
   city VARCHAR(90),
   street VARCHAR(90)
 );
SQL
create_table :contacts do |t|
  t.column :address, :full_address
end

# app/models/contact.rb
class Contact < ApplicationRecord
end

# Использование
Contact.create address: "(Paris,Champs-Élysées)"
contact = Contact.first
contact.address # => "(Paris,Champs-Élysées)"
contact.address = "(Paris,Rue Basse)"
contact.save!
```
#### Типы перечислений

На данный момент нет специальной поддержки для типов перечислений. Они преобразуются к обычным текстовым столбцам:
```
# db/migrate/20131220144913_create_articles.rb
def up
  execute <<-SQL
    CREATE TYPE article_status AS ENUM ('draft', 'published');
  SQL
  create_table :articles do |t|
    t.column :status, :article_status
  end
end

# NOTE: Не забываем удалить таблицу перед удалением enum.
def down
  drop_table :articles

  execute <<-SQL
    DROP TYPE article_status;
  SQL
end

# app/models/article.rb
class Article < ApplicationRecord
end

# Использование
Article.create status: "draft"
article = Article.first
article.status # => "draft"

article.status = "published"
article.save!
```
Чтобы добавить новое значение до/после существующего, следует использовать `ALTER TYPE`:
```
# db/migrate/20150720144913_add_new_state_to_articles.rb
# NOTE: ALTER TYPE ... ADD VALUE нельзя выполнить в блоке транзакции, поэтому используется disable_ddl_transaction!
disable_ddl_transaction!

def up
  execute <<-SQL
    ALTER TYPE article_status ADD VALUE IF NOT EXISTS 'archived' AFTER 'published';
  SQL
end
```
> Значения `ENUM` сейчас нельзя удалять.

Hint: Чтобы показать все имеющиеся значения enum, можно выполнить этот запрос в консоле bin/rails db или psql:
```
SELECT n.nspname AS enum_schema,
       t.typname AS enum_name,
       e.enumlabel AS enum_value
  FROM pg_type t
      JOIN pg_enum e ON t.oid = e.enumtypid
      JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
```
#### Тип `UUID`
> Для использования `uuid` необходимо включить расширение `pgcrypto` (только PostgreSQL >= 9.4).
```
Тип UUID

    определение типа
    pgcrypto generator function
    uuid-ossp generator functions 

Для использования uuid необходимо включить расширение pgcrypto (только PostgreSQL >= 9.4).

# db/migrate/20131220144913_create_revisions.rb
create_table :revisions do |t|
  t.uuid :identifier
end

# app/models/revision.rb
class Revision < ApplicationRecord
end

# Использование
Revision.create identifier: "A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11"

revision = Revision.first
revision.identifier # => "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11"

Вы можете использовать тип uuid для определения ссылок в миграции:

# db/migrate/20150418012400_create_blog.rb
enable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')
create_table :posts, id: :uuid, default: 'gen_random_uuid()'

create_table :comments, id: :uuid, default: 'gen_random_uuid()' do |t|
  # t.belongs_to :post, type: :uuid
  t.references :post, type: :uuid
end

# app/models/post.rb
class Post < ApplicationRecord
  has_many :comments
end

# app/models/comment.rb
class Comment < ApplicationRecord
  belongs_to :post
end
```
#### Битовые строки
```
# db/migrate/20131220144913_create_users.rb
create_table :users, force: true do |t|
  t.column :settings, "bit(8)"
end

# app/models/user.rb
class User < ApplicationRecord
end

# Использование
User.create settings: "01010011"
user = User.first
user.settings # => "01010011"
user.settings = "0xAF"
user.settings # => 10101111
user.save!
```
#### Типы, описывающие сетевые адреса
Типы `inet` и `cidr` преобразуются в Ruby `IPAddr` объекты. Тип `macaddr` преобразуется в обычный текст.
```
# db/migrate/20140508144913_create_devices.rb
create_table(:devices, force: true) do |t|
  t.inet 'ip'
  t.cidr 'network'
  t.macaddr 'address'
end

# app/models/device.rb
class Device < ApplicationRecord
end

# Использование
macbook = Device.create(ip: "192.168.1.12",
                        network: "192.168.2.0/24",
                        address: "32:01:16:6d:05:ef")

macbook.ip
# => #<IPAddr: IPv4:192.168.1.12/255.255.255.255>

macbook.network
# => #<IPAddr: IPv4:192.168.2.0/255.255.255.0>

macbook.address
# => "32:01:16:6d:05:ef"
```
#### Геометрические типы
Все геометрические типы, за исключением `points` преобразуются в обычный текст. А тип `point` соответствует массиву, содержащему координаты `x` и `y`

###  Первичные ключи `UUID` <a name="2.7.2"></a>
> Для генерации случайных `UUIDs` необходимо включить расширение `pgcrypto` (только PostgreSQL >= 9.4) или `uuid-ossp`.

```
# db/migrate/20131220144913_create_devices.rb
enable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')
create_table :devices, id: :uuid, default: 'gen_random_uuid()' do |t|
  t.string :kind
end

# app/models/device.rb
class Device < ApplicationRecord
end

# Использование
device = Device.create
device.id # => "814865cd-5a1d-4771-9306-4268f188fe9e"
```
> Предполагается, что используется `gen_random_uuid()` (из `uuid-pgcrypto`) при отсутствии опции `:default`, переданной в `create_table`.

### Полнотекстовый поиск <a name="2.7.3"></a>
```
# db/migrate/20131220144913_create_documents.rb
create_table :documents do |t|
  t.string 'title'
  t.string 'body'
end

add_index :documents, "to_tsvector('english', title || ' ' || body)", using: :gin, name: 'documents_idx'

# app/models/document.rb
class Document < ApplicationRecord
end

# Использование
Document.create(title: "Cats and Dogs", body: "are nice!")

## Все документы совпадающие с 'cat & dog'
Document.where("to_tsvector('english', title || ' ' || body) @@ to_tsquery(?)",
                 "cat & dog")
```
### Представление базы данных <a name="2.7.4"></a>

Представим, что нам нужно работать со старой базой данных, содержащей следующую таблицу:
```
rails_pg_guide=# \d "TBL_ART"
                                        Table "public.TBL_ART"
   Column   |            Type             |                         Modifiers
------------+-----------------------------+------------------------------------------------------------
 INT_ID     | integer                     | not null default nextval('"TBL_ART_INT_ID_seq"'::regclass)
 STR_TITLE  | character varying           |
 STR_STAT   | character varying           | default 'draft'::character varying
 DT_PUBL_AT | timestamp without time zone |
 BL_ARCH    | boolean                     | default false
Indexes:
    "TBL_ART_pkey" PRIMARY KEY, btree ("INT_ID")
```
Данная таблица не соответствует общепринятым Rails соглашениям. Т.к. простые представление PostgreSQL обновляются по умолчанию, то можно обернуть их следующим образом:
```
# db/migrate/20131220144913_create_articles_view.rb
execute <<-SQL
CREATE VIEW articles AS
  SELECT "INT_ID" AS id,
         "STR_TITLE" AS title,
         "STR_STAT" AS status,
         "DT_PUBL_AT" AS published_at,
         "BL_ARCH" AS archived
  FROM "TBL_ART"
  WHERE "BL_ARCH" = 'f'
  SQL

# app/models/article.rb
class Article < ApplicationRecord
  self.primary_key = "id"
  def archive!
    update_attribute :archived, true
  end
end

# Использование
first = Article.create! title: "Winter is coming",
                        status: "published",
                        published_at: 1.year.ago
second = Article.create! title: "Brace yourself",
                         status: "draft",
                         published_at: 1.month.ago

Article.count # => 2
first.archive!
Article.count # => 1
```
> Это приложение обслуживает только не архивированные `Articles`. Представление также допускает условия, при которых можно напрямую исключать архивные `Articles`.

## Основы Active Model <a name="2.8"></a>
### Введение <a name="2.8.1"></a>
#### Методы атрибутов
Модуль `ActiveModel::AttributeMethods` позволяет добавлять различные суффиксы и префиксы к методам класса. Для использования необходимо определить суффиксы, префиксы, а также к каким методам объекта они будут применяться.
```
class Person
  include ActiveModel::AttributeMethods

  attribute_method_prefix 'reset_'
  attribute_method_suffix '_highest?'
  define_attribute_methods 'age'

  attr_accessor :age

  private
    def reset_attribute(attribute)
      send("#{attribute}=", 0)
    end

    def attribute_highest?(attribute)
      send(attribute) > 100
    end
end

person = Person.new
person.age = 110
person.age_highest?  # => true
person.reset_age     # => 0
person.age_highest?  # => false
```
#### Колбэки

Модуль `ActiveModel::Callbacks` дает Active Record возможность использования функций обратного вызова (колбэков). Это позволяет определять колбэки, вызываемые в определенное время. После определения колбэков можно обернуть их дополнительной функциональностью `before`, `after` и `around`, которые позволяют определить момент вызова колбэка "до", "после" и "до и после" вызова нужного метода.
```
class Person
  extend ActiveModel::Callbacks

  define_model_callbacks :update

  before_update :reset_me

  def update
    run_callbacks(:update) do
      # Этот метод вызывается при вызове у обьекта метода update.
    end
  end

  def reset_me
    # Этот метод вызывается при вызове у обьекта метода update, выполнение метода reset_me произойдет до вызова update, т.к он определен как колбэк before_update.
  end
end
```

#### Преобразования
Если для класса определены методы `persisted?` и `id`, то можно добавить модуль `ActiveModel::Conversion` в этот класс и вызывать методы преобразования Rails на объектах этого класса.
```
class Person
  include ActiveModel::Conversion

  def persisted?
    false
  end

  def id
    nil
  end
end

person = Person.new
person.to_model == person  # => true
person.to_key              # => nil
person.to_param            # => nil
```
#### Грязный объект

Объект становится грязным после одного или нескольких изменений его атрибутов, и при этом он не был сохранен. `ActiveModel::Dirty` дает возможность проверить, был ли объект изменен или нет. Также имеются атрибуты на основе акцессор-методов. Представим, что имеется класс Person с атрибутами `first_name` и `last_name`:
```
class Person
  include ActiveModel::Dirty
  define_attribute_methods :first_name, :last_name

  def first_name
    @first_name
  end

  def first_name=(value)
    first_name_will_change!
    @first_name = value
  end

  def last_name
    @last_name
  end

  def last_name=(value)
    last_name_will_change!
    @last_name = value
  end

  def save
    # метод для сохранения изменений...
    changes_applied
  end
end
```
##### Запрашиваем у объекта список всех измененных атрибутов
```
person = Person.new
person.changed? # => false

person.first_name = "First Name"
person.first_name # => "First Name"

# возвращает true, если хотя бы у одного из атрибутов есть несохраненное значение.
person.changed? # => true

# возвращает список атрибутов, которые были изменены до сохранения.
person.changed # => ["first_name"]

# возвращает хэш с измененными атрибутами вместе с их первоначальными значениями.
person.changed_attributes # => {"first_name"=>nil}

# возвращает хэш изменений с именами атрибутов в качестве ключей, и их значений как массива, который содержит старое и новое значение поля.
person.changes # => {"first_name"=>[nil, "First Name"]}
```
##### Атрибуты, основанные на акцессор-методах
Отслеживает, был ли атрибут изменен или нет.
```
# attr_name_changed?
person.first_name # => "First Name"
person.first_name_changed? # => true
```
Отслеживает предыдущее значение атрибута.
```
# акцессор attr_name_was
person.first_name_was # => nil
```
Отслеживает старое и новое значение измененного атрибута. Возвращает массив, если изменяли, в противном случае nil.
```
# attr_name_change
person.first_name_change # => [nil, "First Name"]
person.last_name_change # => nil
```
#### Валидации
Модуль `ActiveModel::Validations` добавляет возможность проверять объекты, как в Active Record.
```
class Person
  include ActiveModel::Validations

  attr_accessor :name, :email, :token

  validates :name, presence: true
  validates_format_of :email, with: /\A([^\s]+)((?:[-a-z0-9]\.)[a-z]{2,})\z/i
  validates! :token, presence: true
end

person = Person.new
person.token = "2b1f325"
person.valid?                        # => false
person.name = 'vishnu'
person.email = 'me'
person.valid?                        # => false
person.email = 'me@vishnuatrai.com'
person.valid?                        # => true
person.token = nil
person.valid?                        # => вызывается ActiveModel::StrictValidationFailed
```
#### Именование
`ActiveModel::Naming` добавляет ряд методов класса, упрощающие управление именованием и роутингом. Модуль определяет метод класса model_name, который определит несколько акцессоров с помощью методов `ActiveSupport::Inflector`.
```
class Person
  extend ActiveModel::Naming
end

Person.model_name.name                # => "Person"
Person.model_name.singular            # => "person"
Person.model_name.plural              # => "people"
Person.model_name.element             # => "person"
Person.model_name.human               # => "Person"
Person.model_name.collection          # => "people"
Person.model_name.param_key           # => "person"
Person.model_name.i18n_key            # => :person
Person.model_name.route_key           # => "people"
Person.model_name.singular_route_key  # => "person"
```
#### Модель
`ActiveModel::Model` добавляет для класса возможность работать из коробки с Action Pack и Action View.
```
class EmailContact
  include ActiveModel::Model

  attr_accessor :name, :email, :message
  validates :name, :email, :message, presence: true

  def deliver
    if valid?
      # отправить электронную почту 
    end
  end
end
```
При включении `ActiveModel::Model` вы получите несколько возможностей, таких как:

    интроспекция имени модели
    преобразования
    переводы
    валидации 

Он также дает возможность инициализировать объект с помощью хэша атрибутов, подобно любому объекту Active Record.
```
email_contact = EmailContact.new(name: 'David',
                                 email: 'david@example.com',
                                 message: 'Hello World')
email_contact.name       # => 'David'
email_contact.email      # => 'david@example.com'
email_contact.valid?     # => true
email_contact.persisted? # => false
```
Любой класс, включающий `ActiveModel::Model`, может быть использован с `form_for`, `render` и любыми другими методами хелпера `Action View`, точно так же, как и объекты `Active Record`.
#### Сериализация
`ActiveModel::Serialization` предоставляет базовую сериализацию для вашего объекта. Вам необходимо объявить хэш, содержащий атрибуты, которые вы хотите сериализовать. Атрибуты должны быть строками, не символами.
```
class Person
  include ActiveModel::Serialization

  attr_accessor :name

  def attributes
    {'name' => nil}
  end
end

Теперь можно получить доступ к сериализованному хэшу вашего объекта с помощью метода serializable_hash.

person = Person.new
person.serializable_hash   # => {"name"=>nil}
person.name = "Bob"
person.serializable_hash   # => {"name"=>"Bob"}
```
##### `ActiveModel::Serializers`
Active Model также предоставляет модуль `ActiveModel::Serializers::JSON` для сериализации/десериализации JSON. Этот модуль автоматически подключает ранее обсужденный модуль `ActiveModel::Serialization`.

###### `ActiveModel::Serializers::JSON`
Для использования `ActiveModel::Serializers::JSON` необходимо только изменить модуль, который вы подключали, с `ActiveModel::Serialization` на `ActiveModel::Serializers::JSON`.
```
class Person
  include ActiveModel::Serializers::JSON

  attr_accessor :name

  def attributes
    {'name' => nil}
  end
end
```
Метод `as_json`, подобно `serializable_hash`, предоставляет хэш, описывающий модель.
```
person = Person.new
person.as_json # => {"name"=>nil}
person.name = "Bob"
person.as_json # => {"name"=>"Bob"}
```
Также можно определить атрибуты для модели из строки JSON. Однако, в классе нужно определить метод `attributes=`:
```
class Person
  include ActiveModel::Serializers::JSON

  attr_accessor :name

  def attributes=(hash)
    hash.each do |key, value|
      send("#{key}=", value)
    end
  end

  def attributes
    {'name' => nil}
  end
end
```
Теперь есть возможность создавать экземпляры Person и устанавливать атрибуты с помощью `from_json`.
```
json = { name: 'Bob' }.to_json
person = Person.new
person.from_json(json) # => #<Person:0x00000100c773f0 @name="Bob">
person.name            # => "Bob"
```
#### Перевод
`ActiveModel::Translation` предоставляет интеграцию между вашим объектом и фреймворком интернационализации Rails (i18n).
```
class Person
  extend ActiveModel::Translation
end
```
С помощью метода `human_attribute_name` можно преобразовывать имена атрибутов в более удобочитаемый формат. Удобочитаемый формат определяется в вашем(-их) файле(-ах) локали.
```
    # config/locales/app.pt-BR.yml 

  pt-BR:
    activemodel:
      attributes:
        person:
          name: 'Nome'

Person.human_attribute_name('name') # => "Nome"
```
#### Тесты совместимости
`ActiveModel::Lint::Tests` позволяет проверить, совместим ли объект с Active Model API.
```
    app/models/person.rb

    class Person
      include ActiveModel::Model
    end

    test/models/person_test.rb

    require 'test_helper'

    class PersonTest < ActiveSupport::TestCase
      include ActiveModel::Lint::Tests

      setup do
        @model = Person.new
      end
    end
```
```
$ rails test

Run options: --seed 14596

# Running:

......

Finished in 0.024899s, 240.9735 runs/s, 1204.8677 assertions/s.

6 runs, 30 assertions, 0 failures, 0 errors, 0 skips
```
Объекту не нужно реализовывать все API, чтобы работать с Action Pack. Этот модуль всего лишь предназначен для предоставления руководства в случае, если вы хотите все особенности из коробки.
#### Безопасный пароль

`ActiveModel::SecurePassword` предоставляет способ безопасно хранить любой пароль в зашифрованном виде. При включении этого модуля предоставляется метод класса `has_secure_password`, определяющий акцессор `password` с определенными валидациями на нем.

##### Требования
`ActiveModel::SecurePassword` зависит от `bcrypt`, поэтому включите этот гем в свой Gemfile для правильного использования `ActiveModel::SecurePassword`. Чтобы он работал, в модели должен быть акцессор с именем `password_digest`. `has_secure_password` добавит следующие валидации на акцессор `password`:
* Пароль должен существовать.
* Пароль должен совпадать с подтверждением (проверяется, если передан `password_confirmation`).
* Максимальная длина пароля 72 (требуется `bcrypt`, от которого зависит `ActiveModel::SecurePassword`) 

#####  Примеры
```
class Person
  include ActiveModel::SecurePassword
  has_secure_password
  attr_accessor :password_digest
end

person = Person.new

# Когда пароль пустой.
person.valid? # => false

# Когда подтверждение не совпадает с паролем.
person.password = 'aditya'
person.password_confirmation = 'nomatch'
person.valid? # => false

# Когда длина пароля превышает 72.
person.password = person.password_confirmation = 'a' * 100
person.valid? # => false

# Когда предоставлен только пароль без password_confirmation.
person.password = 'aditya'
person.valid? # => true

# Когда проходят все валидации.
person.password = person.password_confirmation = 'aditya'
person.valid? # => true
```


# Вьюхи <a name="3"></a>
## Обзор Action View <a name="3.1"></a>
### Что такое Action View? <a name="3.1.1"></a>
В Rails веб-запросы обрабатываются Action Controller и Action View. Обычно Action Controller ответственен за связь с базой данных и выполнение экшнов CRUD. Тогда как Action View ответственен за компиляцию отклика.

Шаблоны Action View пишутся с помощью тегов встроенного Ruby, смешанных с HTML. Чтобы избежать загромождения вьюх шаблонным кодом, общее поведение для форм, дат и строк представлено рядом классов хелпера. В существующее приложение также легко добавлять новые хелперы.

> Некоторые особенности Action View связаны с Active Record, но это не означает, что Action View зависит от Active Record. Action View — это независимый пакет, который можно использовать с любой библиотекой Ruby.
### Использование Action View с Rails <a name="3.1.2"></a>
Для каждого контроллера имеется связанная директория в директории app/views, содержащая файлы шаблонов, которые формируют вьюхи, связанные с этим контроллером. Эти файлы используются для отображения вьюхи, являющейся результатом каждого экшна контроллера.

Давайте взглянем на то, что делает Rails по умолчанию, когда создает новый ресурс с помощью генератора скаффолда:
```
$ rails generate scaffold article
      [...]
      invoke  scaffold_controller
      create    app/controllers/articles_controller.rb
      invoke    erb
      create      app/views/articles
      create      app/views/articles/index.html.erb
      create      app/views/articles/edit.html.erb
      create      app/views/articles/show.html.erb
      create      app/views/articles/new.html.erb
      create      app/views/articles/_form.html.erb
      [...]
```
В Rails имеется соглашение по именованию вьюх. Как правило, имя вьюхи совпадает с соответствующим экшном контроллера, как вы могли видеть выше. Например, экшн index контроллера в `articles_controller.rb` будет использовать файл вьюхи `index.html.erb` в директории` app/views/articles`. Полный HTML, возвращенный клиенту, состоит из комбинации этого файла ERB, шаблона макета, оборачивающего его, и всех партиалов, на которые вьюха может ссылаться.
### Шаблоны, партиалы и макеты <a name="3.1.3"></a>
#### Шаблоны
Шаблоны Action View могут быть написаны несколькими способами. Если у файла шаблона расширение `.erb`, то он использует смесь ERB (Embedded Ruby) и HTML. Если у файла шаблона расширение `.builder`, то используется библиотека `Builder::XmlMarkup`.

Rails поддерживает несколько систем шаблонирования и использует расширение файла, чтобы различать их. Например, файл HTML, использующий систему шаблонирования ERB, будет иметь расширение файла `.html.erb.`
##### ERB
В шаблоне ERB код Ruby может быть включен с помощью тегов `<% %>` и `<%= %>`. Теги `<% %>` используются для выполнения кода Ruby, который ничего не возвращает, такого как условия, циклы или блоки, а теги `<%= %>` используются, когда вам нужен результат выполнения.

Рассмотрим следующий цикл для имен:
```
<h1>Names of all the people</h1>
<% @people.each do |person| %>
  Name: <%= person.name %><br>
<% end %>
```
Цикл настроен с помощью обычных встраиваемых тегов (`<% %>`), а имя вставлено с помощью выводящих встраиваемых тегов (`<%= %>`). Отметьте, что это не просто совет по использованию: обычные функции для вывода, такие как `print` и `puts` не будут рендериться во вьюху в шаблонах ERB. 
Чтобы запретить предварительные и завершающие пробелы можно использовать `<%-` `-%>` вместо `<%` и `%>`.

##### Builder
Шаблоны Builder — это более программная альтернатива ERB. Они особенно полезны для генерации содержимого в XML. Объект `XmlMarkup` с именем `xml` автоматически доступен в шаблонах с расширением `.builder`.

Вот несколько простых примеров:
```
xml.em("emphasized")
xml.em { xml.b("emph & bold") }
xml.a("A Link", "href" => "https://rubyonrails.org")
xml.target("name" => "compile", "option" => "fast")
```
которые создадут:
```
<em>emphasized</em>
<em><b>emph &amp; bold</b></em>
<a href="https://rubyonrails.org">A link</a>
<target option="fast" name="compile" />
```
Любой метод с блоком будет трактован как разметка тега XML с вложенной разметкой в блоке. Например, следующее:
```
xml.div {
  xml.h1(@person.name)
  xml.p(@person.bio)
}
```
создаст что-то вроде:
```
<div>
  <h1>David Heinemeier Hansson</h1>
  <p>A product of Danish Design during the Winter of '79...</p>
</div>
```
Ниже приведен полноценный пример RSS, фактически используемый в Basecamp:
```
xml.rss("version" => "2.0", "xmlns:dc" => "http://purl.org/dc/elements/1.1/") do
  xml.channel do
    xml.title(@feed_title)
    xml.link(@url)
    xml.description "Basecamp: Recent items"
    xml.language "en-us"
    xml.ttl "40"

    for item in @recent_items
      xml.item do
        xml.title(item_title(item))
        xml.description(item_description(item)) if item_description(item)
        xml.pubDate(item_pubDate(item))
        xml.guid(@person.firm.account.url + @recent_items.url(item))
        xml.link(@person.firm.account.url + @recent_items.url(item))
        xml.tag!("dc:creator", item.author_name) if item_has_creator?(item)
      end
    end
  end
end
```
##### Jbuilder
`Jbuilder` — это гем, поддерживаемый командой Rails и включенный в Rails `Gemfile` по умолчанию. Он похож на Builder, но используется для генерации JSON вместо XML.
Если у вас его нет, можно добавить следующее в Gemfile:
```
gem 'jbuilder'
```
Объект Jbuilder с именем json автоматически становится доступным в шаблонах с расширением `.jbuilder`.

Вот простой пример:
```
json.name("Alex")
json.email("alex@example.com")
```
что создаст:
```
{
  "name": "Alex",
  "email": "alex@example.com"
}
```
##### Кэширование шаблонов
По умолчанию Rails компилирует каждый шаблон в метод перед тем, как рендерить его. Когда вы измените шаблон в режиме `development`, Rails проверит время модификации файла и перекомпилирует его.

#### Партиалы
Частичные шаблоны - обычно называемые "партиалы" - это другая схема разделения процесса рендеринга на более управляемые части. С помощью партиалов можно извлечь части кода из ваших шаблонов в отдельные файлы, а также повторно использовать их в разных шаблонах.

##### Именование партиалов
Чтобы отрендерить партиал как часть вьюхи, в ней используется метод `render`:
```
<%= render "menu" %>
```
Это отрендерит файл с именем `_menu.html.erb` во вьюхе, которая рендерится. Обратите внимание на первый символ подчеркивания: партиалы именуются, начинаясь с подчеркивания, чтобы отличить их от обычных вьюх, хотя к ним и обращаются без подчеркивания. Это истинно, даже если вы вставляете партиал из другой директории:
```
<%= render "shared/menu" %>
```
Этот код вставит партиал из `app/views/shared/_menu.html.erb`.

##### Использование партиалов для упрощения вьюх
Одним из способов использования партиалов является трактовка их как эквивалента подпрограмм; способ выноса части разметки из вьюхи, чтобы можно было проще понять, что происходит. Например, у вас может быть такая вьюха:
```
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>

<%= render "shared/footer" %>
```
Здесь партиалы `_ad_banner.html.erb` и `_footer.html.erb` могут содержать контент, общий для многих страниц приложения. Нет необходимости видеть код этих разделов, чтобы сконцентрироваться на определенной странице.

##### `render` без опций `partial` и `locals`
В вышеприведенном примере render принимает 2 опции: `partial` и `locals`. Но если это единственные опции, которые нужно передать, их можно опустить. Например, вместо:
```
<%= render partial: "product", locals: { product: @product } %>
```
Можно сделать:
```
<%= render "product", product: @product %>
```

##### Опции `as` и `object`
По умолчанию у `ActionView::Partials::PartialRenderer` есть собственный объект в локальной переменной с тем же именем, как у шаблона. Так, если имеем:
```
<%= render partial: "product" %>
```
в партиале `_product` мы получим `@product` в локальной переменной `product`, как будто мы написали:
```
<%= render partial: "product", locals: { product: @product } %>
```
Опцию `object` можно использовать, чтобы непосредственно указать, какой объект рендерится в партиале; полезно, когда объект шаблона находится где-то еще (например, в другой переменной экземпляра или в локальной переменной).

Например, вместо:
```
<%= render partial: "product", locals: { product: @item } %>
```
можно сделать:
```
<%= render partial: "product", object: @item %>
```
С помощью опции as можно указать другое имя для данной локальной переменной. Например, если нам нужно, чтобы оно было `item` вместо `product`, мы сделаем:
```
<%= render partial: "product", object: @item, as: "item" %>
```
Это эквивалентно:
```
<%= render partial: "product", locals: { item: @item } %>
```
#####  Рендеринг коллекций
Часто бывает, что шаблону нужно пройтись по коллекции и отрендерить подшаблон для каждого элемента. Этот паттерн был реализован как отдельный метод, принимающий массив и рендерящий партиал для каждого элемента массива.

Поэтому такой пример для рендеринга всех продуктов:
```
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>
```
может быть переписан с помощью одной строчки:
```
<%= render partial: "product", collection: @products %>
```
Когда партиал вызывается с коллекцией, у отдельных экземпляров партиала есть доступ к рендерящемуся члену коллекции через переменную с именем партиала. В данном случае партиалом является `_product`, и внутри него можно обратиться к `product`, чтобы получить член коллекции, который будет отрендерен.

Для рендеринга коллекций можно использовать сокращенный синтаксис. Предположим, `@products` — это коллекция экземпляров `Product`, тогда можно просто написать следующее, чтобы получить тот же самый результат:
```
<%= render @products %>
```
Rails определяет имя используемого партиала по имени модели в коллекции, в данном случае `Product`. Фактически с помощью этого сокращенного синтаксиса можно рендерить коллекцию, состоящую из экземпляров различных моделей, и Rails выберет подходящий партиал для каждого члена коллекции.

##### Разделяющие шаблоны
Также можете определить второй партиал, который будет отрендерен между экземплярами главного партиала, используя опцию `:spacer_template`:
```
<%= render partial: @products, spacer_template: "product_ruler" %>
```
Rails отрендерит партиал `_product_ruler` (без переданных в него данных) между каждой парой партиалов `_product`.

##### Макеты
Макеты могут быть использованы для рендеринга общего шаблона вьюхи вокруг результатов экшна контроллера Rails. Обычно в приложении Rails несколько макетов, в которых будут рендериться страницы. Например, на сайте может быть один макет для авторизованного пользователя и другой для маркетинга или продаж. Макет для авторизованного пользователя может включать навигацию верхнего уровня, которая должна присутствовать во многих экшнах контроллера. Макет для продаж для приложения SaaS может включать верхнеуровневую навигацию для таких, скажем, страниц как "Pricing" и "Contact Us". Ожидается, что каждый макет должен выглядеть по разному.

### Макеты партиалов <a name="3.1.4"></a>
У партиалов могут быть собственные макеты, применимые к ним. Эти макеты отличаются от тех, которые применяются к экшну контроллера, хотя они работают подобным образом.

Допустим, мы отображаем статью на странице, которая должна быть обернута в `div`, с целью отображения ее как блочный элемент. Сначала мы создадим новую `Article`:
```
Article.create(body: 'Partial Layouts are cool!')
```
В шаблоне `show` мы отрендерим партиал `_article`, обернутый в макет `box`:
```
articles/show.html.erb

<%= render partial: 'article', layout: 'box', locals: { article: @article } %>
```
Макет box просто оборачивает партиал `_article` в `div`:
```
articles/_box.html.erb

<div class='box'>
  <%= yield %>
</div>
```
Отметьте, что у макета партиала есть доступ к локальной переменной `article`, переданной в вызов `render`. Однако, в отличие от макетов приложения, макеты партиалов должны начинаться с подчеркивания.

Также можно отрендерить блок кода в макете партиала вместо вызова `yield`. Например, если у нас нет партиала `_article`, вместо него можно использовать это:
```
articles/show.html.erb

<% render(layout: 'box', locals: { article: @article }) do %>
  <div>
    <p><%= article.body %></p>
  </div>
<% end %>
```
Предположив, что мы используем тот же партиал `_box`, мы получим тот же результат, что и в предыдущем примере.

### Пути вьюх <a name="3.1.5"></a>
При рендеринге отклика контроллер должен решить, где располагаются различные вьюхи. По умолчанию он смотрит только в директории `app/views`.

Мы можем добавить другие места расположения и дать им некий приоритет при определении путей с помощью методов `prepend_view_path` и `append_view_path`.

#### `Prepend view path`
Метод может быть полезным, например, когда мы хотим поместить вьюхи в разные директории для поддоменов.
Мы можем сделать это используя:
```
prepend_view_path "app/views/#{request.subdomain}"
```
Тогда Action View при поиске нужной вьюхи будет искать сначала в этой директории.

#### `Append view path`

Аналогично, мы можем добавить путь:
```
append_view_path "app/views/direct"
```
Это добавит путь `app/views/direct` в конец поиска путей.

### Обзор хелперов, предоставленных Action View <a name="3.1.6"></a>
Тут перечислены не все хелперы.

#### AssetTagHelper
Этот модуль предоставляет методы для генерации HTML, связывающего вьюхи с ресурсами, такими как картинки, файлы JavaScript, таблицы стилей и новостные ленты.

По умолчанию Rails связывается с этими ресурсами на текущем хосте в папке `public`, но можно заставить Rails связываться с ресурсами на выделенном сервере ресурсов, установив `config.action_controller.asset_host` в конфигурации приложения, обычно в `config/environments/production.rb`. Например, допустим хост ваших ресурсов `assets.example.com`:
```
config.action_controller.asset_host = "assets.example.com"
image_tag("rails.png") # => <img src="http://assets.example.com/images/rails.png" />
```

##### `auto_discovery_link_tag`
Возвращает тег ссылки, которую могут использовать браузеры и агрегаторы новостей для автоматического определения RSS, Atom или ленты JSON.
```
auto_discovery_link_tag(:rss, "http://www.example.com/feed.rss", { title: "RSS Feed" }) # =>
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://www.example.com/feed" />
```

##### `image_path`
Вычисляет путь до ресурса картинки в директории app/assets/images. Будут переданы полные пути от корня документа. Используется внутри `image_tag` для создания пути к картинке.
```
image_path("edit.png") # => /assets/edit.png
```
К имени файла будет добавлена метка, если `config.assets.digest` установлен в `true`.
```
image_path("edit.png") # => /assets/edit-2d1a2db63fc738690021fedb5a65b68e.png
```

##### `image_url`
Вычисляет URL ресурса картинки в директории `app/assets/images`. Он вызовет `image_path` и соединит с вашим текущим хостом или вашим хостом ресурсов.
```
image_url("edit.png") # => http://www.example.com/assets/edit.png
```

##### `image_tag`
Возвращает тег картинки HTML для источника. Источником может быть полный путь или файл, существующий в директории `app/assets/images`.
```
image_tag("icon.png") # => <img src="/assets/icon.png" />
```

##### `javascript_include_tag`
Возвращает HTML-тег script для каждого предоставленного источника. Можно передать имя файла (расширение `.js` опционально) или файлы JavaScript, существующие в директории `app/assets/javascripts` для включения в текущую страницу, или передать полный путь относительно корня документа.
```
javascript_include_tag "common" # => <script src="/assets/common.js"></script>
```

##### `javascript_path`
Вычисляет путь до ресурса JavaScript в директории `app/assets/javascripts`. Если у имени файла источника нет расширения, будет добавлено `.js`. Будут переданы полные пути от корня документа. Используется внутри `javascript_include_tag` для создания пути к скрипту.
```
javascript_path "common" # => /assets/common.js
```
##### `javascript_url`
Вычисляет URL ресурса JavaScript в директории `app/assets/javascripts`. Он вызовет `javascript_path` и соединит с вашим текущим хостом или вашим хостом ресурсов.
```
javascript_url "common" # => http://www.example.com/assets/common.js
```

##### `stylesheet_link_tag`
Возвращает тег `link` на таблицу стилей для источников, указанных в качестве аргументов. Если не указать расширение, автоматически будет добавлено `.css`.
```
stylesheet_link_tag "application" # => <link href="/assets/application.css" media="screen" rel="stylesheet" />
```
##### `stylesheet_path`
Вычисляет путь до ресурса таблицы стилей в директории `app/assets/stylesheets`. Если у имени файла источника нет расширения, будет добавлено `.css`. Будут переданы полные пути от корня документа. Используется внутри `stylesheet_link_tag` для создания пути к таблице стилей.
```
stylesheet_path "application" # => /assets/application.css
```
##### `stylesheet_url`
Вычисляет URL ресурса таблицы стилей в директории `app/assets/stylesheets`. Он вызовет `stylesheet_path` и соединит с вашим текущим хостом или вашим хостом ресурсов.
```
stylesheet_url "application" # => http://www.example.com/assets/application.css
```

#### AtomFeedHelper
##### `atom_feed`
Этот хелпер позволяет с легкостью создать новостную ленту Atom. Вот пример полного использования:
```
config/routes.rb

resources :articles

app/controllers/articles_controller.rb

def index
  @articles = Article.all

  respond_to do |format|
    format.html
    format.atom
  end
end

app/views/articles/index.atom.builder

atom_feed do |feed|
  feed.title("Articles Index")
  feed.updated(@articles.first.created_at)

  @articles.each do |article|
    feed.entry(article) do |entry|
      entry.title(article.title)
      entry.content(article.body, type: 'html')

      entry.author do |author|
        author.name(article.author_name)
      end
    end
  end
end
```
#### BenchmarkHelper
##### `benchmark`
Позволяет измерить время выполнения блока в шаблоне и записать результат в лог. Оберните этот блок вокруг затратных операций или потенциальных узких мест, чтобы получить время чтения для операций.
```
<% benchmark "Process data files" do %>
  <%= expensive_files_operation %>
<% end %>
```
Это добавит в лог что-то вроде `"Process data files (0.34523)"`, затем это можно использовать для сравнения времени при оптимизации кода.

#### CacheHelper
##### `cache`
Метод для кэширования фрагмента вьюхи, а не всего экшна или страницы. Эта техника полезна для кэширования таких кусочков, как меню, списки заголовков новостей, статичные фрагменты HTML и так далее. Этот метод принимает блок, содержащий код, который вы хотите закэшировать. Подробности смотрите в `AbstractController::Caching::Fragments`.
```
<% cache do %>
  <%= render "shared/footer" %>
<% end %>
```

#### CaptureHelper
##### `capture`
Метод capture позволяет извлечь часть шаблона в переменную. Эту переменную потом можно использовать в любом месте шаблона или макета.
```
<% @greeting = capture do %>
  <p>Welcome! The date and time is <%= Time.now %></p>
<% end %>
```
Захваченная переменная может быть потом где-то использована.
```
<html>
  <head>
    <title>Welcome!</title>
  </head>
  <body>
    <%= @greeting %>
  </body>
</html>
```

##### `content_for`
Вызов `content_for` хранит блок разметки как идентификатор для дальнейшего использования. Можно совершать последующие вызовы сохраненного содержимого в других шаблонах или макете, передав идентификатор в качестве аргумента в `yield`.

Например, допустим у нас есть стандартный макет приложения, но также есть специальная страница, требующая определенный JavaScript, который не требуется в остальных частях сайта. Можно использовать `content_for`, чтобы включить этот JavaScript на нашу специальную страницу без влияния на оставшуюся часть сайта.

`app/views/layouts/application.html.erb`
```
<html>
  <head>
    <title>Welcome!</title>
    <%= yield :special_script %>
  </head>
  <body>
    <p>Welcome! The date and time is <%= Time.now %></p>
  </body>
</html>
```
`app/views/articles/special.html.erb`
```
<p>This is a special page.</p>

<% content_for :special_script do %>
  <script>alert('Hello!')</script>
<% end %>
```

#### DateHelper
##### `date_select`
Возвращает набор тегов `select` (по одному для года, месяца и дня), предзаполненных для доступа к определенному атрибуту даты.
```
date_select("article", "published_on")
```
##### `datetime_select`
Возвращает набор тегов `select` (по одному для года, месяца, дня, часа и минуты), предзаполненных для доступа к определенному атрибуту даты-времени.
```
datetime_select("article", "published_on")
```
##### `distance_of_time_in_words`

Возвращает приблизительный промежуток времени между двумя объектами `Time` или `Date`, или целыми числами в секундах. Установите `include_seconds` в `true`, если хотите более детальное приближение.
```
distance_of_time_in_words(Time.now, Time.now + 15.seconds)        # => less than a minute
distance_of_time_in_words(Time.now, Time.now + 15.seconds, include_seconds: true)  # => less than 20 seconds
```

##### `select_date`
Возвращает набор HTML-тегов `select` (по одному для года, месяца и дня), предзаполненных предоставленной `date`.
```
# Создает select для date, который по умолчанию соответствует предоставленной дате (шесть дней, начиная с сегодняшнего)
select_date(Time.today + 6.days)

# Создает select для date, который по умолчанию соответствует сегодняшней дате (без аргумента)
select_date()
```

##### `select_datetime`
Возвращает набор HTML-тегов `select` (по одному для года, месяца, дня, часа и минуты), предзаполненных предоставленным `datetime`.
```
# Создает select для datetime, который по умолчанию соответствует предоставленной дате (четыре дня, начиная с сегодняшнего)
select_datetime(Time.now + 4.days)

# Создает select для datetime, который по умолчанию соответствует сегодняшней дате (без аргумента)
select_datetime()
```

##### `select_day`
Возвращает тег `select` с опциями для каждого дня с 1 по 31 и выбранным текущим днем.
```
# Создает поле select для дней с предоставленной датой как значение по умолчанию
select_day(Time.today + 2.days)

# Создает поле select для дней с данным числом как значение по умолчанию
select_day(5)
```
##### `select_hour`
Возвращает тег `select` с опциями для каждого часа с 0 по 23 и выбранным текущим часом.
```
# Создает поле select для часов с предоставленным временем как значение по умолчанию
select_hour(Time.now + 6.hours)
```

##### `select_minute`
Возвращает тег `select` с опциями для каждой минуты с 0 по 59 и выбранной текущей минутой.
```
# Создает поле select для минут с предоставленным временем как значение по умолчанию
select_minute(Time.now + 10.minutes)
```

##### `select_month`
Возвращает тег `select` с опциями для каждого месяца с January по December и выбранным текущим месяцем.
```
# Создает поле select для месяцев с текущим месяцем как значение по умолчанию
select_month(Date.today)
```

##### `select_second`
Возвращает тег `select` с опциями для каждой секунды с 0 по 59 и выбранной текущей секундой.
```
# Создает поле select для секунд с предоставленным временем как значение по умолчанию
select_second(Time.now + 16.seconds)
```

##### `select_time`
Возвращает набор тегов HTML `select` (по одному для часа и минуты).
```
# Создает поля select с предоставленным временем как значение по умолчанию
select_time(Time.now)
```

##### `select_year`
Возвращает тег `select` с опциями для каждого года из пяти от и до выбранного текущего. Пятилетний радиус может быть изменен с помощью опциональных ключей `:start_year` и `:end_year`.
```
# Создает поле select для пяти лет в обе стороны от Date.today, являющаяся значением по умолчанию для текущего года
select_year(Date.today)

# Создает поле select от 1900 до 2016 с текущим годом как значение по умолчанию
select_year(Date.today, start_year: 1900, end_year: 2016)
```

##### `time_ago_in_words`
Подобен `distance_of_time_in_words`, где `to_time` устанавливается `Time.now`.
```
time_ago_in_words(3.minutes.from_now)  # => 3 minutes
```

##### `time_select`
Возвращает набор тегов `select` (по одному для часа, минуты и, опционально, секунды), предзаполненных для доступа к определенному атрибуту времени. Этот набор подготовлен для назначения нескольких параметров в объекте Active Record.
```
# Создает тег select для времени, который при POST будет сохранен в переменную order атрибута submitted
time_select("order", "submitted")
```

#### DebugHelper
Возвращает тег `pre` с объектом, выгруженным в YAML. Это создает удобочитаемый способ проверки объекта.
```
my_hash = { 'first' => 1, 'second' => 'two', 'third' => [1,2,3] }
debug(my_hash)

<pre class='debug_dump'>---
first: 1
second: two
third:
- 1
- 2
- 3
</pre>
```

#### FormHelper
Хелперы форм предназначены для упрощения работы с моделями по сравнению с использованием только стандартных элементов HTML, предоставляя набор методов для создания форм на основе ваших моделей. Этот хелпер создает HTML для форм, предоставляя метод для каждого типа полей ввода (например `text`, `password`, `select` и так далее). Когда форма подтверждается (т.е. когда пользователь нажимает кнопку подтверждения или `form.submit`, вызывается в JavaScript), поля ввода формы будут объединены в объект params и переданы в контроллер.

Существует два типа хелперов форм: те, которые работают с атрибутами модели, и те, которые нет. Этот хелпер относится к тем, которые работают с атрибутами модели; чтобы посмотреть примеры хелперов форм, которые не работают с атрибутами модели, обратитесь к документации `ActionView::Helpers::FormTagHelper`.

Основной метод этого хелпера, `form_for`, дает возможность создавать форму для экземпляра модели; например, допустим, что имеется модель `Person`, и мы хотим создать ее новый экземпляр:
```
# Note: переменная @person была создана в контроллере (т.е. @person = Person.new)
<%= form_for @person, url: { action: "create" } do |f| %>
  <%= f.text_field :first_name %>
  <%= f.text_field :last_name %>
  <%= submit_tag 'Create' %>
<% end %>
```
Созданным HTML будет:
```
<form class="new_person" id="new_person" action="/people" accept-charset="UTF-8" method="post">
  <input name="utf8" type="hidden" value="&#x2713;" />
  <input type="hidden" name="authenticity_token" value="lTuvBzs7ANygT0NFinXj98tfw3Emfm65wwYLbUvoWsK2pngccIQSUorM2C035M9dZswXgWTvKwFS8W5TVblpYw==" />
  <input type="text" name="person[first_name]" id="person_first_name" />
  <input type="text" name="person[last_name]" id="person_last_name" />
  <input type="submit" name="commit" value="Create" data-disable-with="Create" />
</form>
```
Объект params, созданный при отправке этой формы, будет выглядеть так:
```
{"utf8" => "✓", "authenticity_token" => "lTuvBzs7ANygT0NFinXj98tfw3Emfm65wwYLbUvoWsK2pngccIQSUorM2C035M9dZswXgWTvKwFS8W5TVblpYw==", "person" => {"first_name" => "William", "last_name" => "Smith"}, "commit" => "Create", "controller" => "people", "action" => "create"}
```
В хэше params будет вложенное значение `person`, к которому можно получить доступ в контроллере с помощью `params[:person]`.

##### `check_box`
Возвращает тег чекбокса с учетом доступа к определенному атрибуту.
```
# Допустим, что @article.validated? равен 1:
check_box("article", "validated")
# => <input type="checkbox" id="article_validated" name="article[validated]" value="1" />
#    <input name="article[validated]" type="hidden" value="0" />
```
##### `fields_for`
Создает пространство имен вокруг определенного объекта модели наподобие `form_for`, но не создает сами теги формы. Это делает `fields_for` подходящим для указания дополнительных объектов модели в той же форме:
```
<%= form_for @person, url: { action: "update" } do |person_form| %>
  First name: <%= person_form.text_field :first_name %>
  Last name : <%= person_form.text_field :last_name %>

  <%= fields_for @person.permission do |permission_fields| %>
    Admin?  : <%= permission_fields.check_box :admin %>
  <% end %>
<% end %>
```
##### `file_field`
Возвращает поле для загрузки файла с учетом доступа к определенному атрибуту.
```
file_field(:user, :avatar)
# => <input type="file" id="user_avatar" name="user[avatar]" />
```
##### `form_for`
Создает форму и пространство имен вокруг определенного объекта модели, используемого как основа для опроса значений полей.
```
<%= form_for @article do |f| %>
  <%= f.label :title, 'Title' %>:
  <%= f.text_field :title %><br>
  <%= f.label :body, 'Body' %>:
  <%= f.text_area :body %><br>
<% end %>
```
##### `hidden_field`
Возвращает тег скрытого поля с учетом доступа к определенному атрибуту.
```
hidden_field(:user, :token)
# => <input type="hidden" id="user_token" name="user[token]" value="#{@user.token}" />
```
#####  `label`
Возвращает тег `label` с учетом поля ввода для определенного атрибута.
```
label(:article, :title)
# => <label for="article_title">Title</label>
```
##### `password_field`
Возвращает тег `input` типа "password" с учетом доступа к определенному атрибуту.
```
password_field(:login, :pass)
# => <input type="text" id="login_pass" name="login[pass]" value="#{@login.pass}" />
```
##### `radio_button`
Возвращает тег радио кнопки с учетом доступа к определенному атрибуту.
```
# Let's say that @article.category returns "rails":
radio_button("article", "category", "rails")
radio_button("article", "category", "java")
# => <input type="radio" id="article_category_rails" name="article[category]" value="rails" checked="checked" />
#    <input type="radio" id="article_category_java" name="article[category]" value="java" />
```
##### `text_area`
Возвращает набор открывающего и закрывающего тега `textarea` с учетом доступа к определенному атрибуту.
```
text_area(:comment, :text, size: "20x30")
# => <textarea cols="20" rows="30" id="comment_text" name="comment[text]">
#      #{@comment.text}
#    </textarea>
```

##### `text_field`
Возвращает тег `input` типа "text" с учетом доступа к определенному атрибуту.
```
text_field(:article, :title)
# => <input type="text" id="article_title" name="article[title]" value="#{@article.title}" />
```

##### `email_field`
Возвращает тег `input` типа "email" с учетом доступа к определенному атрибуту.
```
email_field(:user, :email)
# => <input type="email" id="user_email" name="user[email]" value="#{@user.email}" />
```

##### `url_field`
Возвращает тег `input` типа "url" с учетом доступа к определенному атрибуту.
```
url_field(:user, :url)
# => <input type="url" id="user_url" name="user[url]" value="#{@user.url}" />
```

#### FormOptionsHelper
Предоставляет ряд методов для превращения различного рода контейнеров в набор тегов `option`.

##### `collection_select`
Возвращает теги `select` и `option` для коллекции значений, возвращаемых `method` для класса `object`.

Пример структуры объекта для использования с этим методом:
```
class Article < ApplicationRecord
  belongs_to :author
end

class Author < ApplicationRecord
  has_many :articles
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
```
Пример использования (выбор связанного `Author` для экземпляра `Article, @article`):
```
collection_select(:article, :author_id, Author.all, :id, :name_with_initial, { prompt: true })
```
Если `@article.author_id` — 1, это вернет:
```
<select name="article[author_id]">
  <option value="">Please select</option>
  <option value="1" selected="selected">D. Heinemeier Hansson</option>
  <option value="2">D. Thomas</option>
  <option value="3">M. Clark</option>
</select>
```

##### `collection_radio_buttons`
Возвращает теги `radio_button` для коллекции значений, возвращаемых `method` для класса `object`.

Пример структуры объекта для использования с этим методом:
```
class Article < ApplicationRecord
  belongs_to :author
end

class Author < ApplicationRecord
  has_many :articles
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
```
Пример использования (выбор связанного Author для экземпляра `Article, @article`):
```
collection_radio_buttons(:article, :author_id, Author.all, :id, :name_with_initial)
```
Если `@article.author_id` — 1, это вернет:
```
<input id="article_author_id_1" name="article[author_id]" type="radio" value="1" checked="checked" />
<label for="article_author_id_1">D. Heinemeier Hansson</label>
<input id="article_author_id_2" name="article[author_id]" type="radio" value="2" />
<label for="article_author_id_2">D. Thomas</label>
<input id="article_author_id_3" name="article[author_id]" type="radio" value="3" />
<label for="article_author_id_3">M. Clark</label>
```
Раскрыть, что некоторый вариант выбран (т.е. программно отметить объект из коллекции):
```
collection_radio_buttons(:article, :author_id, Author.all, :id, :name_with_initial, {checked: Author.last})
```
В этом случае, последний объект из коллекции будет отмечен:
```
<input id="article_author_id_1" name="article[author_id]" type="radio" value="1" />
<label for="article_author_id_1">D. Heinemeier Hansson</label>
<input id="article_author_id_2" name="article[author_id]" type="radio" value="2" />
<label for="article_author_id_2">D. Thomas</label>
<input id="article_author_id_3" name="article[author_id]" type="radio" value="3" checked="checked" />
<label for="article_author_id_3">M. Clark</label>
```
Чтобы программно получить доступ к переданным опциям (например, добавить пользовательский класс, если отмечен):

Образец `html.erb`
```
<%= collection_radio_buttons(:article, :author_id, Author.all, :id, :name_with_initial, {checked: Author.last, required: rue} do |rb| %>
      <%= rb.label(class: "#{'my-custom-class' if rb.value == Author.last.id}") { rb.radio_button + rb.text } %>
<% end %>
```
##### `collection_check_boxes`
Возвращает теги `check_box` для коллекции значений, возвращаемых `method` для класса `object`.

Пример структуры объекта для использования с этим методом:
```
class Article < ApplicationRecord
  has_and_belongs_to_many :authors
end

class Author < ApplicationRecord
  has_and_belongs_to_many :articles
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
```
Пример использования (выбор связанного `Author` для экземпляра `Article, @article`):
```
collection_check_boxes(:article, :author_ids, Author.all, :id, :name_with_initial)
```
Если `@article.author_id` — [1], это вернет:
```
<input id="article_author_ids_1" name="article[author_ids][]" type="checkbox" value="1" checked="checked" />
<label for="article_author_ids_1">D. Heinemeier Hansson</label>
<input id="article_author_ids_2" name="article[author_ids][]" type="checkbox" value="2" />
<label for="article_author_ids_2">D. Thomas</label>
<input id="article_author_ids_3" name="article[author_ids][]" type="checkbox" value="3" />
<label for="article_author_ids_3">M. Clark</label>
<input name="article[author_ids][]" type="hidden" value="" />
```

##### `option_groups_from_collection_for_select`
Возвращает строку с тегами `option`, подобно `options_from_collection_for_select`, но группирует их тегами optgroup на основе объектных отношений аргументов.

Пример структуры объекта для использования с этим методом:
```
class Continent < ApplicationRecord
  has_many :countries
  # attribs: id, name
end

class Country < ApplicationRecord
  belongs_to :continent
  # attribs: id, name, continent_id
end
```
Пример использования:
```
option_groups_from_collection_for_select(@continents, :countries, :name, :id, :name, 3)
```
Возможный результат:
```
<optgroup label="Africa">
  <option value="1">Egypt</option>
  <option value="4">Rwanda</option>
  ...
</optgroup>
<optgroup label="Asia">
  <option value="3" selected="selected">China</option>
  <option value="12">India</option>
  <option value="5">Japan</option>
  ...
</optgroup>
```
Возвращаются только теги `optgroup` и `option`, вам все еще нужно обернуть результат в подходящий тег `select`.

##### `options_for_select`
Принимает контейнер (хэш, массив, перечисление, ваш тип) и возвращает строку тегов `option`.
```
options_for_select([ "VISA", "MasterCard" ])
# => <option>VISA</option> <option>MasterCard</option>
```
Возвращаются только теги `option`, вам все еще нужно обернуть результат в обычный HTML-тег `select`.

##### `options_from_collection_for_select`
Возвращает строку тегов option, собранную с помощью итерации по collection и назначая результат вызова value_method как значение option и text_method как текст option.

##### options_from_collection_for_select(collection, value_method, text_method, selected = nil)

Например, представим цикл, проходящий по каждому человеку в `@project.people` для создания тега ввода:
```
options_from_collection_for_select(@project.people, "id", "name")
# => <option value="#{person.id}">#{person.name}</option>
```
> Возвращаются только теги `option`, вам все еще нужно обернуть результат в обычный HTML-тег `select`.

##### `select`
Создает тег `select` и ряд связанных тегов option для предоставленного объекта и метода.

Пример:
```
select("article", "person_id", Person.all.collect { |p| [ p.name, p.id ] }, { include_blank: true })
```
Если `@article.person_id` — 1, это выдаст:
```
<select name="article[person_id]">
  <option value=""></option>
  <option value="1" selected="selected">David</option>
  <option value="2">Eileen</option>
  <option value="3">Rafael</option>
</select>
```
##### `time_zone_options_for_select`
Возвращает строку тегов `option` для практически любой временной зоны в мире.

##### `time_zone_select`
Возвращает теги `select` и `option` для заданного объекта и метода, используя `time_zone_options_for_select` для создания списка тегов `option`.
```
time_zone_select("user", "time_zone")
```

##### `date_field`
Возвращает тег `input` типа "date" с учетом доступа к определенному атрибуту.
```
date_field("user", "dob")
```

#### FormTagHelper
Предоставляет ряд методов для создания тегов форм, которые не зависят от объекта Active Record, назначенного шаблону, как делает `FormHelper`. Вместо этого вы предоставляете вручную имена и значения

##### `check_box_tag`
Создает тег поля ввода формы в виде чекбокса.
```
check_box_tag 'accept'
# => <input id="accept" name="accept" type="checkbox" value="1" />
```

##### `field_set_tag`
Создает `fieldset` для группировки элементов формы HTML.
```
<%= field_set_tag do %>
  <p><%= text_field_tag 'name' %></p>
<% end %>
# => <fieldset><p><input id="name" name="name" type="text" /></p></fieldset>
```

##### `file_field_tag`
Создает поле для загрузки файла.
```
<%= form_tag({ action:"post" }, multipart: true) do %>
  <label for="file">File to Upload</label> <%= file_field_tag "file" %>
  <%= submit_tag %>
<% end %>
```
Примерный результат:
```
file_field_tag 'attachment'
# => <input id="attachment" name="attachment" type="file" />
```

##### `form_tag`
Открывает тег `form`, указывающий `action` по URL-адресу, настроенный с помощью `url_for_options`, как `ActionController::Base#url_for`.
```
<%= form_tag '/articles' do %>
  <div><%= submit_tag 'Save' %></div>
<% end %>
# => <form action="/articles" method="post"><div><input type="submit" name="submit" value="Save" /></div></form>
```

##### `hidden_field_tag`
Создает скрытое поле `input`, используемое для передачи данных, которые будут потеряны из-за протокола без сохранения состояния HTTP, или данные, которые должны быть скрыты от пользователя.
```
hidden_field_tag 'token', 'VUBJKB23UIVI1UU1VOBVI@'
# => <input id="token" name="token" type="hidden" value="VUBJKB23UIVI1UU1VOBVI@" />
```

##### `image_submit_tag`
Отображает изображение, при нажатии на которое будет отправлена форма.
```
image_submit_tag("login.png")
# => <input src="/images/login.png" type="image" />
```

##### `label_tag`
Создает тег `label`.
```
label_tag 'name'
# => <label for="name">Name</label>
```

##### `password_field_tag`
Создает поле для ввода пароля, скрытое текстовое поле, которое спрячет то, что вводит пользователь символами маски.
```
password_field_tag 'pass'
# => <input id="pass" name="pass" type="password" />
```

##### `radio_button_tag`
Создает радиокнопку; используйте группу радиокнопок с одинаковым именем, чтобы пользователи могли выбирать из группы опций.
```
radio_button_tag 'favorite_color', 'maroon'
# => <input id="favorite_color_maroon" name="favorite_color" type="radio" value="maroon" />
```
##### `select_tag`
Создает выпадающий список.
```
select_tag "people", "<option>David</option>"
# => <select id="people" name="people"><option>David</option></select>
```
##### `submit_tag`
Создает кнопку для отправки формы с текстом-заголовком.
```
submit_tag "Publish this article"
# => <input name="commit" type="submit" value="Publish this article" />
```
##### `text_area_tag`
Создает область ввода текста; используйте `textarea` для длинного ввода текста, такого как статьи в блоге или описания.
```
text_area_tag 'article'
# => <textarea id="article" name="article"></textarea>
```
##### `text_field_tag`

Создает стандартное поле ввода текста; используйте их для ввода небольших кусочков текста, таких как имя пользователя или поисковый запрос.
```
text_field_tag 'name'
# => <input id="name" name="name" type="text" />
```
##### `email_field_tag`
Создает стандартное поле ввода с типом `email`.
```
email_field_tag 'email'
# => <input id="email" name="email" type="email" />
```
##### `url_field_tag`
Создает стандартное поле ввода с типом `url`.
```
url_field_tag 'url'
# => <input id="url" name="url" type="url" />
```
##### `date_field_tag`
Создает стандартное поле ввода с типом `date`.
```
date_field_tag "dob"
# => <input id="dob" name="dob" type="date" />
```

#### JavaScriptHelper
Предоставляет функциональность для работы с JavaScript в ваших вьюхах.

##### `escape_javascript`
Экранирует переводы строк и одиночные и двойные кавычки во фрагментах JavaScript.

##### `javascript_tag`
Возвращает тег JavaScript, оборачивающий предоставленный код.
```
javascript_tag "alert('All is good')"

<script>
//<![CDATA[
alert('All is good')
//]]>
</script>
```

#### NumberHelper
Предоставляет методы для конвертации чисел в форматированные строки. Методы предоставлены для телефонных номеров, валют, процентов, позиционных систем счисления и размеров файла.

##### `number_to_currency`
Форматирует число в строку с символом валюты (например, $13.65).
```
number_to_currency(1234567890.50) # => $1,234,567,890.50
```

##### `number_to_human_size`
Форматирует размер в байтах в более понятное представление; полезно для показа размеров файла пользователям.
```
number_to_human_size(1234)          # => 1.2 KB
number_to_human_size(1234567)       # => 1.2 MB
```

##### `number_to_percentage`
Форматирует число в строку с символом процента.
```
number_to_percentage(100, precision: 0)        # => 100%
```

##### `number_to_phone`
Форматирует число в телефонный номер (по умолчанию США).
```
number_to_phone(1235551234) # => 123-555-1234
```

##### `number_with_delimiter`
Форматирует число с сгруппированными тысячами, используя разделитель.
```
number_with_delimiter(12345678) # => 12,345,678
```

##### `number_with_precision`
Форматирует число с помощью определенного уровня точности, по умолчанию 3.
```
number_with_precision(111.2345)                # => 111.235
number_with_precision(111.2345, precision: 2)  # => 111.23
```

#### SanitizeHelper
Модуль SanitizeHelper предоставляет набор методов для очистки текста от нежелательных элементов HTML.

##### `sanitize`
Хелпер `sanitize` экранирует все теги HTML и удаляет все атрибуты, которые не разрешены явно.
```
sanitize @article.body
```
Если переданы опции или `:attributes`, или `:tags`, разрешены только упомянутые теги и атрибуты, и ничего более.
```
sanitize @article.body, tags: %w(table tr td), attributes: %w(id class style)
```
Чтобы изменить значения по умолчанию для многократного использования, например, добавить теги таблиц к значениям по умолчанию:
```
class Application < Rails::Application
  config.action_view.sanitized_allowed_tags = 'table', 'tr', 'td'
end
```

##### `sanitize_css(style)`
Экранирует блок кода CSS.

##### `strip_links(html)`
Обрезает все теги ссылок в тексте, оставляя только текст ссылки.
```
strip_links('<a href="https://rubyonrails.org">Ruby on Rails</a>')
# => Ruby on Rails

strip_links('emails to <a href="mailto:me@email.com">me@email.com</a>.')
# => emails to me@email.com.

strip_links('Blog: <a href="http://myblog.com/">Visit</a>.')
# => Blog: Visit.
```
##### `strip_tags(html)`
Обрезает все теги HTML из `html`, включая комментарии. Эта функция доступна, если подключен гем `rails-html-sanitizer`.
```
strip_tags("Strip <i>these</i> tags!")
# => Strip these tags!

strip_tags("<b>Bold</b> no more!  <a href='more.html'>See more</a>")
# => Bold no more!  See more
```
NB: Результат все еще может содержать неэкранированные символы '<', '>', '&' и путать браузеры.

#### CsrfHelper
Возвращает метатеги "csrf-param" и "csrf-token" с, соответственно, именами параметра и токена против межсайтовой подделки запроса.
```
<%= csrf_meta_tags %>
```
> Обычные формы создают скрытые поля, поэтому они не используют эти теги.

### Локализованные вьюхи <a name="3.1.7"></a>
В Action View есть возможность рендерить различные шаблоны в зависимости от текущей локали.

Например, предположим, что у вас есть `ArticlesController` с экшном `show`. По умолчанию вызов этого экшна отрендерит `app/views/articles/show.html.erb`. Но если вы установите `I18n.locale = :de`, то вместо него будет отрендерен `app/views/articles/show.de.html.erb`. Если локализованный шаблон отсутствует, будет использована недекорированная версия. Это означает, что не нужно предоставлять локализованные вьюхи для всех случаев, но они будут предпочтительными и будут использоваться, если станут доступны.

Ту же технику можно использовать для локализации страниц ошибок в директории `public`. Например, установка `I18n.locale = :de` и создание `public/500.de.html` и `public/404.de.html` позволит иметь локализованные страницы ошибок.

Так как Rails не ограничивает символы, используемые для установления `I18n.locale`, эту систему можно использовать для отображения различного содержимого, зависящего от чего-либо иного. Например, предположим у вас есть пользователи "expert", которые должны видеть страницы иные, чем пользователи "normal". Можно добавить следующее в `app/controllers/application.rb`:
```
before_action :set_expert_locale

def set_expert_locale
  I18n.locale = :expert if current_user.expert?
end
```
Затем можно добавить специальные вьюхи, такие как `app/views/articles/show.expert.html.erb` которые будут отображены только пользователям `expert`.

## Макеты и рендеринг в Rails <a name="3.2"></a>

### Обзор: как кусочки складываются вместе <a name="3.2.1"></a>
Это руководство сосредотачивается на взаимодействии между контроллером и вьюхой (представлением) в треугольнике модель-представление-контроллер (MVC). Как вы знаете, контроллер ответственен за управление целым процессом обслуживания запросов в Rails, хотя обычно любой серьезный код переносится в модель. Но когда приходит время послать отклик обратно пользователю, контроллер передает все вьюхе. Именно этой передаче посвящено данное руководство.

В общих чертах все связано с решением, что же должно быть послано как отклик, и вызовом подходящего метода для создания этого отклика. Если откликом является полноценная вьюха, Rails также проводит дополнительную работу по упаковыванию вьюхи в макет и, возможно, по вставке частичных вьюх. В общем, все эти этапы вы увидите сами в следующих разделах.

### Создание откликов <a name="3.2.2"></a>
С точки зрения контроллера есть три способа создать отклик HTTP:
* Вызвать `render` для создания полного отклика, возвращаемого браузеру
* Вызвать `redirect_to` для передачи браузеру кода переадресации HTTP
* Вызвать `head` для создания отклика, включающего только заголовки HTTP, возвращаемого браузеру 

#### Рендеринг по умолчанию: соглашения по конфигурации в действии
Вы уже слышали, что Rails содействует принципу "соглашения по конфигурации". Рендеринг по умолчанию - прекрасный пример этого. По умолчанию контроллеры в Rails автоматически рендерят вьюхи с именами, соответствующими валидным маршрутам. 
Итак, в нашей вьюхе мы хотим отобразить свойства всех книг, это делается с помощью шаблона ERB, подобного следующему:
```
<h1>Listing Books</h1>

<table>
  <thead>
    <tr>
      <th>Title</th>
      <th>Content</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <% @books.each do |book| %>
      <tr>
        <td><%= book.title %></td>
        <td><%= book.content %></td>
        <td><%= link_to "Show", book %></td>
        <td><%= link_to "Edit", edit_book_path(book) %></td>
        <td><%= link_to "Destroy", book, method: :delete, data: { confirm: "Are you sure?" } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to "New book", new_book_path %>
```
> Фактически рендеринг осуществляется вложенными классами модуля `ActionView::Template::Handlers`. Мы не будем углубляться в этот процесс, но важно знать, что расширение файла вьюхи контролирует выбор обработчика шаблона.

#### Использование `render`
Во многих случаях метод `ActionController::Base#render` выполняет большую работу по рендерингу содержимого Вашего приложения для использования в браузере. Имеются различные способы настройки возможностей render. Вы можете рендерить вьюху по умолчанию для шаблона Rails, или определенный шаблон, или файл, или встроенный код, или совсем ничего. Можно рендерить текст, JSON или XML. Также можно определить тип содержимого или статус HTTP отрендеренного отклика.

Если хотите увидеть точные результаты вызова `render` без необходимости проверять это в браузере, можете вызвать `render_to_string`. Этот метод принимает те же самые опции, что и render, но возвращает строку вместо отправки отклика обратно браузеру.

##### Рендеринг вьюхи экшна

Если хотите отрендерить вьюху, соответствующую другому шаблону этого же контроллера, можно использовать `render` с именем вьюхи:
```
def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render "edit"
  end
end
```
Если вызов `update` проваливается, вызов экшна `update` в этом контроллере отрендерит шаблон `edit.html.erb`, принадлежащий тому же контроллеру.

Если хотите, можете использовать символ вместо строки для определения экшна для рендеринга:
```
def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render :edit
  end
end
```

##### Рендеринг шаблона экшна из другого контроллера

Что, если вы хотите отрендерить шаблон из абсолютно другого контроллера? Это можно также сделать с `render`, который принимает полный путь шаблона для рендеринга (относительно `app/views`). Например, если запускаем код в `AdminProductsController` который находится в `app/controllers/admin`, можете отрендерить результат экшна в шаблон в `app/views/products` следующим образом:
```
render "products/show"
```
Rails знает, что эта вьюха принадлежит другому контроллеру, поскольку содержит символ слэша в строке. Если хотите быть точными, можете использовать опцию `:template` (которая требовалась в Rails 2.2 и более ранних):
```
render template: "products/show"
```

##### Оборачивание
Вышеописанные три метода рендеринга (рендеринг другого шаблона в контроллере, рендеринг шаблона в другом контроллере и рендеринг произвольного файла в файловой системе) на самом деле являются вариантами одного и того же экшна.

Фактически в классе `BooksController`, в экшне `update`, в котором мы хотим отрендерить шаблон `edit`, если книга не была успешно обновлена, все нижеследующие вызовы отрендерят шаблон `edit.html.erb` в директории `views/books`:
```
render :edit
render action: :edit
render "edit"
render action: "edit"
render "books/edit"
render template: "books/edit"
```
Какой из них вы будете использовать - это вопрос стиля и соглашений, но практическое правило заключается в использовании простейшего, который больше подходит по стилю написания вашего кода.

##### Использование `render` с `:inline`
Метод `render` вполне может обойтись без вьюхи, если вы используете опцию `:inline` для поддержки ERB, как части вызова метода. Это вполне валидно:
```
render inline: "<% products.each do |p| %><p><%= p.name %></p><% end %>"
```
> Должно быть серьезное основание для использования этой опции. Вкрапление ERB в контроллер нарушает MVC ориентированность Rails и создает трудности для других разработчиков в следовании логике вашего проекта. Вместо этого используйте отдельную erb-вьюху.

По умолчанию встроенный рендеринг использует ERB. Можете принудить использовать вместо этого `Builder` с помощью опции `:type`:
```
render inline: "xml.p {'Horrid coding practice!'}", type: :builder
```

##### Рендеринг текста

Вы можете послать простой текст - совсем без разметки - обратно браузеру с использованием опции `:plain` в `render`:
```
render plain: "OK"
```
> Рендеринг чистого текста наиболее полезен, когда вы делаете Ajax-отклик или отвечаете на запросы веб-сервиса, ожидающего что-то иное, чем HTML.

> По умолчанию при использовании опции `:plain` текст рендерится без использования текущего макета. Если хотите, чтобы Rails вложил текст в текущий макет, необходимо добавить опцию `layout: true` и использовать расширение `.text.erb` для файла макета.

##### Рендеринг HTML
Вы можете вернуть HTML, используя опцию `:html` метода `render`:
```
render html: helpers.tag.strong('Not Found')
```

> Это полезно когда вы хотите отрендерить небольшой кусочек HTML-кода. Однако, если у вас достаточно сложная разметка, стоит рассмотреть выделение её в файл шаблона.

> Когда используется опция `html:`, HTML объекты будут экранироваться, если строка не состоит из API, поддерживающих `html_safe`.

##### Рендеринг JSON
JSON - это формат данных JavaScript, используемый многими библиотеками Ajax. Rails имеет встроенную поддержку для преобразования объектов в JSON и рендеринга этого JSON обратно браузеру:
```
render json: @product
```
> Не нужно вызывать `to_json` в объекте, который хотите рендерить. Если используется опция `:json`, `render` автоматически вызовет `to_json` за вас.

##### Рендеринг XML
Rails также имеет встроенную поддержку для преобразования объектов в XML и рендеринга этого XML обратно вызывающему:
```
render xml: @product
```
Не нужно вызывать `to_xml` в объекте, который хотите рендерить. Если используется опция `:xml`, render автоматически вызовет `to_xml` за вас.

##### Рендеринг внешнего JavaScript
Rails может рендерить чистый JavaScript:
```
render js: "alert('Hello Rails');"
```
Это пошлет указанную строку в браузер с типом MIME `text/javascript`.

##### Рендеринг необработанного содержимого
Вы можете вернуть необработанный текст, без установки типа содержимого, используя опцию `:body`, метода `render`:
```
render body: "raw"
```
> Эта опция должна использоваться, только если не важен тип содержимого отклика. Использование `:plain` или `:html` уместнее в большинстве случаев.

> Возвращенным откликом от этой опции будет `text/plain` (если не будет переопределен), так как это тип содержимого по умолчанию у отклика `Action Dispatch`.

##### Рендеринг необработанного файла
Rails может рендерить необработанный файл по абсолютному пути. Это полезно для условного рендеринга статичных файлов, таких как страницы ошибок.
```
render file: "#{Rails.root}/public/404.html", layout: false
```
Это отрендерит необработанный файл (ERB или другие обработчики не поддерживаются). По умолчанию файл рендерится с использованием текущего макета.

> Использование опции `:file` в комбинации с данными, введенными пользователем, может привести к проблемам безопасности, так как злоумышленник может использовать этот экшн для доступа к чувствительным, с точки зрения безопасности, файлам вашей файловой системы.

> `send_file` часто является более быстрым и лучшим вариантом, если макет не требуется.

##### Опции для render
Вызов метода render как правило принимает шесть опций:
* `:content_type`
* `:layout`
* `:location`
* `:status`
* `:formats`
* `:variants` 

###### Опция `:content_type`
По умолчанию Rails будет обрабатывать результаты операции рендеринга с типом содержимого MIME `text/html` (или `application/json`, если используется опция `:json`, или `application/xml` для опции `:xml`). Иногда бывает так, что нужно изменить это, и тогда необходимо настроить опцию `:content_type`:
```
render template: "feed", content_type: "application/rss"
```

###### Опция `:layout`
С большинством опций для render, отрендеренное содержимое отображается как часть текущего макета.
Опция `:layout` нужна, чтобы сообщить Rails о необходимости использовать определенный файл как макет для текущего экшна:
```
render layout: "special_layout"
```
Также можно сообщить Rails, что требуется рендерить вообще без макета:
```
render layout: false
```

###### Опция `:location`
Опцию `:location` можно использовать, чтобы установить заголовок HTTP Location:
```
render xml: photo, location: photo_url(photo)
```

###### Опция `:status`

Rails автоматически сгенерирует отклик с правильным кодом статуса HTML (в большинстве случаев равный 200 OK). Опцию `:status` можно использовать, чтобы изменить это:
```
render status: 500
render status: :forbidden
```
> Если попытаться отрендерить содержимое наряду с кодом статуса без содержимого (100-199, 204, 205 или 304), он будет исключён из отклика.

###### Опция `:formats`

Rails использует формат, определённый в запросе (или `:html` по умолчанию). Вы можете изменить его, передав в опцию `:formats` символ или массив:
```
render formats: :xml
render formats: [:json, :xml]
```
Если шаблон с указанным форматом не существует, вызывается ошибка `ActionView::MissingTemplate`.

###### Опция `:variants`
Она сообщает Rails искать варианты шаблона того же формата. Можно указать список вариантов, передав опции `:variants` символ или массив.

Пример использования.
```
# called in HomeController#index
render variants: [:mobile, :desktop]
```
С таком набором вариантов, Rails будет искать следующий набор шаблонов и использовать первый из существующих.
* `app/views/home/index.html+mobile.erb`
* `app/views/home/index.html+desktop.erb`
* `app/views/home/index.html.erb`
Если шаблон с указанным форматом не существует, будет вызвана ошибка `ActionView::MissingTemplate`.

Вместо указания варианта на вызове `render`, его также можно установить на объекте `request` в экшне контроллера.
```
def index
  request.variant = determine_variant
end

private

def determine_variant
  variant = nil
  # некоторый код для определения варианта(ов) для использования
  variant = :mobile if session[:use_mobile]

  variant    
end
```

###### Поиск макетов
Чтобы найти текущий макет, Rails сначала смотрит файл в `app/views/layouts` с именем, таким же, как имя контроллера. Например, рендеринг экшнов из класса `PhotosController` будет использовать `/app/views/layouts/photos.html.erb` (или `app/views/layouts/photos.builder`). Если такого макета нет, Rails будет использовать `/app/views/layouts/application.html.erb` или `/app/views/layouts/application.builder`. Если макет `.erb` отсутствует, Rails будет использовать макет `.builder`, если таковой имеется. Rails также предоставляет несколько способов для более точного назначения определенных макетов отдельным контроллерам и экшнам.

###### Определение макетов для контроллеров
Вы можете переопределить дефолтные соглашения по макетам в контроллере, используя объявление `layout`. Например:
```
class ProductsController < ApplicationController
  layout "inventory"
  #...
end
```
С этим объявлением все вьюхи, отрендеренные `ProductsController`, будут использовать `app/views/layouts/inventory.html.erb` как макет.

Чтобы привязать определенный макет к приложению в целом, используйте объявление `layout` в классе `ApplicationController`:
```
class ApplicationController < ActionController::Base
  layout "main"
  #...
end
```
С этим объявлением каждая из вьюх во всем приложении будет использовать `app/views/layouts/main.html.erb` как макет.

###### Выбор макетов во время выполнения
Можно использовать символ для отсрочки выбора макета до тех пор, пока не будет обработан запрос:
```
class ProductsController < ApplicationController
  layout :products_layout

  def show
    @product = Product.find(params[:id])
  end

  private
    def products_layout
      @current_user.special? ? "special" : "products"
    end
end
```
Теперь, если текущий пользователь является специальным, он получит специальный макет при просмотре продукта.

Можно даже использовать встроенный метод, такой как `Proc`, для определения макета. Например, если передать объект `Proc`, то блоку, которому вы передаете `Proc`, будет предоставлен экземпляр `controller`, поэтому макет может быть определен, основываясь на текущем запросе:
```
class ProductsController < ApplicationController
  layout Proc.new { |controller| controller.request.xhr? ? "popup" : "application" }
end
```

###### Условные макеты
Макеты, определенные на уровне контроллера, поддерживают опции `:only` и `:except`. Эти опции принимают либо имя метода, либо массив имен методов, соответствующих именам методов в контроллере:
```
class ProductsController < ApplicationController
  layout "product", except: [:index, :rss]
end
```
С таким объявлением макет `product` будет использован везде, кроме методов `rss` и `index`.

###### Наследование макета

Объявление макета ниже по иерархии и более специфическое объявление макета всегда переопределяет более общие. 

###### Наследование шаблона
Следуя логике наследования макета, если шаблон или партиал не найдены по обычному пути, контроллер будет искать шаблон или партиал для рендеринга по цепочке наследования. Например:
```
# in app/controllers/application_controller
class ApplicationController < ActionController::Base
end

# in app/controllers/admin_controller
class AdminController < ApplicationController
end

# in app/controllers/admin/products_controller
class Admin::ProductsController < AdminController
  def index
  end
end
```
Порядок поиска экшна admin/products#index будет такой:
* `app/views/admin/products/`
* `app/views/admin/`
* `app/views/application/` 

Это делает `app/views/application/` хорошим местом для общих партиалов, которые затем могут быть отрендерены в ERB следующим образом:
```
<%# app/views/admin/products/index.html.erb %>
<%= render @products || "empty_list" %>

<%# app/views/application/_empty_list.html.erb %>
There are no items in this list <em>yet</em>.
```

###### Избегание ошибок двойного рендеринга
Рано или поздно, большинство разработчиков на Rails увидят сообщение об ошибке "Can only render or redirect once per action". Хоть такое и раздражает, это относительно просто правится. Обычно такое происходит в связи с фундаментальным непониманием метода работы `render`.

Например, вот некоторый код, который вызовет эту ошибку:
```
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
  render action: "regular_show"
end
```
Если `@book.special?` вычисляется как `true`, Rails начинает процесс рендеринга, выгружая переменную `@book` во вьюху `special_show`. Но это не остановит от выполнения остальной код в экшне `show`, и когда Rails достигнет конца экшна, он начнет рендерить вьюху `show` - и выдаст ошибку. Решение простое: убедитесь, что у вас есть только один вызов `render` или `redirect` за один проход. Еще может помочь такая вещь, как `and return`. Вот исправленная версия метода:
```
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show" and return
  end
  render action: "regular_show"
end
```
Убедитесь, что используете `and return` вместо `&& return`, поскольку `&& return` не будет работать в связи с приоритетом операторов в языке Ruby.

Отметьте, что неявный рендер, выполняемый `ActionController`, определяет, был ли вызван render поэтому следующий код будет работать без проблем:
```
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
end
```
Это отрендерит книгу (book) с `special?`, заданным с помощью шаблона `special_show`, в то время как остальные книги будут рендериться с дефолтным шаблоном `show`.

#### Использование `redirect_to`
Другой способ управлять возвратом отклика на HTTP-запрос - с помощью `redirect_to`. Как вы видели, render сообщает Rails, какую вьюху (или иной ассет) использовать при построении отклика. Метод `redirect_to` делает нечто совершенно отличное: он говорит браузеру послать новый запрос по другому URL. Например, можно перенаправить из любого места, где сейчас выполняется код, к экшну `index` фотографий вашего приложения с помощью этого вызова:
```
redirect_to photos_url
```
Можно использовать `redirect_back`, чтобы вернуть пользователя на страницу с которой он только что пришел. Это место расположения вытаскивается из заголовка HTTP_REFERER, который не обязательно будет установлен браузером, поэтому нужно предоставить `fallback_location` для использования в таком случае.
```
redirect_back(fallback_location: root_path)
```

> `redirect_to` и `redirect_back` не прерывают и не возвращают из выполняемого метода немедленно, а просто устанавливают отклики HTTP. Выражения, следующие после них в методе, будут выполнены. При необходимости можно прервать явным `return` или любым другим механизмом прерывания.

##### Получение различного кода статуса перенаправления

Rails использует код статуса HTTP 302, временное перенаправление, при вызове `redirect_to`. Если хотите использовать иной код статуса, возможно 301, постоянное перенаправление, можете использовать опцию `:status`:
```
redirect_to photos_path, status: 301
```
Подобно опции `:status` для render, `:status` для `redirect_to` принимает и числовые, и символьные обозначения заголовка.

##### Различие между `render` и `redirect_to`
Иногда неопытные разработчики думают о `redirect_to` как о разновидности команды `goto`, перемещающую выполнение из одного места в другое в вашем коде Rails. Это не верно. Ваш код останавливается и ждет нового запроса от браузера. Просто получается так, что вы говорите браузеру, какой запрос он должен сделать следующим, возвращая код статуса HTTP 302.

Рассмотрим эти экшны, чтобы увидеть разницу:
```
def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    render action: "index"
  end
end
```
С кодом в такой форме, вероятно, будет проблема, если переменная `@book` равна `nil`. Помните, `render :action` **не запускает какой-либо код в указанном экшне**, и таким образом ничего не будет присвоено переменной `@books`, которую, возможно, потребует вьюха `index`. Один из способов исправить это - использовать перенаправление вместо рендеринга:
```
def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    redirect_to action: :index
  end
end
```

С помощью этого кода браузер сделает новый запрос для индексной страницы, код в методе `index` запустится, и все будет хорошо.

Единственный недостаток этого кода в том, что он требует круговорот через браузер: браузер запрашивает экшн `show` с помощью `/books/1`, и контроллер обнаруживает, что книг нет, поэтому отсылает отклик-перенаправление 301 браузеру, сообщающий перейти на `/books/`, браузер выполняет и посылает новый запрос контроллеру, теперь запрашивая экшн `index`, затем контроллер получает все книги в базе данных и рендерит шаблон `index`, отсылает его обратно браузеру, который затем показывает его на экране.

Пока это небольшое приложение, такая добавленная задержка не может быть проблемой, но иногда стоит подумать о том, является ли время отклика проблемой. Можем продемонстрировать один из способов управления этим с помощью хитрого примера:
```
def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    @books = Book.all
    flash.now[:alert] = "Your book was not found"
    render "index"
  end
end
```
Это обнаружит, что нет книг с определенным ID, заполнит переменную экземпляра @books всеми книгами в модели, и затем напрямую отрендерит шаблон `index.html.erb`, возвратив его браузеру с предупреждающим сообщением в `flash`, сообщающим пользователю, что произошло.

#### Использование `head` для создания отклика, содержащего только заголовок
Метод `head` может использоваться для отправки браузеру откликов, содержащих только заголовки. Метод `head` принимает число или символ (смотрите таблицу соответствия), представляющие код статуса HTTP. Аргумент опций интерпретируется как хэш заголовков имен и значений. Например, можно возвратить только заголовок ошибки:
```
head :bad_request
```
Это создаст следующий заголовок:
```
HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
```
Или можете использовать другие заголовки HTTP для передачи другой информации:
```
head :created, location: photo_path(@photo)
```
Что создаст:
```
HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
```

### Структурирование макетов <a name="3.2.3"></a>
В макетах у вас есть доступ к трем инструментам для объединения различных кусочков результата для формирования общего отклика:
* Теги ассетов
* `yield` и `content_for`
* Партиалы 

#### Хелперы ассетных тегов
Хелперы ассетных тегов предоставляют методы для генерации HTML, связывающие вьюхи с лентами новостей, JavaScript, таблицами стилей, изображениями, видео и аудио. В Rails доступно шесть хелперов ассетных тегов:
* `auto_discovery_link_tag`
* `javascript_include_tag`
* `stylesheet_link_tag`
* `image_tag`
* `video_tag`
* `audio_tag` 
Эти теги можно использовать в макетах или других вьюхах, хотя `auto_discovery_link_tag`, `javascript_include_tag` и `stylesheet_link_tag` как правило используются в разделе `<head>` макета.

> Хелперы ассетных тегов не проверяют существование ассетов по заданному месту расположения; они просто предполагают, что вы знаете, что делаете, и генерируют ссылку.

##### Присоединение каналов с помощью `auto_discovery_link_tag`

Хелпер `auto_discovery_link_tag` создает HTML-код, который большинство браузеров и агрегаторов новостей могут использовать для определения наличия каналов RSS, Atom или JSON лент. Он принимает тип ссылки (`:rss`, `:atom` или `:json`), хэш опций, которые передаются через `url_for`, и хэш опций для тега:
```
<%= auto_discovery_link_tag(:rss, {action: "feed"},
  {title: "RSS Feed"}) %>
```
Вот три опции тега, доступные для `auto_discovery_link_tag`:
* `:rel` определяет значение rel в ссылке. Значение по умолчанию "alternate"
* `:type` определяет явный тип MIME. Rails генерирует подходящий тип MIME автоматически
* `:title` определяет заголовок ссылки. Значение по умолчанию это значение `:type` в верхнем регистре, например, "ATOM" или "RSS". 

##### Присоединение файлов JavaScript с помощью `javascript_include_tag`
Хелпер `javascript_include_tag` возвращает HTML-тег script для каждого предоставленного источника.

При использовании Rails с включенным Asset Pipeline, этот хелпер сгенерирует ссылку на `/assets/javascripts/`, а не на `public/javascripts`, которая использовалась в более ранних версиях Rails. Затем эта ссылка обслуживается файлопроводом (`asset pipeline`).

Файл JavaScript в приложении Rails или Rails Engine размещается в одном из трех мест расположения: `app/assets`, `lib/assets` или `vendor/assets`.
Можно определить полный путь относительно корня документа или URL, по желанию. Например, сослаться на файл JavaScript, находящийся в директории с именем javascripts в одной из `app/assets`, `lib/assets` или `vendor/assets`, можно так:
```
<%= javascript_include_tag "main" %>
```
Rails тогда выдаст такой тег script:
```
<script src='/assets/main.js'></script>
```
Затем запрос к этому ассету будет обслужен гемом `Sprockets`.

Чтобы включить несколько файлов, таких как `app/assets/javascripts/main.js` и `app/assets/javascripts/columns.js` за один раз:
```
<%= javascript_include_tag "main", "columns" %>
```
Чтобы включить `app/assets/javascripts/main.js` и `app/assets/javascripts/photos/columns.js`:
```
<%= javascript_include_tag "main", "/photos/columns" %>
```
Чтобы включить `http://example.com/main.js`:
```
<%= javascript_include_tag "http://example.com/main.js" %>
```

##### Присоединение файлов CSS с помощью `stylesheet_link_tag`
Хелпер `stylesheet_link_tag` возвращает HTML-тег <link> для каждого предоставленного источника.

При использовании Rails с включенным "Asset Pipeline", этот хелпер сгенерирует ссылку на `/assets/stylesheets/`. Эта ссылка будет затем обработана гемом `Sprockets`. Файл таблицы стилей может быть размещен в одном из трех мест расположения: `app/assets`, `lib/assets` или `vendor/assets`.

Можно определить полный путь относительно корня документа или URL. Например, на файл таблицы стилей в директории `stylesheets`, размещенной в одной из `app/assets`, `lib/assets` или `vendor/assets`, можно сослаться так:
```
<%= stylesheet_link_tag "main" %>
```
Чтобы включить `app/assets/stylesheets/main.css` и `app/assets/stylesheets/columns.css`:
```
<%= stylesheet_link_tag "main", "columns" %>
```
Чтобы включить `app/assets/stylesheets/main.css` и `app/assets/stylesheets/photos/columns.css`:
```
<%= stylesheet_link_tag "main", "/photos/columns" %>
```
Чтобы включить `http://example.com/main.css`:
```
<%= stylesheet_link_tag "http://example.com/main.css" %>
```
По умолчанию `stylesheet_link_tag` создает ссылки с `media="screen" rel="stylesheet"`. Можно переопределить любое из этих дефолтных значений, указав соответствующую опцию (`:media`, `:rel`):
```
<%= stylesheet_link_tag "main_print", media: "print" %>
```

##### Присоединение изображений с помощью `image_tag`
Хелпер `image_tag` создает HTML-тег <img /> для определенного файла. По умолчанию файлы загружаются из `public/images`.

Обратите внимание, что нужно указывать расширение изображения.
```
<%= image_tag "header.png" %>
```
Вы можете предоставить путь к изображению, если желаете:
```
<%= image_tag "icons/delete.gif" %>
```
Вы можете предоставить хэш дополнительных опций HTML:
```
<%= image_tag "icons/delete.gif", {height: 45} %>
```
Или альтернативный текст, если пользователь отключил показ изображений в браузере. Если вы не определили явно тег `alt`, по умолчанию будет указано имя файла с большой буквы и без расширения. Например, эти два тега изображения возвратят одинаковый код:
```
<%= image_tag "home.gif" %>
<%= image_tag "home.gif", alt: "Home" %>
```
Можете указать специальный тег `size` в формате "{width}x{height}":
```
<%= image_tag "home.gif", size: "50x20" %>
```
В дополнение к вышеописанным специальным тегам, можно предоставить итоговый хэш стандартных опций HTML, таких как `:class` или `:id`, или `:name`:
```
<%= image_tag "home.gif", alt: "Go Home",
                          id: "HomeImage",
                          class: "nav_bar" %>
```

##### Присоединение видео с помощью `video_tag`
Хелпер `video_tag` создает тег HTML 5 `<video>` для определенного файла. По умолчанию файлы загружаются из `public/videos`.
```
<%= video_tag "movie.ogg" %>
```
Создаст
```
<video src="/videos/movie.ogg" />
```
Подобно `image_tag`, можно предоставить путь или абсолютный, или относительный к директории `public/videos`. Дополнительно можно определить опцию `size`: "#{width}x#{height}", как и в `image_tag`. Теги видео также могут иметь любые опции HTML, определенные в конце (`id`, `class` и др.).

Тег видео также поддерживает все HTML-опции <video> через хэш HTML-опций, включая:
* `poster`: "image_name.png", предоставляет изображение, которое будет отображаться вместо видео прежде, чем оно начнет проигрываться.
* `autoplay`: true, запускает проигрывание видео при загрузке страницы.
* `loop`: true, запускает видео сначала, как только оно достигает конца.
* `controls`: true, предоставляет пользователю поддерживаемую браузером панель управления для взаимодействия с видео.
* `autobuffer`: true, файл видео предварительно загружается для пользователя при загрузке страницы. 

Также можно определить несколько видео для проигрывания, передав массив видео в `video_tag`:
```
<%= video_tag ["trailer.ogg", "movie.ogg"] %>
```
Это создаст:
```
<video>
  <source src="/videos/trailer.ogg" />
  <source src="/videos/movie.ogg" />
</video>
```
##### Присоединение аудиофайлов с помощью `audio_tag`
Хелпер `audio_tag` создает тег HTML 5 `<audio>` для определенного файла. По умолчанию файлы загружаются из `public/audios`.
```
<%= audio_tag "music.mp3" %>
```
Если хотите, можете предоставить путь к аудио файлу:
```
<%= audio_tag "music/first_song.mp3" %>
```
Также можно предоставить хэш дополнительных опций, таких как `:id`, `:class` и т.д.

Подобно `video_tag`, `audio_tag` имеет специальные опции:
* `autoplay`: true, начинает воспроизведение аудио при загрузке страницы
* `controls`: true, предоставляет пользователю поддерживаемую браузером панель управления для взаимодействия с аудио.
* `autobuffer`: true, файл аудио предварительно загружается для пользователя при загрузке страницы. 

#### Понимание `yield`
В контексте макета, `yield` определяет раздел, где должно быть вставлено содержимое из вьюхи. Самый простой способ его использования - это иметь один `yield` там, куда вставится все содержимое вьюхи, которая в настоящий момент рендерится:
```
<html>
  <head>
  </head>
  <body>
  <%= yield %>
  </body>
</html>
```
Также можете создать макет с несколькими разделами `yield`:
```
<html>
  <head>
  <%= yield :head %>
  </head>
  <body>
  <%= yield %>
  </body>
</html>
```
Основное тело вьюхи всегда рендериться в неименованный `yield`. Чтобы рендерить содержимое в именованный `yield`, используйте метод `content_for`.

#### Использование метода `content_for`
Метод `content_for` позволяет вставлять содержимое в именованный блок `yield` в макете. Например, эта вьюха будет работать с макетом, который вы только что видели:
```
<% content_for :head do %>
  <title>A simple page</title>
<% end %>

<p>Hello, Rails!</p>
```
Результат рендеринга этой страницы в макет будет таким HTML:
```
<html>
  <head>
  <title>A simple page</title>
  </head>
  <body>
  <p>Hello, Rails!</p>
  </body>
</html>
```
Метод `content_for` может помочь, когда макет содержит отдельные разделы, такие как боковые панели или футеры, в которые нужно вставить свои блоки содержимого. Это также полезно при вставке тегов, загружающих специфичные для страницы файлы JavaScript или css в хедер макета в целом.

#### Использование партиалов
Частичные шаблоны - также называемые "партиалы" - являются еще одним подходом к разделению процесса рендеринга на более управляемые кусочки. С партиалами можно перемещать код для рендеринга определенных частей отклика в свои отдельные файлы.

##### Именование партиалов
Чтобы отрендерить партиал как часть вьюхи, используем метод render внутри вьюхи:
```
<%= render "menu" %>
```
Это отрендерит файл, названный `_menu.html.erb` в этом месте в пределах рендерящейся вьюхи. Обратите внимание на начальный символ подчеркивания: файлы партиалов начинаются со знака подчеркивания, чтобы отличать их от обычных вьюх, несмотря на то, что в вызове они указаны без подчеркивания. Это справедливо даже тогда, когда партиалы вызываются из другой папки:
```
<%= render "shared/menu" %>
```
Этот код вытянет партиал из `app/views/shared/_menu.html.erb`.

Использование партиалов для упрощения вьюх

Один из способов применения партиалов это использоваться их как эквивалент подпрограмм: способ переместить часть разметки из вьюхи так, чтобы можно было легче понять, что там происходит. Например, у вас может быть такая вьюха:
```
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
...

<%= render "shared/footer" %>
```
Здесь партиалы `_ad_banner.html.erb` и `_footer.html.erb` могут содержать контент, общий для многих страниц приложения. Нет необходимости видеть код этих разделов, чтобы сконцентрироваться на определенной странице.

Как видно из предыдущих разделов данного руководства, `yield` является очень мощным инструментом для очистки ваших макетов. Имейте в виду, что это чистый Ruby, так что можно использовать его практически везде. Например, его можно использовать для соблюдения принципа DRY при определении макета формы для нескольких похожих ресурсов:
```
    users/index.html.erb

    <%= render "shared/search_filters", search: @q do |f| %>
      <p>
        Name contains: <%= f.text_field :name_contains %>
      </p>
    <% end %>

    roles/index.html.erb

    <%= render "shared/search_filters", search: @q do |f| %>
      <p>
        Title contains: <%= f.text_field :title_contains %>
      </p>
    <% end %>

    shared/_search_filters.html.erb

    <%= form_for(search) do |f| %>
      <h1>Search form:</h1>
      <fieldset>
        <%= yield f %>
      </fieldset>
      <p>
        <%= f.submit "Search" %>
      </p>
    <% end %>
```
> Для содержимого, общего для всех страниц приложения, можно использовать партиалы прямо в макетах.

##### Макеты партиала
Партиал может использовать свой собственный файл макета, подобно тому, как вьюха может использовать макет. Например, можете вызвать подобный партиал:
```
<%= render partial: "link_area", layout: "graybar" %>
```
Это найдет партиал с именем `_link_area.html.erb` и отрендерит его, используя макет` _graybar.html.erb`. Отметьте, что макеты для партиалов также начинаются с подчеркивания, как и обычные партиалы, и размещаются в той же папке с партиалами, которым они принадлежат (не в основной папке `layouts`).

Также отметьте, что явное указание `partial` необходимо, когда передаются дополнительные опции, такие как `layout`

##### Передача локальных переменных

В партиалы также можно передавать локальные переменные, что делает их более мощными и гибкими. Например, можете использовать такую технику для уменьшения дублирования между страницами `new` и `edit`, сохранив немного различающееся содержимое:
```
    new.html.erb

    <h1>New zone</h1>
    <%= render partial: "form", locals: {zone: @zone} %>

    edit.html.erb

    <h1>Editing zone</h1>
    <%= render partial: "form", locals: {zone: @zone} %>

    _form.html.erb

    <%= form_for(zone) do |f| %>
      <p>
        <b>Zone name</b><br>
        <%= f.text_field :name %>
      </p>
      <p>
        <%= f.submit %>
      </p>
    <% end %>
```
Хотя тот же самый партиал будет отрендерен в обоих вьюхах, Action View отправит хелпер, который возвратит "Create Zone" для экшна new и "Update Zone" для экшна `edit`.

**Для передачи локальной переменной в партиал только в особых случаях, используйте `local_assigns`**.
```
    index.html.erb 

  <%= render user.articles %>

    show.html.erb 

  <%= render article, full: true %>

    _article.html.erb 

  <h2><%= article.title %></h2>

  <% if local_assigns[:full] %>
    <%= simple_format article.body %>
  <% else %>
    <%= truncate article.body %>
  <% end %>
```
Таким образом, можно использовать партиал без необходимости объявления всех локальных переменных.

Каждый партиал также имеет локальную переменную с именем, как у партиала (без начального символа подчеркивания). Можете передать объект в эту локальную переменную через опцию `:object`:
```
<%= render partial: "customer", object: @new_customer %>
```
В партиале `customer` переменная `customer` будет указывать на `@new_customer` из родительской вьюхи.

Если есть экземпляр модели для рендеринга в партиале, можно использовать сокращенный синтаксис:
```
<%= render @customer %>
```
Предположим, что переменная экземпляра `@customer` содержит экземпляр модели `Customer`. Эта переменная будет использовать `_customer.html.erb` для рендеринга модели и передаст локальную переменную `customer` в партиал, на который будет ссылаться на переменная экземпляра `@customer` в родительской вьюхе.

##### Рендеринг коллекций

Партиалы часто используют для рендеринга коллекций. Когда коллекция передается в партиал с помощью опции `:collection`, партиал будет вставлен один раз для каждого члена коллекции:
```
    index.html.erb

    <h1>Products</h1>
    <%= render partial: "product", collection: @products %>

    _product.html.erb

    <p>Product Name: <%= product.name %></p>
```
Когда партиал вызывается с коллекцией во множественном числе, то каждый отдельный экземпляр партиала имеет доступ к члену коллекции, подлежащей рендерингу, через переменную с именем партиала. В нашем случает партиал `_product`, и в партиале `_product` можете обращаться к `product` для получения экземпляра, который рендерится.

Имеется также сокращенная запись для этого. Предположив, что `@products` является коллекцией экземпляров `Product`, можно просто написать так в `index.html.erb` и получить аналогичный результат:
```
<h1>Products</h1>
<%= render @products %>
```
Rails определяет имя партиала, изучая имя модели в коллекции. Фактически, можно даже создать гетерогенную коллекцию и рендерить ее таким образом, и Rails подберет подходящий партиал для каждого члена коллекции:
```
    index.html.erb

    <h1>Contacts</h1>
    <%= render [customer1, employee1, customer2, employee2] %>

    customers/_customer.html.erb

    <p>Customer: <%= customer.name %></p>

    employees/_employee.html.erb

    <p>Employee: <%= employee.name %></p>
```
В этом случае Rails использует партиалы `customer` или `employee` по мере необходимости для каждого члена коллекции.

В случае, если коллекция пустая, `render` возвратит `nil`, поэтому очень просто предоставить альтернативное содержимое.
```
<h1>Products</h1>
<%= render(@products) || "There are no products available." %>
```
##### Локальные переменные

Чтобы использовать пользовательские имена локальных переменных в партиале, определите опцию `:as` в вызове партиала:
```
<%= render partial: "product", collection: @products, as: :item %>
```
С этим изменением можете получить доступ к экземпляру коллекции `@products` через локальную переменную `item` в партиале.

Также можно передавать произвольные локальные переменные в любой партиал, который рендерится с помощью опции `locals: {}`:
```
<%= render partial: "product", collection: @products,
           as: :item, locals: {title: "Products Page"} %>
```
В этом случае, партиал имеет доступ к локальной переменной `title` со значением "Products Page".

> Rails также создает переменную счетчика, доступную в партиале, вызываемом коллекцией, названную именем заголовка партиала с добавленным `_counter`. Например, при рендеринге коллекции `@products` партиал `_product.html.erb` может получить доступ к переменной `product_counter`, которая индексирует количество раз, сколько оно было отрендерено во внешнюю вьюху. Отметьте, что это также применимо, когда имя партиала было изменено с помощью опции `as:`. Например, переменная счетчика для вышеуказанного кода будет `item_counter`.

Также можно определить второй партиал, который будет отрендерен между экземплярами главного партиала, используя опцию `:spacer_template`.

##### Разделяющие шаблоны
```
<%= render partial: @products, spacer_template: "product_ruler" %>
```
Rails отрендерит партиал `_product_ruler` (без переданных в него данных) между каждой парой партиалов `_product`.

##### Макеты коллекции партиала

При рендеринге коллекций также возможно использовать опцию `:layout`:
```
<%= render partial: "product", collection: @products, layout: "special_layout" %>
```
Макет будет отрендерен вместе с партиалом для каждого элемента коллекции. Переменные текущего объекта и `object_counter` также будут доступны в макете, как это происходит в партиале.

##### Использование вложенных макетов

Возможно, ваше приложение потребует макет, немного отличающийся от обычного макета приложения, для поддержки одного определенного контроллера. Вместо повторения главного макета и редактирования его, можете выполнить это с помощью вложенных макетов (иногда называемых подшаблонами). Вот пример:

Предположим, имеется макет `ApplicationController`:
```
    app/views/layouts/application.html.erb

    <html>
    <head>
      <title><%= @page_title or "Page Title" %></title>
      <%= stylesheet_link_tag "layout" %>
      <style><%= yield :stylesheets %></style>
    </head>
    <body>
      <div id="top_menu">Top menu items here</div>
      <div id="menu">Menu items here</div>
      <div id="content"><%= content_for?(:content) ? yield(:content) : yield %></div>
    </body>
    </html>
```
На страницах, сгенерированных `NewsController`, допустим, нужно спрятать верхнее меню и добавить правое меню:
```
    app/views/layouts/news.html.erb

    <% content_for :stylesheets do %>
      #top_menu {display: none}
      #right_menu {float: right; background-color: yellow; color: black}
    <% end %>
    <% content_for :content do %>
      <div id="right_menu">Right menu items here</div>
      <%= content_for?(:news_content) ? yield(:news_content) : yield %>
    <% end %>
    <%= render template: "layouts/application" %>
```
Вот и все. Вьюхи News будут использовать новый макет, прячущий верхнее меню и добавляющий новое правое меню в "content" `div`.

Существует несколько способов получения похожих результатов с различными подшаблонными схемами, используя эту технику. Отметьте, что нет ограничений на уровень вложенности. Можно использовать метод `ActionView::render` через `render template: 'layouts/news'`, чтобы создать новый макет на основе макета `News`. Если есть уверенность, что не понадобятся подшаблоны для макета `News`, можно заменить строку `content_for?(:news_content) ? yield(:news_content) : yield` простым `yield`.





# Контроллеры <a name="4"></a>
# Копаем глубже <a name="5"></a>
## Безопасность приложений Rails <a name="5.1"></a>
### Что такое сессии
Сессии позволяют приложению поддерживать пользовательское состояние, пока пользователи взаимодействуют с приложением. Например, сессии позволяют пользователю быть аутентифицированным единожды и оставаться таким во всех будущих запросах.
Если у пользователя уже есть активная сессия, Rails использует существующую сессию. В противном случае будет создана новая сессия.
### Угон сессии
Перехват куки в незащищенной сети. Беспроводная LAN может быть примером такой сети. В незашифрованной беспроводной LAN очень легко прослушивать трафик всех присоединенных клиентов. Для создателя веб-приложений это означает, что необходимо предоставить безопасное соединение через SSL. В Rails 3.1 и позже это может быть выполнено с помощью принуждения к соединению SSL в файле конфигурации приложения: 
`config.force_ssl = true`
### Хранение сессии 
Rails использует ActionDispatch::Session::CookieStore в качестве хранилища сессии по умолчанию.
`CookieStore` Rails сохраняет хэш сессии в куки на стороне клиента. Сервер получает хэш сессии из куки и устраняется необходимость в ID сессии.
`CookieStore` использует <a href="https://api.rubyonrails.org/classes/ActionDispatch/Cookies/ChainedCookieJars.html#method-i-encrypted">зашифрованные</a> куки, чтобы предоставить безопасное, зашифрованное место расположения для хранения данных сессии.
> Ключ шифрования, а также ключ верификации, используемый для подписанных куки, получены из конфигурационного значения secret_key_base.

Секретные ключи должны быть длинными и случайными. Используйте `rails secret` для получения новых уникальных секретных ключей.
Также важно использовать различные значения соли для зашифрованных и подписанных куки.

В test и development средах приложения получают `secret_key_base` из имени приложения. В других средах должен использоваться случайный ключ, присутствующий в `config/credentials.yml.enc`, показанный здесь в дешифрованном состоянии:
```
secret_key_base: 492f...
```
> Если секретные ключи вашего приложения могли быть скомпрометированы, настоятельно рекомендуется изменить секретный ключ. Изменение `secret_key_base` прекратит текущие активные сессии.
### Ротация зашифрованных и подписанных конфигураций куки
Ротация идеально подходит для изменения конфигураций куки и обеспечения того, что старые куки не сразу стали недействительны.

Например, чтобы изменить дайджест, используемый для подписанных куки с SHA1 на SHA256, необходимо сперва назначить новое конфигурационное значение:
```
Rails.application.config.action_dispatch.signed_cookie_digest = "SHA256"
```
Теперь добавьте ротацию для старого дайджеста SHA1, чтобы существующие куки были бесшовно апгрейднуты до нового дайджеста SHA256.
```
Rails.application.config.action_dispatch.cookies_rotations.tap do |cookies|
  cookies.rotate :signed, digest: "SHA1"
end
```
Для получения дополнительной информации о ротации ключа с зашифрованными и подписанными сообщениями, а также о различных опциях, которые принимает метод `rotate`, обратитесь, пожалуйста, к документации по <a href="https://api.rubyonrails.org/classes/ActiveSupport/MessageEncryptor.html">MessageEncryptor API</a> и <a href="https://api.rubyonrails.org/classes/ActiveSupport/MessageVerifier.html">MessageVerifier API</a>.
## Командная строка Rails <a name="5.11"></a>

# Расширяем Rails <a name="6"></a>
## Используем Rails для API приложений <a name="6.5"></a>
### Что такое API приложение
Вместо использования Rails для генерации HTML, взаимодействующего с сервером с помощью форм и ссылок, многие разработчики трактуют их веб-приложения как всего лишь клиент API, созданный из HTML с помощью JavaScript, обращающегося к JSON API.
### Зачем использовать Rails для JSON API?
Давайте посмотрим на некоторые вещи, которые Rails предоставляет из коробки и которые применимы к API-приложениям.

На уровне промежуточных программ:
* Перезагрузка: приложения Rails поддерживают прозрачную перезагрузку. Это работает, даже если ваше приложение становится большим и рестарт сервера для каждого запроса становится неприемлемым.
* Режим разработки: приложения Rails идут с разумными значениями по умолчанию для разработки, что делает разработку приятной без ущерба производительности для production.
* Тестовый режим: то же самое, что и для режима разработки.
* Логирование: приложения Rails логируют каждый запрос с уровнем детализации, приемлемым для текущего режима. Логи Rails в development включают информацию о среде запроса, запросах в базу данных и основную информацию о производительности.
* Безопасность: Rails обнаруживает и мешает исполнению IP-спуфинга, и безопасным способом обрабатывает криптографические сигнатуры в атаках по времени. Не знаете, что такое IP-спуфинг или атака по времени? Вот-вот!
* Парсинг параметров: Хотите устанавливать ваши параметры как JSON вместо URL-кодированной строки? Без проблем. Rails декодирует JSON и сделает его доступным в params. Хотите использовать вложенные URL-кодированные параметры? Это тоже работает.
* Условный GETs: Rails поддерживает условный GET (ETag и Last-Modified), обрабатывая заголовки запроса и возвращая правильный отклик и код статуса. Все, что нужно, это использовать проверку stale? в вашем контроллере, и Rails позаботится обо всех деталях HTTP.
* Запросы HEAD: Rails прозрачно конвертирует запросы HEAD в GET, и возвращает только заголовки тем же образом. Это позволяет HEAD надежно работать во всех API Rails.

Очевидно, что хотя вы и можете это создать сами в терминах существующих промежуточных программ Rack, этот список демонстрирует стек промежуточных программ Rails по умолчанию, представляющий большую ценность, даже если вы "просто генерируете JSON".

На уровне Action Pack:

* Ресурсный роутинг: Если вы создаете RESTful JSON API, вам захочется использовать роутер Rails. Чистое и общепринятое сопоставление от HTTP к контроллерам означает, что не нужно тратить время, думая, как смоделировать ваш API в терминах HTTP.
* Генерация URL: Обратной стороной роутинга является генерация URL. Хороший API, основанный на HTTP, включает URL (в качестве примера смотрите GitHub Gist API).
* Отклики с заголовками и редиректами: `head :no_content` и `redirect_to user_url(current_user)` очень удобны. Конечно, заголовки отклика можно добавить руками, но зачем?
* Кэширование: Rails предоставляет кэширование страниц, экшнов и фрагментов. Кэширование фрагментов особенно полезно при создании вложенных объектов JSON.
* __Базовая, дайджестная и токенная аутентификация__: Rails поставляется с поддержкой из коробки трех типов аутентификации HTTP.
* Инструментарий: в Rails имеется инструментальный API, запускающий зарегистрированные обработчики для множества событий, таких как обработка экшна, отсылка файла или данных, перенаправление и запросы к базе данных. Полезная нагрузка о каждом событии приходит с соответствующими параметрами (для события обработки экшна полезная нагрузка включает контроллер, экшн, параметры, формат запроса, метод запроса и полный путь запроса).
* Генераторы: Часто удобно сгенерировать ресурс и получить модель, контроллер, заготовки для тестов и роутов, созданные одной командой, для дальнейшей доработки. То же самое для миграций и остального.
* Плагины: Многие сторонние библиотеки поставляются с поддержкой Rails, что уменьшает или устраняет стоимость настройки и внедрения библиотеки во фреймворк. Это включает вещи, такие как переопределение генераторов по умолчанию, добавление задач Rake и принятие выбора в Rails (такого как логгер и кэширующий бэкенд). 
Конечно, процесс загрузки Rails также соединяет воедино все зарегистрированные компоненты. Например, процесс загрузки Rails это то, что использует файл `config/database.yml` при конфигурации Active Record.
> Краткая версия: можно не задумываться, какие части Rails все еще применимы, даже если вы уберете уровень представления, ответом будет - большая часть из них.
### Базовая конфигурация
#### Генерация приложения 
```
rails new my_api --api
```
Это сделает три основных вещи:
* Сконфигурирует приложение, чтобы оно запускало более ограниченный набор промежуточных программ, чем обычно. В частности, оно не включит по умолчанию какие-либо промежуточные программы, полезные для браузерных приложений (такие как поддержка куки).
* Унаследует ApplicationController от `ActionController::API` вместо `ActionController::Base`. Как и в случае с промежуточными программами, это выкинет все модули Action Controller, предоставляющие функциональность, в основном используемую браузерными приложениями.
* Сконфигурирует генераторы, чтобы они пропускали генерацию вьюх, хелперов и ассетов при генерации нового ресурса
#### Изменение существующего приложения
В `config/application.rb` добавьте следующую строчку в самый верх определения класса Application:
```
config.api_only = true
```
В `config/environments/development.rb` установите `config.debug_exception_response_format`, чтобы настроить формат, используемый в откликах, когда происходит ошибка в режиме development.

Чтобы отрендерить страницу HTML с отладочной информацией, используйте значение :default
```
config.debug_exception_response_format = :default
```
Чтобы отрендерить отладочную информацию, сохранив формат отклика, используйте значение :api
```
config.debug_exception_response_format = :api
```
По умолчанию `config.debug_exception_response_format` установлен :api, когда `config.api_only` установлен true.

Наконец, в `app/controllers/application_controller.rb` вместо:

```
class ApplicationController < ActionController::Base
end
```
сделайте:
```
class ApplicationController < ActionController::API
end
```
### Выбор промежуточных программ
API-приложение поставляется со следующими промежуточными программами по умолчанию:
* `Rack::Sendfile`
* `ActionDispatch::Static`
* `ActionDispatch::Executor`
* `ActiveSupport::Cache::Strategy::LocalCache::Middleware`
* `Rack::Runtime`
* `ActionDispatch::RequestId`
* `ActionDispatch::RemoteIp`
* `Rails::Rack::Logger`
* `ActionDispatch::ShowExceptions`
* `ActionDispatch::DebugExceptions`
* `ActionDispatch::Reloader`
* `ActionDispatch::Callbacks`
* `ActiveRecord::Migration::CheckPending`
* `Rack::Head`
* `Rack::ConditionalGet`
* `Rack::ETag`

Другие плагины, включая Active Record, могут добавлять дополнительные промежуточные программы. В основном, эти промежуточные программы безразличны к типу создаваемого приложения, и имеют смысл в API-приложении Rails.

Можно получить список всех промежуточных программ вашего приложения с помощью:
```
rails middleware
```
#### Использование кэширующей промежуточной программы

По умолчанию Rails добавит промежуточную программу, предоставляющую хранилище кэша, основанного на конфигурации вашего приложения (по умолчанию memcache). Это означает, что встроенный кэш HTTP будет полагаться на нее.

Например, используя метод `stale?`:
```
def show
  @post = Post.find(params[:id])

  if stale?(last_modified: @post.updated_at)
    render json: @post
  end
end
```
Вызов `stale?` сравнит заголовок `If-Modified-Since` в запросе с `@post.updated_at`. Если заголовок новее, чем время последнего модифицирования, этот экшн вернет отклик "304 Not Modified". В противном случае, он отрендерит отклик и включит в него заголовок `Last-Modified`.

Обычно этот механизм используется отдельно для каждого клиента. Кэширующая промежуточная программа позволяет распределять этот кэширующий механизм между клиентами. Можно включить межклиентское кэширование в вызове `stale?`:
```
def show
  @post = Post.find(params[:id])

  if stale?(last_modified: @post.updated_at, public: true)
    render json: @post
  end
end
```
Это означает, что кэширующая промежуточная программа сохранит значение `Last-Modified` для URL в кэше Rails, и добавит заголовок `If-Modified-Since` в любой последующий входящий запрос к этому URL.

Воспринимайте это как кэширование страниц в семантике HTTP.
#### Использование Rack::Sendfile
При использовании метода `send_file` в контроллере Rails, он устанавливает заголовок `X-Sendfile`. `Rack::Sendfile` ответственен за фактическую отсылку файла.

Если ваш фронтенд сервер поддерживает ускоренную отсылку файла, `Rack::Sendfile` переложит работу по фактической отсылке файла на фронтенд сервер.
Можно настроить имя заголовка, которое использует ваш фронтенд сервер для этой цели, с помощью `config.action_dispatch.x_sendfile_header` в соответствующем среде конфигурационном файле.
<a href="https://rubydoc.info/github/rack/rack/master/Rack/Sendfile">Подробнее о send_file</a>
Вот несколько значений этого заголовка для некоторых популярных серверов, которые, как только эти серверы будут настроены, добавят поддержку для ускоренной отсылки файла:
```
# Apache и lighttpd
config.action_dispatch.x_sendfile_header = "X-Sendfile"

# Nginx
config.action_dispatch.x_sendfile_header = "X-Accel-Redirect"
```
Убедитесь, что сконфигурировали на своем сервере поддержку этих опций в соответствии с инструкциями в документации `Rack::Sendfile`
#### Использование ActionDispatch::Request
`ActionDispatch::Request#params` примет параметры от клиента в формате JSON и сделает их доступными в контроллере внутри `params`.

Для его использования клиенту нужно сделать запрос с кодированными в JSON параметрами и указать `Content-Type` как `application/json`.

Вот пример на jQuery:
```
jQuery.ajax({
  type: 'POST',
  url: '/people',
  dataType: 'json',
  contentType: 'application/json',
  data: JSON.stringify({ person: { firstName: "Yehuda", lastName: "Katz" } }),
  success: function(json) { }
});
```
ActionDispatch::Request увидит Content-Type и вашими параметрами будут:
```
{ :person => { :firstName => "Yehuda", :lastName => "Katz" } }
```
####  Другие промежуточные программы
Rails поставляется с рядом других промежуточных программ, которые вы, возможно, захотите использовать в API-приложении, особенно если одним из клиентов вашего API является браузер:
* `Rack::MethodOverride`
* `ActionDispatch::Cookies`
* `ActionDispatch::Flash`
Для управления сессией:
* `ActionDispatch::Session::CacheStore`
* `ActionDispatch::Session::CookieStore`
* `ActionDispatch::Session::MemCacheStore`

Любые из этих промежуточных программ могут быть добавлены с помощью:
```
config.middleware.use Rack::MethodOverride
```
#### Удаление промежуточных программ
Если вы не хотите использовать промежуточную программу, которая включена по умолчанию в набор промежуточных программ для API, ее можно убрать с помощью:
```
config.middleware.delete ::Rack::Sendfile
```
Учтите, что удаление этих промежуточных программ удалит поддержку для определенных особенностей в Action Controller.
### Выбор модулей контроллера
API-приложение (использующее `ActionController::API`) по умолчанию поставляется со следующими модулями:
* `ActionController::UrlFor`: Делает доступными url_for и подобные хелперы.
* `ActionController::Redirecting`: Поддержка для redirect_to.
* `AbstractController::Rendering` и `ActionController::ApiRendering`: Базовая поддержка для рендеринга.
* `ActionController::Renderers::All`: Поддержка для `render :json` и сотоварищей.
* `ActionController::ConditionalGet`: Поддержка для `stale?`.
* `ActionController::BasicImplicitRender`: Убеждается, что возвращен пустой отклик, если нет явного.
* `ActionController::StrongParameters`: Поддержка для фильтрации параметров в сочетании с массовым назначением Active Model.
* `ActionController::DataStreaming`: Поддержка для `send_file` и `send_data`.
* `AbstractController::Callbacks`: Поддержка для `before_action` и подобных хелперов.
* `ActionController::Rescue: Поддержка для rescue_from.
* `ActionController::Instrumentation`: Поддержка для инструментальных хуков, определенных Action Controller (подробности относительно этого смотрите в руководстве Инструментарий Active Support).
* `ActionController::ParamsWrapper`: Оборачивает хэш параметров во вложенный хэш, таким образом, к примеру, не нужно указывать корневые элементы при посылка запросов POST.
* `ActionController::Head`: Поддержка возврата отклика без тела сообщения, только заголовки 
Другие плагины могут добавлять дополнительные модули. Список всех модулей, включенных в `ActionController::API` можно получить в консоли rails:
```
$ rails c
>> ActionController::API.ancestors - ActionController::Metal.ancestors
=> [ActionController::API,
    ActiveRecord::Railties::ControllerRuntime,
    ActionDispatch::Routing::RouteSet::MountedHelpers,
    ActionController::ParamsWrapper,
    ... ,
    AbstractController::Rendering,
    ActionView::ViewPaths]
```
#### Добавление других модулей
Все модули Action Controller знают о зависимых модулях, поэтому можно свободно включать любые модули в контроллеры, и будут включены и настроены все зависимости.

Некоторые распространенные модули, которые вы, возможно, захотите добавить:
* `AbstractController::Translation`: Поддержка для методов локализации l и перевода t.
* Поддержка для базовой, дайджестной или токенной аутентификации HTTP:
  1. `ActionController::HttpAuthentication::Basic::ControllerMethods` <a href="https://apidock.com/rails/v3.2.1/ActionController/HttpAuthentication/Basic">подробнее</a>,
  2. `ActionController::HttpAuthentication::Digest::ControllerMethods`,
  3. `ActionController::HttpAuthentication::Token::ControllerMethods` <a href="https://apidock.com/rails/v6.0.0/ActionController/HttpAuthentication/Token">Подробнее</a>
* `ActionView::Layouts`: Поддержка для макетов при рендеринге.
* `ActionController::MimeResponds`: Поддержка для respond_to.
* `ActionController::Cookies`: Поддержка для cookies, что включает поддержку для подписанных и зашифрованных куки. Он требует промежуточную программу для куки.
* `ActionController::Caching:` Поддержка кэширования вьюх для контроллера API. Отметьте, что нужно вручную указать хранилище кэша внутри контроллера подобно следующему: `ruby class ApplicationController < ActionController::API include ::ActionController::Caching self.cache_store = :mem_cache_store end` Rails не передает эту конфигурацию автоматически. 

Лучшим местом для добавления модулей является `ApplicationController`, но вы также можете добавить модули в отдельные контроллеры.

# Вносим вклад <a name="7"></a>

# Дополнительно <a name="8"></a>
## Все подряд
### task_desire_api
Модели:
```
rails g model User login:string:uniq password_digest name sign
rails g model Article head:string announcement:string content:text status:boolean user:references
```
Контроллеры:
```
rails g controller Articles create update destroy
```
### Задачи Rake
* `rake db:create` - Cоздать баду данных
* `rake db:drop` - Удалить базу данных
* `rake db:migrate` - Запустить миграцию базы
* `rake db:rollback` - Откатить миграцию данных к предыдущему состоянию
* `rake db:schema:dump` - Построение файла schema.rb на основе текущей структуры базы данных
* `rake db:schema:load` - Восстановление структуры базы данных из schema.rb
* `rake db:seed` - Запускает скрипт db/seed.rb который по идее должен заполнить базу первоначальными данными
* `rake db:setup` - Запустит поочереди create, schema:load, seed
* `rake db:structure:dump` - Сделает дамп структуры в db/structue.sql
* `rake db:structure:load` - Восстановит базу из db/structue.sql

