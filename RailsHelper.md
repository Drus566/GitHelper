# Содержание
1. [С чего начать](#1)
* 1.1 [Rails для начинающих](#1.1)
* * 1.1.1 [Что такое Rails](#1.1.1)
* * 1.1.2 [Создание Rails приложения](#1.1.2)
* * 1.1.3 [Hello Rails](#1.1.3)
* * 1.1.4 [Безопасность Rails](#1.1.4)
* * 1.1.5 [Что дальше](#1.1.5)
2. [Модели](#2)
* 2.1 [Основы Active Record](#2.1)
* * 2.1.1 [Что такое Active record](#2.1.1)
* * 2.1.2 [Соглашения над конфигурацией](#2.1.2)
* * 2.1.3 [Создание моделей Active record](#2.1.3)
* * 2.1.4 [Переопределение соглашений о конфигурации](#2.1.4)
* * 2.1.5 [CRUD операции](#2.1.5)
* * 2.1.6 [Валидации](#2.1.6)
* * 2.1.7 [Колбэки](#2.1.7)
* * 2.1.8 [Миграции](#2.1.8)
* 2.2 [Миграции Active Record](#2.2)
* * 2.2.1 [Обзор миграции](#2.2.1)
* * 2.2.2 [Создание миграции](#2.2.2)
* * 2.2.3 [Написание миграции](#2.2.3)
* * 2.2.4 [Запуск миграции](#2.2.4)
* * 2.2.5 [Изменение существующих миграций](#2.2.5)
* * 2.2.6 [Выгрузка схемы](#2.2.6)
* * 2.2.7 [Active Record и ссылочная целостность](#2.2.7)
* * 2.2.8 [Миграции и сиды](#2.2.8)
* * 2.2.9 [Старые миграции](#2.2.9)
* 2.3 [Валидации](#2.3)
* * 2.3.1 [Обзор валидаций](#2.3.1)
* * 2.3.2 [Валидационные хелперы](#2.3.2)
* * 2.3.3 [Общие опции валидаций](#2.3.3)
* * 2.3.4 [Строгие валидации](#2.3.4)
* * 2.3.5 [Условная валидация](#2.3.5)
* * 2.3.6 [Выполнение собственных валидаций](#2.3.6)
* * 2.3.7 [Работаем с ошибками валидации](#2.3.7)
* * 2.3.8 [Отображение ошибок валидации во вьюхах](#2.3.8)
* 2.4 [Колбэки](#2.4)
* * 2.4.1 [Жизненный цикл объекта](#2.4.1)
* * 2.4.2 [Обзор колбэков](#2.4.2)
* * 2.4.3 [Доступные колбэки](#2.4.3)
* * 2.4.4 [Запуск колбэков](#2.4.4)
* * 2.4.5 [Пропуск колбэков](#2.4.5)
* * 2.4.6 [Прерывание выполнения](#2.4.6)
* * 2.4.7 [Колбэки для отношений](#2.4.7)
* * 2.4.8 [Условные колбэки](#2.4.8)
* * 2.4.9 [Классы колбэков](#2.4.9)
* * 2.4.10 [Транзакционные колбэки](#2.4.10)
* 2.5 [Связи (ассоциации)](#2.5)
* * 2.5.1 [Зачем нужны связи?](#2.5.1)
* * 2.5.2 [Типы связей](#2.5.2)
* * 2.5.3 [Полезные советы и предупреждения](#2.5.3)
* * 2.5.4 [Подробная информация по связи belongs_to](#2.5.4)
* * 2.5.5 [Подробная информация по связи has_one](#2.5.5)
* * 2.5.6 [Подробная информация по связи has_many](#2.5.6)
* * 2.5.7 [Подробная информация по связи has_and_belongs_to_many](#2.5.7)
* * 2.5.8 [Подробная информация по колбэкам и расширениям связи](#2.5.8)
* * 2.5.9 [Наследование с единой таблицей (STI)](#2.5.9)
* 2.6 [Интерфейс запросов](#2.6)
* * 2.6.1 [Получение объектов из базы данных](#2.6.1)
* * 2.6.2 [Условия](#2.6.2)
* * 2.6.3 [Сортировка](#2.6.3)
* * 2.6.4 [Выбор определенных полей](#2.6.4)
* * 2.6.5 [Ограничение и смещение](#2.6.5)
* * 2.6.6 [Группировка](#2.6.6)
* * 2.6.7 [Having](#2.6.7)
* * 2.6.8 [Переопределяющие условия](#2.6.8)
* * 2.6.9 [Нулевой Relation](#2.6.9)
* * 2.6.10 [Объекты только для чтения](#2.6.10)
* * 2.6.11 [Блокировка записей для обновления](#2.6.11)
* * 2.6.12 [Соединительные таблицы](#2.6.12)
* * 2.6.13 [Нетерпеливая загрузка связей](#2.6.13)
* * 2.6.14 [Скоупы](#2.6.14)
* * 2.6.15 [Динамический поиск](#2.6.15)
* * 2.6.16 [Enum](#2.6.16)
* * 2.6.17 [Цепочки методов](#2.6.17)
* * 2.6.18 [Поиск или создание нового объекта](#2.6.18)
* * 2.6.19 [Поиск с помощью SQL](#2.6.19)
* * 2.6.20 [Существование объектов](#2.6.20)
* * 2.6.21 [Вычисления](#2.6.21)
* * 2.6.22 [Запуск EXPLAIN](#2.6.22)
* 2.7 [Active Record для PostgreSQL](#2.7)
* * 2.7.1 [Типы данных](#2.7.1)
* * 2.7.2 [Первичные ключи UUID](#2.7.2)
* * 2.7.3 [Полнотекстовый поиск](#2.7.3)
* * 2.7.4 [Представление базы данных](#2.7.4)
* 2.8 [Основы Active Model](#2.8)
* * 2.8.1 [Введение](#2.8.1)

3. [Вьюхи](#3)
* 3.1 [Обзор Action View](#3.1)
* * 3.1.1 [Что такое Action View?](#3.1.1)
* * 3.1.2 [Использование Action View с Rails](#3.1.2)
* * 3.1.3 [Шаблоны, партиалы и макеты](#3.1.3)
* * 3.1.4 [Макеты партиалов](#3.1.4)
* * 3.1.5 [Пути вьюх](#3.1.5)
* * 3.1.6 [Обзор хелперов, предоставленных Action View](#3.1.6)
* * 3.1.7 [Локализованные вьюхи](#3.1.7)
* 3.2 [Макеты и рендеринг в Rails](#3.2)
* * 3.2.1 [Обзор: как кусочки складываются вместе](#3.2.1)
* * 3.2.2 [Создание откликов](#3.2.2)
* * 3.2.3 [Структурирование макетов](#3.2.3)
* 3.3 [Макеты и рендеринг в Rails](#3.3)
* * 3.3.1 [Разбираемся с простыми формами](#3.3.1)
* * 3.3.2 [Работаем с объектами модели](#3.3.2)
* * 3.3.3 [Легкое создание списков выбора](#3.3.3)
* * 3.3.4 [Использование хелперов даты и времени](#3.3.4)
* * 3.3.5 [Загрузка файлов](#3.3.5)
* * 3.3.6 [Настройка Form Builder](#3.3.6)
* * 3.3.7 [Понимание соглашений по именованию параметров](#3.3.7)
* * 3.3.8 [Формы к внешним ресурсам](#3.3.8)
* * 3.3.9 [Создание сложных форм](#3.3.9)
* * 3.3.10 [Использование form_for и form_tag](#3.3.10)

4. [Контроллеры](#4)
* 4.1 [Обзор Action Controller](#4.1)
* * 4.1.1 [Что делает контроллер?](#4.1.1)
* * 4.1.2 [Соглашение по именованию контроллеров](#4.1.2)
* * 4.1.3 [Методы и экшны](#4.1.3)
* * 4.1.4 [Параметры](#4.1.4)
* * 4.1.5 [Сессия](#4.1.5)
* * 4.1.6 [Куки](#4.1.6)
* * 4.1.7 [Рендеринг данных XML и JSON](#4.1.7)
* * 4.1.8 [Фильтры](#4.1.8)
* * 4.1.9 [Защита от подделки запроса](#4.1.9)
* * 4.1.10 [Объекты Request и Response](#4.1.10)
* * 4.1.11 [Аутентификации HTTP](#4.1.11)
* * 4.1.12 [Потоки и загрузка файлов](#4.1.12)
* * 4.1.13 [Фильтрация лога](#4.1.13)
* * 4.1.14 [Обработка ошибок](#4.1.14)
* * 4.1.15 [Навязывание протокола HTTPS](#4.1.15)
* 4.2 [Роутинг в Rails](#4.2)
* * 4.2.1 [Цель роутера Rails](#4.2.1)
* * 4.2.2 [Ресурсный роутинг](#4.2.2)
* * 4.2.3 [Нересурсные маршруты](#4.2.3)
* * 4.2.4 [Настройка ресурсных маршрутов](#4.2.4)
* * 4.2.5 [Разделение очень большого маршрутного файл на несколько небольших:](#4.2.5)
* * 4.2.6 [Осмотр и тестирование маршрутов](#4.2.6)




5. [Копаем глубже](#5)
* 5.1 [Безопасность приложений на Rails](#5.1)
* 5.11 [Командная строка Rails](#5.11)
6. [Расширяем Rails](#6)
* 6.5 [Rails для API приложений](#6.5)
7. [Вносим вклад](#7)
8. [Дополнительно](#8)

> В rus rails имеется множество ссылок, на ресурсы по связанным темам прямо в тексте, которые здесь не отображены.

# C чего начать <a name="1"></a>
## Rails для начинающих <a name="1.1"></a>
### Что такое Rails <a name="1.1.1"></a>
Если изучите "The Rails Way", то, возможно, откроете в себе значительное увеличение производительности. Если будете упорствовать и переносить старые привычки с других языков в разработку на Rails, и попытаетесь использовать шаблоны, изученные где-то еще, ваш опыт разработки будет менее счастливым.

Философия Rails включает два важных ведущих принципов:
* Don't Repeat Yourself: DRY — это принцип разработки ПО, который гласит, что "Каждый кусочек информации должен иметь единственное, неизбыточное, авторитетное представление в системе". Не пишите одну и ту же информацию снова и снова, код будет легче поддерживать, и он будет более расширяемым и менее ошибочным.
* Convention Over Configuration: у Rails есть мнения о наилучших способах делать множество вещей в веб-приложении, и по умолчанию выставлены эти соглашения, вместо того, чтобы заставлять вас по мелочам править многочисленные конфигурационные файлы. 
### Создание Rails приложения <a name="1.1.2"></a>
Для установки Rails используйте команду `gem install`, представленную RubyGems:
```
gem install rails
```
Создание приложения:
```
rails new blog
```
Это создаст приложение на Rails с именем Blog в директории blog и установит гемы, зависимости от которых упомянуты в Gemfile при использовании `bundle install`.
> При использовании Windows Subsystem for Linux, имеются некоторые ограничения на сообщения файловой системы, означающие, что следует отключить гемы spring и listen, что можно сделать, запустив `rails new blog --skip-spring --skip-listen`.

Можно посмотреть все возможные опции командной строки, которые принимает билдер приложения на Rails, запустив rails new -h.

Директория
| Файл/Папка | Назначение |
|------------|------------|
| app/ | Содержит контроллеры, модели, вьюхи, хелперы, рассыльщики, каналы, задания и ассеты вашего приложения. Мы рассмотрим эту папку подробнее далее. |
| bin/ | Содержит Rails скрипты которые стартуют ваше приложение, также директория может содержать другие скрипты которые вы используете для настройки, обновления, деплоя или запуска. |
| config/ | Конфигурации маршрутов, базы данных вашего приложения, и т.д. Более подробно это раскрыто в Конфигурирование приложений на Rails |
| config.ru | Конфигурация Rack для серверов, основанных на Rack, используемых для запуска приложения. Подробнее о Rack смотрите на сайте Rack. |
| db/ | Содержит текущую схему вашей базы данных, а также миграции базы данных. |
| Gemfile Gemfile.lock | Эти файлы позволяют указать, какие зависимости от гемов нужны для вашего приложения на Rails. Эти файлы используются гемом Bundler. Подробнее о Bundler смотрите на сайте Bundler. |
| lib/ | Внешние модули для вашего приложения. |
| log/ | Файлы логов приложения. |
| package.json | Этот файл позволяет указать, какие зависимости npm необходимы для приложения Rails. Этот файл используется Yarn. Подробнее о Yarn смотрите на сайте Yarn. |
| public/ | Единственная папка, которая доступна извне как есть. Содержит статичные файлы и скомпилированные ассеты. |
| Rakefile | Этот файл находит и загружает задачи, которые могут быть запущены в командной строке. Определенная задача доступна во всех компонентах Rails. Вместо изменения Rakefile, можно добавить свои собственные задачи, добавив файлы в директорию lib/tasks приложения. |
| README.md | Это вводный мануал для вашего приложения. Его следует отредактировать, чтобы рассказать остальным, что ваше приложение делает, как его настроить, и т.п. |
| storage/ | Файлы Active Storage для сервиса Disk. Это раскрывается в руководстве Обзор Active Storage. |
| test/ | Юнит-тесты, фикстуры и прочий аппарат тестирования. Это раскрывается в руководстве Тестирование приложений на Rails |
| tmp/ | Временные файлы (такие как файлы кэша и pid) |
| vendor/ | Место для кода сторонних разработчиков. В типичном приложении на Rails включает внешние гемы. |
| .gitignore | Этот файл сообщает git, какие файлы (явно или по шаблону) ему следует игнорировать. Подробнее об игнорировании файлов смотрите GitHub - Ignoring files. |
| .ruby-version | Этот файл содержит дефолтную версию Ruby |
### Hello rails <a name="1.1.3"></a>
Запуск `rails server`
> Если вы используете Windows, вы должны передавать скрипты из папки bin непосредственно в интерпретатор Ruby, то есть ruby bin\rails server.

Веб сервер по умолчанию - puma

> Сжатие ассетов JavaScript требует среды выполнения JavaScript в вашей системе, и его отсутствие приведет к ошибке execjs во время сжатия ассетов. Обычно macOS и Windows поставляются с установленной средой выполнения JavaScript. therubyrhino - рекомендованная среда выполнения для пользователей JRuby, она добавляется в Gemfile, если приложение генерируется под JRuby. Можно узнать все о поддерживаемых средах выполнения в ExecJS

`Ctrl + C` - остановка сервера
В режиме development, Rails в основном не требует остановки сервера; все изменения, которые Вы делаете в файлах, автоматически подхватываются сервером.

`rails routes` - выводит в терминал все пути 
Основной form builder для Rails представлен методом хелпера по имени `form_with`
```
<%= form_with scope: :article, url: articles_path, local: true do |form| %>
<%= form_with scope: :article, local: true do |form| %>
```
ПРИМЕЧАНИЕ: По умолчанию form_with отправляет формы с использованием Ajax, тем самым не осуществляя редирект всей страницы. Чтобы облегчить чтение данного руководства, мы отключили это с помощью `local: true`.
#### Создание статей
При отправке формы, ее поля будут посланы в Rails как параметры. К этим параметрам можно обратиться из экшнов контроллера, как правило, для выполнения определенных задач. Чтобы увидеть, на что похожи эти параметры, измените экшн create так:
```
def create
  render plain: params[:article].inspect
end
```
Метод params возвращает объект ActionController::Parameters, позволяющий получать доступ к ключам хэша с использованием или строк, или символов.
> Давайте рассмотрим в качестве примера URL: http://www.example.com/?username=dhh&email=dhh@email.com. В этом URL, params[:username] будет равен "dhh" и params[:email] будет равен "dhh@email.com".

Если еще раз отправить форму, вы увидите что-то вроде следующего:
`<ActionController::Parameters {"title"=>"First Article!", "text"=>"This is my first article."} permitted: false>`

#### Создание модели Article
`rails generate model Article title:string text:text`
создаст:
```
class CreateArticles < ActiveRecord::Migration[6.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :text

      t.timestamps
    end
  end
end
```
Миграция в бд `rails db:migrate`
Если хотите выполнить миграции в другой среде, например в production, следует явно передать ее при вызове команды: `rails db:migrate RAILS_ENV=production`

Rails имеет ряд защитных мер, помогающих писать безопасные приложения, и вы только что столкнулись с одной из них. Она называется strong parameters и требует, чтобы мы указали Rails, какие именно параметры разрешено передавать в экшны нашего контроллера.

Нам нужно определить разрешенные параметры нашего контроллера, чтобы предотвратить ошибочное массовое назначение. В этом случае, мы хотим и разрешить, и затребовать параметры title и text для правильного использования в create. Синтаксис для этого представлен методами `require` и `permit`. Изменение затрагивает одну строчку в экшне create:
```
private
  def article_params
    params.require(:article).permit(:title, :text)
  end
```
> Если вам нужна ссылка на экшн того же контроллера, не нужно определять опцию :controller, так как Rails по умолчанию использует текущий контроллер.

В режиме development (с которым вы работаете по умолчанию), Rails перегружает ваше приложение с каждым запросом браузера, так что не нужно останавливать и перезапускать веб-сервер при внесении изменений.
`pluralize` это хелпер rails, принимающий число и строку как аргументы. Если число больше одного, строка будет автоматически склонено во множественном числе.
Rails автоматически оборачивает поля, содержащие ошибку, в div с классом `field_with_errors`. Можно определить правило CSS, чтобы сделать их выделяющимися.
Передача объекта статьи в метод `form_with` автоматически установит URL для отправки формы отредактированной статьи. Эта опция сообщает Rails, что мы хотим, чтобы эта форма была отправлена с помощью PATCH, метода HTTP, от которого ожидается, что он используется для обновления ресурсов в соответствии с протоколом REST.
Также, передача объекта модели в `form_with`, наподобие `model: @article` во вьюхе редактирования выше, заставит хелпер формы заполнить поля формы соответствующими значениями объекта. Передача в пространство имен символа, такая как `scope: :article`, что было сделано во вьюхе new, только создаст пустые поля формы.
> Не обязательно передавать все атрибуты в update. К примеру, если был вызван `@article.update(title: 'A new title')`, Rails обновит только атрибут title, оставив все другие атрибуты нетронутыми.
Хелперы, в том числе `form with` https://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with-label-Resource-oriented+style
`rails generate model Comment commenter:string body:text article:references`
Ключевое слово `(:references)`, использованное в команде bash, это специальный тип данных для моделей. Он создает новый столбец в вашей базе данных с именем представленной модели с добавленным _id, который может содержать числовые значения. Чтобы лучше понять, проанализируйте файл db/schema.rb после выполнения миграции.

В дополнение к модели, Rails также сделал миграцию для создания соответствующей таблицы базы данных:
```
class CreateComments < ActiveRecord::Migration[6.0]
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :article, null: false, foreign_key: true

      t.timestamps
    end

  end
end
```
Строчка `t.references` создает числовой столбец с именем `article_id`, индекс для него, и ограничение внешнего ключа, указывающего на столбец id таблицы `articles`.

#### Добавляем маршрут для комментариев
```
resources :articles do
  resources :comments
end
```
`<%= form_with(model: [ @article, @article.comments.build ], local: true) do |form| %>`
```
<%= link_to 'Destroy Comment', [comment.article, comment],
               method: :delete,
               data: { confirm: 'Are you sure?' } %>
```
#### Удаление связанных объектов
`has_many :comments, dependent: :destroy`
### Безопасность <a name="1.1.4"></a>
Если вы опубликуете свой блог онлайн, любой сможет добавлять, редактировать и удалять статьи или удалять комментарии.

Rails предоставляет базовую аутентификационную систему HTTP, которая хорошо работает в этой ситуации.

В ArticlesController нам нужен способ блокировать доступ к различным экшнам, если пользователь не аутентифицирован. Тут мы можем использовать метод Rails `http_basic_authenticate_with`, разрешающий доступ к требуемым экшнам, если метод позволит это.

Чтобы использовать систему аутентификации, мы определим ее вверху нашего ArticlesController в app/controllers/articles_controller.rb. В нашем случае, мы хотим, чтобы пользователь был аутентифицирован для каждого экшна, кроме index и show, поэтому напишем так:
```
class ArticlesController < ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", except: [:index, :show]

  def index
    @articles = Article.all
  end
```
Мы также хотим позволить только аутентифицированным пользователям удалять комментарии, поэтому в CommentsController (app/controllers/comments_controller.rb) мы напишем:
```
class CommentsController < ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", only: :destroy

  def create
    @article = Article.find(params[:article_id])
    # ...
  end
```
Теперь, если попытаетесь создать новую статью, то встретитесь с вызовом базовой аутентификации HTTP.
### Что дальше? <a name="1.1.5"></a>
тут ссылки на ресурсы в оригинале на RusRails 

# Модели <a name="2"></a>
## Основы Active record <a name="2.1"></a>
<a href="https://api.rubyonrails.org/classes/ActiveRecord/Base.html#class-ActiveRecord::Base-label-Single+table+inheritance">Active Record Documentation</a>
### Что такое Active record <a name="2.1.1"></a>
Active Record это M в MVC - модель - которая является слоем в системе, ответственным за представление бизнес-логики и данных. Active Record упрощает создание и использование бизнес-объектов, данные которых требуют персистентного хранения в базе данных. Сама по себе эта реализация паттерна Active Record является описанием системы ORM (Object Relational Mapping).

Active Record был описан Martin Fowler в его книге Patterns of Enterprise Application Architecture. В Active Record объекты содержат и персистентные данные, и поведение, которое работает с этими данными. Active Record исходит из мнения, что обеспечение логики доступа к данным как части объекта покажет пользователям этого объекта то, как читать и писать в базу данных

Object Relational Mapping (объектно-реляционное отображение), обычно упоминающееся как аббревиатура ORM, это техника, соединяющая сложные объекты приложения с таблицами в системе управления реляционными базами данных.

Active Record предоставляет нам несколько механизмов, наиболее важными из которых являются способности для:
* Представления моделей и их данных.
* Представления связей между этими моделями.
* Представления иерархий наследования с помощью связанных моделей.
* Валидации моделей до того, как они станут персистентными в базе данных.
* Выполнения операций с базой данных в объектно-ориентированном стиле. 
### Соглашения над конфигурацией <a name="2.1.2"></a>
Идея в том, что в большинстве случаев вы настраиваете свои приложения одинаковым образом, и этот способ должен быть способом по умолчанию. Таким образом, явная конфигурация потребуется только тогда, когда вы не следуете соглашениям по какой-то причине.
* Таблица базы данных - Множественная форма со словами, разделенными знаком подчеркивания (т.е., book_clubs).
* Класс модели - Единственное число с первой прописной буквой в каждом слове (т.е., BookClub).

| Модель / Класс | Таблица / Схема |
|----------------|-----------------|
| Article        |	articles       | 
| LineItem       |  line_items     |
| Deer           |  deers          |
| Mouse          |	mice           |
| Person         |  people         |

#### Cоглашения схемы
Active Record использует соглашения о именовании для столбцов в таблицах базы данных, зависящих от назначения этих столбцов.
* Внешние ключи - Эти поля должны именоваться по образцу singularized_table_name_id (т.е., item_id, order_id). Это поля, которые ищет Active Record при создании связей между вашими моделями.
* Первичные ключи - По умолчанию Active Record использует числовой столбец с именем id как первичный ключ таблицы. Этот столбец будет автоматически создан при использовании миграций Active Record для создания таблиц. 

Также имеются некоторые опциональные имена столбцов, добавляющие дополнительные особенности для экземпляров Active Record:
* created_at - Автоматически будут установлены текущие дата и время при изначальном создании записи.
* updated_at - Автоматически будут установлены текущие дата и время всякий раз, когда обновляется запись.
* lock_version - Добавляет оптимистическую блокировку к модели.
* type - Указывает, что модель использует Single Table Inheritance.
* (association_name)_type - Хранит тип для полиморфных связей.
* **(table_name)_count - Используется для кэширования количества принадлежащих по связи объектов. Например, столбец comments_count в классе Article, у которого может быть несколько связанных экземпляров Comment, закэширует количество существующих комментариев для каждой статьи.**

> Хотя эти имена столбцов опциональны, фактически они зарезервированы Active Record. Избегайте зарезервированных ключевых слов, если вы не желаете дополнительной функциональности. Например, type - это зарезервированное слово для определения таблицы, использующей наследование с единой таблицей (STI). Если вы не используете STI, попытайтесь использовать аналогичное слово, такое как "context", которое также может аккуратно описать данные, которые вы моделируете

### Создание моделей Active Record <a name="2.1.3"></a>
Создавать модели Active Record очень просто. Все, что необходимо сделать, - это создать подкласс ApplicationRecord, и готово:
```
class Product < ApplicationRecord
end
```
Это создаст модель Product, **связав ее с таблицей products в базе данных**. Сделав так, также появится способность связать столбцы каждой строки этой таблицы с атрибутами экземпляров вашей модели. Допустим, что таблица products была создана с использованием такого выражения SQL (или одно из его расширений):
```
CREATE TABLE products (
   id int(11) NOT NULL auto_increment,
   name varchar(255),
   PRIMARY KEY  (id)
);
```
Вышеуказанная схема объявляет таблицу с двумя столбцами: id и name. Каждая строка этой таблицы представляет собой определенный продукт с этими двумя параметрами. Таким образом, можно написать подобный код:
```
p = Product.new
p.name = "Some Book"
puts p.name # "Some Book"
```
### Переопределение соглашений об именовании <a name="2.1.4"></a>
Но что, если вы следуете другому соглашению по именованию или используете новое приложение Rails со старой базой данных? Не проблема, можно просто переопределить соглашения по умолчанию.

ApplicationRecord наследуется от `ActiveRecord::Base`, который определяет ряд полезных методов. Можно использовать метод `ActiveRecord::Base.table_name=` для указания имени таблицы, которая должна быть использована:
```
class Product < ApplicationRecord
  self.table_name = "my_products"
end
```
Если так сделать, нужно вручную определить имя класса, содержащего фикстуры (my_products.yml), используя метод set_fixture_class в определении теста:
```
class ProductTest < ActiveSupport::TestCase
  set_fixture_class my_products: Product
  fixtures :my_products
  ...
end
```
Также возможно переопределить столбец, который должен быть использован как первичный ключ таблицы, с помощью метода `ActiveRecord::Base.primary_key=`:
```
class Product < ApplicationRecord
  self.primary_key = "product_id"
end
```
### CRUD: Чтение и запись данных <a name="2.1.5"></a>
CRUD это сокращение для четырех глаголов, используемых для описания операций с данными: Create (создать), Read (прочесть), Update (обновить) и Delete (удалить). Active Record автоматически создает методы, позволяющие приложению читать и воздействовать на данные, хранимые в своих таблицах.
Если предоставлен блок и `create`, и `new` передадут новый объект в этот блок для инициализации:
```
user = User.new do |u|
  u.name = "David"
  u.occupation = "Code Artist"
end
```
Возвратит первого пользователя с именем David
```
david = User.find_by(name: 'David')
```
Найдет всех пользователей с именем David, которые Code Artists, и сортирует их по created_at в обратном хронологическом порядке:
```
users = User.where(name: 'David', occupation: 'Code Artist').order(created_at: :desc)
```
<a href="http://rusrails.ru/active-record-query-interface">Подробнее в интерфейсе запросов Active Record</a>

Обновление:
```
user = User.find_by(name: 'David')
user.update(name: 'Dave')
```
Это наиболее полезно, когда необходимо обновить несколько атрибутов за раз. Если, с другой стороны, необходимо обновить несколько записей за раз, полезен метод класса update_all:
```
User.update_all "max_login_attempts = 3, must_change_password = 'true'"
```
Более того, после получения, объект Active Record может быть уничтожен, что уберет его из базы данных.
```
user = User.find_by(name: 'David')
user.destroy
```
Если необходимо удалить сразу несколько записей, можно использовать метод destroy_all:
```
# найти и удалить всех пользователей с именем David
User.where(name: 'David').destroy_all

# удалить всех пользователей
User.destroy_all
```
### Валидации <a name="2.1.6"></a>
Active Record позволяет проверять состояние модели до того, как она будет записана в базу данных.
Валидация - это очень важный вопрос, который нужно рассмотреть при сохранении в базу данных, поэтому методы `save` и `update` учитывают ее при запуске: они возвращают `false`, когда валидация проваливается, и фактически они не выполняют каких-либо операций с базой данных. Каждый из этих методов имеет пару с восклицательным знаком (`save!` и `update!`), которые строже в том, что они вызывают исключение `ActiveRecord::RecordInvalid` если валидация провалится. Краткий пример:
```
class User < ApplicationRecord
  validates :name, presence: true
end

user = User.new
user.save  # => false
user.save! # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
```
<a href="http://rusrails.ru/active-record-validations">Валидации Active record</a>
### Колбэки <a name="2.1.7"></a>
Колбэки Active Record разрешают присоединить код к определенным событиям в жизненном цикле ваших моделей. Это позволяет добавить поведение модели, прозрачно выполнив код, когда эти события произойдут, например, когда вы создадите новую запись, обновите его, удалите его и так далее. Подробнее о колбэках можно прочитать в руководстве <a href="http://rusrails.ru/active-record-callbacks">Колбэки Active Record</a>.
### Миграции <a name="2.1.8"></a>
Rails предоставляет DSL для управления схемой базы данных, называемый миграциями. Миграции хранятся в файлах, выполняемых для любой базы данных, которую **поддерживает Active Record, с использованием `rake`**. Вот миграция, создающая таблицу:
```
class CreatePublications < ActiveRecord::Migration[5.0]
  def change
    create_table :publications do |t|
      t.string :title
      t.text :description
      t.references :publication_type
      t.integer :publisher_id
      t.string :publisher_type
      t.boolean :single_issue

      t.timestamps
    end
    add_index :publications, :publication_type_id
  end
end
```
Rails отслеживает, какие файлы переданы в базу данных, и представляет возможность отката. Чтобы фактически создать таблицу, нужно запустить rails `db:migrate`, **а чтобы ее откатить rails `db:rollback`**.
> Отметьте, что вышеприведенный код не зависит от базы данных: он выполнится в MySQL, PostgreSQL, Oracle и иных. 

## Миграции Active Record <a name="2.2"></a>
Миграции - это особенность Active Record, позволяющая изменять схему вашей базы данных время от времени.
### Обзор миграций <a name="2.2.1"></a>
В базах данных, поддерживающих транзакции с выражениями, изменяющими схему, миграции оборачиваются в транзакцию. Если база данных это не поддерживает, и миграция проваливается, части, которые прошли успешно, не будут откачены назад. Вам нужно произвести откат вручную.
> Некоторые запросы не могут быть запущены в транзакции. Если ваш адаптер поддерживает транзакции DDL, можно использовать `disable_ddl_transaction!` для их отключения для отдельной миграции.

Если хотите миграцию для чего-то, что Active Record не знает, как обратить, вы можете использовать `reversible`
```
class ChangeProductsPrice < ActiveRecord::Migration[5.0]
  def change
    reversible do |dir|
      change_table :products do |t|
        dir.up   { t.change :price, :string }
        dir.down { t.change :price, :integer }
      end
    end
  end
end
```
С другой стороны, можно использовать `up` и `down` вместо `change`:
```
class ChangeProductsPrice < ActiveRecord::Migration[5.0]
  def up
    change_table :products do |t|
      t.change :price, :string
    end
  end

  def down
    change_table :products do |t|
      t.change :price, :integer
    end
  end
end
```
### Создание миграции <a name="2.2.2"></a>
#### Создание автономной миграции
Миграции хранятся как файлы в директории `db/migrate`, один файл на каждый класс. Имя файла имеет вид `YYYYMMDDHHMMSS_create_products.rb`, это означает, что временная метка UTC идентифицирует миграцию, затем идет знак подчеркивания, затем идет имя миграции, где слова разделены подчеркиваниями. Имя класса миграции содержит буквенную часть названия файла, но уже в формате `CamelCase` (т.е. слова пишутся слитно, каждое слово начинается с большой буквы). Например, `20080906120000_create_products.rb` должен определять класс `CreateProducts`, а `20080906120001_add_details_to_products.rb` должен определять `AddDetailsToProducts`. Rails использует эту метку, чтобы определить, какая миграция должна быть запущена и в каком порядке, так что если вы копируете миграции из другого приложения или генерируете файл сами, будьте более бдительны.

**Пустая миграция**:
```
rails generate migration AddPartNumberToProducts
```
Это создаст правильно названную пустую миграцию:
```
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
  end
end
```
**Обычное поле столбец**.
```
rails generate migration AddPartNumberToProducts part_number:string
или
rails generate migration AddDetailsToProducts part_number:string price:decimal
```
генерирует
```
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
  end
end

и

class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end
```
**Индекс** на новый столбец, вы можете сделать это так
```
rails generate migration AddPartNumberToProducts part_number:string:index
```
генерирует
```
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_index :products, :part_number
  end
end
```
**Удаление столбца**
```
rails generate migration RemovePartNumberFromProducts part_number:string
```
генерирует
```
class RemovePartNumberFromProducts < ActiveRecord::Migration[5.0]
  def change
    remove_column :products, :part_number, :string
  end
end
```
**Cоздание таблицы** 
```
rails generate migration CreateProducts name:string part_number:string
```
генерирует
```
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.string :part_number

      t.timestamps
    end
  end
end
```
**Столбец references** <a href="https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_reference">Документация</a>
```
rails generate migration AddUserRefToProducts user:references
```
генерирует 
```
class AddUserRefToProducts < ActiveRecord::Migration[5.0]
  def change
    add_reference :products, :user, foreign_key: true
  end
end
```
**Соединительная таблица**
```
rails generate migration CreateJoinTableCustomerProduct customer product
```
генерирует
```
class CreateJoinTableCustomerProduct < ActiveRecord::Migration[5.0]
  def change
    create_join_table :customers, :products do |t|
      # t.index [:customer_id, :product_id]
      # t.index [:product_id, :customer_id]
    end
  end
end
```
> Как всегда, то, что было сгенерировано, является всего лишь стартовой точкой. Вы можете добавлять и убирать строки, как считаете нужным, отредактировав файл `db/migrate/YYYYMMDDHHMMSS_add_details_to_products.rb`.
#### Генераторы модели
Генераторы модели и скаффолда создадут миграции, подходящие для создания новой модели.
```
rails generate model Product name:string description:text
```
-> 
```
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
```
#### Передача модификаторов
```
rails generate migration AddDetailsToProducts 'price:decimal{5,2}' supplier:references{polymorphic}
```
->
```
class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :price, :decimal, precision: 5, scale: 2
    add_reference :products, :supplier, polymorphic: true
  end
end
```
### Написание миграции <a name="2.2.3"></a>
#### Создание таблицы
По умолчанию `create_table` создаст первичный ключ, названный `id`. Вы можете изменить имя первичного ключа с помощью опции `:primary_key` (не забудьте также обновить соответствующую модель), или, если вы вообще не хотите первичный ключ, можно указать опцию `id: false`. Если нужно передать базе данных специфичные опции, вы можете поместить фрагмент SQL в опцию `:options`. Например:
```
create_table :products, options: "ENGINE=BLACKHOLE" do |t|
  t.string :name, null: false
end
```
добавит `ENGINE=BLACKHOLE` к SQL выражению, используемому для создания таблицы.
Также можно передать опцию `:comment` с любым описанием для таблицы, которое будет сохранено в самой базе данных, и может быть просмотрено с помощью инструментов администрирования базы данных
#### Создание соединительной таблицы
**Миграционный метод** `create_join_table` создает соединительную таблицу HABTM (has and belongs to many, многие ко многим).
```
create_join_table :products, :categories
```
что создаст таблицу categories_products с двумя столбцами по имени `category_id` и `product_id`. У этих столбцов есть опция `:null`, установленная в `false` по умолчанию. Это может быть переопределено опцией `:column_options:`
```
create_join_table :products, :categories, column_options: { null: true }
```

**По умолчанию**, имя соединительной таблицы получается как соединение первых двух аргументов, переданных в `create_join_table`, в алфавитном порядке. Чтобы настроить имя таблицы, передайте опцию `:table_name:`
```
create_join_table :products, :categories, table_name: :categorization
```
создает таблицу `categorization`

**По умолчанию** `create_join_table` создаст два столбца без опций, но можно определить эти опции с использованием опции `:column_options`. Например,
```
create_join_table :products, :categories, column_options: { null: true }
```
создаст `product_id` и `category_id` с опцией `:null` равной `true`.
`create_join_table` также принимает блок, который можно использовать для добавления индексов (которые по умолчанию не создаются) или дополнительных столбцов:
```
create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end
```
#### Изменение таблиц
```
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
```
удаляет столбцы `description` и `name`, создает строковый столбец `part_number` и добавляет индекс на него. Наконец, он переименовывает столбец `upccode`.
#### Изменение столбцов
```
change_column :products, :part_number, :text
```
Он меняет тип столбца `part_number` в таблице products на `:text`. Отметьте, что команда `change_column` — необратима.

**Кроме** `change_column`, методы `change_column_null` и `change_column_default` используются чтобы изменить ограничение не-null или значение столбца по умолчанию.
```
change_column_null :products, :name, false
change_column_default :products, :approved, from: true, to: false
```
Это настроит поле `:name` в products быть NOT NULL столбцом и изменит значение по умолчанию для поля `:approved` с `true` на `false`.

Также можно написать предыдущую миграцию `change_column_default` как `change_column_default :products, :approved, false`, но, в отличие от предыдущего примера, это сделало бы вашу миграцию необратимой
#### Модификаторы столбца
Модификаторы столбца могут быть применены при создании или изменении столбца:
* `limit` Устанавливает максимальный размер полей `string/text/binary/integer`.
* `precision` Определяет точность для полей `decimal`, определяющую общее количество цифр в числе.
* `scale` Определяет масштаб для полей `decimal`, определяющий количество цифр после запятой.
* `polymorphic` Добавляет столбец `type` для связей `belongs_to`.
* `null` Позволяет или запрещает значения `NULL` в столбце.
* `default` Позволяет установить значение по умолчанию для столбца. Отметьте, что если вы используете динамическое значение (такое как дату), значение по умолчанию будет вычислено лишь один раз (т.е. на дату, когда миграция будет применена).
* `comment` Добавляет комментарий для столбца.
Некоторые адаптеры могут поддерживать дополнительные опции; за подробностями обратитесь к документации API конкретных адаптеров.
> С помощью командной строки нельзя указать null и default
#### Внешние ключи
Хотя это и не требуется, вы можете захотеть добавить ограничения внешнего ключа для обеспечения ссылочной целостности.
```
add_foreign_key :articles, :authors
```
Это добавит новый внешний ключ к столбцу `author_id` таблицы `articles`. Ключ ссылается на столбец `id` таблицы `authors`. Если имена столбцов не могут быть произведены из имен таблиц, можно использовать опции `:column` и `:primary_key`.
Rails сгенерирует имя для каждого внешнего ключа, начинающееся с `fk_rails_` плюс 10 символов, которые детерминировано генерируются на основе `from_table` и `column`. Также есть опция `:name`, если хотите указать другое имя.

> Active Record поддерживает внешние ключи только для отдельных столбцов. Чтобы использовать составные внешние ключи, требуются `execute` и `structure.sql`.

**Убрать внешний ключ** также просто:
```
# позволим Active Record выяснить имя столбца
remove_foreign_key :accounts, :branches

# уберем внешний ключ для определенного столбца
remove_foreign_key :accounts, column: :owner_id

# уберем внешний ключ по имени
remove_foreign_key :accounts, name: :special_fk_name
```
#### Когда хелперов недостаточно
Если хелперов, предоставленных Active Record, недостаточно, можно использовать метод `execute` для выполнения произвольного SQL:
```
Product.connection.execute("UPDATE products SET price = 'free' WHERE 1=1")
```
Больше подробностей и примеров отдельных методов содержится в документации по API. В частности, документация для `ActiveRecord::ConnectionAdapters::SchemaStatements` (который обеспечивает методы, доступные в методах `up`, `down` и `change`), `ActiveRecord::ConnectionAdapters::TableDefinition` (который обеспечивает методы, доступные у объекта, переданного методом `create_table`) и `ActiveRecord::ConnectionAdapters::Table` (который обеспечивает методы, доступные у объекта, переданного методом `change_table`).
#### Использование метода change
Метод `change` это основной метод написания миграций. Он работает в большинстве случаев, когда `Active Record` знает, как обратить миграцию автоматически. На текущий момент метод change поддерживает только эти определения миграции:
* `add_column`
* `add_foreign_key`
* `add_index`
* `add_reference`
* `add_timestamps`
* `change_column_default` (необходимо указать опции :from и :to)
* `change_column_null`
* `create_join_table`
* `create_table`
* `disable_extension`
* `drop_join_table`
* `drop_table` (необходимо указать блок)
* `enable_extension`
* `remove_column` (необходимо указать тип)
* `remove_foreign_key` (необходимо указать вторую таблицу)
* `remove_index`
* `remove_reference`
* `remove_timestamps`
* `rename_column`
* `rename_index`
* `rename_table` 

`change_table` также является обратимым, пока блок не вызывает `change`, `change_default` или `remove`.

`remove_column` обратима, если предоставить тип столбца третьим аргументом. Также предоставьте опции оригинального столбца, иначе Rails не сможет в точности пересоздать этот столбец при откате:
```
remove_column :posts, :slug, :string, null: false, default: ''
```
**Если вы нуждаетесь в использовании иных методов**, следует использовать `reversible` или писать методы `up` и `down` вместо метода `change`.
#### Использование `reversible`
 Вы можете использовать reversible, чтобы указать что делать когда запускается миграция и когда она требует отката.
 ```
 class ExampleMigration < ActiveRecord::Migration
  def change
    create_table :distributors do |t|
      t.string :zipcode
    end

    reversible do |dir|
      dir.up do
        # добавим ограничение CHECK
        execute <<-SQL
          ALTER TABLE distributors
            ADD CONSTRAINT zipchk
              CHECK (char_length(zipcode) = 5) NO INHERIT;
        SQL
      end
      dir.down do
        execute <<-SQL
          ALTER TABLE distributors
            DROP CONSTRAINT zipchk
        SQL
      end
    end

    add_column :users, :home_page_url, :string
    rename_column :users, :email, :email_address
  end
end
```
Использование `reversible` гарантирует, что инструкции выполнятся в правильном порядке. Если предыдущий пример миграции откатывается, `down` блок начнёт выполнятся после того как столбец `home_page_url` будет удалён и перед перед тем как произойдёт удаление таблицы `distributors`.

Иногда миграция будет делать то, что просто необратимо; например, она может уничтожить некоторые данные. В таких случаях, вы можете вызвать `ActiveRecord::IrreversibleMigration` в вашем `down` блоке. Если кто-либо попытается отменить вашу миграцию, будет отображена ошибка, что это не может быть выполнено.
#### Использование методов `up/down`
По аналогии с верхним примером 
```
class ExampleMigration < ActiveRecord::Migration[5.0]
  def up
    create_table :distributors do |t|
      t.string :zipcode
    end

    #добавляем ограничение CHECK
    execute <<-SQL
      ALTER TABLE distributors
        ADD CONSTRAINT zipchk
        CHECK (char_length(zipcode) = 5);
    SQL

    add_column :users, :home_page_url, :string
    rename_column :users, :email, :email_address
  end

  def down
    rename_column :users, :email_address, :email
    remove_column :users, :home_page_url

    execute <<-SQL
      ALTER TABLE distributors
        DROP CONSTRAINT zipchk
    SQL

    drop_table :distributors
  end
end
```
#### Возвращение к предыдущим миграциям
```
require_relative '20121212123456_example_migration'

class FixupExampleMigration < ActiveRecord::Migration[5.0]
  def change
    revert ExampleMigration

    create_table(:apples) do |t|
      t.string :variety
    end
  end
end
```
Метод `revert` также может принимать блок. Это может быть полезно для отката выбранной части предыдущих миграций. Для примера, давайте представим, что `ExampleMigration` закоммичена, а позже мы решили, что было бы лучше использовать валидации `Active Record`, вместо ограничения `CHECK`, для проверки `zipcode`.
```
class DontUseConstraintForZipcodeValidationMigration < ActiveRecord::Migration[5.0]
  def change
    revert do
      reversible do |dir|
        dir.up do
          # добавим ограничение CHECK
          execute <<-SQL
            ALTER TABLE distributors
              ADD CONSTRAINT zipchk
                CHECK (char_length(zipcode) = 5);
          SQL
        end
        dir.down do
          execute <<-SQL
            ALTER TABLE distributors
              DROP CONSTRAINT zipchk
          SQL
        end
      end

      # The rest of the migration was ok
    end
  end
end
```
Подобная миграция также может быть написана без использования `revert`, но это бы привело к ещё нескольким шагам: изменение порядка (следования) `create table` и `reversible`, замена `create_table` на `drop_table` и в конечном итоге изменение `up` на `down` и наоборот. Обо всём этом уже позаботился `revert`.

> Если необходимо добавить ограничения `CHECK`, как в вышеуказанных примерах, нужно использовать `structure.sql` в качестве метода для выгрузки.
### Запуск миграций <a name="2.2.4"></a>
`rails db:migrate` запускает метод `change` или `up` для всех миграций, которые еще не были запущены. 3апуск команды `db:migrate` также вызывает команду `db:schema:dump`, которая обновляет ваш файл `db/schema.rb` в соответствии со структурой вашей базы данных.
Если вы определите целевую версию, `Active Record` запустит требуемые миграции (методы `up`, `down` или `change`), пока не достигнет требуемой версии. Версия это числовой префикс у файла миграции. Например, чтобы мигрировать к версии `20080906120000`, запустите:
```
$ rails db:migrate VERSION=20080906120000
```
Если миграция назад, это запустит метод `down` для всех миграций до, но не включая, `20080906120000`.
#### Откат
```
$ rails db:rollback
```
Если нужно отменить несколько миграций, можно указать параметр `STEP`:
```
$ rails db:rollback STEP=3
```
Команда `db:migrate:redo` это ярлык для выполнения отката, а затем запуска миграции снова.
```
rails db:migrate:redo STEP=3
```
#### Установка базы данных
Команда `rails db:setup` создаст базу данных, загрузит схему и инициализирует ее с помощью данных `seed`.
#### Сброс базы данных
Команда `rails db:reset` удалит базу данных и установит ее заново. Функционально это эквивалентно `rails db:drop db:setup`.
> Это не то же самое, что запуск всех миграций. Будет использовано только текущее содержимое файла `db/schema.rb` или `db/structure.sql`. Если миграцию откатить невозможно, `rails db:reset` может не помочь вам.
#### Запуск определенных миграций
Если необходимо запустить определённую миграцию вверх или вниз, это делают команды `db:migrate:up` и `db:migrate:down`. Просто укажите подходящую версию и у соответствующей миграции будет вызван метод `change`, `up` или `down`, например:
```
$ rails db:migrate:up VERSION=20080906120000
```
#### Запуск миграций в различных средах
По умолчанию запуск `rails db:migrate` запустится в окружении `development`.
```
rails db:migrate RAILS_ENV=test
```
#### Изменение вывода результата запущенных миграций
Метод             |	Назначение
------------------|---------------
suppress_messages | Принимает блок как аргумент и запрещает любой вывод, сгенерированный этим блоком.
say 	            | Принимает сообщение как аргумент и выводит его как есть. Может быть передан второй булевый аргумент для указания, нужен отступ или нет.
say_with_time     | Выводит текст вместе с продолжительностью выполнения блока. Если блок возвращает число, предполагается, что это количество затронутых строк.

Например, эта миграция:
```
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end

    say "Created a table"

    suppress_messages {add_index :products, :name}
    say "and an index!", true

    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end
end
```
сгенерирует следующий результат
```
==  CreateProducts: migrating =================================================
-- Created a table
   -> and an index!
-- Waiting for a while
   -> 10.0013s
   -> 250 rows
==  CreateProducts: migrated (10.0054s) =======================================
```
Если хотите, чтобы Active Record ничего не выводил, запуск `rails db:migrate VERBOSE=false` запретит любой вывод.

### Изменение существующих миграций <a name="2.2.5"></a>
Периодически вы будете делать ошибки при написании миграции. Если вы уже запустили миграцию, вы не сможете просто отредактировать миграцию и запустить ее снова: Rails посчитает, что он уже выполнял миграцию, и ничего не сделает при запуске `rails db:migrate`. Вы должны откатить миграцию (например, с помощью `rails db:rollback`), отредактировать миграцию и затем запустить `rails db:migrate` для запуска исправленной версии.

В целом, редактирование существующих миграций не хорошая идея. Вы создадите дополнительную работу себе и своим коллегам, и вызовете море головной боли, если существующая версия миграции уже была запущена в `production`. Вместо этого, следует написать новую миграцию, выполняющую требуемые изменения. Редактирование только что сгенерированные миграции, которая еще не была закоммичена в систему контроля версий (или, хотя бы, не ушла дальше вашей рабочей машины) относительно безвредно.

Метод `revert` может быть очень полезным при написании новой миграции для возвращения предыдущей в целом или какой то части.

### Выгрузка схемы <a name="2.2.6"></a>
#### Для чего нужны файлы схемы?
Миграции, какими бы не были они мощными, не являются авторитетным источником для схемы базы данных. База данных остается авторитетным источником. По умолчанию Rails генерирует `db/schema.rb`, которая пытается охватить текущее состояние схемы базы данных.

Она имеет тенденцию быть более быстрой и менее подверженной ошибкам, связанным с созданием нового экземпляра базы данных приложения, загружая файл схемы через `rails db:schema:load`, чем при повторном воспроизведении всей истории миграций. Старые миграции могут работать неправильно, если эти миграции используют изменения внешних зависимостей или полагаются на код приложения, который развивается отдельно от этих миграций.

Файлы схемы также полезны, если необходимо быстро посмотреть, какие атрибуты есть у объекта Active Record. Эта информация не содержится в коде модели и часто распределена по нескольким миграциям, но собрана воедино в файле схемы.
#### Типы выгрузок схемы
Формат выгрузки схемы, сгенерированный Rails, управляется настройкой `config.active_record.schema_format` в `config/application.rb`. Форматом по умолчанию является `:ruby`, но также он может быть установлен в `:sql`.

Если выбрано `:ruby`, тогда схема хранится в `db/schema.rb`. Посмотрев в этот файл, можно увидеть, что он очень похож на одну большую миграцию:
```
ActiveRecord::Schema.define(version: 2008_09_06_171750) do
  create_table "authors", force: true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  create_table "products", force: true do |t|
    t.string   "name"
    t.text     "description"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "part_number"
  end
end
```
Во многих случаях этого достаточно. Этот файл создается путем проверки базы данных и описывает свою структуру, используя `create_table`, `add_index` и так далее.

`db/schema.rb` не может описать все, что может поддерживать база данных, например триггеры, последовательности, хранимые процедуры, ограничения `CHECK` и так далее. Отметьте, в то время как в миграциях можно выполнить произвольные выражения SQL, эти выражения не смогут быть воспроизведены выгрузчиком схемы. Если используете подобные особенности, необходимо установить формат схемы как `:sql`, чтобы получить точный файл схемы, который будет полезен для создания новых экземпляров базы данных.

Когда формат схемы установлен в `:sql`, структура базы данных будет выгружена с помощью инструмента, предназначенного для этой базы данных в `db/structure.sql`. Например, для PostgreSQL используется утилита `pg_dump`. Для MySQL и MariaDB этот файл будет содержать результат SHOW CREATE TABLE для разных таблиц.

Чтобы загрузить схему из `db/structure.sql`, запустите `rails db:structure:load`. Загрузка этого файла осуществляется путем выполнения содержащихся в нем выражений SQL. По определению создастся точная копия структуры базы данных.
#### Выгрузки схем и управление версиями
Поскольку файлы схемы обычно используются для создания новых баз данных, настоятельно рекомендуется проверять файл схемы в системе управления версиями.

Конфликты слияния могут возникать в файле схемы, когда две ветки модифицируют схему. Для разрешения этих конфликтов, запустите `rails db:migrate`, чтобы восстановить файл схемы.
### Active Record и ссылочная целостность <a name="2.2.7"></a>
Способ Active Record требует, чтобы логика была в моделях, а не в базе данных. По большому счету, функции, такие как триггеры или ограничения, которые переносят часть логики обратно в базу данных, не используются активно.

Валидации, такие как `validates :foreign_key, uniqueness: true`, это один из способов, которым ваши модели могут соблюдать ссылочную целостность. Опция :dependent в связях позволяет моделям автоматически уничтожать дочерние объекты при уничтожении родителя. Подобно всему, что работает на уровне приложения, это не может гарантировать ссылочной целостности, таким образом кто-то может добавить еще и внешние ключи как ограничители ссылочной целостности в базе данных.

Хотя Active Record не предоставляет каких-либо инструментов для работы напрямую с этими функциями, метод `execute` может использоваться для выполнения произвольного SQL.
### Миграции и сиды <a name="2.2.8"></a>
Основным назначением миграции Rails является запуск команд, последовательно модифицирующих схему. Миграции также могут быть использованы для добавления или модифицирования данных. Это полезно для существующей базы данных, которую нельзя удалить и пересоздать, такой как база данных на `production`.
```
class AddInitialProducts < ActiveRecord::Migration[5.0]
  def up
    5.times do |i|
      Product.create(name: "Product ##{i}", description: "A product.")
    end
  end

  def down
    Product.delete_all
  end
end
```
Чтобы добавить изначальные данные в базу данных после создания, в Rails имеется встроенная особенность 'seeds', которая делает процесс быстрым и простым. Это особенно полезно при частой перезагрузке базы данных в средах разработки и тестирования. Этой особенностью легко начать пользоваться: просто заполните `db/seeds.rb` некоторым кодом Ruby и запустите `rails db:seed`:
```
5.times do |i|
  Product.create(name: "Product ##{i}", description: "A product.")
end
```
В основном, это более чистый способ настроить базу данных для пустого приложения.
### Старые миграции <a name="2.2.9"></a>
`db/schema.rb` или `db/structure.sql` это снимок текущего состояния вашей базы данных и авторитетный источник для восстановления этой базы данных. Поэтому возможно удалить старые файлы миграций.

Когда вы удалите файлы миграций в директории `db/migrate/`, любая среда, в которой `rails db:migrate` была запущена, когда эти файлы еще существовали, будет хранить ссылки на временные метки миграций во внутренней таблице Rails по имени `schema_migrations`. Эта таблица используется для отслеживания, была ли миграция выполнена в указанной среде.

Если вы запустите команду `rails db:migrate:status`, которая отображает статус (`up` или `down`) каждой миграции, вы увидите `********** NO FILE **********`, отображенный рядом с каждым удаленным файлом миграции, который однажды был запущен в указанной среде, но больше не найден в директории db/migrate/.
## Валидации <a name="2.3"></a>
### Обзор валидаций <a name="2.3.1"></a>
```
class Person < ApplicationRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false
```
#### Зачем использовать валидации?
Есть несколько способов валидации данных, прежде чем они будут сохранены в вашу базу данных, включая ограничения, встроенные в базу данных, валидации на клиентской части и валидации на уровне контроллера. Вкратце о плюсах и минусах:
* Ограничения базы данных и/или хранимые процедуры делают механизмы валидации зависимыми от базы данных, что делает тестирование и поддержку более трудными. Однако, если ваша база данных используется другими приложениями, валидация на уровне базы данных может безопасно обрабатывать некоторые вещи (такие как уникальность в нагруженных таблицах), которые затруднительно выполнять по-другому.
* Валидации на клиентской части могут быть очень полезны, но в целом ненадежны, если используются в одиночку. Если они используют JavaScript, они могут быть пропущены, если JavaScript отключен в клиентском браузере. Однако, если этот способ комбинировать с другими, валидации на клиентской части могут быть удобным способом предоставить пользователям немедленную обратную связь при использовании вашего сайта.
* Валидации на уровне контроллера заманчиво делать, но это часто приводит к громоздкости и трудности тестирования и поддержки. Во всех случаях, когда это возможно, держите свои контроллеры 'тощими', тогда с вашим приложением будет приятно работать в долгосрочной перспективе. 

Выбирайте их под свои определенные специфичные задачи. Общее мнение команды Rails состоит в том, что валидации на уровне модели - наиболее подходящий вариант во многих случаях.
#### Когда происходит валидация?
Создание и сохранение новой записи посылает операцию `SQL INSERT` базе данных. Обновление существующей записи вместо этого посылает операцию `SQL UPDATE`. Валидации обычно запускаются до того, как эти команды посылаются базе данных. Если любая из валидаций проваливается, объект помечается как недействительный и Active Record не выполняет операцию `INSERT` или `UPDATE`. Это помогает избежать хранения невалидного объекта в базе данных. Можно выбирать запуск специфичных валидаций, когда объект создается, сохраняется или обновляется.

Есть разные методы изменения состояния объекта в базе данных. Некоторые методы вызывают валидации, некоторые нет. Это означает, что возможно сохранить в базу данных объект с недействительным статусом, если вы будете не внимательны.

Следующие методы вызывают валидацию, и сохраняют объект в базу данных только если он валиден:
* `create`
* `create!`
* `save`
* `save!`
* `update`
* `update!`

Версии с восклицательным знаком (т.е. `save!`) **вызывают исключение**, если запись недействительна. Невосклицательные версии не вызывают: `save` и `update` возвращают `false`, `create` **возвращает объект**.
#### Пропуск валидаций
Следующие методы пропускают валидации, и сохраняют объект в базу данных, независимо от его валидности. Их нужно использовать осторожно.
* `decrement!`
* `decrement_counter`
* `increment!`
* `increment_counter`
* `toggle!`
* `touch`
* `update_all`
* `update_attribute`
* `update_column`
* `update_columns`
* `update_counters`

Заметьте, что `save` также имеет способность пропустить валидации, если передать `validate: false` как аргумент. Этот способ нужно использовать осторожно.
```
save(validate: false) 
```
#### `valid?` или `invalid?`
Вы также можете запускать эти валидации самостоятельно. `valid?` вызывает ваши валидации и возвращает `true`, если ни одной ошибки не было найдено у объекта, иначе `false`.
```
class Person < ApplicationRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false
```
После того, как Active Record выполнит валидации, все найденные ошибки будут доступны в методе экземпляра `errors.messages`, возвращающем коллекцию ошибок.
`invalid?` это просто антипод `valid?`.
#### `errors[]`
Чтобы проверить, является или нет конкретный атрибут объекта валидным, можно использовать `errors[:attribute]`, который возвращает массив со всеми ошибками атрибута, когда нет ошибок по определенному атрибуту, возвращается пустой массив.
#### `errors.details`
Чтобы проверить, какие валидации упали на невалидном атрибуте, можно использовать `errors.details[:attribute]`. Он возвращает массив хэшей с ключом `:error`, чтобы получить символ валидатора:
```
class Person < ApplicationRecord
  validates :name, presence: true
end

>> person = Person.new
>> person.valid?
>> person.errors.details[:name] # => [{error: :blank}]
```
### Валидационные хелперы <a name="2.3.2"></a>
Каждый хелпер принимает произвольное количество имен атрибутов, поэтому в одной строчке кода можно добавить валидации одинакового вида для нескольких атрибутов.

Они все принимают опции `:on` и `:message`, которые определяют, когда валидация должна быть запущена, и какое сообщение должно быть добавлено в коллекцию `errors`, если она провалится. Опция `:on` принимает одно из значений `:create` или `:update`. Для каждого валидационного хелпера есть свое сообщение об ошибке по умолчанию. Эти сообщения используются, если не определена опция `:message`.
#### `acceptance`
Этот метод проверяет, что чекбокс в пользовательском интерфейсе был нажат, когда форма была подтверждена.
```
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: true
end
```
Эта проверка выполнится, только если `terms_of_service` не `nil`.
Можно передать произвольное сообщение с помощью опции `message`.
```
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: { message: 'must be abided' }
end
```
Также он может получать опцию `:accept`, которая определяет допустимые значения, которые будут считаться принятыми. По умолчанию это "1", но его можно изменить.
```
class Person < ApplicationRecord
  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }
end
```
Эта валидация очень специфична для веб-приложений, и ее принятие не нужно записывать куда-либо в базу данных. Если у вас нет поля для него, хелпер всего лишь создаст виртуальный атрибут. Если поле существует в базе данных, опция `accept` должна быть установлена или включать `true`, а иначе эта валидация не будет выполнена.
#### `validates_associated`
Этот хелпер можно использовать, когда у вашей модели есть связи с другими моделями, и их также нужно проверить на валидность. Когда вы пытаетесь сохранить свой объект, будет вызван метод `valid?` для каждого из связанных объектов.
```
class Library < ApplicationRecord
  has_many :books
  validates_associated :books
end
```
Эта валидация работает со всеми типами связей.

> Не используйте `validates_associated` на обоих концах ваших связей, они будут вызывать друг друга в бесконечном цикле.

Для `validates_associated` сообщение об ошибке по умолчанию следующее "is invalid". Заметьте, что каждый связанный объект имеет свою собственную коллекцию `errors`; ошибки не добавляются к вызывающей модели.
#### `confirmation`
Этот хелпер можно использовать, если у вас есть два текстовых поля, из которых нужно получить полностью идентичное содержание.
Например, вы хотите подтверждение адреса электронной почты или пароля. Эта валидация создает виртуальный атрибут, имя которого равно имени подтверждаемого поля с добавлением "confirmation".
```
class Person < ApplicationRecord
  validates :email, confirmation: true
end
```
В вашем шаблоне вьюхи нужно использовать что-то вроде этого:
```
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
```
Эта проверка выполняется, только если `email_confirmation` не равно `nil`. Чтобы требовать подтверждение, нужно добавить еще проверку на существование проверяемого атрибута (мы рассмотрим presence чуть позже):
```
class Person < ApplicationRecord
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end
```
Также имеется опция `:case_sensitive`, которую используют, чтобы определить, должно ли ограничение подтверждения быть чувствительным к регистру. Эта опция по умолчанию `true`.
```
class Person < ApplicationRecord
  validates :email, confirmation: { case_sensitive: false }
end
```
#### `exclusion`
Этот хелпер проводит валидацию того, что значения атрибутов не включены в указанный набор. Фактически, этот набор может быть любым перечисляемым объектом.
```
class Account < ApplicationRecord
  validates :subdomain, exclusion: { in: %w(www us ca jp),
    message: "%{value} is reserved." }
end
```
Хелпер exclusion имеет опцию `:in`, которая получает набор значений, которые не должны приниматься проверяемыми атрибутами. Опция `:in` имеет псевдоним `:within`, который используется для тех же целей. Этот пример использует опцию `:message`, чтобы показать вам, как можно включать значение атрибута.
#### `format`
Этот хелпер проводит валидацию значений атрибутов, тестируя их на соответствие указанному регулярному выражению, которое определяется с помощью опции `:with`.
```
class Product < ApplicationRecord
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,
    message: "only allows letters" }
end
```
В качестве альтернативы можно потребовать, чтобы указанный атрибут не соответствовал регулярному выражению, используя опцию `:without`.
#### `inclusion`
Этот хелпер проводит валидацию значений атрибутов на включение в указанный набор. Фактически этот набор может быть любым перечисляемым объектом.
```
class Coffee < ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }
end
```
#### `length`
```
class Person < ApplicationRecord
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end
```
Возможные опции ограничения длины такие:
* `:minimum` - атрибут не может быть меньше определенной длины.
* `:maximum` - атрибут не может быть больше определенной длины.
* `:in` (или `:within`) - длина атрибута должна находиться в указанном интервале. Значение этой опции должно быть интервалом.
* `:is` - длина атрибута должна быть равной указанному значению. 

Значение сообщения об ошибке по умолчанию зависит от типа выполняемой валидации длины. Можно переопределить эти сообщения, используя опции `:wrong_length`, `:too_long` и `:too_short`, и `%{count}` как местозаполнитель (placeholder) числа, соответствующего длине используемого ограничения. Можете использовать опцию `:message` для определения сообщения об ошибке.
```
class Person < ApplicationRecord
  validates :bio, length: { maximum: 1000,
    too_long: "%{count} characters is the maximum allowed" }
end
```
Отметьте, что сообщения об ошибке по умолчанию во множественном числе (т.е., "is too short (minimum is %{count} characters)"). По этой причине, когда `:minimum` равно 1, следует предоставить собственное сообщение или использовать вместо него `presence: true`. Когда `:in` или `:within` имеют как нижнюю границу 1, следует или предоставить собственное сообщение, или вызвать `presence` перед `length`.
#### `numericality`
Этот хелпер проводит валидацию того, что ваши атрибуты имеют только числовые значения. По умолчанию, этому будет соответствовать возможный знак первым символом, и следующее за ним целочисленное или с плавающей запятой число. Чтобы определить, что допустимы только целочисленные значения, установите `:only_integer` в `true`.

Если установить `:only_integer` в `true`, тогда будет использоваться регулярное выражение
```
/\A[+-]?\d+\z/
```
для проведения валидации значения атрибута. В противном случае, он будет пытаться конвертировать значение в число, используя `Float`.
```
class Player < ApplicationRecord
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
end
```

Кроме `:only_integer`, хелпер `validates_numericality_of` также принимает следующие опции для добавления ограничений к приемлемым значениям:
* `:greater_than` - определяет, что значение должно быть больше, чем значение опции.
* `:greater_than_or_equal_to` - определяет, что значение должно быть больше или равно значению опции.
* `:equal_to` - определяет, что значение должно быть равно значению опции.
* `:less_than` - определяет, что значение должно быть меньше, чем значение опции. 
* `:less_than_or_equal_to` - определяет, что значение должно быть меньше или равно значению опции.
* `:other_than` - определяет, что значение должно отличаться от представленного значения.
* `:odd` - определяет, что значение должно быть нечетным, если установлено true.
* `:even` - определяет, что значение должно быть четным, если установлено true.

> По умолчанию `numericality` не допускает значения `nil`. Чтобы их разрешить, можно использовать опцию `allow_nil: true`.
#### `presence`
Этот хелпер проводит валидацию того, что определенные атрибуты не пустые. Он использует метод `blank?` для проверки того, является ли значение или `nil`, или пустой строкой (это строка, которая или пуста, или состоит из пробелов).
```
class Person < ApplicationRecord
  validates :name, :login, :email, presence: true
end
```
Если хотите быть уверенным, **что связь существует**, нужно проверить, существует ли сам связанный объект, а не внешний ключ, используемый для связи.
```
class LineItem < ApplicationRecord
  belongs_to :order
  validates :order, presence: true
end
```
Для того, чтобы **проверять связанные записи**, чье присутствие необходимо, нужно определить опцию `:inverse_of` для связи:
```
class Order < ApplicationRecord
  has_many :line_items, inverse_of: :order
end
```
При проведении валидации существования объекта, связанного отношением `has_one` или `has_many`, будет проверено, что объект ни `blank?`, ни `marked_for_destruction?`.

Так как `false.blank?` это `true`, если хотите **провести валидацию существования булева поля**, нужно использовать одну из следующих валидаций:
```
validates :boolean_field_name, inclusion: { in: [true, false] }
validates :boolean_field_name, exclusion: { in: [nil] }
```
При использовании одной из этих валидаций, вы можете быть уверены, что значение не будет `nil`, которое в большинстве случаев преобразуется в `NULL` значение.
#### `absence`
Этот хелпер проверяет, что указанные атрибуты отсутствуют. Он использует метод `present?` для проверки, что значение является либо `nil`, либо пустой строкой (то есть либо нулевой длины, либо состоящей из пробелов).
```
class Person < ApplicationRecord
  validates :name, :login, :email, absence: true
end
```
Если хотите **убедиться, что отсутствует связь**, необходимо проверить, что отсутствует сам связанный объект, а не внешний ключ, используемый для связи.
```
class LineItem < ApplicationRecord
  belongs_to :order
  validates :order, absence: true
end
```
Чтобы проверять связанные объекты, отсутствие которых требуется, для связи необходимо указать опцию `:inverse_of`:
```
class Order < ApplicationRecord
  has_many :line_items, inverse_of: :order
end
```
Если проверяете отсутствие объекта, связанного отношением `has_one` или `has_many`, он проверит, что объект и не `present?`, и не `marked_for_destruction?`.

Поскольку `false.present?` является `false`, если хотите проверить отсутствие булева поля, следует использовать `validates :field_name, exclusion: { in: [true, false] }`
#### `uniqueness`
Этот хелпер проводит валидацию того, что значение атрибута уникально, перед тем, как объект будет сохранен. Он не создает условие уникальности в базе данных, следовательно, может произойти так, что два разных подключения к базе данных создадут две записи с одинаковым значением для столбца, который вы подразумеваете уникальным. Чтобы этого избежать, нужно создать индекс `unique` на оба столбцах в вашей базе данных.
```
class Account < ApplicationRecord
  validates :email, uniqueness: true
end
```
Валидация производится путем SQL-запроса в таблицу модели, поиска существующей записи с тем же значением атрибута.

Имеется опция `:scope`, которую можно использовать для определения одного и более атрибутов, используемых для ограничения проверки уникальности:
```
class Holiday < ApplicationRecord
  validates :name, uniqueness: { scope: :year,
    message: "should happen once per year" }
end
```
Если хотите создать ограничение на уровне базы данных, чтобы предотвратить возможные нарушения валидации уникальности с помощью опции `:scope`, необходимо создать индекс уникальности на обоих столбцах базы данных.
Также имеется опция `:case_sensitive`, которой можно определить, будет ли ограничение уникальности чувствительно к регистру или нет. Опция по умолчанию равна `true`.
```
class Person < ApplicationRecord
  validates :name, uniqueness: { case_sensitive: false }
end
```
> Отметьте, что некоторые базы данных настроены на выполнение чувствительного к регистру поиска в любом случае.
#### `validates_with`
```
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end

class Person < ApplicationRecord
  validates_with GoodnessValidator
end
```
> Ошибки, добавляемые в `record.errors[:base]` относятся к состоянию записи в целом, а не к определенному атрибуту.
Хелпер `validates_with` принимает класс или список классов для использования в валидации. Для `validates_with` нет сообщения об ошибке по умолчанию. Следует вручную добавлять ошибки в коллекцию errors записи в классе валидатора.

Для применения метода validate, необходимо иметь определенным параметр record, который является записью, проходящей валидацию.

Подобно всем другим валидациям, `validates_with` принимает опции `:if`, `:unless` и `:on`. Если передадите любые другие опции, они будут переданы в класс валидатора как `options`:
```
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end

class Person < ApplicationRecord
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
end
```
Отметьте, что валидатор будет инициализирован только один раз на протяжении всего жизненного цикла приложения, а не при каждом запуске валидации, поэтому будьте аккуратнее с использованием переменных экземпляра в нем.

Если ваш валидатор настолько сложный, что вы хотите использовать переменные экземпляра, вместо него проще использовать обычные объекты Ruby:
```
class Person < ApplicationRecord
  validate do |person|
    GoodnessValidator.new(person).validate
  end
end

class GoodnessValidator
  def initialize(person)
    @person = person
  end

  def validate
    if some_complex_condition_involving_ivars_and_private_methods?
      @person.errors[:base] << "This person is evil"
    end
  end

  # ...
end
```
#### `validates_each`
Этот хелпер помогает провести валидацию атрибутов с помощью блока кода. Он не имеет предопределенной валидационной функции. Вы должны создать ее, используя блок, и каждый атрибут, указанный в `validates_each`, будет протестирован в нем. В следующем примере нам не нужны имена и фамилии, начинающиеся с маленькой буквы.
```
class Person < ApplicationRecord
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[[:lower:]]/
  end
end
```
Блок получает запись, имя атрибута и значение атрибута. Вы можете делать что угодно для проверки валидности данных внутри блока. Если валидация проваливается, следует добавить сообщение об ошибке в модель, которое делает ее невалидной.
### Общие опции валидаций <a name="2.3.3"></a>
#### `:allow_nil`
Опция `:allow_nil` пропускает валидацию, когда проверяемое значение равно `nil`.
```
class Coffee < ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }, allow_nil: true
end
```
#### `:allow_blank`

Опция `:allow_blank` подобна опции `:allow_nil`. Эта опция пропускает валидацию, если значение атрибута `blank?`, например `nil` или пустая строка.
```
class Topic < ApplicationRecord
  validates :title, length: { is: 5 }, allow_blank: true
end

Topic.create(title: "").valid?  # => true
Topic.create(title: nil).valid? # => true
```
#### `:message`
Значение `String` в `:message` может опционально содержать любые из `%{value}`, `%{attribute}` и `%{model}`, которые будут динамически заменены, когда валидация провалится. Эта замена выполняется, если используется гем `I18n`, и местозаполнитель должен полностью совпадать, пробелы не допускаются.

Значение `Proc` в `:message` задается с двумя аргументами: проверяемым объектом и хэшем с ключами `:model`, `:attribute` и `:value`.
```
class Person < ApplicationRecord
  # Жестко закодированное сообщение
  validates :name, presence: { message: "must be given please" }

  # Сообщение со значением с динамическим атрибутом. %{value} будет заменено
  # фактическим значением атрибута. Также доступны %{attribute} и %{model}.
  validates :age, numericality: { message: "%{value} seems wrong" }

  # Proc
  validates :username,
    uniqueness: {
      # object = person object being validated
      # data = { model: "Person", attribute: "Username", value: <username> }
      message: ->(object, data) do
        "Hey #{object.name}!, #{data[:value]} is taken already! Try again #{Time.zone.tomorrow}"
      end
    }
end
```
#### `:on`
Используйте `on: :create`, для запуска валидации только когда создается новая запись, или `on: :update`, для запуска валидации когда запись обновляется.
```
class Person < ApplicationRecord
  # будет возможно обновить email с дублирующим значением
  validates :email, uniqueness: true, on: :create

  # будет возможно создать запись с нечисловым возрастом
  validates :age, numericality: true, on: :update

  # по умолчанию (проверяет и при создании, и при обновлении)
  validates :name, presence: true
end
```
`on:` также можно использовать для **определения пользовательского контекста**. Пользовательские контексты должны быть явно включены с помощью передачи имени контекста в `valid?`, `invalid?` или `save`.
```
class Person < ApplicationRecord
  validates :email, uniqueness: true, on: :account_setup
  validates :age, numericality: true, on: :account_setup
end

person = Person.new
```
`person.valid?(:account_setup)` выполнит обе валидации без сохранения модели. И `person.save(context: :account_setup)` перед сохранением валидирует `person` в контексте `account_setup`. При явном включении модель валидируется только валидациями только этого контекста и валидациями без контекста.

### Строгие валидации <a name="2.3.4"></a>
Также можно определить валидации строгими, чтобы они вызывали `ActiveModel::StrictValidationFailed`, когда объект невалиден.
```
class Person < ApplicationRecord
  validates :name, presence: { strict: true }
end

Person.new.valid?  # => ActiveModel::StrictValidationFailed: Name can't be blank
```
Также возможно передать собственное исключение в опцию `:strict`.
```
class Person < ApplicationRecord
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
end

Person.new.valid?  # => TokenGenerationException: Token can't be blank
```
### Условная валидация <a name="2.3.5"></a>
#### Использование символа с `:if` и `:unless`
```
class Order < ApplicationRecord
  validates :card_number, presence: true, if: :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end
```
#### Использование `Proc` с `:if` и `:unless`
Использование объекта `Proc` дает возможность написать встроенное условие вместо отдельного метода. Этот вариант лучше всего подходит для однострочного кода.
```
class Account < ApplicationRecord
  validates :password, confirmation: true,
    unless: Proc.new { |a| a.password.blank? }
end
```
#### Группировка условных валидаций `with_options`
```
class User < ApplicationRecord
  with_options if: :is_admin? do |admin|
    admin.validates :password, length: { minimum: 10 }
    admin.validates :email, presence: true
  end
end
````
Во все валидации внутри `with_options` будет автоматически передано условие `if: :is_admin?`
#### Объединение условий валидации
С другой стороны, может использоваться массив, когда несколько условий определяют, должна ли произойти валидация. Более того, в одной и той же валидации можно применить и `:if:`, и `:unless`.
```
class Computer < ApplicationRecord
  validates :mouse, presence: true,
                    if: [Proc.new { |c| c.market.retail? }, :desktop?],
                    unless: Proc.new { |c| c.trackpad.present? }
end
```
Валидация выполнится только тогда, когда все условия `:if` и ни одно из условий `:unless` будут вычислены со значением `true`.
### Выполнение собственных валидаций <a name="2.3.6"></a>
#### Собственные валидаторы
Собственные валидаторы это классы, наследуемые от `ActiveModel::Validator`. Эти классы должны реализовать метод `validate`, принимающий запись как аргумент и выполняющий валидацию на ней. Собственный валидатор вызывается с использованием метода `validates_with`
```
class MyValidator < ActiveModel::Validator
  def validate(record)
    unless record.name.starts_with? 'X'
      record.errors[:name] << 'Need a name starting with X please!'
    end
  end
end
 
class Person
  include ActiveModel::Validations
  validates_with MyValidator
end
```
Простейшим способом добавить собственные валидаторы для валидации отдельных атрибутов является наследуемость от `ActiveModel::EachValidator`. В этом случае класс собственного валидатора должен реализовать метод `validate_each`, принимающий три аргумента: запись, атрибут и значение. Это будут соответствующие экземпляр, атрибут, который будет проверяться и значение атрибута в переданном экземпляре:
```
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)`[a-z]{2,})\z/i
      record.errors[attribute] << (options[:message] || "is not an email")
    end
  end
end

class Person < ApplicationRecord
  validates :email, presence: true, email: true
end
```
Как показано в примере, можно объединять стандартные валидации со своими произвольными валидаторами.
#### Собственные методы
Метод `valid?` проверит, что коллекция ошибок пуста. поэтому ваши собственные методы валидации должны добавить ошибки в нее, когда вы хотите, чтобы валидация провалилась:
```
class Invoice < ApplicationRecord
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    if expiration_date.present? && expiration_date < Date.today
      errors.add(:expiration_date, "can't be in the past")
    end
  end

  def discount_cannot_be_greater_than_total_value
    errors.add(:discount, "can't be greater than total value") if
      discount > total_value
  end
end
```
По умолчанию такие валидации будут выполнены каждый раз при вызове `valid?` или сохранении объекта. Но также возможно контролировать, когда выполнять собственные валидации, передав опцию `:on` в метод `validate`, с ключами: `:create` или `:update`.
```
class Invoice < ApplicationRecord
  validate :active_customer, on: :create

  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
  end
end
```
### Работаем с ошибками валидации <a name="2.3.7"></a>
#### `errors`
Возвращает экземпляр класса `ActiveModel::Errors`, содержащий все ошибки. Каждый ключ это имя атрибута и значение это массив строк со всеми ошибками.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors.messages
 # => {:name=>["can't be blank", "is too short (minimum is 3 characters)"]}

person = Person.new(name: "John Doe")
person.valid? # => true
person.errors.messages # => []
```
#### `errors[]`
Он возвращает массив строк со всеми сообщениями об ошибке для заданного атрибута, каждая строка с одним сообщением об ошибке. Если нет ошибок, относящихся к атрибуту, возвратится пустой массив.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new(name: "John Doe")
person.valid? # => true
person.errors[:name] # => []

person = Person.new(name: "JD")
person.valid? # => false
person.errors[:name] # => ["is too short (minimum is 3 characters)"]

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
```
#### `errors.add`
Метод add позволяет добавлять сообщение об ошибке, относящейся к определенному атрибуту. Он принимает в качестве аргументов атрибут и сообщение об ошибке.

Метод `errors.full_messages` (или его эквивалент `errors.to_a`) возвращает сообщения об ошибках в дружелюбном формате с именем атрибута с прописной буквы, предшествующим каждому сообщению, как показано в следующем примере.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
  end
end

person = Person.create(name: "!@#")

person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]

person.errors.full_messages
 # => ["Name cannot contain the characters !@#%*()_-+="]
```
Эквивалентом `errors#add` является использование `<<` для добавления сообщения к массиву `errors.messages` атрибута:
```
  class Person < ApplicationRecord
    def a_method_used_for_validation_purposes
      errors.messages[:name] << "cannot contain the characters !@#%*()_-+="
    end
  end

  person = Person.create(name: "!@#")

  person.errors[:name]
   # => ["cannot contain the characters !@#%*()_-+="]

  person.errors.to_a
   # => ["Name cannot contain the characters !@#%*()_-+="]
```
#### `errors.details`
Можно указать тип валидатора в возвращаемом хэше подробностей об ошибке `detail` с помощью метода `errors.add`.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors.add(:name, :invalid_characters)
  end
end

person = Person.create(name: "!@#")

person.errors.details[:name]
# => [{error: :invalid_characters}]
```
Чтобы расширить хэш подробностей об ошибке `details`, добавив, к примеру, недопустимые символы, можно передать дополнительные ключи в `errors.add`.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors.add(:name, :invalid_characters, not_allowed: "!@#%*()_-+=")
  end
end

person = Person.create(name: "!@#")

person.errors.details[:name]
# => [{error: :invalid_characters, not_allowed: "!@#%*()_-+="}]
```
Все встроенные в Rails валидаторы заполняют хэш details соответствующим типом валидатора.
#### `errors[:base]`
Можете добавлять сообщения об ошибках, которые относятся к состоянию объекта в целом, а не к отдельному атрибуту. Этот метод можно использовать, если вы хотите сказать, что объект невалиден, независимо от значений его атрибутов. Поскольку `errors[:base]` массив, можете просто добавить строку к нему, и она будет использована как сообщение об ошибке.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors[:base] << "This person is invalid because ..."
  end
end
```
#### `errors.clear`
Метод `clear` используется, когда вы намеренно хотите очистить все сообщения в коллекции errors. Естественно, вызов `errors.clear` для невалидного объекта фактически не сделает его валидным: сейчас коллекция `errors` будет пуста, но в следующий раз, когда вы вызовете `valid?` или любой метод, который пытается сохранить этот объект в базу данных, валидации выполнятся снова. Если любая из валидаций провалится, коллекция errors будет заполнена снова.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]

person.errors.clear
person.errors.empty? # => true

person.save # => false

person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
```
#### `errors.size`
Метод `size` возвращает количество сообщений об ошибке для объекта.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors.size # => 2

person = Person.new(name: "Andrea", email: "andrea@example.com")
person.valid? # => true
person.errors.size # => 0
```
### Отображение ошибок валидации во вьюхах <a name="2.3.8"></a>
Как только вы создали модель и добавили валидации, если эта модель создается с помощью веб-формы, то вы, возможно хотите отображать сообщение об ошибке, когда одна из валидаций проваливается.

Поскольку каждое приложение обрабатывает подобные вещи по-разному, в Rails нет какого-то хелпера вьюхи для непосредственной генерации этих сообщений. Однако, благодаря богатому набору методов, Rails в целом дает способ взаимодействия с валидациями, очень просто создать свой собственный. Кроме того, при генерации скаффолда, Rails поместит некоторый ERB в `_form.html.erb`, генерируемый для отображения полного списка ошибок этой модели.

Допустим, у нас имеется модель, сохраненная в переменную экземпляра @article, это выглядит следующим образом:
```
<% if @article.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@article.errors.count, "error") %> prohibited this article from being saved:</h2>
    <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
```
Более того, при использовании хелперов форм Rails для создания форм, когда у поля происходит ошибка валидации, генерируется дополнительный `<div>` вокруг содержимого.
```
<div class="field_with_errors">
 <input id="article_title" name="article[title]" size="30" type="text" value="">
</div>
```
Этот `div` можно стилизовать по желанию. К примеру, дефолтный скаффолд, который генерирует Rails, добавляет это правило CSS:
```
.field_with_errors {
  padding: 2px;
  background-color: red;
  display: table;
}
```
## Колбэки Active Record <a name="2.4"></a>
### Жизненный цикл объекта <a name="2.4.1"></a>
В результате обычных операций приложения на Rails, объекты могут быть созданы, обновлены и уничтожены. Active Record дает возможность вмешаться в этот жизненный цикл объекта, таким образом, вы можете контролировать свое приложение и его данные.

Валидации позволяют вам быть уверенными, что только валидные данные хранятся в вашей базе данных. Колбэки позволяют вам переключать логику до или после изменения состояния объекта.
### Обзор колбэков <a name="2.4.2"></a>
#### Регистрация колбэков 
Для того, чтобы использовать доступные колбэки, их нужно зарегистрировать. Можно реализовать колбэки как обычные методы, а затем использовать макро-методы класса для их регистрации в качестве колбэков.
```
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_validation :ensure_login_has_a_value

  private
    def ensure_login_has_a_value
      if login.nil?
        self.login = email unless email.blank?
      end
    end
end
```
**Макро-методы** класса также могут получать блок. Их следует использовать, если код внутри блока такой короткий, что помещается в одну строчку.
```
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_create do
    self.name = login.capitalize if name.blank?
  end
end
```
Колбэки также могут быть зарегистрированы на выполнение **при определенных событиях жизненного цикла**:
```
class User < ApplicationRecord
  before_validation :normalize_name, on: :create

  # :on также принимает массив
  after_validation :set_location, on: [ :create, :update ]

  private
    def normalize_name
      self.name = name.downcase.titleize
    end

    def set_location
      self.location = LocationService.query(self)
    end
end
```
Считается **хорошей практикой** объявлять методы колбэков как `private`. Если их оставить `public`, они могут быть вызваны извне модели и нарушить принципы инкапсуляции объекта.
### Доступные колбэки <a name="2.4.3"></a>
Вот список всех доступных колбэков Active Record, перечисленных в том порядке, в котором они вызываются в течение соответствующих операций:
#### Создание объекта
* `before_validation`
* `after_validation`
* `before_save`
* `around_save`
* `before_create`
* `around_create`
* `after_create`
* `after_save`
* `after_commit/after_rollback` 
#### Обновление объекта
* `before_validation`
* `after_validation`
* `before_save`
* `around_save`
* `before_update`
* `around_update`
* `after_update`
* `after_save`
* `after_commit/after_rollback` 
#### Уничтожение объекта
* `before_destroy`
* `around_destroy`
* `after_destroy`
* `after_commit/after_rollback` 
> `after_save` запускается и при создании, и при обновлении, но всегда после более специфичных колбэков `after_create` и `after_update`, независимо от порядка, в котором выполняются макро-вызовы.
> Колбэк `before_destroy` должен быть размещен перед связями `dependent: :destroy` (или использовать опцию `prepend: true`), чтобы убедиться, что они выполняются до того, как записи будут удалены с помощью `dependent: :destroy`.

#### `after_initialize` и `after_find`
**Колбэк `after_initialize`** вызывается всякий раз, когда возникает экземпляр объекта Active Record, или непосредственно при использовании new, или когда запись загружается из базы данных. Он может быть полезен, чтобы избежать необходимости напрямую переопределять метод Active Record `initialize`.
**Колбэк `after_find`** будет вызван всякий раз, когда Active Record загружает запись из базы данных. `after_find` вызывается перед `after_initialize`, если они оба определены.
У колбэков `after_initialize` и `after_find` **нет пары `before_*`**, но они могут быть зарегистрированы подобно другим колбэкам Active Record.
```
class User < ApplicationRecord
  after_initialize do |user|
    puts "You have initialized an object!"
  end

  after_find do |user|
    puts "You have found an object!"
  end
end

>> User.new
You have initialized an object!
=> #<User id: nil>

>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
```
#### `after_touch`
Колбэк `after_touch` будет вызван, когда на объекте Active Record вызван `touch`.
```
class User < ApplicationRecord
  after_touch do |user|
    puts "You have touched an object"
  end
end

>> u = User.create(name: 'Kuldeep')
=> #<User id: 1, name: "Kuldeep", created_at: "2013-11-25 12:17:49", updated_at: "2013-11-25 12:17:49">

>> u.touch
You have touched an object
=> true
```
Он может быть **использован совместно с `belongs_to`**:
```
class Employee < ApplicationRecord
  belongs_to :company, touch: true
  after_touch do
    puts 'An Employee was touched'
  end
end

class Company < ApplicationRecord
  has_many :employees
  after_touch :log_when_employees_or_company_touched

  private
  def log_when_employees_or_company_touched
    puts 'Employee/Company was touched'
  end
end

>> @employee = Employee.last
=> #<Employee id: 1, company_id: 1, created_at: "2013-11-25 17:04:22", updated_at: "2013-11-25 17:05:05">

# вызывает @employee.company.touch
>> @employee.touch
Employee/Company was touched
An Employee was touched
=> true
```
### Запуск колбэков <a name="2.4.4"></a>
Следующие методы запускают колбэки:
* `create`
* `create!`
* `destroy`
* `destroy!`
* `destroy_all`
* `save`
* `save!`
* `save(validate: false)`
* `toggle!`
* `touch`
* `update_attribute`
* `update`
* `update!`
* `valid?` 

Дополнительно, **колбэк `after_find` запускается** следующими поисковыми методами:
* `all`
* `first`
* `find`
* `find_by`
* `find_by_*`
* `find_by_*!`
* `find_by_sql`
* `last` 

Колбэк **`after_initialize` запускается** всякий раз, **когда инициализируется** новый объект класса.

> Методы `find_by_*` и `find_by_*!` это динамические методы поиска, генерируемые автоматически для каждого атрибута.
### Пропуск колбэков <a name="2.4.5"></a>

Подобно валидациям, также возможно пропустить колбэки, используя следующие методы.
* `decrement`
* `decrement_counter`
* `delete`
* `delete_all`
* `increment`
* `increment_counter`
* `toggle`
* `update_column`
* `update_columns`
* `update_all`
* `update_counters` 

Однако, эти методы нужно использовать осторожно, поскольку важные бизнес-правила и логика приложения могут содержаться в колбэках. Пропуск их без понимания возможных последствий может привести к невалидным данным.
### Прерывание выполнения <a name="2.4.6"></a>
Как только вы зарегистрировали новые колбэки в своих моделях, они будут поставлены в очередь на выполнение. Эта очередь включает все валидации вашей модели, зарегистрированные колбэки и операции с базой данных для выполнения.

Вся цепочка колбэков упаковывается в операцию. **Если любой колбэк вызывает исключение, выполняемая цепочка прерывается** и запускается `ROLLBACK`. Чтобы преднамеренно остановить цепочку, используйте:
```
throw :abort
```
> Вызов произвольного исключения может прервать код, который предполагает, что save и тому подобное не будут провалены подобным образом. Исключение `ActiveRecord::Rollback` чуть точнее сообщает Active Record, что происходит откат. Он подхватывается изнутри, но не перевызывает исключение.
> Любое исключение, кроме `ActiveRecord::Rollback` или `ActiveRecord::RecordInvalid`, будет перевызвано Rails после того, как прервется цепочка колбэков. Вызов исключения, отличного от `ActiveRecord::Rollback` или `ActiveRecord::RecordInvalid`, может сломать код, который не ожидает, что методы, такие как `save` и `update` (которые обычно пытаются вернуть `true` или `false`) вызовут исключение.

### Колбэки для отношений <a name="2.4.7"></a>
Колбэки работают с отношениями между моделями, и даже могут быть определены ими. Представим пример, где пользователь имеет много статей. Статьи пользователя должны быть уничтожены, если уничтожается пользователь. Давайте добавим колбэк `after_destroy` в модель `User` через ее отношения с моделью `Article`.
```
class User < ApplicationRecord
  has_many :articles, dependent: :destroy
end

class Article < ActiveRecord::Base
  after_destroy :log_destroy_action

  def log_destroy_action
    puts 'Article destroyed'
  end
end

>> user = User.first
=> #<User id: 1>
>> user.articles.create!
=> #<Article id: 1, user_id: 1>
>> user.destroy
Article destroyed
=> #<User id: 1>
```
### Условные колбэки <a name="2.4.8"></a>
#### Использование `:if` и `:unless` с `Symbol`
При использовании такой формы регистрации, также возможно зарегистрировать несколько различных предикатов, которые будут вызваны, чтобы проверить, должен ли выполняться колбэк.
```
class Order < ApplicationRecord
  before_save :normalize_card_number, if: :paid_with_card?
end
```
#### Использование `:if` и `:unless` с `Proc`
Этот вариант больше всего подходит при написании коротких методов, обычно однострочных.
```
class Order < ApplicationRecord
  before_save :normalize_card_number,
    if: Proc.new { |order| order.paid_with_card? }
end
```
#### Составные условия для колбэков
```
class Comment < ApplicationRecord
  after_create :send_email_to_author, if: :author_wants_emails?,
    unless: Proc.new { |comment| comment.article.ignore_comments? }
end
```
### Классы колбэков <a name="2.4.9"></a>
Вот пример, где создается класс с колбэком `after_destroy` для модели `PictureFile`:
```
class PictureFileCallbacks
  def after_destroy(picture_file)
    if File.exist?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
```
При объявлении внутри класса, как выше, методы колбэка получают объект модели как параметр. Теперь можем использовать класс колбэка в модели:
```
class PictureFile < ApplicationRecord
  after_destroy PictureFileCallbacks.new
end
```
Заметьте, что нам нужно создать экземпляр нового объекта `PictureFileCallbacks`, после того, как объявили наш колбэк как отдельный метод. Это особенно полезно, если колбэки используют состояние экземпляра объекта. Часто, однако, более подходящим является объявление его в качестве метода класса.
```
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    if File.exist?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
```
Если метод колбэка объявляется таким образом, нет необходимости создавать экземпляр объекта `PictureFileCallbacks`.
```
class PictureFile < ApplicationRecord
  after_destroy PictureFileCallbacks
end
```
Внутри своего колбэк-класса можно создать сколько угодно колбэков.
### Транзакционные колбэки <a name="2.4.10"></a>
Имеются два дополнительных колбэка, которые включаются по завершению транзакции базы данных: `after_commit` и `after_rollback`. Эти колбэки очень похожи на колбэк `after_save`, за исключением того, что они не выполняются пока изменения в базе данных не будут подтверждены или обращены. Они наиболее полезны, когда вашим моделям Active Record необходимо взаимодействовать с внешними системами, не являющимися частью транзакции базы данных.

Рассмотрим, допустим, предыдущий пример, где модели `PictureFile` необходимо удалить файл после того, как запись уничтожена. Если что-либо вызовет исключение после того, как был вызван колбэк `after_destroy`, и транзакция откатывается, файл будет удален и модель останется в противоречивом состоянии. Например, предположим, что `picture_file_2` в следующем коде не валидна, и метод `save!` вызовет ошибку.
```
PictureFile.transaction do
  picture_file_1.destroy
  picture_file_2.save!
end
```
Используя колбэк `after_commit`, можно учесть этот случай.
```
class PictureFile < ApplicationRecord
  after_commit :delete_picture_file_from_disk, on: :destroy

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
```
> Опция `:on` определяет, когда будет запущен колбэк. Если не предоставить опцию `:on`, колбэк будет запущен для каждого экшна.

Так как принято использовать колбэк `after_commit` только при создании, обновлении или удалении, есть псевдонимы для этих операций:
* `after_create_commit`
* `after_update_commit`
* `after_destroy_commit` 
```
class PictureFile < ApplicationRecord
  after_destroy_commit :delete_picture_file_from_disk

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
```
> Колбэки `after_commit` и `after_rollback` вызываются для всех созданных, обновленных или удаленных моделей внутри блока транзакции. Однако, если какое-либо исключение вызовется в одном из этих колбэков, это исключение всплывет, и любые оставшиеся методы `after_commit` или `after_rollback` не будут выполнены. По сути, если код вашего колбэка может вызвать исключение, нужно для него вызвать `rescue`, и обработать его в колбэке, чтобы позволить запуститься другим колбэкам.

> При одновременном **использовании `after_create_commit` и `after_update_commit`** в одной и той же модели сработает только колбэк, **определенный последним**, переопределив все остальные.

```
class User < ApplicationRecord
  after_create_commit :log_user_saved_to_db
  after_update_commit :log_user_saved_to_db

  private
  def log_user_saved_to_db
    puts 'User was saved to database'
  end
end

# ничего не выводит
>> @user = User.create

# обновление @user
>> @user.save
=> User was saved to database
```
Чтобы зарегистрировать **колбэки как для create, так и для update** экшнов, используйте **`after_commit`**.
```
class User < ApplicationRecord
  after_commit :log_user_saved_to_db, on: [:create, :update]
end
```


## Связи (ассоциации) <a name="2.5"></a>
### Зачем нужны связи <a name="2.5.1"></a>
```
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end
```
С этими изменениями создание новой книги для определенного автора проще:
```
@book = @author.books.create(published_at: Time.now)
```
Удаление автора и всех его книг намного проще:
```
@author.destroy
```
### Типы связей <a name="2.5.2"></a>
Rails поддерживает шесть типов связей:
* `belongs_to`
* `has_one`
* `has_many`
* `has_many :through`
* `has_one :through`
* `has_and_belongs_to_many` 
Связи реализуются с использованием макро-вызовов (macro-style calls), и, таким образом, вы можете декларативно добавлять возможности для своих моделей. Например, объявляя, что одна модель принадлежит (`belongs_to`) другой, вы указываете Rails сохранять информацию о первичном-внешнем ключах между экземплярами двух моделей, а также получаете несколько полезных методов, добавленных в модель.

#### Связь `belongs_to`
Связь belongs_to устанавливает соединение один-к-одному с другой моделью, когда один экземпляр объявляющей модели "принадлежит" одному экземпляру другой модели. Например, если в приложении есть авторы и книги, и одна книга может быть связана только с одним автором, нужно объявить модель book следующим образом:
```
class Book < ApplicationRecord
  belongs_to :author
end
```
> связи `belongs_to` обязаны использовать единственное число. Если использовать множественное число в вышеприведенном примере для связи `author` в модели `Book` и создать экземпляр с помощью `Book.create(authors: @author)`, будет сообщено "uninitialized constant `Book::Authors`". Это так, потому что Rails автоматически получает имя класса из имени связи. Если в имени связи неправильно использовано число, то получаемый класс также будет неправильного числа.

Соответствующая миграция может выглядеть так:
```
class CreateOrders < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```
#### Связь `has_one`
Связь `has_one` также устанавливает соединение один-к-одному с другой моделью, но в несколько ином смысле (и с другими последствиями). Эта связь показывает, что каждый экземпляр модели содержит или обладает одним экземпляром другой модели. Например, если каждый поставщик имеет только один аккаунт, можете объявить модель supplier подобно этому:
```
class Supplier < ApplicationRecord
  has_one :account
end
```
Соответствующая миграция может выглядеть так:
```
class CreateSuppliers < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
```
В зависимости от применения, возможно потребуется создать индекс уникальности и/или ограничение внешнего ключа на указанный столбец таблицы `accounts`. В этом случае определение столбца может выглядеть так:
```
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
  # ...
end
```
#### Связь `has_many`
Связь has_many указывает на соединение один-ко-многим с другой моделью. Эта связь часто бывает на "другой стороне" связи `belongs_to`. Эта связь указывает на то, что каждый экземпляр модели имеет ноль или более экземпляров другой модели. Например, в приложении, содержащем авторов и книги, модель `author` может быть объявлена следующим образом:
```
class Author < ApplicationRecord
  has_many :books
end
```
Имя другой модели указывается во множественном числе при объявлении связи `has_many`.
Соответствующая миграция может выглядеть так:
```
class CreateAuthors < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```
####  Связь `has_many :through`
Связь `has_many :through` часто используется для настройки соединения многие-ко-многим с другой моделью. Эта связь указывает, что объявляющая модель может соответствовать нулю или более экземплярам другой модели через третью модель. Например, рассмотрим поликлинику, где пациентам (patients) дают направления (appointments) к врачам (physicians). Соответствующие объявления связей будут выглядеть следующим образом:
```
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end

class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
```
Соответствующая миграция может выглядеть так:
```
class CreateAppointments < ActiveRecord::Migration[5.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
```
Коллекция соединительных моделей может управляться с помощью методов связи `has_many`. Например, если вы присвоите:
```
physician.patients = patients
```
Тогда будут автоматически созданы новые соединительные модели для вновь связанных объектов. Если некоторые из ранее существующих сейчас отсутствуют, их соединительные строки автоматически удаляются.

> Автоматическое удаление соединительных моделей прямое, ни один из колбэков на уничтожение не включается.

Связь **`has_many :through` также полезна для настройки "ярлыков" через вложенные связи `has_many`**. Например, если документ имеет много секций, а секция имеет много параграфов, иногда хочется получить просто коллекцию всех параграфов в документе. Это можно настроить следующим образом:
```
class Document < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end
```
С определенным `through: :sections` Rails теперь понимает:
```
@document.paragraphs
```
#### Связь `has_one :through`
Связь `has_one :through` настраивает соединение один-к-одному с другой моделью. Эта связь показывает, что объявляющая модель может быть связана с одним экземпляром другой модели через третью модель. Например, если каждый поставщик имеет один аккаунт, и каждый аккаунт связан с одной историей аккаунта, тогда модели могут выглядеть так:
```
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end
```
Соответствующая миграция может выглядеть так:
```
class CreateAccountHistories < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
```
#### Связь `has_and_belongs_to_many`
Связь `has_and_belongs_to_many` создает прямое соединение многие-ко-многим с другой моделью, без промежуточной модели. Например, если ваше приложение включает сборки (assemblies) и детали (parts), где каждый узел имеет много деталей, и каждая деталь встречается во многих сборках, модели можно объявить таким образом:
```
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```
Соответствующая миграция может выглядеть так:
```
class CreateAssembliesAndParts < ActiveRecord::Migration[5.0]
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
```
#### Выбор между `belongs_to` и `has_one`

Если хотите настроить отношение один-к-одному между двумя моделями, необходимо добавить `belongs_to` к одной и `has_one` к другой. Как узнать что к какой?

Различие в том, где помещен внешний ключ (он должен быть в таблице для класса, объявляющего связь `belongs_to`), но вы также должны думать о реальном значении данных. Отношение `has_one` говорит, что что-то принадлежит вам - то есть что что-то указывает на вас. Например, больше смысла в том, что поставщик владеет аккаунтом, чем в том, что аккаунт владеет поставщиком. Это означает, что правильные отношения подобны этому:
```
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```
Соответствующая миграция может выглядеть так:
```
class CreateSuppliers < ActiveRecord::Migration[5.2]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.bigint  :supplier_id
      t.string  :account_number
      t.timestamps
    end

    add_index :accounts, :supplier_id
  end
end
```
> Использование `t.bigint :supplier_id` указывает имя внешнего ключа очевидно и явно. В современных версиях Rails можно абстрагироваться от деталей реализации используя `t.references :supplier`

#### Выбор между `has_many :through` и `has_and_belongs_to_many`
Rails предлагает два разных способа объявления отношения многие-ко-многим между моделями. Простейший способ - использовать `has_and_belongs_to_many`, который позволяет создать связь напрямую:
```
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```
Второй способ объявить отношение многие-ко-многим - использование `has_many :through`. Это осуществляет связь не напрямую, а через соединяющую модель:
```
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end

class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
```
Простейший признак того, что нужно настраивать отношение `has_many :through` - если необходимо работать с моделью отношений как с независимым объектом. Если вам не нужно ничего делать с моделью отношений, проще настроить связь `has_and_belongs_to_many` (хотя нужно не забыть создать соединяющую таблицу в базе данных).

Вы должны использовать `has_many :through`, если нужны валидации, колбэки или дополнительные атрибуты для соединительной модели.

#### Полиморфные связи
Полиморфные связи - это немного более "навороченный" вид связей. С полиморфными связями модель может принадлежать более чем одной модели, на одиночной связи. Например, имеется модель изображения, которая принадлежит или модели работника, или модели продукта. Вот как это объявляется:
```
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end

class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end

class Product < ApplicationRecord
  has_many :pictures, as: :imageable
end
```
Можно считать полиморфное объявление `belongs_to` как настройку интерфейса, которую может использовать любая другая модель. Из экземпляра модели `Employee` можно получить коллекцию изображений:` @employee.pictures`.

Подобным образом можно получить `@product.pictures`.

Если имеется экземпляр модели `Picture`, можно получить его родителя посредством `@picture.imageable`. Чтобы это работало, необходимо объявить столбец внешнего ключа и столбец типа в модели, объявляющей полиморфный интерфейс:
```
class CreatePictures < ActiveRecord::Migration[5.2]
  def change
    create_table :pictures do |t|
      t.string  :name
      t.bigint  :imageable_id
      t.string  :imageable_type
      t.timestamps
    end

    add_index :pictures, [:imageable_type, :imageable_id]
  end
end
```
Эта миграция может быть упрощена при использовании формы `t.references`:
```
class CreatePictures < ActiveRecord::Migration[5.0]
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end
```
#### Присоединение к себе
При разработке модели данных иногда находится модель, которая может иметь отношение сама к себе. Например, мы хотим хранить всех работников в одной модели базы данных, но нам нужно отслеживать отношения начальник-подчиненный. Эта ситуация может быть смоделирована с помощью связей, присоединяемых к себе:
```
class Employee < ApplicationRecord
  has_many :subordinates, class_name: "Employee",
                          foreign_key: "manager_id"

  belongs_to :manager, class_name: "Employee", optional: true
end
```
С такой настройкой, вы можете получить `@employee.subordinates` и `@employee.manager`.

В миграциях/схеме следует добавить столбец ссылки модели на саму себя.
```
class CreateEmployees < ActiveRecord::Migration[5.0]
  def change
    create_table :employees do |t|
      t.references :manager
      t.timestamps
    end
  end
end
```

### Полезные советы и предупреждения <a name="2.5.3"></a>
Вот некоторые вещи, которые необходимо знать для эффективного использования связей Active Record в вашем приложении на Rails:
* Управление кэшированием
* Предотвращение коллизий имен
* Обновление схемы
* Управление областью видимости связей
* Двусторонние связи 

#### Управление кэшированием
Все методы связи построены вокруг кэширования, которое хранит результаты последних запросов доступными для будущих операций. Кэш является общим для разных методов. Например:
```
author.books                 # получаем книги из базы данных
author.books.size            # используем кэшированную копию книг
author.books.empty?          # используем кэшированную копию книг
```
Но что если вы хотите перезагрузить кэш, так как данные могли быть изменены другой частью приложения? Всего лишь вызовите `reload` на связи:
```
author.books                 # получаем книги из базы данных
author.books.size            # используем кэшированную копию книг
author.books.reload.empty?   # отказываемся от кэшированной копии книг
                             # и снова обращаемся к базе данных
```
#### Предотвращение коллизий имен
Вы не свободны в выборе любого имени для своих связей. Поскольку создание связи добавляет метод с таким именем в модель, будет плохой идеей дать связи имя, уже используемое как метод экземпляра `ActiveRecord::Base`. Метод связи тогда переопределит базовый метод, и что-нибудь перестанет работать. Например, `attributes` или `connection` плохие имена для связей.

#### Обновление схемы
Связи очень полезные, но не волшебные. Вы ответственны за содержание вашей схемы базы данных в соответствии со связями. На практике это означает две вещи, в зависимости от того, какой тип связей создаете. Для связей `belongs_to` нужно создать внешние ключи, а для связей `has_and_belongs_to_many` нужно создать подходящую соединительную таблицу.

##### Создание внешних ключей для связей `belongs_to`
Когда объявляете связь `belongs_to`, нужно создать внешние ключи, при необходимости. Например, рассмотрим эту модель:
```
class Book < ApplicationRecord
  belongs_to :author
end
```
Это объявление нуждается в поддержке соответствующим столбцом внешнего ключа в таблице `books`. Для совершенно новой таблицы миграция может выглядеть примерно так:
```
class CreateBooks < ActiveRecord::Migration[5.0]
  def change
    create_table :books do |t|
      t.datetime   :published_at
      t.string     :book_number
      t.references :author
    end
  end
end
```
В то время как для существующей таблицы, это может выглядеть следующим образом:
```
class AddAuthorToBooks < ActiveRecord::Migration[5.0]
  def change
    add_reference :books, :author
  end
end
```
Если необходимо принудительно использовать ссылочную целостность на уровне базы данных, добавьте опцию `foreign_key: true` в вышеприведенное объявление 'reference' столбца

##### Создание соединительных таблиц для связей `has_and_belongs_to_many`
Если вы создали связь `has_and_belongs_to_many`, необходимо обязательно создать соединительную таблицу. Если имя соединительной таблицы явно не указано с использованием опции `:join_table`, `Active Record` создает имя, используя алфавитный порядок имен классов. Поэтому соединение между моделями author и book по умолчанию даст значение имени таблицы "authors_books", так как "a" идет перед "b" в алфавитном порядке.

> Приоритет между именами модели рассчитывается с использованием оператора `<=>` для `String`. Это означает, что если строки имеют разную длину и в своей короткой части они равны, тогда более длинная строка рассматривается как с более высоким лексическим приоритетом, по сравнению с короткой. Например, кто-то ожидает, что таблицы "paper_boxes" и "papers" создадут соединительную таблицу "papers_paper_boxes" поскольку имя "paper_boxes" длиннее, но фактически будет сгенерирована таблица с именем "paper_boxes_papers" (поскольку знак подчеркивания "`_`" лексикографически меньше, чем "s" в обычной кодировке).

Какое бы ни было имя, вы должны вручную сгенерировать соединительную таблицу в соответствующей миграции. Например, рассмотрим эти связи:
```
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```
Теперь нужно написать миграцию для создания таблицы `assemblies_parts`. Эта таблица должна быть создана без первичного ключа:
```
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.2]
  def change
    create_table :assemblies_parts, id: false do |t|
      t.bigint :assembly_id
      t.bigint :part_id
    end

    add_index :assemblies_parts, :assembly_id
    add_index :assemblies_parts, :part_id
  end
end
```
Мы передаем `id: false в create_table`, так как эта таблица не представляет модель. Это необходимо, чтобы связь работала правильно. Если вы видите странное поведение в связи `has_and_belongs_to_many`, например, искаженные ID моделей, или исключения в связи с конфликтом ID, скорее всего вы забыли убрать первичный ключ.

Также можно использовать метод `create_join_table`
```
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.0]
  def change
    create_join_table :assemblies, :parts do |t|
      t.index :assembly_id
      t.index :part_id
    end
  end
end
```
#### Управление областью видимости связей
По умолчанию связи ищут объекты только в пределах области видимости текущего модуля. Это важно, когда вы объявляете модели Active Record внутри модуля. Например:
```
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end

    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```
Это будет работать, так как оба класса `Supplier` и `Account` определены в пределах одной области видимости. Но нижеследующее не будет работать, потому что `Supplier` и `Account` определены в разных областях видимости:
```
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```
Для связи модели с моделью в другом пространстве имен, необходимо указать полное имя класса в объявлении связи:
```
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end
```
#### Двусторонние связи
Для связей нормально работать в двух направлениях, затребовав объявление в двух различных моделях:
```
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
```
Active Record попытается автоматически определить, что эти две модели образуют двунаправленную связь, основываясь на имени связи. Таким образом, Active Record загрузит только одну копию объекта `Author`, делая ваше приложение более эффективным и предотвращая несогласованные данные:
```
a = Author.first
b = a.books.first
a.first_name == b.author.first_name # => true
a.first_name = 'David'
a.first_name == b.author.first_name # => true
```
Active Record **поддерживает автоматическое определение для большинства связей** со стандартными именами. Однако, Active Record **не будет автоматически определять двунаправленные связи**, содержащие область видимости или любые из следующих опций:
* `:through`
* `:foreign_key` 

Например, рассмотрим следующие объявления моделей:
```
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```
Active Record больше не будет автоматически распознавать двунаправленную связь:
```
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => false
```
Active Record представляет опцию `:inverse_of`, таким образом можно явно объявить двунаправленные связи:
```
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```
Включив опцию `:inverse_of` в объявлении связи `has_many`, Active Record будет распознавать двунаправленную связь:
```
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => true
```
### Подробная информация по связи `belongs_to` <a name="2.5.4"></a>
Связь `belongs_to` создает соответствие один-к-одному с другой моделью. В терминах базы данных эта связь сообщает, что этот класс содержит внешний ключ. Если внешний ключ содержит другой класс, вместо этого следует использовать `has_one`.
#### Методы, добавляемые `belongs_to`
Когда объявляете связь `belongs_to`, объявляющий класс автоматически получает 6 методов, относящихся к связи:
* `association`
* `association=(associate)`
* `build_association(attributes = {})`
* `create_association(attributes = {})`
* `create_association!(attributes = {})`
* `reload_association` 
Во всех четырех методах association заменяется символом, переданным как первый аргумент в `belongs_to`. Например, имеем объявление:
```
class Book < ApplicationRecord
  belongs_to :author
end
```
Каждый экземпляр модели `Book` будет иметь эти методы:
* `author`
* `author=`
* `build_author`
* `create_author`
* `create_author!`
* `reload_author`
> Когда устанавливаете новую связь `has_one` или `belongs_to`, следует использовать префикс `build_` для построения связи, в отличие от метода `association.build`, используемый для связей `has_many или has_and_belongs_to_many`. Чтобы создать связь, используйте префикс `create_`.
##### `association`
Метод `association` возвращает связанный объект, если он есть. Если объекта нет, возвращает `nil`.
```
@author = @book.author
```
Если связанный объект уже был получен из базы данных для этого объекта, возвращается кэшированная версия. Чтобы переопределить это поведение (и заставить прочитать из базы данных), вызовите `#reload_association` на родительском объекте.
```
@author = @book.reload_author
```
##### `association=(associate)`

Метод `association=` привязывает связанный объект к этому объекту. Фактически это означает извлечение первичного ключа из связанного объекта и присвоение его значения внешнему ключу.
```
@book.author = @author
```
##### `build_association(attributes = {})`

Метод `build_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, будет установлена связь с внешним ключом этого объекта, но связанный объект пока не будет сохранен.
```
@author = @book.build_author(author_number: 123,
                                  author_name: "John Doe")
```
##### `create_association(attributes = {})`

Метод `create_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, будет установлена связь с внешним ключом этого объекта, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен.
```
@author = @book.create_author(author_number: 123, author_name: "John Doe")
```
##### `create_association!(attributes = {})`

Работает так же, как и вышеприведенный `create_association`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

#### Опции для `belongs_to`
Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `belongs_to`. Такая настройка легко выполнима с помощью передачи опций и блоков со скоупом при создании связи. Например, эта связь использует две такие опции:
```
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at,
    counter_cache: true
end
```
Связь `belongs_to` поддерживает эти опции:
* `:autosave`
* `:class_name`
* `:counter_cache`
* `:dependent`
* `:foreign_key`
* `:primary_key`
* `:inverse_of`
* `:polymorphic`
* `:touch`
* `:validate`
* `:optional` 

##### `:autosave`
Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave в false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosave` отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.
##### `:class_name`
Если имя другой модели не может быть получено из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если книга принадлежит автору, но фактическое имя модели, содержащей авторов, `Patron`, можете установить это следующим образом:
```
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron"
end
```
##### `:counter_cache`
Опция `:counter_cache` может быть использована, чтобы сделать поиск количества принадлежащих объектов более эффективным. Рассмотрим эти модели:
```
class Book < ApplicationRecord
  belongs_to :author
end
class Author < ApplicationRecord
  has_many :books
end
```
С этими объявлениями запрос значения `@author.books.size` требует обращения к базе данных для выполнения запроса `COUNT(*)`. Чтобы этого избежать, можете добавить кэш счетчика в принадлежащую модель:
```
class Book < ApplicationRecord
  belongs_to :author, counter_cache: true
end
class Author < ApplicationRecord
  has_many :books
end
```
С этим объявлением, Rails будет хранить в кэше актуальное значение и затем возвращать это значение в отклик на метод `size`.

Хотя опция `:counter_cache` определяется в модели, включающей определение `belongs_to`, фактический столбец должен быть добавлен в связанную (`has_many`) модель. В вышеописанном случае, необходимо добавить столбец, названный `books_count` в модель `Author`.

Имя столбца по умолчанию можно переопределить, указав произвольное имя столбца в объявлении `counter_cache` вместо `true`. Например, для использования `count_of_books` вместо `books_count`:
```
class Book < ApplicationRecord
  belongs_to :author, counter_cache: :count_of_books
end
class Author < ApplicationRecord
  has_many :books
end
```
> Опцию `:counter_cache` необходимо указывать только на стороне `belongs_to` связи. Столбцы кэша счетчика добавляются в список атрибутов модели только для чтения посредством `attr_readonly`.

##### `:dependent`

Если установить опцию `:dependent` в:
* `:destroy`, когда объект будет уничтожен, `destroy` будет вызван на его связанных объектах.
* `:delete`, когда объект будет уничтожен, все его связанные объекты будут удалены прямо из базы данных без вызова метода `destroy`. 

> Не следует определять эту опцию в связи `belongs_to`, которая соединена со связью `has_many` в другом классе. Это приведет к "битым" связям в записях вашей базы данных.

##### `:foreign_key`

По соглашению Rails предполагает, что столбец, используемый для хранения внешнего ключа в этой модели, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron", foreign_key: "patron_id"
end
```
> В любом случае, Rails не создаст столбцы внешнего ключа за вас. Вам необходимо явно определить их в своих миграциях.

##### `:primary_key`

По соглашению Rails предполагает, что для первичного ключа используется столбец `id` в таблице. Опция `:primary_key` позволяет указать иной столбец.

Например, имеется таблица `users` с `guid` в качестве первичного ключа. Если мы хотим отдельную таблицу `todos`, содержащую внешний ключ `user_id` из столбца `guid`, для этого можно использовать `primary_key` следующим образом:
```
class User < ApplicationRecord
  self.primary_key = 'guid' # primary key is guid and not id
end

class Todo < ApplicationRecord
  belongs_to :user, primary_key: 'guid'
end
```
При выполнении `@user.todos.create`, у записи `@todo` будет значение `user_id` таким же, как значение `guid` у `@user`.

##### `:inverse_of`

Опция `:inverse_of` определяет имя связи `has_many` или `has_one`, являющейся противоположностью для этой связи.
```
class Author < ApplicationRecord
  has_many :books, inverse_of: :author # книга имеет автора book.author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books # автор имеет книги author.books
end
```
##### `:polymorphic`

Передача `true` для опции `:polymorphic` показывает, что это полиморфная связь.

##### `:touch`

Если установите опцию `:touch` в `true`, то временные метки `updated_at` или `updated_on` на связанном объекте будут установлены в текущее время всякий раз, когда этот объект будет сохранен или уничтожен:
```
class Book < ApplicationRecord
  belongs_to :author, touch: true
end

class Author < ApplicationRecord
  has_many :books
end
```
В этом случае, сохранение или уничтожение книги обновит временную метку на связанном авторе. **Также можно определить конкретный атрибут** временной метки для обновления:
```
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at
end
```
##### `:validate`

Если установите опцию `:validate` в `true`, тогда связанные объекты будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `false`: связанные объекты не проходят валидацию, когда этот объект сохраняется.

##### `:optional`

Если установить `:optional` в `true`, тогда наличие связанных объектов не будет валидироваться. По умолчанию установлено в `false`.

#### Скоупы для `belongs_to`
Иногда хочется настроить запрос, используемый `belongs_to`. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `includes`
* `readonly`
* `select` 

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
```
##### `includes`

Метод `includes` можно использовать для определения связей второго порядка, которые должны быть лениво загружены при использовании этой связи. Например, рассмотрим эти модели:
```
class Chapter < ApplicationRecord
  belongs_to :book
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```
Если вы часто получаете авторов непосредственно из глав (`@chapter.book.author`), то можно улучшить эффективность кода, включив авторов в связь между книгой и ее главами:
```
class Chapter < ApplicationRecord
  belongs_to :book, -> { includes :author }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```
> Нет необходимости в использовании `includes` для ближайших связей - то есть, если есть `Book belongs_to :author`, то `author` автоматически лениво загружается при необходимости.

##### `readonly`

При использовании `readonly`, связанный объект будет только для чтения при получении через связь.

##### `select`

Метод `select` позволяет переопределить SQL выражение SELECT, используемое для получения данных о связанном объекте. **По умолчанию Rails получает все столбцы**.

> При использовании метода `select` на связи `belongs_to`, следует также установить опцию `:foreign_key` для гарантии правильных результатов.

#### Существуют ли связанные объекты?

Можно увидеть, существует ли какой-либо связанный объект, при использовании метода `association.nil?`:
```
if @book.author.nil?
  @msg = "No author found for this book"
end
```
#### Когда сохраняются объекты?

Присвоение связи `belongs_to` не приводит к автоматическому сохранению ни самого объекта, ни связанного объекта.

### Подробная информация по связи `has_one` <a name="2.5.5"></a>
Связь `has_one` создает соответствие один-к-одному с другой моделью. В терминах базы данных эта связь сообщает, что другой класс содержит внешний ключ. Если этот класс содержит внешний ключ, следует использовать `belongs_to`.

#### Методы, добавляемые `has_one`
Когда объявляете связь `has_one`, объявляющий класс автоматически получает 6 методов, относящихся к связи:
* `association`
* `association=(associate)`
* `build_association(attributes = {})`
* `create_association(attributes = {})`
* `create_association!(attributes = {})`
* `reload_association`

> При установлении новой связи `has_one` или `belongs_to`, следует использовать префикс `build_` для построения связи, в отличие от метода `association.build`, используемого для связей `has_many` или `has_and_belongs_to_many`. Чтобы создать связь, используйте префикс `create_`.

##### `association`
Метод `association` возвращает связанный объект, если таковой имеется. Если связанный объект не найден, возвращает `nil`.
```
@account = @supplier.account
```
Если связанный объект уже был получен из базы данных для этого объекта, возвращается кэшированная версия. Чтобы переопределить это поведение (и заставить прочитать из базы данных), вызовите `#reload_association` на родительском объекте.
```
@account = @supplier.reload_account
```
##### `association=(associate)`

Метод `association=` привязывает связанный объект к этому объекту. Фактически это означает извлечение первичного ключа этого объекта и присвоение его значения внешнему ключу связанного объекта.
```
@supplier.account = @account
```

##### `build_association(attributes = {})`

Метод `build_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, и будет установлена связь через внешний ключ, но связанный объект пока не будет сохранен.
```
@account = @supplier.build_account(terms: "Net 30")
```

##### `create_association(attributes = {})`

Метод `create_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, будет установлена связь через внешний ключ, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен
```
@account = @supplier.create_account(terms: "Net 30")
```

##### `create_association!(attributes = {})`

Работает так же, как и вышеприведенный `create_association`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

#### Опции для `has_one`
Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `has_one`. Такая настройка легко выполнима с помощью передачи опции при создании связи. Например, эта связь использует две такие опции:
```
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing", dependent: :nullify
end
```
Связь has_one поддерживает эти опции:
* `:as`
* `:autosave`
* `:class_name`
* `:dependent`
* `:foreign_key`
* `:inverse_of`
* `:primary_key`
* `:source`
* `:source_type`
* `:through`
* `:touch`
* `:validate`

##### `:as`
Установка опции `:as` показывает, что это полиморфная связь.

##### `:autosave`

Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave` в `false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosave` отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.

##### `:class_name`

Если имя другой модели не может быть образовано из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если поставщик имеет аккаунт, но фактическое имя модели, содержащей аккаунты, это `Billing`, можете установить это следующим образом:
```
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing"
end
```

##### `:dependent`

Управляет тем, что произойдет со связанным объектом, когда его владелец будет уничтожен:
* `:destroy` приведет к тому, что связанный объект также будет уничтожен
* `:delete` приведет к тому, что связанный объект будет удален из базы данных напрямую (таким образом не будут выполнены колбэки)
* `:nullify` приведет к тому, что внешний ключ будет установлен NULL. Столбцы полиморфного типа на полиморфных связях также обнуляются. Колбэки не выполняются.
* `:restrict_with_exception` приведет к вызову исключения `ActiveRecord::DeleteRestrictionError`, если есть связанный объект
* `:restrict_with_error` приведет к ошибке, добавляемой к владельцу, если есть связанный объект 

Нельзя устанавливать или оставлять опцию `:nullify` для связей, имеющих ограничение NOT NULL. Если не установить `dependent` для уничтожения таких связей, вы не сможете изменить связанный объект, так как внешнему ключу изначально связанного объекта будет назначено недопустимое значение NULL.

##### `:foreign_key`

По соглашению Rails предполагает, что столбец, используемый для хранения внешнего ключа в этой модели, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class Supplier < ApplicationRecord
  has_one :account, foreign_key: "supp_id"
end
```
> В любом случае, Rails не создаст столбцы внешнего ключа за вас. Вам необходимо явно определить их в своих миграциях.

##### `:inverse_of`

Опция `:inverse_of` определяет имя связи `belongs_to`, являющейся обратной для этой связи.
```
class Supplier < ApplicationRecord
  has_one :account, inverse_of: :supplier
end

class Account < ApplicationRecord
  belongs_to :supplier, inverse_of: :account
end
```

##### `:primary_key`

По соглашению, Rails предполагает, что столбец, используемый для хранения первичного ключа, это `id`. Вы можете переопределить это и явно определить первичный ключ с помощью опции `:primary_key`

##### `:source`

Опция `:source` определяет имя источника связи для связи `has_one :through`

##### `:source_type`

Опция `:source_type` определяет тип источника связи для связи `has_one :through`, который действует при полиморфной связи.
```
class Book < ApplicationRecord
  has_one :format, polymorphic: true
  has_one :dust_jacket, through: :format, source: :dust_jacket, source_type: "Hardback"
end

class Paperback < ApplicationRecord; end

class Hardback < ApplicationRecord
  has_one :dust_jacket
end

class DustJacket < ApplicationRecord; end
```

##### `:through`

Опция `:through` определяет соединительную модель, через которую выполняется запрос. 

##### `:touch`

Если опция `:touch` установлена `true`, тогда временные метки `updated_at` или `updated_on` у связанного объекта будут установлены в текущее время всякий раз, когда этот объект будет сохранен или уничтожен:
```
class Supplier < ApplicationRecord
  has_one :account, touch: true
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```
В этом случае, сохранение или удаление поставщика обновит временную метку у связанного счета. Также можно указать конкретный атрибут временной метки для обновления:
```
class Supplier < ApplicationRecord
  has_one :account, touch: :suppliers_updated_at
end
```

##### `:validate`

Если установите опцию `:validate` в `true`, тогда связанные объекты будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `false`: связанные объекты не проходят валидацию, когда этот объект сохраняется.

#### Скоупы для `has_one`
Иногда хочется настроить запрос, используемый `has_one`. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Supplier < ApplicationRecord
  has_one :account, -> { where active: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `includes`
* `readonly`
* `select`

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Supplier < ApplicationRecord
  has_one :account, -> { where "confirmed = 1" }
end
```

##### `includes`

Метод `includes` позволяет определить связи второго порядка, которые должны быть лениво загружены при использовании этой связи. Например, рассмотрим эти модели:
```
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end

class Representative < ApplicationRecord
  has_many :accounts
end
```
Если вы часто получаете `representatives` непосредственно из `suppliers` (`@supplier.account.representative`), то можно улучшить эффективность кода, включив `representatives` в связь между `suppliers` и `accounts`:
```
class Supplier < ApplicationRecord
  has_one :account, -> { includes :representative }
end

class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end

class Representative < ApplicationRecord
  has_many :accounts
end
```
##### `readonly`

При использовании `readonly`, связанный объект будет только для чтения при получении через связь

##### `select`

Метод `select` позволяет переопределить SQL выражение SELECT, используемое для получения данных о связанном объекте. По умолчанию Rails получает все столбцы.

#### Существуют ли связанные объекты?
Можно увидеть, существует ли какой-либо связанный объект, при использовании метода `association.nil?`:
```
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
```

#### Когда сохраняются объекты?

Когда вы назначаете объект связью `has_one`, этот объект автоматически сохраняется (для того, чтобы обновить его внешний ключ). Кроме того, любой заменяемый объект также автоматически сохраняется, поскольку его внешний ключ также изменяется.

Если одно из этих сохранений проваливается из-за ошибок валидации, тогда выражение назначения возвращает `false`, и само назначение отменяется.

Если родительский объект (который объявляет связь `has_one`) является несохраненным (то есть `new_record?` возвращает `true`), тогда дочерние объекты не сохраняются. Они сохранятся автоматически, когда сохранится родительский объект.

Если вы хотите назначить объект связью has_one без сохранения объекта, используйте метод `build_association`.

### Подробная информация по связи `has_many` <a name="2.5.6"></a>
Связь `has_many` создает отношение один-ко-многим с другой моделью. В терминах базы данных эта связь говорит, что другой класс будет иметь внешний ключ, относящийся к экземплярам этого класса.

#### Методы, добавляемые `has_many`
Когда объявляете связь `has_many`, объявляющий класс автоматически получает 17 методов, относящихся к связи:
* `collection`
* `collection<<(object, ...)`
* `collection.delete(object, ...)`
* `collection.destroy(object, ...)`
* `collection=(objects)`
* `collection_singular_ids`
* `collection_singular_ids=(ids)`
* `collection.clear`
* `collection.empty?`
* `collection.size`
* `collection.find(...)`
* `collection.where(...)`
* `collection.exists?(...)`
* `collection.build(attributes = {}, ...)`
* `collection.create(attributes = {})`
* `collection.create!(attributes = {})`
* `collection.reload` 
Во всех этих методах `collection` заменяется символом, переданным как первый аргумент в `has_many`, и `collection_singular` заменяется версией в единственном числе этого символа. Например, имеем объявление:
```
class Author < ApplicationRecord
  has_many :books
end
```
Каждый экземпляр модели `Author` будет иметь эти методы:
* `books`
* `books<<(object, ...)`
* `books.delete(object, ...)`
* `books.destroy(object, ...)`
* `books=(objects)`
* `book_ids`
* `book_ids=(ids)`
* `books.clear`
* `books.empty?`
* `books.size`
* `books.find(...)`
* `books.where(...)`
* `books.exists?(...)`
* `books.build(attributes = {}, ...)`
* `books.create(attributes = {})`
* `books.create!(attributes = {})`
* `books.reload`

##### `collection`

Метод `collection` возвращает Relation всех связанных объектов. Если нет связанных объектов, он возвращает пустой Relation.
```
@books = @author.books
```

##### `collection<<(object, ...)`

Метод `collection<<` добавляет один или более объектов в коллекцию, устанавливая их внешние ключи равными первичному ключу вызывающей модели.
```
@author.books << @book1
```
##### `collection.delete(object, ...)`

Метод `collection.delete` убирает один или более объектов из коллекции, установив их внешние ключи в NULL.
```
@author.books.delete(@book1)
```
> Объекты будут в дополнение уничтожены, если связаны с `dependent: :destroy`, и удалены, если они связаны с `dependent: :delete_all`.

##### `collection.destroy(object, ...)`

Метод `collection.destroy` убирает один или более объектов из коллекции, выполняя `destroy` для каждого объекта.
```
@author.books.destroy(@book1)
```
> Объекты будут всегда удаляться из базы данных, игнорируя опцию `:dependent`.

##### `collection=(objects)`

Метод `collection=` делает коллекцию содержащей только представленные объекты, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных

##### `collection_singular_ids`

Метод `collection_singular_ids` возвращает массив `id` объектов в коллекции.
```
@book_ids = @author.book_ids
```

##### `collection_singular_ids=(ids)`

Метод `collection_singular_ids=` делает коллекцию содержащей только объекты, идентифицированные представленными значениями первичного ключа, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных.

##### `collection.clear`

Метод `collection.clear` убирает каждый объект из коллекции в соответствии со стратегией, определенной опцией `dependent`. Если опция не указана, он следует стратегии по умолчанию. Стратегия по умолчанию для `has_many :through` это `delete_all`, а для связей `has_many` — установить их внешние ключи в NULL.
```
@author.books.clear
```
Объекты будут удалены, если они связаны с помощью `dependent: :destroy`, как и с помощью `dependent: :delete_all`.

##### `collection.empty?`

Метод `collection.empty?` возвращает `true`, если коллекция не содержит каких-либо связанных объектов.
```
<% if @author.books.empty? %>
  No Books Found
<% end %>
```

##### `collection.size`

Метод `collection.size` возвращает количество объектов в коллекции.
```
@book_count = @author.books.size
```

##### `collection.find(...)`

Метод `collection.find` ищет объекты в коллекции. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.find`.
```
@available_book = @author.books.find(1)
```

##### `collection.where(...)`

Метод `collection.where` ищет объекты в коллекции, основываясь на переданных условиях, но объекты загружаются лениво, что означает, что база данных запрашивается только когда происходит доступ к объекту(-там).
```
@available_books = @author.books.where(available: true) # Пока нет запроса
@available_book = @available_books.first # Теперь база данных будет запрошена
```

##### `collection.exists?(...)`

Метод `collection.exists?` проверяет, существует ли в коллекции объект, отвечающий представленным условиям. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.exists?`.

##### `collection.build(attributes = {}, ...)`

Метод `collection.build` возвращает один или массив объектов связанного типа. Объект(ы) будут экземплярами с переданными атрибутами, будет создана ссылка через их внешние ключи, но связанные объекты не будут пока сохранены.
```
@book = @author.books.build(published_at: Time.now,
                                book_number: "A12345")

@books = @author.books.build([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }])
```

##### `collection.create(attributes = {})`

Метод `collection.create` возвращает один или массив новых объектов связанного типа. Объект(ы) будут экземплярами с переданными атрибутами, будет создана ссылка через его внешний ключ, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен
```
@book = @author.books.create(published_at: Time.now,
                                 book_number: "A12345")

@books = @author.books.create([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }])
```

##### `collection.create!(attributes = {})`

Работает так же, как вышеприведенный `collection.create`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

##### `collection.reload`

Метод `collection.reload` возвращает Relation всех связанных объектов, принудительно читая базу данных. Если нет связанных объектов, он возвращает пустой Relation.
```
@books = @author.books.reload
```

#### Опции для `has_many`

Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `has_many`. Такая настройка легко выполнима с помощью передачи опций при создании связи. Например, эта связь использует две такие опции:
```
class Author < ApplicationRecord
  has_many :books, dependent: :delete_all, validate: false
end
```
Связь `has_many` поддерживает эти опции:
* `:as`
* `:autosave`
* `:class_name`
* `:counter_cache`
* `:dependent`
* `:foreign_key`
* `:inverse_of`
* `:primary_key`
* `:source`
* `:source_type`
* `:through`
* `:validate` 

##### `:as`

Установка опции `:as` показывает, что это полиморфная связь. 

##### `:autosave`

Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave` в `false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosav`e отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.

##### `:class_name`

Если имя другой модели не может быть произведено из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если автор имеет много книг, но фактическое имя модели, содержащей книги, это `Transaction`, можете установить это следующим образом:
```
class Author < ApplicationRecord
  has_many :books, class_name: "Transaction"
end
```

##### `:counter_cache`

Эта опция используется для настройки произвольно названного `:counter_cache`. Эту опцию нужно использовать, только если вы изменили имя вашего `:counter_cache` у связи `belongs_to`.

##### `:dependent`

Управляет тем, что произойдет со связанными объектами, когда его владелец будет уничтожен:
* `:destroy` приведет к тому, что связанные объекты также будут уничтожены
* `:delete_all` приведет к тому, что связанные объекты будут удалены из базы данных напрямую (таким образом не будут выполнены колбэки)
* `:nullify` приведет к тому, что внешние ключи будет установлен NULL. Столбцы полиморфного типа на полиморфных связях также обнуляются. Колбэки не выполняются.
* `:restrict_with_exception` приведет к вызову исключения `ActiveRecord::DeleteRestrictionError`, если есть какой-нибудь связанный объект
* `:restrict_with_error` приведет к ошибке, добавляемой к владельцу, если есть какой-нибудь связанный объект 

> Опции `:destroy` и `:delete_all` также влияют на семантику методов `collection.delete` и `collection=`, вынуждая их удалять связанные объекты при удалении из коллекции.

##### `:foreign_key`

По соглашению Rails предполагает, что столбец, используемый для хранения внешнего ключа в этой модели, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class Author < ActiveRecord::Base
  has_many :books, foreign_key: "cust_id"
end
```
##### `:inverse_of`

Опция `:inverse_of` определяет имя связи `belongs_to`, являющейся обратной для этой связи.
```
class Author < ApplicationRecord
  has_many :books, inverse_of: :author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books
end
```

##### `:primary_key`

По соглашению, Rails предполагает, что столбец, используемый для хранения первичного ключа, это `id`. Вы можете переопределить это и явно определить первичный ключ с помощью опции `:primary_key`.

Допустим, в таблице `users` есть `id` в качестве `primary_key`, но также имеется столбец `guid`. Имеется требование, что таблица `todos` должна содержать значение столбца `guid`, а не значение `id`. Это достигается следующим образом:
```
class User < ApplicationRecord
  has_many :todos, primary_key: :guid
end
```
Теперь, если выполнить `@todo = @user.todos.create`, то в запись `@todo` значение `user_id` будет таким же, как значение `guid` в `@user`.

##### `:source`

Опция `:source` определяет имя источника связи для связи `has_many :through`. Эту опцию нужно использовать, только если имя источника связи не может быть автоматически выведено из имени связи.
```
class Author < ApplicationRecord
  has_many :books
  has_many :paperbacks, through: :books, source: :format, source_type: "Paperback"
end

class Book < ApplicationRecord
  has_one :format, polymorphic: true
end

class Hardback < ApplicationRecord; end
class Paperback < ApplicationRecord; end
```

##### `:source_type`

Опция `:source_type` определяет тип источника связи для связи `has_many :through`, который действует при полиморфной связи

##### `:through`

Опция `:through` определяет соединительную модель, через которую выполняется запрос. Связи `has_many :through` предоставляют способ осуществления отношений многие-ко-многим

##### `:validate`

Если установите опцию `:validate` в `false`, тогда связанные объекты не будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `true`: связанные объекты проходят валидацию, когда этот объект сохраняется.

#### Скоупы для `has_many`

Иногда хочется настроить запрос, используемый has_many. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Author < ApplicationRecord
  has_many :books, -> { where processed: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `extending`
* `group`
* `includes`
* `limit`
* `offset`
* `order`
* `readonly`
* `select`
* `distinct` 

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Author < ApplicationRecord
  has_many :confirmed_books, -> { where "confirmed = 1" },
    class_name: "Book"
end

Также можно задать условия хэшем:

class Author < ApplicationRecord
  has_many :confirmed_books, -> { where confirmed: true },
                              class_name: "Book"
end
```
> При использовании опции `where` хэшем, при создании записи через эту связь будет автоматически применен скоуп с использованием хэша. В этом случае при использовании` @author.confirmed_books.create` или `@author.confirmed_books.build` будут созданы книги, в которых столбец `confirmed` будет иметь значение `true`.

##### `extending`

Метод `extending` определяет именованный модуль для расширения прокси связи.

##### `group`

Метод `group` предоставляет имя атрибута, по которому группируется результирующий набор, используя выражение GROUP BY в поисковом SQL.
```
class Author < ApplicationRecord
  has_many :chapters, -> { group 'books.id' },
                      through: :books
end
```

##### `includes`

Можете использовать метод `includes` для определения связей второго порядка, которые должны быть нетерпеливо загружены, когда эта связь используется. Например, рассмотрим эти модели:
```
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Chapter < ApplicationRecord
  belongs_to :book
end
```
Если вы часто получаете главы прямо из авторов (`@author.books.chapters`), тогда можете сделать свой код более эффективным, включив главы в связь от авторов к книгам:
```
class Author < ApplicationRecord
  has_many :books, -> { includes :chapters }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Chapter < ApplicationRecord
  belongs_to :book
end
```
##### `limit`

Метод `limit` позволяет ограничить общее количество объектов, которые будут выбраны через связь.
```
class Author < ApplicationRecord
  has_many :recent_books,
    -> { order('published_at desc').limit(100) },
    class_name: "Book"
end
```

##### `offset`

Метод `offset` позволяет определить начальное смещение для выбора объектов через связь. Например, -> { offset(11) } пропустит первые 11 записей.

##### `order`

Метод `order` предписывает порядок, в котором связанные объекты будут получены (в синтаксисе SQL, используемом в условии ORDER BY).
```
class Author < ApplicationRecord
  has_many :books, -> { order "date_confirmed DESC" }
end
```

##### `readonly`

При использовании метода `readonly`, связанные объекты будут доступны только для чтения, когда получены посредством связи.

##### `select`

Метод `select` позволяет переопределить SQL условие SELECT, которое используется для получения данных о связанном объекте. По умолчанию Rails получает все столбцы.

> Если укажете свой собственный select, не забудьте включить столбцы первичного ключа и внешнего ключа в связанной модели. Если так не сделать, Rails выдаст ошибку.

##### `distinct`

Используйте метод `distinct`, чтобы убирать дубликаты из коллекции. Это полезно в сочетании с опцией `:through`.
```
class Person < ApplicationRecord
  has_many :readings
  has_many :articles, through: :readings
end

article   = Article.create(name: 'a1')
person.articles << article
person.articles << article
person.articles.inspect # => [#<Article id: 5, name: "a1">, #<Article id: 5, name: "a1">]
Reading.all.inspect     # => [#<Reading id: 12, person_id: 5, article_id: 5>, #<Reading id: 13, person_id: 5, article_id: 5>]
```
В вышеописанной задаче два `reading`, и `person.articles` выявляет их оба, даже если эти записи указывают на одну и ту же статью.

Давайте установим `distinct`:
```
class Person
  has_many :readings
  has_many :articles, -> { distinct }, through: :readings
end

person = Person.create(name: 'Honda')
article   = Article.create(name: 'a1')
person.articles << article
person.articles << article
person.articles.inspect # => [#<Article id: 7, name: "a1">]
Reading.all.inspect     # => [#<Reading id: 16, person_id: 7, article_id: 7>, #<Reading id: 17, person_id: 7, article_id: 7>]
```
В вышеописанной задаче все еще два `reading`. Однако `person.articles` показывает только одну статью, поскольку коллекция загружает только уникальные записи.

Если вы хотите быть уверенными, что **после вставки все записи персистентной связи различны** (и, таким образом, убедиться, что при просмотре связи никогда не будет дублирующихся записей), следует добавить уникальный индекс для самой таблицы. Например, если таблица называется `readings`, и вы хотите убедиться, что все публикации могут быть добавлены к персоне один раз, следует добавить в миграцию:
```
add_index :readings, [:person_id, :article_id], unique: true
```
Как только у вас появится этот индекс уникальности, попытка добавить статью к персоне дважды вызовет ошибку `ActiveRecord::RecordNotUnique`:
```
person = Person.create(name: 'Honda')
article = Article.create(name: 'a1')
person.articles << article
person.articles << article # => ActiveRecord::RecordNotUnique
```
Отметьте, что проверка уникальности при использовании чего-то, наподобие `include?`, подвержено состояниям гонки. Не пытайтесь использовать `include?` для соблюдения уникальности в связи. Используя вышеприведенный пример со статьёй, нижеследующий код вызовет гонку, поскольку несколько пользователей могут использовать его одновременно:
```
person.articles << article unless person.articles.include?(post)
```
#### Когда сохраняются объекты? 
Когда вы назначаете объект связью `has_many`, этот объект автоматически сохраняется (для того, чтобы обновить его внешний ключ). Если назначаете несколько объектов в одном выражении, они все будут сохранены.

Если одно из этих сохранений проваливается из-за ошибок валидации, тогда выражение назначения возвращает `false`, и само назначение отменяется.

Если родительский объект (который объявляет связь `has_many`) является несохраненным (то есть `new_record?` возвращает `true`), тогда дочерние объекты не сохраняются при добавлении. Все несохраненные члены связи сохранятся автоматически, когда сохранится родительский объект.

Если вы хотите назначить объект связью `has_many` без сохранения объекта, используйте метод `collection.build`.

### Подробная информация по связи `has_and_belongs_to_many` <a name="2.5.7"></a>
Связь `has_and_belongs_to_many` создает отношение многие-ко-многим с другой моделью. В терминах базы данных это связывает два класса через промежуточную соединительную таблицу, которая включает внешние ключи, относящиеся к каждому классу.

#### Методы, добавляемые `has_and_belongs_to_many`

Когда объявляете связь `has_and_belongs_to_many`, объявляющий класс автоматически получает 17 методов, относящихся к связи:
* `collection`
* `collection<<(object, ...)`
* `collection.delete(object, ...)`
* `collection.destroy(object, ...)`
* `collection=(objects)`
* `collection_singular_ids`
* `collection_singular_ids=(ids)`
* `collection.clear`
* `collection.empty?`
* `collection.size`
* `collection.find(...)`
* `collection.where(...)`
* `collection.exists?(...)`
* `collection.build(attributes = {})`
* `collection.create(attributes = {})`
* `collection.create!(attributes = {})`
* `collection.reload `
Во всех этих методах collection заменяется символом, переданным как первый аргумент в has_and_belongs_to_many, а collection_singular заменяется версией в единственном числе этого символа.

##### Дополнительные методы столбцов

Если соединительная таблица для связи `has_and_belongs_to_many` имеет дополнительные столбцы, кроме двух внешних ключей, эти столбцы будут добавлены как атрибуты к записям, получаемым посредством связи. Записи, возвращаемые с дополнительными атрибутами, будут всегда только для чтения, поскольку Rails не может сохранить значения этих атрибутов.

> Использование дополнительных атрибутов в соединительной таблице в связи `has_and_belongs_to_many` **устарело**. Если требуется этот тип сложного поведения таблицы, соединяющей две модели в отношениях многие-ко-многим, следует использовать связь `has_many :through` вместо `has_and_belongs_to_many`.

##### `collection`

Метод `collection` возвращает Relation всех связанных объектов. Если нет связанных объектов, он возвращает пустой Relation.
```
@assemblies = @part.assemblies
```

##### `collection<<(object, ...)`

Метод `collection<<` добавляет один или более объектов в коллекцию, создавая записи в соединительной таблице.
```
@part.assemblies << @assembly1
```
> Этот метод - просто псевдоним к `collection.concat` и `collection.push`.

##### `collection.delete(object, ...)`

Метод `collection.delete` убирает один или более объектов из коллекции, удаляя записи в соединительной таблице. Это не уничтожает объекты.
```
@part.assemblies.delete(@assembly1)
```

##### `collection.destroy(object, ...)`

Метод `collection.destroy` убирает один или более объектов из коллекции, удаляя записи в соединительной таблице. Это не уничтожает объекты.
```
@part.assemblies.destroy(@assembly1)
```

##### `collection=(objects)`

Метод `collection=` делает коллекцию содержащей только представленные объекты, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных.

##### `collection_singular_ids`

Метод `collection_singular_ids` возвращает массив `id` объектов в коллекции.
```
@assembly_ids = @part.assembly_ids
```

##### `collection_singular_ids=(ids)`

Метод `collection_singular_ids=` делает коллекцию содержащей только объекты, идентифицированные представленными значениями первичного ключа, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных.

##### `collection.clear`

Метод `collection.clear` убирает каждый объект из коллекции, удаляя строки из соединительной таблицы. Это не уничтожает связанные объекты.

##### `collection.empty?`

Метод `collection.empty?` возвращает `true`, если коллекция не содержит каких-либо связанных объектов.
```
<% if @part.assemblies.empty? %>
  This part is not used in any assemblies
<% end %>
```

##### `collection.size`

Метод `collection.size` возвращает количество объектов в коллекции.
```
@assembly_count = @part.assemblies.size
```

##### `collection.find(...)`

Метод `collection.find` ищет объекты в коллекции. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.find`. А также добавляет дополнительное условие, что объект должен быть в коллекции.
```
@assembly = @part.assemblies.find(1)
```

##### `collection.where(...)`

Метод `collection.where` ищет объекты в коллекции, основываясь на переданных условиях, но объекты загружаются лениво, что означает, что база данных запрашивается только когда происходит доступ к объекту(-там).
```
@new_assemblies = @part.assemblies.where("created_at > ?", 2.days.ago)
```

##### `collection.exists?(...)`

Метод `collection.exists?` проверяет, существует ли в коллекции объект, отвечающий представленным условиям. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.exists?`.

##### `collection.build(attributes = {})`

Метод `collection.build` возвращает один или более объектов связанного типа. Эти объекты будут экземплярами с переданными атрибутами, и будет создана связь через соединительную таблицу, но связанный объект пока не будет сохранен.
```
@assembly = @part.assemblies.build({assembly_name: "Transmission housing"})
```

##### `collection.create(attributes = {})`

Метод `collection.create` возвращает один или более объектов связанного типа. Эти объекты будут экземплярами с переданными атрибутами, будет создана связь через соединительную таблицу, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен.
```
@assembly = @part.assemblies.create({assembly_name: "Transmission housing"})
```

##### `collection.create!(attributes = {})`

Работает так же, как вышеприведенный `collection.create`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

##### `collection.reload`

Метод `collection.reload` возвращает Relation всех связанных объектов, принудительно читая базу данных. Если нет связанных объектов, он возвращает пустой Relation.
```
@assemblies = @part.assemblies.reload
```

#### Опции для `has_and_belongs_to_many`

Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `has_and_belongs_to_many`. Такая настройка легко выполнима с помощью передачи опции при создании связи. Например, эта связь использует две такие опции:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { readonly },
                                       autosave: true
end
```
Связь `has_and_belongs_to_many` поддерживает эти опции:
* `:association_foreign_key`
* `:autosave`
* `:class_name`
* `:foreign_key`
* `:join_table`
* `:validate`

##### `:association_foreign_key`

По соглашению Rails предполагает, что столбец в соединительной таблице, используемый для хранения внешнего ключа, указываемого на другую модель, является именем этой модели с добавленным суффиксом `_id`. Опция `:association_foreign_key` позволяет установить имя внешнего ключа явно:

> Опции `:foreign_key` и `:association_foreign_key` полезны при настройке присоединения к себе многие-ко-многим. Например:

```
class User < ApplicationRecord
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id", # типа твой айди
      association_foreign_key: "other_user_id" # типа айди друга
end
```

##### `:autosave`

Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave` в `false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosave` отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.

##### `:class_name`

Если имя другой модели не может быть произведено из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если часть имеет много сборок, но фактическое имя модели, содержащей сборки - это `Gadget`, можете установить это следующим образом:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, class_name: "Gadget"
end
```

##### `:foreign_key`

По соглашению Rails предполагает, что столбец в соединительной таблице, используемый для хранения внешнего ключа, указываемого на эту модель, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class User < ApplicationRecord
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
end
```

##### `:join_table`

Если имя соединительной таблицы по умолчанию, основанное на алфавитном порядке, - это не то, что вам нужно, используйте опцию `:join_table`, чтобы переопределить его.

##### `:validate`

Если установите опцию `:validate` в `false`, тогда связанные объекты не будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `true:` связанные объекты проходят валидацию, когда этот объект сохраняется.

#### Скоупы для `has_and_belongs_to_many`

Иногда хочется настроить запрос, используемый `has_many`. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { where active: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `extending`
* `group`
* `includes`
* `limit`
* `offset`
* `order`
* `readonly`
* `select`
* `distinct`

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { where "factory = 'Seattle'" }
end
```
Также можно задать условия хэшем:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { where factory: 'Seattle' }
end
```
При использовании опции `where` хэшем, при создание записи через эту связь будет автоматически применен скоуп с использованием хэша. В этом случае при использовании `@parts.assemblies.create` или `@parts.assemblies.build` будут созданы заказы, в которых столбец `factory` будет иметь значение `Seattle`.

##### `extending`

Метод `extending` определяет именованный модуль для расширения прокси связи. 

##### `group`

Метод `group` предоставляет имя атрибута, по которому группируется результирующий набор, используя выражение GROUP BY в поисковом запросе SQL.
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { group "factory" }
end
```

##### `includes`

Можете использовать метод `includes` для определения связей второго порядка, которые должны быть нетерпеливо загружены, когда эта связь используется.

##### `limit`

Метод `limit` позволяет ограничить общее количество объектов, которые будут выбраны через связь.
```
class Customer < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { order("created_at DESC").limit(50) }
end
```

##### `offset`

Метод `offset` позволяет определить начальное смещение для выбора объектов через связь. Например, `-> { offset(11) }` пропустит первые 11 записей.

##### `order`

Метод `order` предписывает порядок, в котором связанные объекты будут получены (в синтаксисе SQL, используемом в условии ORDER BY).
```
class Customer < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { order "assembly_name ASC" }
end
```

##### `readonly`

При использовании метода `:readonly`, связанные объекты будут доступны только для чтения, когда получены посредством связи

##### `select`

Метод `select` позволяет переопределить SQL условие SELECT, которое используется для получения данных о связанном объекте. По умолчанию Rails получает все столбцы.

##### `distinct`

Используйте метод `distinct`, чтобы убирать дубликаты из коллекции.

#### Когда сохраняются объекты?

Когда вы назначаете объект связью `has_and_belongs_to_many`, этот объект автоматически сохраняется (в порядке обновления соединительной таблицы). Если назначаете несколько объектов в одном выражении, они все будут сохранены.

Если одно из этих сохранений проваливается из-за ошибок валидации, тогда выражение назначения возвращает `false`, a само назначение отменяется.

Если родительский объект (который объявляет связь has_and_belongs_to_many) является несохраненным (то есть `new_record?` возвращает `true`), тогда дочерние объекты не сохраняются при добавлении. Все несохраненные члены связи сохранятся автоматически, когда сохранится родительский объект.

Если вы хотите назначить объект связью `has_and_belongs_to_many` без сохранения объекта, используйте метод `collection.build`.

### Подробная информация по колбэкам и расширениям связи <a name="2.5.8"></a>
Обычно колбэки прицепляются к жизненному циклу объектов Active Record, позволяя вам работать с этими объектами в различных точках. Например, можете использовать колбэк `:before_save`, чтобы вызвать что-то перед тем, как объект будет сохранен.

Колбэки связи похожи на обычные колбэки, но они включаются событиями в жизненном цикле коллекции. Доступны четыре колбэка связи:
* `before_add`
* `after_add`
* `before_remove`
* `after_remove`

Колбэки связи объявляются с помощью добавления опций в объявление связи. Например:
```
class Author < ApplicationRecord
  has_many :books, before_add: :check_credit_limit

  def check_credit_limit(book)
    ...
  end
end
```
Rails передает добавляемый или удаляемый объект в колбэк.

Можете помещать колбэки в очередь на отдельное событие, передав их как массив:
```
class Author < ApplicationRecord
  has_many :books,
    before_add: [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(book)
    ...
  end

  def calculate_shipping_charges(book)
    ...
  end
end
```
Если колбэк `before_add` вызывает исключение, объект не будет добавлен в коллекцию. Подобным образом, если колбэк `before_remove` вызывает исключение, объект не убирается из коллекции.

Эти колбэки вызываются только когда связанные объекты добавляются или убираются через коллекцию связи:
```
# Вызывает колбэк `before_add`
author.books << book
author.books = [book, book2]

# Не вызывает колбэк `before_add`
book.update(author_id: 1)
```

#### Расширения связи
Вы не ограничены функциональностью, которую Rails автоматически встраивает в выданные по связи объекты. Можно расширить эти объекты с помощью анонимных модулей, добавив новые методы поиска, методы создания и иные методы. Например:
```
class Author < ApplicationRecord
  has_many :books do
    def find_by_book_prefix(book_number)
      find_by(category_id: book_number[0..2])
    end
  end
end
```
Если имеется расширение, которое должно быть общим для нескольких связей, можно использовать именованный модуль расширения. Например:
```
module FindRecentExtension
  def find_recent
    where("created_at > ?", 5.days.ago)
  end
end

class Author < ApplicationRecord
  has_many :books, -> { extending FindRecentExtension }
end

class Supplier < ApplicationRecord
  has_many :deliveries, -> { extending FindRecentExtension }
end
```
Расширения могут ссылаться на внутренние методы выданных по связи объектов, используя следующие три атрибута акцессора `proxy_association`:
* `proxy_association.owner` возвращает объект, в котором объявлена связь.
* `proxy_association.reflection` возвращает объект reflection, описывающий связь.
* `proxy_association.target` возвращает связанный объект для `belongs_to` или `has_one`, или коллекцию связанных объектов для `has_many` или `has_and_belongs_to_many`.

### Наследование с единой таблицей (STI) <a name="2.5.9"></a>
Иногда можно делиться полями и поведением между различными моделями. Скажем, у нас есть модели `Car`, `Motorcycle` и `Bicycle`. Мы хотим совместно использовать поля `color` и `price` и некоторые методы всеми из них, но иметь некоторое специфичное поведение для каждого, а также различные контроллеры.

Rails позволяет сделать это достаточно просто. Сначала нужно сгенерировать базовую модель `Vehicle`:
```
$ rails generate model vehicle type:string color:string price:decimal{10.2}
```
Вы заметили, что мы добавили поле "type"? Так как все модели будут сохранены в одну таблицу базы данных, Rails сохранит в этот столбец имя модели, которая сохраняется. В нашем примере это может быть "Car", "Motorcycle" или "Bicycle." STI не работает без поля "type" в таблице.

Затем мы сгенерируем три модели, унаследованные от `Vehicle`. Для этого можно использовать опцию `--parent=PARENT`, которая сгенерирует модель, унаследованную от указанного родителя и без эквивалентной миграции (так как таблица уже существует).

Например, чтобы сгенерировать модель `Car`:
```
$ rails generate model car --parent=Vehicle
```
Сгенерированная модель будет выглядеть так:
```
class Car < Vehicle
end
```
Это означает, что все поведение, такое как связи, публичные методы и так далее, добавленное в `Vehicle`, доступно также для `Car`.

Создание автомобиля сохранит его в таблице `vehicles` со значением "Car" в поле `type`:
```
Car.create(color: 'Red', price: 10000)
```
сгенерирует следующий SQL:
```
INSERT INTO "vehicles" ("type", "color", "price") VALUES ('Car', 'Red', 10000)
```
Запрос записей автомобилей будет просто искать среди транспортных средств, которые являются автомобилями:
```
Car.all
```
запустит подобный запрос:
```
SELECT "vehicles".* FROM "vehicles" WHERE "vehicles"."type" IN ('Car')
```

## Интерфейс запрососв <a name="2.6"></a>
Если вы использовали чистый SQL для поиска записей в базе данных, то скорее всего обнаружите, что в Rails есть лучшие способы выполнения тех же операций. Active Record ограждает вас от необходимости использования SQL во многих случаях.

Примеры кода далее в этом руководстве будут относиться к некоторым из этих моделей:

Все модели используют `id` как первичный ключ, если не указано иное.
```
class Client < ApplicationRecord
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end

class Address < ApplicationRecord
  belongs_to :client
end

class Order < ApplicationRecord
  belongs_to :client, counter_cache: true
end

class Role < ApplicationRecord
  has_and_belongs_to_many :clients
end
```
Active Record выполнит запросы в базу данных за вас, он совместим с большинством СУБД, включая MySQL, MariaDB, PostgreSQL и SQLite. Независимо от того, какая используется СУБД, формат методов Active Record будет всегда одинаковый.

### Получение объектов из базы данных <a name="2.6.1"></a>
Для получения объектов из базы данных Active Record предоставляет несколько методов поиска. В каждый метод поиска можно передавать аргументы для выполнения определенных запросов в базу данных без необходимости писать на чистом SQL.

Методы следующие:
* `find`
* `create_with`
* `distinct`
* `eager_load`
* `extending`
* `from`
* `group`
* `having`
* `includes`
* `joins`
* `left_outer_joins`
* `limit`
* `lock`
* `none`
* `offset`
* `order`
* `preload`
* `readonly`
* `references`
* `reorder`
* `reverse_order`
* `select`
* `where `

Методы поиска, возвращающие коллекцию, такие как where и group, возвращают экземпляр `ActiveRecord::Relation`. Методы, ищущие отдельную сущность, такие как `find` и `first`, возвращают отдельный экземпляр модели.

Вкратце основные операции `Model.find(options)` таковы:
* Преобразовать предоставленные опции в эквивалентный запрос SQL.
* Выполнить запрос SQL и получить соответствующие результаты из базы данных.
* Создать экземпляр эквивалентного объекта Ruby подходящей модели для каждой строки результата запроса.
* Запустить колбэки `after_find` и далее `after_initialize`, если таковые имеются. 

#### Получение одиночного объекта
##### `find`
Используя метод `find`, можно получить объект, соответствующий определенному первичному ключу (`primary key`) и предоставленным опциям. Например:
```
# Ищет клиента с первичным ключом (id) 10.
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
```
Метод `find` вызывает исключение `ActiveRecord::RecordNotFound`, если соответствующей записи не было найдено.

Этот метод также можно использовать для получения нескольких объектов. Вызовите метод find и передайте в него массив первичных ключей. Возвращенным результатом будет массив, содержащий все записи, соответствующие представленным первичным ключам. Например:
```
# Найдем клиентов с первичными ключами 1 и 10.
clients = Client.find([1, 10]) # Или даже Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients WHERE (clients.id IN (1,10))
```
##### `take`
Метод `take` получает запись без какого-либо явного упорядочивания. Например:
```
client = Client.take
# => #<Client id: 1, first_name: "Lifo">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients LIMIT 1
```
Метод `take` возвращает `nil`, если ни одной записи не найдено, и исключение не будет вызвано.

В метод take можно передать числовой аргумент, чтобы вернуть это количество результатов. Например
```
clients = Client.take(2)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 220, first_name: "Sara">
# ]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients LIMIT 2
```
Метод `take!` ведет себя подобно `take`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи.

> Получаемая запись может отличаться в зависимости от подсистемы хранения СУБД.

##### `first`

Метод `first` находит первую запись, упорядоченную по первичному ключу (по умолчанию). Например:
```
client = Client.first
# => #<Client id: 1, first_name: "Lifo">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
```
Метод `first` возвращает `nil`, если не найдено соответствующей записи, и исключение не вызывается.

Если скоуп по умолчанию содержит метод `order`, `first` возвратит первую запись в соответствии с этим упорядочиванием.

В метод `first` можно передать числовой аргумент, чтобы вернуть это количество результатов. Например
```
clients = Client.first(3)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 2, first_name: "Fifo">,
#   #<Client id: 3, first_name: "Filo">
# ]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3
```
На коллекции, упорядоченной с помощью `order`, `first` вернет первую запись, упорядоченную по указанному в order атрибуту.
```
client = Client.order(:first_name).first
# => #<Client id: 2, first_name: "Fifo">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.first_name ASC LIMIT 1
```
Метод `first!` ведет себя подобно `first`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи.

##### `last`

Метод `last` находит последнюю запись, упорядоченную по первичному ключу (по умолчанию). Например:
```
client = Client.last
# => #<Client id: 221, first_name: "Russel">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
```
Метод `last` возвращает `nil`, если не найдено соответствующей записи, и исключение не вызывается.

Если скоуп по умолчанию содержит метод `order`, `last` возвратит последнюю запись в соответствии с этим упорядочиванием.

В метод `last` можно передать числовой аргумент, чтобы вернуть это количество результатов. Например
```
clients = Client.last(3)
# => [
#   #<Client id: 219, first_name: "James">,
#   #<Client id: 220, first_name: "Sara">,
#   #<Client id: 221, first_name: "Russel">
# ]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3
```
На коллекции, упорядоченной с помощью `order`, `last` вернет последнюю запись, упорядоченную по указанному в `order` атрибуту.
```
client = Client.order(:first_name).last
# => #<Client id: 220, first_name: "Sara">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.first_name DESC LIMIT 1
```
Метод `last!` ведет себя подобно `last`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи.

##### `find_by`

Метод `find_by` ищет первую запись, соответствующую некоторым условиям. Например:
```
Client.find_by first_name: 'Lifo'
# => #<Client id: 1, first_name: "Lifo">

Client.find_by first_name: 'Jon'
# => nil
```
Это эквивалент записи:
```
Client.where(first_name: 'Lifo').take
```
SQL эквивалент выражения выше, следующий:
```
SELECT * FROM clients WHERE (clients.first_name = 'Lifo') LIMIT 1
```
Метод `find_by!` ведет себя подобно `find_by`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи. Например:
```
Client.find_by! first_name: 'does not exist'
# => ActiveRecord::RecordNotFound
```
Это эквивалент записи:
```
Client.where(first_name: 'does not exist').take!
```

#### Получение нескольких объектов пакетами

Часто необходимо перебрать огромный набор записей, например, когда рассылаем письма всем пользователям или импортируем некоторые данные.

Это может показаться простым:
```
# Это может потребить слишком много памяти, если таблица большая.
User.all.each do |user|
  NewsMailer.weekly(user).deliver_now
end
```
Но этот подход становится очень непрактичным с увеличением размера таблицы, поскольку `User.all.each` говорит Active Record извлечь таблицу полностью за один проход, создать объект модели для каждой строки и держать этот массив в памяти. В реальности, если имеется огромное количество записей, полная коллекция может превысить количество доступной памяти.

Rails предоставляет два метода, которые решают эту проблему путем разделения записей на дружелюбные к памяти пакеты для обработки. Первый метод, `find_each`, получает пакет записей и затем вкладывает каждую запись в блок отдельно как модель. Второй метод, `find_in_batches`, получает пакет записей и затем вкладывает весь пакет в блок как массив моделей.

> Методы `find_each` и `find_in_batches` предназначены для пакетной обработки большого числа записей, которые не поместятся в памяти за раз. Если нужно просто перебрать тысячу записей, более предпочтителен вариант обычных методов поиска.

##### `find_each`

Метод `find_each` получает пакет записей и затем передает каждую запись в блок. В следующем примере `find_each` получает пользователей пакетами по 1000 записей, а затем передает их в блок один за другим:
```
User.find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
```
Этот процесс повторяется, извлекая больше пакетов при необходимости, пока не будут обработаны все записи.

`find_each` работает на классах модели, как показано выше, а также на relation:
```
User.where(weekly_subscriber: true).find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
```
только у них нет упорядочивания, так как методу необходимо собственное упорядочивание для работы.

Если у получателя есть упорядочивание, то поведение зависит от флажка `config.active_record.error_on_ignored_order`. Если `true`, вызывается `ArgumentError`, в противном случае упорядочивание игнорируется, что является поведением по умолчанию. Это можно переопределить с помощью опции `:error_on_ignore`, описанной ниже.

#### Опции для `find_each`

##### `:batch_size`

Опция `:batch_size` позволяет определить число записей, подлежащих получению в одном пакете, до передачи отдельной записи в блок. Например, для получения 5000 записей в пакете:
```
User.find_each(batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end
```
##### `:start`

По умолчанию записи извлекаются в порядке увеличения первичного ключа, который должен быть числом. Опция `:start` позволяет вам настроить первый ID последовательности, когда наименьший ID не тот, что вам нужен. Это может быть полезно, например, если хотите возобновить прерванный процесс пакетирования, предоставив последний обработанный ID как контрольную точку.

Например, чтобы выслать письма только пользователям с первичным ключом, начинающимся от 2000:
```
User.find_each(start: 2000) do |user|
  NewsMailer.weekly(user).deliver_now
end
```
##### `:finish`

Подобно опции `:start`, `:finish` позволяет указать последний ID последовательности, когда наибольший ID не тот, что вам нужен. Это может быть полезно, например, если хотите запустить процесс пакетирования, используя подмножество записей на основании `:start` и `:finish`

Например, чтобы выслать письма только пользователям с первичным ключом от 2000 до 10000:
```
User.find_each(start: 2000, finish: 10000) do |user|
  NewsMailer.weekly(user).deliver_now
end
```
Другим примером является наличие нескольких воркеров, работающих с одной и той же очередью обработки. Можно было бы обрабатывать каждым воркером 10000 записей, установив подходящие опции `:start` и `:finish` в каждом воркере.

##### `:error_on_ignore`

Переопределяет настройку приложения, указывающую, должна ли быть вызвана ошибка, если в relation присутствует упорядочивание.


#### `find_in_batches`

Метод `find_in_batches` похож на `find_each` тем, что они оба получают пакеты записей. Различие в том, что `find_in_batches` передает в блок пакеты как массив моделей, вместо отдельной модели. Следующий пример передаст в представленный блок массив из 1000 счетов за раз, а в последний блок содержащий все оставшиеся счета:
```
# Передает в add_invoices массив из 1000 счетов за раз.
Invoice.find_in_batches do |invoices|
  export.add_invoices(invoices)
end
```
`find_in_batches` работает на классах модели, как показано выше, а также на relation:
```
Invoice.pending.find_in_batches do |invoices|
  pending_invoices_export.add_invoices(invoices)
end
```
только у них нет упорядочивания, так как методу необходимо собственное упорядочивание для работы.

#### Опции для `find_in_batches`

Метод `find_in_batches` принимает те же опции, что и `find_each`.

### `Условия`<a name="2.6.2"></a>

Метод `where` позволяет определить условия для ограничения возвращаемых записей, которые представляют `WHERE`-часть выражения SQL. Условия могут быть заданы как строка, массив или хэш.

#### Чисто строковые условия

Если вы хотите добавить условия в свой поиск, можете просто определить их там, подобно `Client.where("orders_count = '2'")`. Это найдет всех клиентов, где значение поля `orders_count` равно 2.

> Создание условий в чистой строке подвергает вас риску SQL-инъекций. Например, `Client.where("first_name LIKE '%#{params[:first_name]}%'")` не безопасно.

#### Условия с использованием массива

Что если количество может изменяться, скажем, как аргумент откуда-то извне, возможно даже от пользователя? Поиск тогда принимает такую форму:
```
Client.where("orders_count = ?", params[:orders])
```
Active Record примет первый аргумент в качестве строки условия, а все остальные элементы подставит вместо знаков вопроса `(?)` в ней.

Если хотите определить несколько условий:
```
Client.where("orders_count = ? AND locked = ?", params[:orders], false)
```
В этом примере первый знак вопроса будет заменен на значение в `params[:orders]` и второй будет заменен SQL аналогом `false`, который зависит от адаптера.

Этот код значительно предпочтительнее:
```
Client.where("orders_count = ?", params[:orders])
```
чем такой код:
```
Client.where("orders_count = #{params[:orders]}")
```
по причине безопасности аргумента. Помещение переменной прямо в строку условий передает переменную в базу данных как есть. Это означает, что неэкранированная переменная, переданная пользователем, может иметь злой умысел. Если так сделать, вы подвергаете базу данных риску, так как если пользователь обнаружит, что он может использовать вашу базу данных, то он сможет сделать с ней что угодно. Никогда не помещайте аргументы прямо в строку условий!

##### Местозаполнители в условиях

Подобно тому, как `(?)` заменяют параметры, можно использовать ключи в условиях совместно с соответствующим хэшем ключей/значений:
```
Client.where("created_at >= :start_date AND created_at <= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
```
Читаемость улучшится, в случае если вы используете большое количество переменных в условиях.

#### Условия с использованием хэша

Active Record также позволяет передавать условия в хэше, что улучшает читаемость синтаксиса условий. В этом случае передается хэш с ключами, соответствующими полям, которые хотите уточнить, и с значениями, которые вы хотите к ним применить:

> Хэшем можно передать условия проверки только равенства, интервала и подмножества.


#### Условия с использованием хэша

Active Record также позволяет передавать условия в хэше, что улучшает читаемость синтаксиса условий. В этом случае передается хэш с ключами, соответствующими полям, которые хотите уточнить, и с значениями, которые вы хотите к ним применить:

Хэшем можно передать условия проверки только равенства, интервала и подмножества.

##### Условия равенства
```
Client.where(locked: true)
```
Это сгенерирует такой SQL:
```
SELECT * FROM clients WHERE (clients.locked = 1)
```
Имя поля также может быть строкой, а не символом:
```
Client.where('locked' => true)
```
В случае отношений `belongs_to`, может быть использован ключ связи для указания модели, если как значение используется объект Active Record. Этот метод также работает с полиморфными отношениями.
```
Article.where(author: author)
Author.joins(:articles).where(articles: { author: author })
```
##### Интервальные условия
```
Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
```
Это найдет всех клиентов, созданных вчера, с использованием SQL выражения `BETWEEN`:
```
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
```
Это была демонстрация более короткого синтаксиса для примеров в Условия с использованием массива

##### Условия подмножества

Если хотите найти записи, используя выражение `IN`, можете передать массив в хэш условий:
```
Client.where(orders_count: [1,3,5])
```
Этот код сгенерирует подобный SQL:
```
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
```

#### Условия `NOT`

Запросы `NOT` в SQL могут быть созданы с помощью `where.not`:
```
Client.where.not(locked: true)
```
Другими словами, этот запрос может быть сгенерирован с помощью вызова where без аргументов и далее присоединенным `not` с переданными условиями для `where`. Это сгенерирует такой SQL:
```
SELECT * FROM clients WHERE (clients.locked != 1)
```

#### Условия `OR`

Условия `OR` между двумя отношениями могут быть построены путем вызова or на первом отношении и передачи второго в качестве аргумента.
```
Client.where(locked: true).or(Client.where(orders_count: [1,3,5]))
```
```
SELECT * FROM clients WHERE (clients.locked = 1 OR clients.orders_count IN (1,3,5))
```

### `Сортировка` <a name="2.6.3"></a>

Чтобы получить записи из базы данных в определенном порядке, можете использовать метод `order`.

Например, если вы получаете ряд записей и хотите упорядочить их в порядке возрастания поля `created_at` в таблице:
```
Client.order(:created_at)
# ИЛИ
Client.order("created_at")
```
Также можете определить `ASC` или `DESC`:
```
Client.order(created_at: :desc)
# ИЛИ
Client.order(created_at: :asc)
# ИЛИ
Client.order("created_at DESC")
# ИЛИ
Client.order("created_at ASC")
```
Или сортировку по нескольким полям:
```
Client.order(orders_count: :asc, created_at: :desc)
# ИЛИ
Client.order(:orders_count, created_at: :desc)
# ИЛИ
Client.order("orders_count ASC, created_at DESC")
# ИЛИ
Client.order("orders_count ASC", "created_at DESC")
```
**Если хотите вызвать `order` несколько раз, последующие сортировки будут добавлены к первой**:
```
Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC
```
> Если используется MySQL 5.7.5 и выше, то при выборе полей из результирующей выборки с помощью методов, таких как `select`, `pluck` и `ids`; метод `order` вызовет исключение `ActiveRecord::StatementInvalid`, если поля, используемые в выражении `order`, не включены в список выбора.

### Выбор определенных полей <a name="2.6.4"></a>

По умолчанию `Model.find` выбирает все множество полей результата, используя `select *`.

Чтобы выбрать подмножество полей из всего множества, можете определить его, используя метод `select`.

Например, чтобы выбрать только столбцы `viewable_by` и `locked`:
```
Client.select("viewable_by, locked")
```
Используемый для этого запрос SQL будет иметь подобный вид:
```
SELECT viewable_by, locked FROM clients
```
Будьте осторожны, поскольку это также означает, что будет инициализирован объект модели только с теми полями, которые вы выбрали. Если вы попытаетесь обратиться к полям, которых нет в инициализированной записи, то получите:
```
ActiveModel::MissingAttributeError: missing attribute: <attribute>
```
Где <attribute> это атрибут, который был запрошен. Метод `id` не вызывает `ActiveRecord::MissingAttributeError`, поэтому будьте аккуратны при работе со связями, так как они нуждаются в методе `id` для правильной работы.

Если хотите вытащить только по одной записи для каждого уникального значения в определенном поле, можно использовать `distinct`:
```
Client.select(:name).distinct
```
Это сгенерирует такой SQL:
```
SELECT DISTINCT name FROM clients
```
Также можно убрать ограничение уникальности:
```
query = Client.select(:name).distinct
# => Возвратит уникальные имена

query.distinct(false)
# => Возвратит все имена, даже если есть дубликаты
```
### Ограничение и смещение <a name="2.6.5"></a>
Чтобы применить `LIMIT` к SQL, запущенному с помощью `Model.find`, нужно определить LIMIT, используя методы `limit` и `offset` на relation.

Используйте `limit` для определения количества записей, которые будут получены, и `offset` - для числа записей, которые будут пропущены до начала возврата записей. Например:
```
Client.limit(5)
```
возвратит максимум 5 клиентов, и, поскольку не определено смещение, будут возвращены первые 5 клиентов в таблице. Выполняемый SQL будет выглядеть подобным образом:
```
SELECT * FROM clients LIMIT 5
```
Добавление `offset` к этому
```
Client.limit(5).offset(30)
```
Возвратит максимум 5 клиентов, начиная с 31-го. SQL выглядит так:
```
SELECT * FROM clients LIMIT 5 OFFSET 30
```

### Группировка <a name="2.6.6"></a>
Чтобы применить условие `GROUP BY` к SQL, можно использовать метод `group`.

Например, если хотите найти коллекцию дат, в которые были созданы заказы:
```
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
```
Это выдаст вам отдельный объект `Order` на каждую дату, для которой были заказы в базе данных.

SQL, который будет выполнен, будет выглядеть так:
```
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
```

#### Общее количество сгруппированных элементов

Чтобы получить общее количество сгруппированных элементов одним запросом, вызовите `count` после `group`.
```
Order.group(:status).count
# => { 'awaiting_approval' => 7, 'paid' => 12 }
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT COUNT (*) AS count_all, status AS status
FROM "orders"
GROUP BY status
```
### `Having` <a name="2.6.7"></a>

SQL использует условие `HAVING` для определения условий для полей, указанных в `GROUP BY`. Условие `HAVING`, определенное в SQL, запускается в `Model.find` с использованием метода `having` для поиска.

Например:
```
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)").having("sum(price) > ?", 100)
```
SQL, который будет выполнен, выглядит так:
```
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) > 100
```
Это возвращает дату и итоговую цену для каждого объекта заказа, сгруппированные по дню, когда они были заказаны, и где цена больше $100.

### Переопределяющие условия<a name="2.6.8"></a>
#### `unscope`

Можете указать определенные условия, которые будут убраны, используя метод `unscope`. Например:
```
Article.where('id > 10').limit(20).order('id asc').unscope(:order)
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE id > 10 LIMIT 20

# Оригинальный запрос без `unscope`
SELECT * FROM articles WHERE id > 10 ORDER BY id asc LIMIT 20
```

Также можно убрать определенные условия `where`. Например:
```
Article.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "articles".* FROM "articles" WHERE trashed = 0
```
Relation, использующий unscope повлияет на любой relation, в который он слит:
```
Article.order('id asc').merge(Article.unscope(:order))
# SELECT "articles".* FROM "articles"
```

#### `only`

Также можно переопределить условия, используя метод `only`. Например:
```
Article.where('id > 10').limit(20).order('id desc').only(:order, :where)
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE id > 10 ORDER BY id DESC

# Оригинальный запрос без `only`
SELECT * FROM articles WHERE id > 10 ORDER BY id DESC LIMIT 20
```

#### `reorder`

Метод `reorder` переопределяет сортировку скоупа по умолчанию. Например:
```
class Article < ApplicationRecord
  ..
  ..
  has_many :comments, -> { order('posted_at DESC') }
end

Article.find(10).comments.reorder('name')
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY name
```
В случае, когда условие reorder не было использовано, выполненный SQL будет:
```
SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY posted_at DESC
```

#### `reverse_order`

Метод `reverse_order` меняет направление условия сортировки, если оно определено:
```
Client.where("orders_count > 10").order(:name).reverse_order
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM clients WHERE orders_count > 10 ORDER BY name DESC
```
Если условие сортировки не было определено в запросе, `reverse_order` сортирует по первичному ключу в обратном порядке:
```
Client.where("orders_count > 10").reverse_order
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM clients WHERE orders_count > 10 ORDER BY clients.id DESC
```
Этот метод не принимает аргументы.

#### `rewhere`

Метод `rewhere` переопределяет существующее именованное условие `where`. Например:
```
Article.where(trashed: true).rewhere(trashed: false)
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE `trashed` = 0
```
В случае, когда не используется условие `rewhere`,
```
Article.where(trashed: true).where(trashed: false)
```
выполненный SQL будет следующий:
```
SELECT * FROM articles WHERE `trashed` = 1 AND `trashed` = 0
```

### Нулевой Relation <a name="2.6.9"></a>

Метод none возвращает сцепляемый `relation` без записей. Любые последующие условия, сцепленные с возвращенным `relation`, продолжат генерировать пустые `relation`. Это полезно в случаях, когда необходим сцепляемый отклик на метод или скоуп, который может вернуть пустые результаты.
```
Article.none # возвращает пустой Relation и не вызывает запросов.

# От метода visible_articles ожидается, что он вернет Relation.
@articles = current_user.visible_articles.where(name: params[:name])

def visible_articles
  case role
  when 'Country Manager'
    Article.where(country: country)
  when 'Reviewer'
    Article.published
  when 'Bad User'
    Article.none # => если бы вернули [] или nil, код поломался бы в этом случае
  end
end
```

### Объекты только для чтения <a name="2.6.10"></a>

Active Record предоставляет relation метод `readonly` для явного запрета на модификацию любого из возвращаемых объектов. Любая попытка изменить запись, доступную только для чтения, не удастся, вызвав исключение `ActiveRecord::ReadOnlyRecord`.
```
client = Client.readonly.first
client.visits += 1
client.save
```
Так как `client` явно указан как объект доступный только для чтения, выполнение вышеуказанного кода выдаст исключение `ActiveRecord::ReadOnlyRecord` при вызове `client.save` с обновленным значением `visits`.


### `Блокировка записей для обновления` <a name="2.6.11"></a>

Блокировка полезна для предотвращения состояния гонки при обновлении записей в базе данных и обеспечения атомарного обновления.

Active Record предоставляет два механизма блокировки:
* Оптимистическая блокировка
* Пессимистическая блокировка 

#### Оптимистическая блокировка

Оптимистическая блокировка позволяет нескольким пользователям обращаться к одной и той же записи для редактирования и предполагает минимум конфликтов с данными. Она осуществляет это с помощью проверки, внес ли другой процесс изменения в записи, с тех пор как она была открыта. Если это происходит, вызывается исключение `ActiveRecord::StaleObjectError`, и обновление игнорируется.

**Столбец оптимистической блокировки**

Чтобы начать использовать оптимистическую блокировку, таблица должна иметь столбец, называющийся `lock_version`, с типом `integer`. Каждый раз, когда запись обновляется, Active Record увеличивает значение `lock_version`, и средства блокирования обеспечивают, что для записи, вызванной дважды, та, которая первая успеет, будет сохранена, а для второй будет вызвано исключение `ActiveRecord::StaleObjectError`. Пример:
```
c1 = Client.find(1)
c2 = Client.find(1)

c1.first_name = "Michael"
c1.save

c2.name = "should fail"
c2.save # вызывает исключение ActiveRecord::StaleObjectError
```
Вы ответственны за разрешение конфликта с помощью обработки исключения и либо отката, либо объединения, либо применения бизнес-логики, необходимой для разрешения конфликта.

Это поведение может быть отключено, если установить `ActiveRecord::Base.lock_optimistically = false`.

Для переопределения имени столбца `lock_version`, `ActiveRecord::Base` предоставляет атрибут класса `locking_column`:
```
class Client < ApplicationRecord
  self.locking_column = :lock_client_column
end
```
#### Пессимистическая блокировка

Пессимистическая блокировка использует механизм блокировки, предоставленный лежащей в основе базой данных. Использование `lock` при построении relation применяет эксклюзивную блокировку для выбранных строк. Relations, которые используют `lock`, обычно упакованы внутри `transaction` для предотвращения условий взаимной блокировки (дедлока).

Например:
```
Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save!
end
```
Вышеописанная сессия осуществляет следующие SQL для бэкенда MySQL:
```
SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT
```
Также можно передать чистый SQL в опцию `lock` для разрешения различных типов блокировок. Например, в MySQL есть выражение, называющееся `LOCK IN SHARE MODE`, которым можно заблокировать запись, но все же разрешить другим запросам читать ее. Чтобы указать это выражения, просто передайте его как опцию блокировки:
```
Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
end
```
Если у вас уже имеется экземпляр модели, можно одновременно начать транзакцию и затребовать блокировку, используя следующий код:
```
item = Item.first
item.with_lock do
  # Этот блок вызывается в транзакции,
  # элемент уже заблокирован.
  item.increment!(:views)
end
```

### Соединительные таблицы <a name="2.6.12"></a>

Active Record предоставляет два метода поиска для определения условия `JOIN` в результирующем SQL: `joins` и `left_outer_joins`. В то время, как `joins` следует использовать для `INNER JOIN` или пользовательских запросов, `left_outer_joins` используется для запросов с помощью `LEFT OUTER JOIN`.

#### `joins`

Существует несколько способов использования метода `joins`

##### Использование строкового фрагмента SQL

Можно просто передать чистый SQL, определяющий условие `JOIN` в `joins`.
```
Author.joins("INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'")
```
Это приведет к следующему SQL:
```
SELECT authors.* FROM authors INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'
```

##### Использование массива/хэша именованных связей

Active Record позволяет использовать имена связей, определенных в модели, как ярлыки для определения условия `JOIN` этих связей при использовании метода `joins`.

Например, рассмотрим следующие модели `Category`, `Article`, `Comment`, `Guest` и `Tag`:
```
class Category < ApplicationRecord
  has_many :articles
end

class Article < ApplicationRecord
  belongs_to :category
  has_many :comments
  has_many :tags
end

class Comment < ApplicationRecord
  belongs_to :article
  has_one :guest
end

class Guest < ApplicationRecord
  belongs_to :comment
end

class Tag < ApplicationRecord
  belongs_to :article
end
```
Сейчас все нижеследующее создаст ожидаемые соединительные запросы с использованием `INNER JOIN`:

###### Соединение одиночной связи
```
Category.joins(:articles)
```
Это создаст:
```
SELECT categories.* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id
```
Или, по-русски, "возвратить объект Category для всех категорий со статьями". Обратите внимание, что будут дублирующиеся категории, если более одной статьи имеют одинаковые категорию. Если нужны уникальные категории, можно использовать 
```
Category.joins(:articles).distinct.
```
###### Соединение нескольких связей
```
Article.joins(:category, :comments)
```
Это создаст:
```
SELECT articles.* FROM articles
  INNER JOIN categories ON categories.id = articles.category_id
  INNER JOIN comments ON comments.article_id = articles.id
```
Или, по-русски, "возвратить все статьи, у которых есть категория и как минимум один комментарий". Отметьте, что статьи с несколькими комментариями будут показаны несколько раз.

###### Соединение вложенных связей (одного уровня)
```
Article.joins(comments: :guest)
```
Это создаст:
```
SELECT articles.* FROM articles
  INNER JOIN comments ON comments.article_id = articles.id
  INNER JOIN guests ON guests.comment_id = comments.id
```
Или, по-русски, "возвратить все статьи, в которых есть комментарий, оставленный гостем".

##### Определение условий в соединительных таблицах

В соединительных таблицах можно определить условия, используя обычные массивные и строковые условия. Условия с использованием хэша предоставляют специальный синтаксис для определения условий в соединительных таблицах:
```
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where('orders.created_at' => time_range)
```
Альтернативный и более чистый синтаксис для этого - вложенные хэш-условия:
```
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where(orders: { created_at: time_range })
```
Будут найдены все клиенты, имеющие созданные вчера заказы, снова используя выражение SQL `BETWEEN`.

#### `left_outer_joins`

Если хотите выбрать ряд записей, независимо от того, имеют ли они связанные записи, можно использовать метод `left_outer_joins`.
```
Author.left_outer_joins(:posts).distinct.select('authors.*, COUNT(posts.*) AS posts_count').group('authors.id')
```
Который создаст:
```
SELECT DISTINCT authors.*, COUNT(posts.*) AS posts_count FROM "authors"
LEFT OUTER JOIN posts ON posts.author_id = authors.id GROUP BY authors.id
```
### Нетерпеливая загрузка связей <a name="2.6.13"></a>

Нетерпеливая загрузка - это механизм загрузки связанных записей объекта, возвращаемых `Model.find`, с использованием как можно меньшего количества запросов.

Проблема N + 1 запроса

Рассмотрим следующий код, который находит 10 клиентов и выводит их почтовые индексы:
```
clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end
```
На первый взгляд выглядит хорошо. Но проблема лежит в общем количестве выполненных запросов. Вышеупомянутый код выполняет 1 (чтобы найти 10 клиентов) + 10 (каждый на одного клиента для загрузки адреса) = итого 11 запросов.
Что означает: "возвратить всех авторов и количество их публикаций, независимо от того, имеются ли у них вообще публикации".

**Решение проблемы N + 1 запроса**

Active Record позволяет заранее указать все связи, которые должны быть загружены. Это возможно с помощью указания метода `includes` на вызове `Model.find`. Посредством `includes`, Active Record обеспечивает то, что все указанные связи загружаются с использованием минимально возможного количества запросов.

Пересмотрев вышеупомянутую задачу, можно переписать `Client.limit(10)`, чтобы нетерпеливо загрузить адреса:
```
clients = Client.includes(:address).limit(10)

clients.each do |client|
  puts client.address.postcode
end
```
Этот код выполнит всего 2 запроса, вместо 11 запросов из прошлого примера:
```
SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
```

#### Нетерпеливая загрузка нескольких связей
Массив нескольких связей
```
Article.includes(:category, :comments)
```
Это загрузит все статьи и связанные категорию, и комментарии для каждой статьи.

#### Вложенный хэш связей
```
Category.includes(articles: [{ comments: :guest }, :tags]).find(1)
```
Вышеприведенный код находит категории с `id 1` и нетерпеливо загружает все связанные статьи, теги и комментарии каждой статьи, а также гостей, связанных с комментариями.

#### Определение условий для нетерпеливой загрузки связей

Хотя Active Record и позволяет определить условия для нетерпеливой загрузки связей точно так же, как и в `joins`, рекомендуем использовать вместо этого `joins`.

Однако, если сделать так, то можно использовать `where` как обычно.
```
Article.includes(:comments).where(comments: { visible: true })
```
Это сгенерирует запрос с ограничением `LEFT OUTER JOIN`, в то время как метод `joins` сгенерировал бы его с использованием функции `INNER JOIN`.
```
  SELECT "articles"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "articles"
    LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE (comments.visible = 1)
```
Если бы не было условия `where`, то сгенерировался бы обычный набор из двух запросов.

> Использование where подобным образом будет работать только, если передавать в него хэш. Для фрагментов SQL необходимо использовать `references` для принуждения соединения таблиц:
```
Article.includes(:comments).where("comments.visible = true").references(:comments)
```
Если, в случае с этим запросом `includes`, не будет ни одного комментария ни для одной статьи, все статьи все равно будут загружены. При использовании `joins` (`INNER JOIN`), соединительные условия должны соответствовать, иначе ни одной записи не будет возвращено.

> Если связь нетерпеливо загружена как часть `join`, любые поля из произвольного выражения `select` не будут присутствовать в загруженных моделях. Это так, потому что это избыточность, которая должна появиться или в родительской модели, или в дочерней.

### Скоупы <a name="2.6.14"></a>
Скоупы позволяют задавать часто используемые запросы, к которым можно обращаться как к вызовам метода в связанных объектах или моделях. С помощью этих скоупов можно использовать каждый ранее раскрытый метод, такой как `where`, `joins` и `includes`. Все методы скоупов возвращают объект `ActiveRecord::Relation`, который позволяет вызывать на нем дополнительные методы (такие как другие скоупы).

Для определения простого скоупа мы используем метод scope внутри класса, передав запрос, который хотим запустить при вызове этого скоупа:
```
class Article < ApplicationRecord
  scope :published, -> { where(published: true) }
end
```
Это в точности то же самое, что определение метода класса, и то, что именно вы используете, является вопросом профессионального предпочтения:
```
class Article < ApplicationRecord
  def self.published
    where(published: true)
  end
end
```
Скоупы также сцепляются с другими скоупами:
```
class Article < ApplicationRecord
  scope :published,               -> { where(published: true) }
  scope :published_and_commented, -> { published.where("comments_count > 0") }
end
```
Для вызова скоупа `published`, можно вызвать его либо на классе:
```
Article.published # => [опубликованные статьи]
```
Либо на связи, состоящей из объектов `Article`:
```
category = Category.first
category.articles.published # => [опубликованные статьи, принадлежащие этой категории]
```

#### Передача аргумента

Скоуп может принимать аргументы:
```
class Article < ApplicationRecord
  scope :created_before, ->(time) { where("created_at < ?", time) }
end
```
Вызывайте скоуп, как будто это метод класса:
```
Article.created_before(Time.zone.now)
```
Однако, это всего лишь дублирование функциональности, которая должна быть предоставлена методом класса.
```
class Article < ApplicationRecord
  def self.created_before(time)
    where("created_at < ?", time)
  end
end
```
Использование метода класса - более предпочтительный способ принятию аргументов скоупом. Эти методы также будут доступны на связанных объектах:
```
category.articles.created_before(time)
```

#### Использование условий

Ваши скоупы могут использовать условия:
```
class Article < ApplicationRecord
  scope :created_before, ->(time) { where("created_at < ?", time) if time.present? }
end
```
Подобно остальным примерам, это ведет себя подобно методу класса.
```
class Article < ApplicationRecord
  def self.created_before(time)
    where("created_at < ?", time) if time.present?
  end
end
```
Однако, имеется одно важное предостережение: скоуп всегда должен возвращать объект `ActiveRecord::Relation`, даже если условие вычисляется `false`, в отличие от метода класса, возвращающего `nil`. Это может вызвать `NoMethodError` при сцеплении методов класса с условиями, если одно из условий вернет `false`.

#### Применение скоупа по умолчанию

Если хотите, чтобы скоуп был применен ко всем запросам модели, можно использовать метод `default_scope` в самой модели.
```
class Client < ApplicationRecord
  default_scope { where("removed_at IS NULL") }
end
```
Когда запросы для этой модели будут выполняться, запрос SQL теперь будет выглядеть примерно так:
```
SELECT * FROM clients WHERE removed_at IS NULL
```
Если необходимо сделать более сложные вещи со скоупом по умолчанию, альтернативно его можно определить как метод класса:
```
class Client < ApplicationRecord
  def self.default_scope
    # Должен возвращать ActiveRecord::Relation.
  end
end
```
`default_scope` также применяется при создании записи, когда аргументы скоупа передаются как Hash. Он не применяется при обновлении записи. То есть:
```
class Client < ApplicationRecord
  default_scope { where(active: true) }
end

Client.new          # => #<Client id: nil, active: true>
Client.unscoped.new # => #<Client id: nil, active: nil>
```
Имейте в виду, что когда передаются в формате Array, аргументы запроса `default_scope` не могут быть преобразованы в Hash для назначения атрибутов по умолчанию. То есть:
```
class Client < ApplicationRecord
  default_scope { where("active = ?", true) }
end

Client.new # => #<Client id: nil, active: nil>
```

#### Объединение скоупов

Подобно условиям where, скоупы объединяются с использованием `AND`.
```
class User < ApplicationRecord
  scope :active, -> { where state: 'active' }
  scope :inactive, -> { where state: 'inactive' }
end

User.active.inactive
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'
```
Можно комбинировать условия `scope` и `where`, и результирующий sql будет содержать все условия, соединенные с помощью `AND`.
```
User.active.where(state: 'finished')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'
```
Если необходимо, чтобы сработало только **последнее условие where**, тогда можно использовать `Relation#merge`.
```
User.active.merge(User.inactive)
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
```
Важным предостережением является то, что `default_scope` **переопределяется условиями `scope` и `where`**.
```
class User < ApplicationRecord
  default_scope { where state: 'pending' }
  scope :active, -> { where state: 'active' }
  scope :inactive, -> { where state: 'inactive' }
end

User.all
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'

User.active
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active'

User.where(state: 'inactive')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
```
Как видите, `default_scope` объединяется как со `scope`, так и с `where` условиями.

#### Удаление всех скоупов

Если хотите удалить скоупы по какой-то причине, можете использовать метод `unscoped`. Это особенно полезно, если в модели определен `default_scope`, и он не должен быть применен для конкретно этого запроса.
```
Client.unscoped.load
```
Этот метод удаляет все скоупы и выполняет обычный запрос к таблице.
```
Client.unscoped.all
# SELECT "clients".* FROM "clients"

Client.where(published: false).unscoped.all
# SELECT "clients".* FROM "clients"
```
`unscoped` также может принимать блок.
```
Client.unscoped {
  Client.created_before(Time.zone.now)
}
```
### Динамический поиск <a name="2.6.15"></a>

Для каждого поля (также называемого атрибутом), определенного в вашей таблице, Active Record предоставляет метод поиска. Например, если есть поле `first_name` в вашей модели `Client`, вы автоматически получаете `find_by_first_name` от Active Record. Если также есть поле `locked` в модели `Client`, вы также получаете `find_by_locked` метод.

Можете определить восклицательный знак (`!`) в конце динамического поиска, чтобы он вызвал ошибку `ActiveRecord::RecordNotFound`, если не возвратит ни одной записи, например так `Client.find_by_name!("Ryan")`

Если хотите искать и по `first_name`, и по `locked`, можете сцепить эти поиски вместе, просто написав "`and`" между полями, например, `Client.find_by_first_name_and_locked("Ryan", true)`.

### `Enum` <a name="2.6.16"></a>

Макрос `enum` связывает числовой столбец с набором возможных значений.
```
class Book < ApplicationRecord
  enum availability: [:available, :unavailable]
end
```
Это автоматически создаст соответствующие скоупы для запроса модели. Также добавляются методы для перехода между состояниями и запроса текущего состояния.
```
# Оба примера ниже запрашивают только доступные книги.
Book.available
# или
Book.where(availability: :available)

book = Book.new(availability: :available)
book.available?   # => true
book.unavailable! # => true
book.available?   # => false
```
Полную документацию об `enum` можно прочитать в <a href="https://api.rubyonrails.org/classes/ActiveRecord/Enum.html">документации Rails API</a>.

### Цепочки методов <a name="2.6.17"></a>

В Active Record есть полезный приём программирования Method Chaining, который позволяет нам комбинировать множество Active Record методов.

Можно сцепить несколько методов в единое выражение, если предыдущий вызываемый метод возвращает `ActiveRecord::Relation`, такие как `all`, `where` и `joins`. Методы, которые возвращают одиночный объект (смотрите раздел Получение одиночного объекта) должны вызываться в конце.

Ниже представлены несколько примеров. Это руководство не покрывает все возможности, а только некоторые, для ознакомления. Когда вызывается Active Record метод, запрос не сразу генерируется и отправляется в базу, это происходит только тогда, когда данные реально необходимы. Таким образом, каждый пример ниже генерирует только один запрос.

#### Получение отфильтрованных данных из нескольких таблиц
```
Person
  .select('people.id, people.name, comments.text')
  .joins(:comments)
  .where('comments.created_at > ?', 1.week.ago)
```
Результат должен быть примерно следующим:
```
SELECT people.id, people.name, comments.text
FROM people
INNER JOIN comments
  ON comments.person_id = people.id
WHERE comments.created_at > '2015-01-01'
```

#### Получение определённых данных из нескольких таблиц
```
Person
  .select('people.id, people.name, companies.name')
  .joins(:company)
  .find_by('people.name' => 'John') # это должно быть в конце
```
Выражение выше, сгенерирует следующий SQL-запрос:
```
SELECT people.id, people.name, companies.name
FROM people
INNER JOIN companies
  ON companies.person_id = people.id
WHERE people.name = 'John'
LIMIT 1
```
> Обратите внимание, что если запросу соответствует несколько записей, `find_by` вернет только первую запись и проигнорирует остальные (смотрите `LIMIT 1` выше).

### Поиск или создание нового объекта <a name="2.6.18"></a>

Часто бывает, что вам нужно найти запись или создать ее, если она не существует. Вы можете сделать это с помощью методов `find_or_create_by` и `find_or_create_by!`.

#### `find_or_create_by`

Метод `find_or_create_by` проверяет, существует ли запись с определенными атрибутами. Если нет, то вызывается `create`. Давайте рассмотрим пример.

Предположим, вы хотите найти клиента по имени 'Andy', и, если такого нет, создать его. Это можно сделать, выполнив:
```
Client.find_or_create_by(first_name: 'Andy')
# => #<Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">
```
SQL, генерируемый этим методом, будет выглядеть так:
```
SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT
```
`find_or_create_by` возвращает либо уже существующую запись, либо новую запись. В нашем случае, у нас еще нет клиента с именем Andy, поэтому запись будет создана и возвращена.

Новая запись может быть не сохранена в базу данных; это зависит от того, прошли валидации или нет (подобно `create`).

Предположим, мы хотим установить атрибут `'locked'` как `false`, если создаем новую запись, но не хотим включать его в запрос. Таким образом, мы хотим найти клиента по имени "Andy" или, если этот клиент не существует, создать клиента по имени "Andy", который не заблокирован.

Этого можно достичь двумя способами. Первый - это использование `create_with`:
```
Client.create_with(locked: false).find_or_create_by(first_name: 'Andy')
```
Второй способ - это использование блока:
```
Client.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end
```
Блок будет выполнен, только если клиент был создан. Во второй раз, при запуске этого кода, блок будет проигнорирован.

#### `find_or_create_by!`

Можно также использовать `find_or_create_by!`, чтобы вызвать исключение, если новая запись невалидна. Валидации не раскрываются в этом руководстве, но давайте на момент предположим, что вы временно добавили
```
validates :orders_count, presence: true
```
в модель `Client`. Если попытаетесь создать нового `Client` без передачи `orders_count`, запись будет невалидной и будет вызвано исключение:
```
Client.find_or_create_by!(first_name: 'Andy')
# => ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank
```
#### `find_or_initialize_by`

Метод `find_or_initialize_by` работает похоже на `find_or_create_by`, но он вызывает не `create`, а `new`. Это означает, что новый экземпляр модели будет создан в памяти, но не будет сохранен в базу данных. Продолжая пример с `find_or_create_by`, теперь нам нужен клиент по имени 'Nick':
```
nick = Client.find_or_initialize_by(first_name: 'Nick')
# => #<Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">

nick.persisted?
# => false

nick.new_record?
# => true
```
Поскольку объект еще не сохранен в базу данных, сгенерированный SQL выглядит так:
```
SELECT * FROM clients WHERE (clients.first_name = 'Nick') LIMIT 1
```
Когда захотите сохранить его в базу данных, просто вызовите `save`:
```
nick.save
# => true
```
### Поиск с помощью SQL <a name="2.6.19"></a>

Если вы предпочитаете использовать собственные запросы SQL для поиска записей в таблице, можете использовать `find_by_sql`. Метод `find_by_sql` возвратит массив объектов, даже если лежащий в основе запрос вернет всего лишь одну запись. Например, можете запустить такой запрос:
```
Client.find_by_sql("SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc")
# =>  [
#   #<Client id: 1, first_name: "Lucas" >,
#   #<Client id: 2, first_name: "Jan" >,
#   ...
# ]
```
`find_by_sql` предоставляет простой способ создания произвольных запросов к базе данных и получения экземпляров объектов.

#### `select_all`

У `find_by_sql` есть близкий родственник, называемый `connection#select_all`. `select_all` получит объекты из базы данных, используя произвольный SQL, как и в `find_by_sql`, но не создаст их экземпляры. Этот метод вернет экземпляр класса `ActiveRecord::Result` и вызвав `to_hash` на этом объекте вернет массив хэшей, где каждый хэш указывает на запись.
```
Client.connection.select_all("SELECT first_name, created_at FROM clients WHERE id = '1'").to_hash
# => [
#   {"first_name"=>"Rafael", "created_at"=>"2012-11-10 23:23:45.281189"},
#   {"first_name"=>"Eileen", "created_at"=>"2013-12-09 11:22:35.221282"}
# ]
```

#### `pluck`

`pluck` может быть использован для запроса с одним или несколькими столбцами из таблицы, лежащей в основе модели. Он принимает список имен столбцов как аргумент и возвращает массив значений определенных столбцов соответствующего типа данных.
```
Client.where(active: true).pluck(:id)
# SELECT id FROM clients WHERE active = 1
# => [1, 2, 3]

Client.distinct.pluck(:role)
# SELECT DISTINCT role FROM clients
# => ['admin', 'member', 'guest']

Client.pluck(:id, :name)
# SELECT clients.id, clients.name FROM clients
# => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
```
`pluck` позволяет заменить такой код:
```
Client.select(:id).map { |c| c.id }
# или
Client.select(:id).map(&:id)
# или
Client.select(:id, :name).map { |c| [c.id, c.name] }
```
на:
```
Client.pluck(:id)
# или
Client.pluck(:id, :name)
```
В отличие от `select`, `pluck` непосредственно конвертирует результат запроса в массив Ruby, без создания объектов ActiveRecord. Это может означать лучшую производительность для больших или часто используемых запросов. Однако, любые **переопределения методов в модели будут недоступны**. Например:
```
class Client < ApplicationRecord
  def name
    "I am #{super}"
  end
end

Client.select(:name).map &:name
# => ["I am David", "I am Jeremy", "I am Jose"]

Client.pluck(:name)
# => ["David", "Jeremy", "Jose"]
```
Более того, в отличие от `select` и других скоупов Relation, `pluck` вызывает немедленный запрос, и поэтому **не может быть соединен с любыми последующими скоупами, хотя он может работать со скоупами, подключенными ранее**:
```
Client.pluck(:name).limit(1)
# => NoMethodError: undefined method `limit' for #<Array:0x007ff34d3ad6d8>

Client.limit(1).pluck(:name)
# => ["David"]
```

#### `ids`

`ids` может быть использован для сбора всех ID для relation, используя первичный ключ таблицы.
```
Person.ids
# SELECT id FROM people
```
```
class Person < ApplicationRecord
  self.primary_key = "person_id"
end

Person.ids
# SELECT person_id FROM people
```

### Существование объектов <a name="2.6.20"></a>

Если вы просто хотите проверить существование объекта, есть метод, называемый `exists?`. Этот метод запрашивает базу данных, используя тот же запрос, что и `find`, но вместо возврата объекта или коллекции объектов, он возвращает или `true`, или `false`.
```
Client.exists?(1)
```

Метод `exists?` также принимает несколько значений, при этом возвращает `true`, если хотя бы одна из этих записей существует.
```
Client.exists?(id: [1,2,3])
# или
Client.exists?(name: ['John', 'Sergei'])
```
Даже возможно использовать `exists?` без аргументов на модели или `relation`:
```
Client.where(first_name: 'Ryan').exists?
```
Пример выше вернет `true`, если есть хотя бы один клиент с `first_name 'Ryan'`, и `false` в противном случае.
```
Client.exists?
```
Это возвратит `false`, если таблица `clients` пустая, и `true` в противном случае.

Для проверки на существование также можно использовать `any?` и `many?` на модели или relation.
```
# на модели
Article.any?
Article.many?

# на именованном скоупе
Article.recent.any?
Article.recent.many?

# на relation
Article.where(published: true).any?
Article.where(published: true).many?

# на связи
Article.first.categories.any?
Article.first.categories.many?
```

### Вычисления <a name="2.6.21"></a>

Этот раздел использует count для примера в этой преамбуле, но описанные опции применяются ко всем подразделам.

Все методы вычисления работают прямо на модели:
```
Client.count
# SELECT COUNT(*) FROM clients
```
Или на relation:
```
Client.where(first_name: 'Ryan').count
# SELECT COUNT(*) FROM clients WHERE (first_name = 'Ryan')
```
Можно также использовать различные методы поиска на relation для выполнения сложных вычислений:
```
Client.includes("orders").where(first_name: 'Ryan', orders: { status: 'received' }).count
```
Что выполнит:
```
SELECT COUNT(DISTINCT clients.id) FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = clients.id
  WHERE (clients.first_name = 'Ryan' AND orders.status = 'received')
```

#### Количество

Если хотите увидеть, сколько записей есть в таблице модели, можете вызвать `Client.count`, и он возвратит число. Если хотите быть более определенным и найти всех клиентов с присутствующим в базе данных возрастом, используйте `Client.count(:age)`.

#### Среднее

Если хотите увидеть среднее значение определенного показателя в одной из ваших таблиц, можно вызвать метод `average` для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.average("orders_count")
```
Это возвратит число (возможно, с плавающей запятой, такое как 3.14159265), представляющее среднее значение поля.

#### Минимум

Если хотите найти минимальное значение поля в таблице, можете вызвать метод minimum для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.minimum("age")
```

#### Максимум

Если хотите найти максимальное значение поля в таблице, можете вызвать метод maximum для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.maximum("age")
```

#### Сумма

Если хотите найти сумму полей для всех записей в таблице, можете вызвать метод sum для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.sum("orders_count")
```

### Запуск EXPLAIN <a name="2.6.22"></a>

Можно запустить `EXPLAIN` на запросах, вызываемых в relations. Например,
```
User.where(id: 1).joins(:articles).explain
```

может выдать
```
EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+----------+-------+---------------+
| id | select_type | table    | type  | possible_keys |
+----+-------------+----------+-------+---------------+
|  1 | SIMPLE      | users    | const | PRIMARY       |
|  1 | SIMPLE      | articles | ALL   | NULL          |
+----+-------------+----------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)
```
для MySQL и MariaDB.

Active Record применяет красивое форматирование, эмулирующее работу соответствующей оболочки базы данных. Таким образом, запуск того же запроса с адаптером PostgreSQL выдаст вместо этого
```
EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "articles" ON "articles"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (articles.user_id = users.id)
   ->  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   ->  Seq Scan on articles  (cost=0.00..28.88 rows=8 width=4)
         Filter: (articles.user_id = 1)
(6 rows)
```
Нетерпеливая загрузка может вызвать более одного запроса за раз, и некоторым запросам могут потребоваться результаты предыдущих. Поэтому `explain` фактически выполняет запрос, а затем запрашивает планы запросов. Например,
```
User.where(id: 1).includes(:articles).explain
```
выдаст
```
EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+
| id | select_type | table | type  | possible_keys |
+----+-------------+-------+-------+---------------+
|  1 | SIMPLE      | users | const | PRIMARY       |
+----+-------------+-------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `articles`.* FROM `articles`  WHERE `articles`.`user_id` IN (1)
+----+-------------+----------+------+---------------+
| id | select_type | table    | type | possible_keys |
+----+-------------+----------+------+---------------+
|  1 | SIMPLE      | articles | ALL  | NULL          |
+----+-------------+----------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+
```

1 row in set (0.00 sec)

для MySQL и MariaDB

## Active Record для PostgreSQL <a name="2.7"></a>
### Типы данных <a name="2.7.1"></a>
PostgreSQL предлагает достаточное количество специфичных типов данных. Далее представлен список типов, которые поддерживаются адаптером PostgreSQL.
#### Двоичные типы данных
```
# db/migrate/20140207133952_create_documents.rb
create_table :documents do |t|
  t.binary 'payload'
end

# app/models/document.rb
class Document < ApplicationRecord
end

# Использование
data = File.read(Rails.root + "tmp/output.pdf")
Document.create payload: data
```
#### Массивы
```
# db/migrate/20140207133952_create_books.rb
create_table :books do |t|
  t.string 'title'
  t.string 'tags', array: true
  t.integer 'ratings', array: true
end
add_index :books, :tags, using: 'gin'
add_index :books, :ratings, using: 'gin'

# app/models/book.rb
class Book < ApplicationRecord
end

# Использование
Book.create title: "Brave New World",
            tags: ["fantasy", "fiction"],
            ratings: [4, 5]

## Книги с одним тегом
Book.where("'fantasy' = ANY (tags)")

## Книги с несколькими тегами
Book.where("tags @> ARRAY[?]::varchar[]", ["fantasy", "fiction"])

## Книги с рейтингом 3 и более
Book.where("array_length(ratings, 1) >= 3")
```
#### `Hstore`
> Чтобы использовать `hstore`, необходимо включить расширение `hstore`.
```
# db/migrate/20131009135255_create_profiles.rb
ActiveRecord::Schema.define do
  enable_extension 'hstore' unless extension_enabled?('hstore')
  create_table :profiles do |t|
    t.hstore 'settings'
  end
end

# app/models/profile.rb
class Profile < ApplicationRecord
end

# Использование
Profile.create(settings: { "color" => "blue", "resolution" => "800x600" })

profile = Profile.first
profile.settings # => {"color"=>"blue", "resolution"=>"800x600"}

profile.settings = {"color" => "yellow", "resolution" => "1280x1024"}
profile.save!

Profile.where("settings->'color' = ?", "yellow")
# => #<ActiveRecord::Relation [#<Profile id: 1, settings: {"color"=>"yellow", "resolution"=>"1280x1024"}>]>
```
#### `JSON` и `JSONB`
```
# db/migrate/20131220144913_create_events.rb
# ... для типа данных json:
create_table :events do |t|
  t.json 'payload'
end
# ... или для типа данных jsonb:
create_table :events do |t|
  t.jsonb 'payload'
end

# app/models/event.rb
class Event < ApplicationRecord
end

# Использование
Event.create(payload: { kind: "user_renamed", change: ["jack", "john"]})

event = Event.first
event.payload # => {"kind"=>"user_renamed", "change"=>["jack", "john"]}

## Запрос, основанный на JSON документе
# Оператор -> возвращает исходный JSON тип (который может быть объектом), где ->> возвращает текст
Event.where("payload->>'kind' = ?", "user_renamed")
```
#### Диапазонные типы
Этот тип преобразуется в `Ruby Range` объекты.
```
# db/migrate/20130923065404_create_events.rb
create_table :events do |t|
  t.daterange 'duration'
end

# app/models/event.rb
class Event < ApplicationRecord
end

# Использование
Event.create(duration: Date.new(2014, 2, 11)..Date.new(2014, 2, 12))

event = Event.first
event.duration # => Tue, 11 Feb 2014...Thu, 13 Feb 2014

## Все события в заданную дату
Event.where("duration @> ?::date", Date.new(2014, 2, 12))

## Работает с границами диапазона
event = Event.
  select("lower(duration) AS starts_at").
  select("upper(duration) AS ends_at").first

event.starts_at # => Tue, 11 Feb 2014
event.ends_at # => Thu, 13 Feb 2014
```
#### Составные типы
На данный момент нет специальной поддержки для составных типов. Они преобразуются к обычным текстовым столбцам:
```
CREATE TYPE full_address AS
(
  city VARCHAR(90),
  street VARCHAR(90)
);
```
```
# db/migrate/20140207133952_create_contacts.rb
execute <<-SQL
 CREATE TYPE full_address AS
 (
   city VARCHAR(90),
   street VARCHAR(90)
 );
SQL
create_table :contacts do |t|
  t.column :address, :full_address
end

# app/models/contact.rb
class Contact < ApplicationRecord
end

# Использование
Contact.create address: "(Paris,Champs-Élysées)"
contact = Contact.first
contact.address # => "(Paris,Champs-Élysées)"
contact.address = "(Paris,Rue Basse)"
contact.save!
```
#### Типы перечислений

На данный момент нет специальной поддержки для типов перечислений. Они преобразуются к обычным текстовым столбцам:
```
# db/migrate/20131220144913_create_articles.rb
def up
  execute <<-SQL
    CREATE TYPE article_status AS ENUM ('draft', 'published');
  SQL
  create_table :articles do |t|
    t.column :status, :article_status
  end
end

# NOTE: Не забываем удалить таблицу перед удалением enum.
def down
  drop_table :articles

  execute <<-SQL
    DROP TYPE article_status;
  SQL
end

# app/models/article.rb
class Article < ApplicationRecord
end

# Использование
Article.create status: "draft"
article = Article.first
article.status # => "draft"

article.status = "published"
article.save!
```
Чтобы добавить новое значение до/после существующего, следует использовать `ALTER TYPE`:
```
# db/migrate/20150720144913_add_new_state_to_articles.rb
# NOTE: ALTER TYPE ... ADD VALUE нельзя выполнить в блоке транзакции, поэтому используется disable_ddl_transaction!
disable_ddl_transaction!

def up
  execute <<-SQL
    ALTER TYPE article_status ADD VALUE IF NOT EXISTS 'archived' AFTER 'published';
  SQL
end
```
> Значения `ENUM` сейчас нельзя удалять.

Hint: Чтобы показать все имеющиеся значения enum, можно выполнить этот запрос в консоле bin/rails db или psql:
```
SELECT n.nspname AS enum_schema,
       t.typname AS enum_name,
       e.enumlabel AS enum_value
  FROM pg_type t
      JOIN pg_enum e ON t.oid = e.enumtypid
      JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
```
#### Тип `UUID`
> Для использования `uuid` необходимо включить расширение `pgcrypto` (только PostgreSQL >= 9.4).
```
Тип UUID

    определение типа
    pgcrypto generator function
    uuid-ossp generator functions 

Для использования uuid необходимо включить расширение pgcrypto (только PostgreSQL >= 9.4).

# db/migrate/20131220144913_create_revisions.rb
create_table :revisions do |t|
  t.uuid :identifier
end

# app/models/revision.rb
class Revision < ApplicationRecord
end

# Использование
Revision.create identifier: "A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11"

revision = Revision.first
revision.identifier # => "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11"

Вы можете использовать тип uuid для определения ссылок в миграции:

# db/migrate/20150418012400_create_blog.rb
enable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')
create_table :posts, id: :uuid, default: 'gen_random_uuid()'

create_table :comments, id: :uuid, default: 'gen_random_uuid()' do |t|
  # t.belongs_to :post, type: :uuid
  t.references :post, type: :uuid
end

# app/models/post.rb
class Post < ApplicationRecord
  has_many :comments
end

# app/models/comment.rb
class Comment < ApplicationRecord
  belongs_to :post
end
```
#### Битовые строки
```
# db/migrate/20131220144913_create_users.rb
create_table :users, force: true do |t|
  t.column :settings, "bit(8)"
end

# app/models/user.rb
class User < ApplicationRecord
end

# Использование
User.create settings: "01010011"
user = User.first
user.settings # => "01010011"
user.settings = "0xAF"
user.settings # => 10101111
user.save!
```
#### Типы, описывающие сетевые адреса
Типы `inet` и `cidr` преобразуются в Ruby `IPAddr` объекты. Тип `macaddr` преобразуется в обычный текст.
```
# db/migrate/20140508144913_create_devices.rb
create_table(:devices, force: true) do |t|
  t.inet 'ip'
  t.cidr 'network'
  t.macaddr 'address'
end

# app/models/device.rb
class Device < ApplicationRecord
end

# Использование
macbook = Device.create(ip: "192.168.1.12",
                        network: "192.168.2.0/24",
                        address: "32:01:16:6d:05:ef")

macbook.ip
# => #<IPAddr: IPv4:192.168.1.12/255.255.255.255>

macbook.network
# => #<IPAddr: IPv4:192.168.2.0/255.255.255.0>

macbook.address
# => "32:01:16:6d:05:ef"
```
#### Геометрические типы
Все геометрические типы, за исключением `points` преобразуются в обычный текст. А тип `point` соответствует массиву, содержащему координаты `x` и `y`

###  Первичные ключи `UUID` <a name="2.7.2"></a>
> Для генерации случайных `UUIDs` необходимо включить расширение `pgcrypto` (только PostgreSQL >= 9.4) или `uuid-ossp`.

```
# db/migrate/20131220144913_create_devices.rb
enable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')
create_table :devices, id: :uuid, default: 'gen_random_uuid()' do |t|
  t.string :kind
end

# app/models/device.rb
class Device < ApplicationRecord
end

# Использование
device = Device.create
device.id # => "814865cd-5a1d-4771-9306-4268f188fe9e"
```
> Предполагается, что используется `gen_random_uuid()` (из `uuid-pgcrypto`) при отсутствии опции `:default`, переданной в `create_table`.

### Полнотекстовый поиск <a name="2.7.3"></a>
```
# db/migrate/20131220144913_create_documents.rb
create_table :documents do |t|
  t.string 'title'
  t.string 'body'
end

add_index :documents, "to_tsvector('english', title || ' ' || body)", using: :gin, name: 'documents_idx'

# app/models/document.rb
class Document < ApplicationRecord
end

# Использование
Document.create(title: "Cats and Dogs", body: "are nice!")

## Все документы совпадающие с 'cat & dog'
Document.where("to_tsvector('english', title || ' ' || body) @@ to_tsquery(?)",
                 "cat & dog")
```
### Представление базы данных <a name="2.7.4"></a>

Представим, что нам нужно работать со старой базой данных, содержащей следующую таблицу:
```
rails_pg_guide=# \d "TBL_ART"
                                        Table "public.TBL_ART"
   Column   |            Type             |                         Modifiers
------------+-----------------------------+------------------------------------------------------------
 INT_ID     | integer                     | not null default nextval('"TBL_ART_INT_ID_seq"'::regclass)
 STR_TITLE  | character varying           |
 STR_STAT   | character varying           | default 'draft'::character varying
 DT_PUBL_AT | timestamp without time zone |
 BL_ARCH    | boolean                     | default false
Indexes:
    "TBL_ART_pkey" PRIMARY KEY, btree ("INT_ID")
```
Данная таблица не соответствует общепринятым Rails соглашениям. Т.к. простые представление PostgreSQL обновляются по умолчанию, то можно обернуть их следующим образом:
```
# db/migrate/20131220144913_create_articles_view.rb
execute <<-SQL
CREATE VIEW articles AS
  SELECT "INT_ID" AS id,
         "STR_TITLE" AS title,
         "STR_STAT" AS status,
         "DT_PUBL_AT" AS published_at,
         "BL_ARCH" AS archived
  FROM "TBL_ART"
  WHERE "BL_ARCH" = 'f'
  SQL

# app/models/article.rb
class Article < ApplicationRecord
  self.primary_key = "id"
  def archive!
    update_attribute :archived, true
  end
end

# Использование
first = Article.create! title: "Winter is coming",
                        status: "published",
                        published_at: 1.year.ago
second = Article.create! title: "Brace yourself",
                         status: "draft",
                         published_at: 1.month.ago

Article.count # => 2
first.archive!
Article.count # => 1
```
> Это приложение обслуживает только не архивированные `Articles`. Представление также допускает условия, при которых можно напрямую исключать архивные `Articles`.

## Основы Active Model <a name="2.8"></a>
### Введение <a name="2.8.1"></a>
#### Методы атрибутов
Модуль `ActiveModel::AttributeMethods` позволяет добавлять различные суффиксы и префиксы к методам класса. Для использования необходимо определить суффиксы, префиксы, а также к каким методам объекта они будут применяться.
```
class Person
  include ActiveModel::AttributeMethods

  attribute_method_prefix 'reset_'
  attribute_method_suffix '_highest?'
  define_attribute_methods 'age'

  attr_accessor :age

  private
    def reset_attribute(attribute)
      send("#{attribute}=", 0)
    end

    def attribute_highest?(attribute)
      send(attribute) > 100
    end
end

person = Person.new
person.age = 110
person.age_highest?  # => true
person.reset_age     # => 0
person.age_highest?  # => false
```
#### Колбэки

Модуль `ActiveModel::Callbacks` дает Active Record возможность использования функций обратного вызова (колбэков). Это позволяет определять колбэки, вызываемые в определенное время. После определения колбэков можно обернуть их дополнительной функциональностью `before`, `after` и `around`, которые позволяют определить момент вызова колбэка "до", "после" и "до и после" вызова нужного метода.
```
class Person
  extend ActiveModel::Callbacks

  define_model_callbacks :update

  before_update :reset_me

  def update
    run_callbacks(:update) do
      # Этот метод вызывается при вызове у обьекта метода update.
    end
  end

  def reset_me
    # Этот метод вызывается при вызове у обьекта метода update, выполнение метода reset_me произойдет до вызова update, т.к он определен как колбэк before_update.
  end
end
```

#### Преобразования
Если для класса определены методы `persisted?` и `id`, то можно добавить модуль `ActiveModel::Conversion` в этот класс и вызывать методы преобразования Rails на объектах этого класса.
```
class Person
  include ActiveModel::Conversion

  def persisted?
    false
  end

  def id
    nil
  end
end

person = Person.new
person.to_model == person  # => true
person.to_key              # => nil
person.to_param            # => nil
```
#### Грязный объект

Объект становится грязным после одного или нескольких изменений его атрибутов, и при этом он не был сохранен. `ActiveModel::Dirty` дает возможность проверить, был ли объект изменен или нет. Также имеются атрибуты на основе акцессор-методов. Представим, что имеется класс Person с атрибутами `first_name` и `last_name`:
```
class Person
  include ActiveModel::Dirty
  define_attribute_methods :first_name, :last_name

  def first_name
    @first_name
  end

  def first_name=(value)
    first_name_will_change!
    @first_name = value
  end

  def last_name
    @last_name
  end

  def last_name=(value)
    last_name_will_change!
    @last_name = value
  end

  def save
    # метод для сохранения изменений...
    changes_applied
  end
end
```
##### Запрашиваем у объекта список всех измененных атрибутов
```
person = Person.new
person.changed? # => false

person.first_name = "First Name"
person.first_name # => "First Name"

# возвращает true, если хотя бы у одного из атрибутов есть несохраненное значение.
person.changed? # => true

# возвращает список атрибутов, которые были изменены до сохранения.
person.changed # => ["first_name"]

# возвращает хэш с измененными атрибутами вместе с их первоначальными значениями.
person.changed_attributes # => {"first_name"=>nil}

# возвращает хэш изменений с именами атрибутов в качестве ключей, и их значений как массива, который содержит старое и новое значение поля.
person.changes # => {"first_name"=>[nil, "First Name"]}
```
##### Атрибуты, основанные на акцессор-методах
Отслеживает, был ли атрибут изменен или нет.
```
# attr_name_changed?
person.first_name # => "First Name"
person.first_name_changed? # => true
```
Отслеживает предыдущее значение атрибута.
```
# акцессор attr_name_was
person.first_name_was # => nil
```
Отслеживает старое и новое значение измененного атрибута. Возвращает массив, если изменяли, в противном случае nil.
```
# attr_name_change
person.first_name_change # => [nil, "First Name"]
person.last_name_change # => nil
```
#### Валидации
Модуль `ActiveModel::Validations` добавляет возможность проверять объекты, как в Active Record.
```
class Person
  include ActiveModel::Validations

  attr_accessor :name, :email, :token

  validates :name, presence: true
  validates_format_of :email, with: /\A([^\s]+)((?:[-a-z0-9]\.)[a-z]{2,})\z/i
  validates! :token, presence: true
end

person = Person.new
person.token = "2b1f325"
person.valid?                        # => false
person.name = 'vishnu'
person.email = 'me'
person.valid?                        # => false
person.email = 'me@vishnuatrai.com'
person.valid?                        # => true
person.token = nil
person.valid?                        # => вызывается ActiveModel::StrictValidationFailed
```
#### Именование
`ActiveModel::Naming` добавляет ряд методов класса, упрощающие управление именованием и роутингом. Модуль определяет метод класса model_name, который определит несколько акцессоров с помощью методов `ActiveSupport::Inflector`.
```
class Person
  extend ActiveModel::Naming
end

Person.model_name.name                # => "Person"
Person.model_name.singular            # => "person"
Person.model_name.plural              # => "people"
Person.model_name.element             # => "person"
Person.model_name.human               # => "Person"
Person.model_name.collection          # => "people"
Person.model_name.param_key           # => "person"
Person.model_name.i18n_key            # => :person
Person.model_name.route_key           # => "people"
Person.model_name.singular_route_key  # => "person"
```
#### Модель
`ActiveModel::Model` добавляет для класса возможность работать из коробки с Action Pack и Action View.
```
class EmailContact
  include ActiveModel::Model

  attr_accessor :name, :email, :message
  validates :name, :email, :message, presence: true

  def deliver
    if valid?
      # отправить электронную почту 
    end
  end
end
```
При включении `ActiveModel::Model` вы получите несколько возможностей, таких как:

    интроспекция имени модели
    преобразования
    переводы
    валидации 

Он также дает возможность инициализировать объект с помощью хэша атрибутов, подобно любому объекту Active Record.
```
email_contact = EmailContact.new(name: 'David',
                                 email: 'david@example.com',
                                 message: 'Hello World')
email_contact.name       # => 'David'
email_contact.email      # => 'david@example.com'
email_contact.valid?     # => true
email_contact.persisted? # => false
```
Любой класс, включающий `ActiveModel::Model`, может быть использован с `form_for`, `render` и любыми другими методами хелпера `Action View`, точно так же, как и объекты `Active Record`.
#### Сериализация
`ActiveModel::Serialization` предоставляет базовую сериализацию для вашего объекта. Вам необходимо объявить хэш, содержащий атрибуты, которые вы хотите сериализовать. Атрибуты должны быть строками, не символами.
```
class Person
  include ActiveModel::Serialization

  attr_accessor :name

  def attributes
    {'name' => nil}
  end
end

Теперь можно получить доступ к сериализованному хэшу вашего объекта с помощью метода serializable_hash.

person = Person.new
person.serializable_hash   # => {"name"=>nil}
person.name = "Bob"
person.serializable_hash   # => {"name"=>"Bob"}
```
##### `ActiveModel::Serializers`
Active Model также предоставляет модуль `ActiveModel::Serializers::JSON` для сериализации/десериализации JSON. Этот модуль автоматически подключает ранее обсужденный модуль `ActiveModel::Serialization`.

###### `ActiveModel::Serializers::JSON`
Для использования `ActiveModel::Serializers::JSON` необходимо только изменить модуль, который вы подключали, с `ActiveModel::Serialization` на `ActiveModel::Serializers::JSON`.
```
class Person
  include ActiveModel::Serializers::JSON

  attr_accessor :name

  def attributes
    {'name' => nil}
  end
end
```
Метод `as_json`, подобно `serializable_hash`, предоставляет хэш, описывающий модель.
```
person = Person.new
person.as_json # => {"name"=>nil}
person.name = "Bob"
person.as_json # => {"name"=>"Bob"}
```
Также можно определить атрибуты для модели из строки JSON. Однако, в классе нужно определить метод `attributes=`:
```
class Person
  include ActiveModel::Serializers::JSON

  attr_accessor :name

  def attributes=(hash)
    hash.each do |key, value|
      send("#{key}=", value)
    end
  end

  def attributes
    {'name' => nil}
  end
end
```
Теперь есть возможность создавать экземпляры Person и устанавливать атрибуты с помощью `from_json`.
```
json = { name: 'Bob' }.to_json
person = Person.new
person.from_json(json) # => #<Person:0x00000100c773f0 @name="Bob">
person.name            # => "Bob"
```
#### Перевод
`ActiveModel::Translation` предоставляет интеграцию между вашим объектом и фреймворком интернационализации Rails (i18n).
```
class Person
  extend ActiveModel::Translation
end
```
С помощью метода `human_attribute_name` можно преобразовывать имена атрибутов в более удобочитаемый формат. Удобочитаемый формат определяется в вашем(-их) файле(-ах) локали.
```
    # config/locales/app.pt-BR.yml 

  pt-BR:
    activemodel:
      attributes:
        person:
          name: 'Nome'

Person.human_attribute_name('name') # => "Nome"
```
#### Тесты совместимости
`ActiveModel::Lint::Tests` позволяет проверить, совместим ли объект с Active Model API.
```
    app/models/person.rb

    class Person
      include ActiveModel::Model
    end

    test/models/person_test.rb

    require 'test_helper'

    class PersonTest < ActiveSupport::TestCase
      include ActiveModel::Lint::Tests

      setup do
        @model = Person.new
      end
    end
```
```
$ rails test

Run options: --seed 14596

# Running:

......

Finished in 0.024899s, 240.9735 runs/s, 1204.8677 assertions/s.

6 runs, 30 assertions, 0 failures, 0 errors, 0 skips
```
Объекту не нужно реализовывать все API, чтобы работать с Action Pack. Этот модуль всего лишь предназначен для предоставления руководства в случае, если вы хотите все особенности из коробки.
#### Безопасный пароль

`ActiveModel::SecurePassword` предоставляет способ безопасно хранить любой пароль в зашифрованном виде. При включении этого модуля предоставляется метод класса `has_secure_password`, определяющий акцессор `password` с определенными валидациями на нем.

##### Требования
`ActiveModel::SecurePassword` зависит от `bcrypt`, поэтому включите этот гем в свой Gemfile для правильного использования `ActiveModel::SecurePassword`. Чтобы он работал, в модели должен быть акцессор с именем `password_digest`. `has_secure_password` добавит следующие валидации на акцессор `password`:
* Пароль должен существовать.
* Пароль должен совпадать с подтверждением (проверяется, если передан `password_confirmation`).
* Максимальная длина пароля 72 (требуется `bcrypt`, от которого зависит `ActiveModel::SecurePassword`) 

#####  Примеры
```
class Person
  include ActiveModel::SecurePassword
  has_secure_password
  attr_accessor :password_digest
end

person = Person.new

# Когда пароль пустой.
person.valid? # => false

# Когда подтверждение не совпадает с паролем.
person.password = 'aditya'
person.password_confirmation = 'nomatch'
person.valid? # => false

# Когда длина пароля превышает 72.
person.password = person.password_confirmation = 'a' * 100
person.valid? # => false

# Когда предоставлен только пароль без password_confirmation.
person.password = 'aditya'
person.valid? # => true

# Когда проходят все валидации.
person.password = person.password_confirmation = 'aditya'
person.valid? # => true
```


# Вьюхи <a name="3"></a>
## Обзор Action View <a name="3.1"></a>
### Что такое Action View? <a name="3.1.1"></a>
В Rails веб-запросы обрабатываются Action Controller и Action View. Обычно Action Controller ответственен за связь с базой данных и выполнение экшнов CRUD. Тогда как Action View ответственен за компиляцию отклика.

Шаблоны Action View пишутся с помощью тегов встроенного Ruby, смешанных с HTML. Чтобы избежать загромождения вьюх шаблонным кодом, общее поведение для форм, дат и строк представлено рядом классов хелпера. В существующее приложение также легко добавлять новые хелперы.

> Некоторые особенности Action View связаны с Active Record, но это не означает, что Action View зависит от Active Record. Action View — это независимый пакет, который можно использовать с любой библиотекой Ruby.
### Использование Action View с Rails <a name="3.1.2"></a>
Для каждого контроллера имеется связанная директория в директории app/views, содержащая файлы шаблонов, которые формируют вьюхи, связанные с этим контроллером. Эти файлы используются для отображения вьюхи, являющейся результатом каждого экшна контроллера.

Давайте взглянем на то, что делает Rails по умолчанию, когда создает новый ресурс с помощью генератора скаффолда:
```
$ rails generate scaffold article
      [...]
      invoke  scaffold_controller
      create    app/controllers/articles_controller.rb
      invoke    erb
      create      app/views/articles
      create      app/views/articles/index.html.erb
      create      app/views/articles/edit.html.erb
      create      app/views/articles/show.html.erb
      create      app/views/articles/new.html.erb
      create      app/views/articles/_form.html.erb
      [...]
```
В Rails имеется соглашение по именованию вьюх. Как правило, имя вьюхи совпадает с соответствующим экшном контроллера, как вы могли видеть выше. Например, экшн index контроллера в `articles_controller.rb` будет использовать файл вьюхи `index.html.erb` в директории` app/views/articles`. Полный HTML, возвращенный клиенту, состоит из комбинации этого файла ERB, шаблона макета, оборачивающего его, и всех партиалов, на которые вьюха может ссылаться.
### Шаблоны, партиалы и макеты <a name="3.1.3"></a>
#### Шаблоны
Шаблоны Action View могут быть написаны несколькими способами. Если у файла шаблона расширение `.erb`, то он использует смесь ERB (Embedded Ruby) и HTML. Если у файла шаблона расширение `.builder`, то используется библиотека `Builder::XmlMarkup`.

Rails поддерживает несколько систем шаблонирования и использует расширение файла, чтобы различать их. Например, файл HTML, использующий систему шаблонирования ERB, будет иметь расширение файла `.html.erb.`
##### ERB
В шаблоне ERB код Ruby может быть включен с помощью тегов `<% %>` и `<%= %>`. Теги `<% %>` используются для выполнения кода Ruby, который ничего не возвращает, такого как условия, циклы или блоки, а теги `<%= %>` используются, когда вам нужен результат выполнения.

Рассмотрим следующий цикл для имен:
```
<h1>Names of all the people</h1>
<% @people.each do |person| %>
  Name: <%= person.name %><br>
<% end %>
```
Цикл настроен с помощью обычных встраиваемых тегов (`<% %>`), а имя вставлено с помощью выводящих встраиваемых тегов (`<%= %>`). Отметьте, что это не просто совет по использованию: обычные функции для вывода, такие как `print` и `puts` не будут рендериться во вьюху в шаблонах ERB. 
Чтобы запретить предварительные и завершающие пробелы можно использовать `<%-` `-%>` вместо `<%` и `%>`.

##### Builder
Шаблоны Builder — это более программная альтернатива ERB. Они особенно полезны для генерации содержимого в XML. Объект `XmlMarkup` с именем `xml` автоматически доступен в шаблонах с расширением `.builder`.

Вот несколько простых примеров:
```
xml.em("emphasized")
xml.em { xml.b("emph & bold") }
xml.a("A Link", "href" => "https://rubyonrails.org")
xml.target("name" => "compile", "option" => "fast")
```
которые создадут:
```
<em>emphasized</em>
<em><b>emph &amp; bold</b></em>
<a href="https://rubyonrails.org">A link</a>
<target option="fast" name="compile" />
```
Любой метод с блоком будет трактован как разметка тега XML с вложенной разметкой в блоке. Например, следующее:
```
xml.div {
  xml.h1(@person.name)
  xml.p(@person.bio)
}
```
создаст что-то вроде:
```
<div>
  <h1>David Heinemeier Hansson</h1>
  <p>A product of Danish Design during the Winter of '79...</p>
</div>
```
Ниже приведен полноценный пример RSS, фактически используемый в Basecamp:
```
xml.rss("version" => "2.0", "xmlns:dc" => "http://purl.org/dc/elements/1.1/") do
  xml.channel do
    xml.title(@feed_title)
    xml.link(@url)
    xml.description "Basecamp: Recent items"
    xml.language "en-us"
    xml.ttl "40"

    for item in @recent_items
      xml.item do
        xml.title(item_title(item))
        xml.description(item_description(item)) if item_description(item)
        xml.pubDate(item_pubDate(item))
        xml.guid(@person.firm.account.url + @recent_items.url(item))
        xml.link(@person.firm.account.url + @recent_items.url(item))
        xml.tag!("dc:creator", item.author_name) if item_has_creator?(item)
      end
    end
  end
end
```
##### Jbuilder
`Jbuilder` — это гем, поддерживаемый командой Rails и включенный в Rails `Gemfile` по умолчанию. Он похож на Builder, но используется для генерации JSON вместо XML.
Если у вас его нет, можно добавить следующее в Gemfile:
```
gem 'jbuilder'
```
Объект Jbuilder с именем json автоматически становится доступным в шаблонах с расширением `.jbuilder`.

Вот простой пример:
```
json.name("Alex")
json.email("alex@example.com")
```
что создаст:
```
{
  "name": "Alex",
  "email": "alex@example.com"
}
```
##### Кэширование шаблонов
По умолчанию Rails компилирует каждый шаблон в метод перед тем, как рендерить его. Когда вы измените шаблон в режиме `development`, Rails проверит время модификации файла и перекомпилирует его.

#### Партиалы
Частичные шаблоны - обычно называемые "партиалы" - это другая схема разделения процесса рендеринга на более управляемые части. С помощью партиалов можно извлечь части кода из ваших шаблонов в отдельные файлы, а также повторно использовать их в разных шаблонах.

##### Именование партиалов
Чтобы отрендерить партиал как часть вьюхи, в ней используется метод `render`:
```
<%= render "menu" %>
```
Это отрендерит файл с именем `_menu.html.erb` во вьюхе, которая рендерится. Обратите внимание на первый символ подчеркивания: партиалы именуются, начинаясь с подчеркивания, чтобы отличить их от обычных вьюх, хотя к ним и обращаются без подчеркивания. Это истинно, даже если вы вставляете партиал из другой директории:
```
<%= render "shared/menu" %>
```
Этот код вставит партиал из `app/views/shared/_menu.html.erb`.

##### Использование партиалов для упрощения вьюх
Одним из способов использования партиалов является трактовка их как эквивалента подпрограмм; способ выноса части разметки из вьюхи, чтобы можно было проще понять, что происходит. Например, у вас может быть такая вьюха:
```
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>

<%= render "shared/footer" %>
```
Здесь партиалы `_ad_banner.html.erb` и `_footer.html.erb` могут содержать контент, общий для многих страниц приложения. Нет необходимости видеть код этих разделов, чтобы сконцентрироваться на определенной странице.

##### `render` без опций `partial` и `locals`
В вышеприведенном примере render принимает 2 опции: `partial` и `locals`. Но если это единственные опции, которые нужно передать, их можно опустить. Например, вместо:
```
<%= render partial: "product", locals: { product: @product } %>
```
Можно сделать:
```
<%= render "product", product: @product %>
```

##### Опции `as` и `object`
По умолчанию у `ActionView::Partials::PartialRenderer` есть собственный объект в локальной переменной с тем же именем, как у шаблона. Так, если имеем:
```
<%= render partial: "product" %>
```
в партиале `_product` мы получим `@product` в локальной переменной `product`, как будто мы написали:
```
<%= render partial: "product", locals: { product: @product } %>
```
Опцию `object` можно использовать, чтобы непосредственно указать, какой объект рендерится в партиале; полезно, когда объект шаблона находится где-то еще (например, в другой переменной экземпляра или в локальной переменной).

Например, вместо:
```
<%= render partial: "product", locals: { product: @item } %>
```
можно сделать:
```
<%= render partial: "product", object: @item %>
```
С помощью опции as можно указать другое имя для данной локальной переменной. Например, если нам нужно, чтобы оно было `item` вместо `product`, мы сделаем:
```
<%= render partial: "product", object: @item, as: "item" %>
```
Это эквивалентно:
```
<%= render partial: "product", locals: { item: @item } %>
```
#####  Рендеринг коллекций
Часто бывает, что шаблону нужно пройтись по коллекции и отрендерить подшаблон для каждого элемента. Этот паттерн был реализован как отдельный метод, принимающий массив и рендерящий партиал для каждого элемента массива.

Поэтому такой пример для рендеринга всех продуктов:
```
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>
```
может быть переписан с помощью одной строчки:
```
<%= render partial: "product", collection: @products %>
```
Когда партиал вызывается с коллекцией, у отдельных экземпляров партиала есть доступ к рендерящемуся члену коллекции через переменную с именем партиала. В данном случае партиалом является `_product`, и внутри него можно обратиться к `product`, чтобы получить член коллекции, который будет отрендерен.

Для рендеринга коллекций можно использовать сокращенный синтаксис. Предположим, `@products` — это коллекция экземпляров `Product`, тогда можно просто написать следующее, чтобы получить тот же самый результат:
```
<%= render @products %>
```
Rails определяет имя используемого партиала по имени модели в коллекции, в данном случае `Product`. Фактически с помощью этого сокращенного синтаксиса можно рендерить коллекцию, состоящую из экземпляров различных моделей, и Rails выберет подходящий партиал для каждого члена коллекции.

##### Разделяющие шаблоны
Также можете определить второй партиал, который будет отрендерен между экземплярами главного партиала, используя опцию `:spacer_template`:
```
<%= render partial: @products, spacer_template: "product_ruler" %>
```
Rails отрендерит партиал `_product_ruler` (без переданных в него данных) между каждой парой партиалов `_product`.

##### Макеты
Макеты могут быть использованы для рендеринга общего шаблона вьюхи вокруг результатов экшна контроллера Rails. Обычно в приложении Rails несколько макетов, в которых будут рендериться страницы. Например, на сайте может быть один макет для авторизованного пользователя и другой для маркетинга или продаж. Макет для авторизованного пользователя может включать навигацию верхнего уровня, которая должна присутствовать во многих экшнах контроллера. Макет для продаж для приложения SaaS может включать верхнеуровневую навигацию для таких, скажем, страниц как "Pricing" и "Contact Us". Ожидается, что каждый макет должен выглядеть по разному.

### Макеты партиалов <a name="3.1.4"></a>
У партиалов могут быть собственные макеты, применимые к ним. Эти макеты отличаются от тех, которые применяются к экшну контроллера, хотя они работают подобным образом.

Допустим, мы отображаем статью на странице, которая должна быть обернута в `div`, с целью отображения ее как блочный элемент. Сначала мы создадим новую `Article`:
```
Article.create(body: 'Partial Layouts are cool!')
```
В шаблоне `show` мы отрендерим партиал `_article`, обернутый в макет `box`:
```
articles/show.html.erb

<%= render partial: 'article', layout: 'box', locals: { article: @article } %>
```
Макет box просто оборачивает партиал `_article` в `div`:
```
articles/_box.html.erb

<div class='box'>
  <%= yield %>
</div>
```
Отметьте, что у макета партиала есть доступ к локальной переменной `article`, переданной в вызов `render`. Однако, в отличие от макетов приложения, макеты партиалов должны начинаться с подчеркивания.

Также можно отрендерить блок кода в макете партиала вместо вызова `yield`. Например, если у нас нет партиала `_article`, вместо него можно использовать это:
```
articles/show.html.erb

<% render(layout: 'box', locals: { article: @article }) do %>
  <div>
    <p><%= article.body %></p>
  </div>
<% end %>
```
Предположив, что мы используем тот же партиал `_box`, мы получим тот же результат, что и в предыдущем примере.

### Пути вьюх <a name="3.1.5"></a>
При рендеринге отклика контроллер должен решить, где располагаются различные вьюхи. По умолчанию он смотрит только в директории `app/views`.

Мы можем добавить другие места расположения и дать им некий приоритет при определении путей с помощью методов `prepend_view_path` и `append_view_path`.

#### `Prepend view path`
Метод может быть полезным, например, когда мы хотим поместить вьюхи в разные директории для поддоменов.
Мы можем сделать это используя:
```
prepend_view_path "app/views/#{request.subdomain}"
```
Тогда Action View при поиске нужной вьюхи будет искать сначала в этой директории.

#### `Append view path`

Аналогично, мы можем добавить путь:
```
append_view_path "app/views/direct"
```
Это добавит путь `app/views/direct` в конец поиска путей.

### Обзор хелперов, предоставленных Action View <a name="3.1.6"></a>
Тут перечислены не все хелперы.

#### AssetTagHelper
Этот модуль предоставляет методы для генерации HTML, связывающего вьюхи с ресурсами, такими как картинки, файлы JavaScript, таблицы стилей и новостные ленты.

По умолчанию Rails связывается с этими ресурсами на текущем хосте в папке `public`, но можно заставить Rails связываться с ресурсами на выделенном сервере ресурсов, установив `config.action_controller.asset_host` в конфигурации приложения, обычно в `config/environments/production.rb`. Например, допустим хост ваших ресурсов `assets.example.com`:
```
config.action_controller.asset_host = "assets.example.com"
image_tag("rails.png") # => <img src="http://assets.example.com/images/rails.png" />
```

##### `auto_discovery_link_tag`
Возвращает тег ссылки, которую могут использовать браузеры и агрегаторы новостей для автоматического определения RSS, Atom или ленты JSON.
```
auto_discovery_link_tag(:rss, "http://www.example.com/feed.rss", { title: "RSS Feed" }) # =>
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://www.example.com/feed" />
```

##### `image_path`
Вычисляет путь до ресурса картинки в директории app/assets/images. Будут переданы полные пути от корня документа. Используется внутри `image_tag` для создания пути к картинке.
```
image_path("edit.png") # => /assets/edit.png
```
К имени файла будет добавлена метка, если `config.assets.digest` установлен в `true`.
```
image_path("edit.png") # => /assets/edit-2d1a2db63fc738690021fedb5a65b68e.png
```

##### `image_url`
Вычисляет URL ресурса картинки в директории `app/assets/images`. Он вызовет `image_path` и соединит с вашим текущим хостом или вашим хостом ресурсов.
```
image_url("edit.png") # => http://www.example.com/assets/edit.png
```

##### `image_tag`
Возвращает тег картинки HTML для источника. Источником может быть полный путь или файл, существующий в директории `app/assets/images`.
```
image_tag("icon.png") # => <img src="/assets/icon.png" />
```

##### `javascript_include_tag`
Возвращает HTML-тег script для каждого предоставленного источника. Можно передать имя файла (расширение `.js` опционально) или файлы JavaScript, существующие в директории `app/assets/javascripts` для включения в текущую страницу, или передать полный путь относительно корня документа.
```
javascript_include_tag "common" # => <script src="/assets/common.js"></script>
```

##### `javascript_path`
Вычисляет путь до ресурса JavaScript в директории `app/assets/javascripts`. Если у имени файла источника нет расширения, будет добавлено `.js`. Будут переданы полные пути от корня документа. Используется внутри `javascript_include_tag` для создания пути к скрипту.
```
javascript_path "common" # => /assets/common.js
```
##### `javascript_url`
Вычисляет URL ресурса JavaScript в директории `app/assets/javascripts`. Он вызовет `javascript_path` и соединит с вашим текущим хостом или вашим хостом ресурсов.
```
javascript_url "common" # => http://www.example.com/assets/common.js
```

##### `stylesheet_link_tag`
Возвращает тег `link` на таблицу стилей для источников, указанных в качестве аргументов. Если не указать расширение, автоматически будет добавлено `.css`.
```
stylesheet_link_tag "application" # => <link href="/assets/application.css" media="screen" rel="stylesheet" />
```
##### `stylesheet_path`
Вычисляет путь до ресурса таблицы стилей в директории `app/assets/stylesheets`. Если у имени файла источника нет расширения, будет добавлено `.css`. Будут переданы полные пути от корня документа. Используется внутри `stylesheet_link_tag` для создания пути к таблице стилей.
```
stylesheet_path "application" # => /assets/application.css
```
##### `stylesheet_url`
Вычисляет URL ресурса таблицы стилей в директории `app/assets/stylesheets`. Он вызовет `stylesheet_path` и соединит с вашим текущим хостом или вашим хостом ресурсов.
```
stylesheet_url "application" # => http://www.example.com/assets/application.css
```

#### AtomFeedHelper
##### `atom_feed`
Этот хелпер позволяет с легкостью создать новостную ленту Atom. Вот пример полного использования:
```
config/routes.rb

resources :articles

app/controllers/articles_controller.rb

def index
  @articles = Article.all

  respond_to do |format|
    format.html
    format.atom
  end
end

app/views/articles/index.atom.builder

atom_feed do |feed|
  feed.title("Articles Index")
  feed.updated(@articles.first.created_at)

  @articles.each do |article|
    feed.entry(article) do |entry|
      entry.title(article.title)
      entry.content(article.body, type: 'html')

      entry.author do |author|
        author.name(article.author_name)
      end
    end
  end
end
```
#### BenchmarkHelper
##### `benchmark`
Позволяет измерить время выполнения блока в шаблоне и записать результат в лог. Оберните этот блок вокруг затратных операций или потенциальных узких мест, чтобы получить время чтения для операций.
```
<% benchmark "Process data files" do %>
  <%= expensive_files_operation %>
<% end %>
```
Это добавит в лог что-то вроде `"Process data files (0.34523)"`, затем это можно использовать для сравнения времени при оптимизации кода.

#### CacheHelper
##### `cache`
Метод для кэширования фрагмента вьюхи, а не всего экшна или страницы. Эта техника полезна для кэширования таких кусочков, как меню, списки заголовков новостей, статичные фрагменты HTML и так далее. Этот метод принимает блок, содержащий код, который вы хотите закэшировать. Подробности смотрите в `AbstractController::Caching::Fragments`.
```
<% cache do %>
  <%= render "shared/footer" %>
<% end %>
```

#### CaptureHelper
##### `capture`
Метод capture позволяет извлечь часть шаблона в переменную. Эту переменную потом можно использовать в любом месте шаблона или макета.
```
<% @greeting = capture do %>
  <p>Welcome! The date and time is <%= Time.now %></p>
<% end %>
```
Захваченная переменная может быть потом где-то использована.
```
<html>
  <head>
    <title>Welcome!</title>
  </head>
  <body>
    <%= @greeting %>
  </body>
</html>
```

##### `content_for`
Вызов `content_for` хранит блок разметки как идентификатор для дальнейшего использования. Можно совершать последующие вызовы сохраненного содержимого в других шаблонах или макете, передав идентификатор в качестве аргумента в `yield`.

Например, допустим у нас есть стандартный макет приложения, но также есть специальная страница, требующая определенный JavaScript, который не требуется в остальных частях сайта. Можно использовать `content_for`, чтобы включить этот JavaScript на нашу специальную страницу без влияния на оставшуюся часть сайта.

`app/views/layouts/application.html.erb`
```
<html>
  <head>
    <title>Welcome!</title>
    <%= yield :special_script %>
  </head>
  <body>
    <p>Welcome! The date and time is <%= Time.now %></p>
  </body>
</html>
```
`app/views/articles/special.html.erb`
```
<p>This is a special page.</p>

<% content_for :special_script do %>
  <script>alert('Hello!')</script>
<% end %>
```

#### DateHelper
##### `date_select`
Возвращает набор тегов `select` (по одному для года, месяца и дня), предзаполненных для доступа к определенному атрибуту даты.
```
date_select("article", "published_on")
```
##### `datetime_select`
Возвращает набор тегов `select` (по одному для года, месяца, дня, часа и минуты), предзаполненных для доступа к определенному атрибуту даты-времени.
```
datetime_select("article", "published_on")
```
##### `distance_of_time_in_words`

Возвращает приблизительный промежуток времени между двумя объектами `Time` или `Date`, или целыми числами в секундах. Установите `include_seconds` в `true`, если хотите более детальное приближение.
```
distance_of_time_in_words(Time.now, Time.now + 15.seconds)        # => less than a minute
distance_of_time_in_words(Time.now, Time.now + 15.seconds, include_seconds: true)  # => less than 20 seconds
```

##### `select_date`
Возвращает набор HTML-тегов `select` (по одному для года, месяца и дня), предзаполненных предоставленной `date`.
```
# Создает select для date, который по умолчанию соответствует предоставленной дате (шесть дней, начиная с сегодняшнего)
select_date(Time.today + 6.days)

# Создает select для date, который по умолчанию соответствует сегодняшней дате (без аргумента)
select_date()
```

##### `select_datetime`
Возвращает набор HTML-тегов `select` (по одному для года, месяца, дня, часа и минуты), предзаполненных предоставленным `datetime`.
```
# Создает select для datetime, который по умолчанию соответствует предоставленной дате (четыре дня, начиная с сегодняшнего)
select_datetime(Time.now + 4.days)

# Создает select для datetime, который по умолчанию соответствует сегодняшней дате (без аргумента)
select_datetime()
```

##### `select_day`
Возвращает тег `select` с опциями для каждого дня с 1 по 31 и выбранным текущим днем.
```
# Создает поле select для дней с предоставленной датой как значение по умолчанию
select_day(Time.today + 2.days)

# Создает поле select для дней с данным числом как значение по умолчанию
select_day(5)
```
##### `select_hour`
Возвращает тег `select` с опциями для каждого часа с 0 по 23 и выбранным текущим часом.
```
# Создает поле select для часов с предоставленным временем как значение по умолчанию
select_hour(Time.now + 6.hours)
```

##### `select_minute`
Возвращает тег `select` с опциями для каждой минуты с 0 по 59 и выбранной текущей минутой.
```
# Создает поле select для минут с предоставленным временем как значение по умолчанию
select_minute(Time.now + 10.minutes)
```

##### `select_month`
Возвращает тег `select` с опциями для каждого месяца с January по December и выбранным текущим месяцем.
```
# Создает поле select для месяцев с текущим месяцем как значение по умолчанию
select_month(Date.today)
```

##### `select_second`
Возвращает тег `select` с опциями для каждой секунды с 0 по 59 и выбранной текущей секундой.
```
# Создает поле select для секунд с предоставленным временем как значение по умолчанию
select_second(Time.now + 16.seconds)
```

##### `select_time`
Возвращает набор тегов HTML `select` (по одному для часа и минуты).
```
# Создает поля select с предоставленным временем как значение по умолчанию
select_time(Time.now)
```

##### `select_year`
Возвращает тег `select` с опциями для каждого года из пяти от и до выбранного текущего. Пятилетний радиус может быть изменен с помощью опциональных ключей `:start_year` и `:end_year`.
```
# Создает поле select для пяти лет в обе стороны от Date.today, являющаяся значением по умолчанию для текущего года
select_year(Date.today)

# Создает поле select от 1900 до 2016 с текущим годом как значение по умолчанию
select_year(Date.today, start_year: 1900, end_year: 2016)
```

##### `time_ago_in_words`
Подобен `distance_of_time_in_words`, где `to_time` устанавливается `Time.now`.
```
time_ago_in_words(3.minutes.from_now)  # => 3 minutes
```

##### `time_select`
Возвращает набор тегов `select` (по одному для часа, минуты и, опционально, секунды), предзаполненных для доступа к определенному атрибуту времени. Этот набор подготовлен для назначения нескольких параметров в объекте Active Record.
```
# Создает тег select для времени, который при POST будет сохранен в переменную order атрибута submitted
time_select("order", "submitted")
```

#### DebugHelper
Возвращает тег `pre` с объектом, выгруженным в YAML. Это создает удобочитаемый способ проверки объекта.
```
my_hash = { 'first' => 1, 'second' => 'two', 'third' => [1,2,3] }
debug(my_hash)

<pre class='debug_dump'>---
first: 1
second: two
third:
- 1
- 2
- 3
</pre>
```

#### FormHelper
Хелперы форм предназначены для упрощения работы с моделями по сравнению с использованием только стандартных элементов HTML, предоставляя набор методов для создания форм на основе ваших моделей. Этот хелпер создает HTML для форм, предоставляя метод для каждого типа полей ввода (например `text`, `password`, `select` и так далее). Когда форма подтверждается (т.е. когда пользователь нажимает кнопку подтверждения или `form.submit`, вызывается в JavaScript), поля ввода формы будут объединены в объект params и переданы в контроллер.

Существует два типа хелперов форм: те, которые работают с атрибутами модели, и те, которые нет. Этот хелпер относится к тем, которые работают с атрибутами модели; чтобы посмотреть примеры хелперов форм, которые не работают с атрибутами модели, обратитесь к документации `ActionView::Helpers::FormTagHelper`.

Основной метод этого хелпера, `form_for`, дает возможность создавать форму для экземпляра модели; например, допустим, что имеется модель `Person`, и мы хотим создать ее новый экземпляр:
```
# Note: переменная @person была создана в контроллере (т.е. @person = Person.new)
<%= form_for @person, url: { action: "create" } do |f| %>
  <%= f.text_field :first_name %>
  <%= f.text_field :last_name %>
  <%= submit_tag 'Create' %>
<% end %>
```
Созданным HTML будет:
```
<form class="new_person" id="new_person" action="/people" accept-charset="UTF-8" method="post">
  <input name="utf8" type="hidden" value="&#x2713;" />
  <input type="hidden" name="authenticity_token" value="lTuvBzs7ANygT0NFinXj98tfw3Emfm65wwYLbUvoWsK2pngccIQSUorM2C035M9dZswXgWTvKwFS8W5TVblpYw==" />
  <input type="text" name="person[first_name]" id="person_first_name" />
  <input type="text" name="person[last_name]" id="person_last_name" />
  <input type="submit" name="commit" value="Create" data-disable-with="Create" />
</form>
```
Объект params, созданный при отправке этой формы, будет выглядеть так:
```
{"utf8" => "✓", "authenticity_token" => "lTuvBzs7ANygT0NFinXj98tfw3Emfm65wwYLbUvoWsK2pngccIQSUorM2C035M9dZswXgWTvKwFS8W5TVblpYw==", "person" => {"first_name" => "William", "last_name" => "Smith"}, "commit" => "Create", "controller" => "people", "action" => "create"}
```
В хэше params будет вложенное значение `person`, к которому можно получить доступ в контроллере с помощью `params[:person]`.

##### `check_box`
Возвращает тег чекбокса с учетом доступа к определенному атрибуту.
```
# Допустим, что @article.validated? равен 1:
check_box("article", "validated")
# => <input type="checkbox" id="article_validated" name="article[validated]" value="1" />
#    <input name="article[validated]" type="hidden" value="0" />
```
##### `fields_for`
Создает пространство имен вокруг определенного объекта модели наподобие `form_for`, но не создает сами теги формы. Это делает `fields_for` подходящим для указания дополнительных объектов модели в той же форме:
```
<%= form_for @person, url: { action: "update" } do |person_form| %>
  First name: <%= person_form.text_field :first_name %>
  Last name : <%= person_form.text_field :last_name %>

  <%= fields_for @person.permission do |permission_fields| %>
    Admin?  : <%= permission_fields.check_box :admin %>
  <% end %>
<% end %>
```
##### `file_field`
Возвращает поле для загрузки файла с учетом доступа к определенному атрибуту.
```
file_field(:user, :avatar)
# => <input type="file" id="user_avatar" name="user[avatar]" />
```
##### `form_for`
Создает форму и пространство имен вокруг определенного объекта модели, используемого как основа для опроса значений полей.
```
<%= form_for @article do |f| %>
  <%= f.label :title, 'Title' %>:
  <%= f.text_field :title %><br>
  <%= f.label :body, 'Body' %>:
  <%= f.text_area :body %><br>
<% end %>
```
##### `hidden_field`
Возвращает тег скрытого поля с учетом доступа к определенному атрибуту.
```
hidden_field(:user, :token)
# => <input type="hidden" id="user_token" name="user[token]" value="#{@user.token}" />
```
#####  `label`
Возвращает тег `label` с учетом поля ввода для определенного атрибута.
```
label(:article, :title)
# => <label for="article_title">Title</label>
```
##### `password_field`
Возвращает тег `input` типа "password" с учетом доступа к определенному атрибуту.
```
password_field(:login, :pass)
# => <input type="text" id="login_pass" name="login[pass]" value="#{@login.pass}" />
```
##### `radio_button`
Возвращает тег радио кнопки с учетом доступа к определенному атрибуту.
```
# Let's say that @article.category returns "rails":
radio_button("article", "category", "rails")
radio_button("article", "category", "java")
# => <input type="radio" id="article_category_rails" name="article[category]" value="rails" checked="checked" />
#    <input type="radio" id="article_category_java" name="article[category]" value="java" />
```
##### `text_area`
Возвращает набор открывающего и закрывающего тега `textarea` с учетом доступа к определенному атрибуту.
```
text_area(:comment, :text, size: "20x30")
# => <textarea cols="20" rows="30" id="comment_text" name="comment[text]">
#      #{@comment.text}
#    </textarea>
```

##### `text_field`
Возвращает тег `input` типа "text" с учетом доступа к определенному атрибуту.
```
text_field(:article, :title)
# => <input type="text" id="article_title" name="article[title]" value="#{@article.title}" />
```

##### `email_field`
Возвращает тег `input` типа "email" с учетом доступа к определенному атрибуту.
```
email_field(:user, :email)
# => <input type="email" id="user_email" name="user[email]" value="#{@user.email}" />
```

##### `url_field`
Возвращает тег `input` типа "url" с учетом доступа к определенному атрибуту.
```
url_field(:user, :url)
# => <input type="url" id="user_url" name="user[url]" value="#{@user.url}" />
```

#### FormOptionsHelper
Предоставляет ряд методов для превращения различного рода контейнеров в набор тегов `option`.

##### `collection_select`
Возвращает теги `select` и `option` для коллекции значений, возвращаемых `method` для класса `object`.

Пример структуры объекта для использования с этим методом:
```
class Article < ApplicationRecord
  belongs_to :author
end

class Author < ApplicationRecord
  has_many :articles
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
```
Пример использования (выбор связанного `Author` для экземпляра `Article, @article`):
```
collection_select(:article, :author_id, Author.all, :id, :name_with_initial, { prompt: true })
```
Если `@article.author_id` — 1, это вернет:
```
<select name="article[author_id]">
  <option value="">Please select</option>
  <option value="1" selected="selected">D. Heinemeier Hansson</option>
  <option value="2">D. Thomas</option>
  <option value="3">M. Clark</option>
</select>
```

##### `collection_radio_buttons`
Возвращает теги `radio_button` для коллекции значений, возвращаемых `method` для класса `object`.

Пример структуры объекта для использования с этим методом:
```
class Article < ApplicationRecord
  belongs_to :author
end

class Author < ApplicationRecord
  has_many :articles
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
```
Пример использования (выбор связанного Author для экземпляра `Article, @article`):
```
collection_radio_buttons(:article, :author_id, Author.all, :id, :name_with_initial)
```
Если `@article.author_id` — 1, это вернет:
```
<input id="article_author_id_1" name="article[author_id]" type="radio" value="1" checked="checked" />
<label for="article_author_id_1">D. Heinemeier Hansson</label>
<input id="article_author_id_2" name="article[author_id]" type="radio" value="2" />
<label for="article_author_id_2">D. Thomas</label>
<input id="article_author_id_3" name="article[author_id]" type="radio" value="3" />
<label for="article_author_id_3">M. Clark</label>
```
Раскрыть, что некоторый вариант выбран (т.е. программно отметить объект из коллекции):
```
collection_radio_buttons(:article, :author_id, Author.all, :id, :name_with_initial, {checked: Author.last})
```
В этом случае, последний объект из коллекции будет отмечен:
```
<input id="article_author_id_1" name="article[author_id]" type="radio" value="1" />
<label for="article_author_id_1">D. Heinemeier Hansson</label>
<input id="article_author_id_2" name="article[author_id]" type="radio" value="2" />
<label for="article_author_id_2">D. Thomas</label>
<input id="article_author_id_3" name="article[author_id]" type="radio" value="3" checked="checked" />
<label for="article_author_id_3">M. Clark</label>
```
Чтобы программно получить доступ к переданным опциям (например, добавить пользовательский класс, если отмечен):

Образец `html.erb`
```
<%= collection_radio_buttons(:article, :author_id, Author.all, :id, :name_with_initial, {checked: Author.last, required: rue} do |rb| %>
      <%= rb.label(class: "#{'my-custom-class' if rb.value == Author.last.id}") { rb.radio_button + rb.text } %>
<% end %>
```
##### `collection_check_boxes`
Возвращает теги `check_box` для коллекции значений, возвращаемых `method` для класса `object`.

Пример структуры объекта для использования с этим методом:
```
class Article < ApplicationRecord
  has_and_belongs_to_many :authors
end

class Author < ApplicationRecord
  has_and_belongs_to_many :articles
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
```
Пример использования (выбор связанного `Author` для экземпляра `Article, @article`):
```
collection_check_boxes(:article, :author_ids, Author.all, :id, :name_with_initial)
```
Если `@article.author_id` — [1], это вернет:
```
<input id="article_author_ids_1" name="article[author_ids][]" type="checkbox" value="1" checked="checked" />
<label for="article_author_ids_1">D. Heinemeier Hansson</label>
<input id="article_author_ids_2" name="article[author_ids][]" type="checkbox" value="2" />
<label for="article_author_ids_2">D. Thomas</label>
<input id="article_author_ids_3" name="article[author_ids][]" type="checkbox" value="3" />
<label for="article_author_ids_3">M. Clark</label>
<input name="article[author_ids][]" type="hidden" value="" />
```

##### `option_groups_from_collection_for_select`
Возвращает строку с тегами `option`, подобно `options_from_collection_for_select`, но группирует их тегами optgroup на основе объектных отношений аргументов.

Пример структуры объекта для использования с этим методом:
```
class Continent < ApplicationRecord
  has_many :countries
  # attribs: id, name
end

class Country < ApplicationRecord
  belongs_to :continent
  # attribs: id, name, continent_id
end
```
Пример использования:
```
option_groups_from_collection_for_select(@continents, :countries, :name, :id, :name, 3)
```
Возможный результат:
```
<optgroup label="Africa">
  <option value="1">Egypt</option>
  <option value="4">Rwanda</option>
  ...
</optgroup>
<optgroup label="Asia">
  <option value="3" selected="selected">China</option>
  <option value="12">India</option>
  <option value="5">Japan</option>
  ...
</optgroup>
```
Возвращаются только теги `optgroup` и `option`, вам все еще нужно обернуть результат в подходящий тег `select`.

##### `options_for_select`
Принимает контейнер (хэш, массив, перечисление, ваш тип) и возвращает строку тегов `option`.
```
options_for_select([ "VISA", "MasterCard" ])
# => <option>VISA</option> <option>MasterCard</option>
```
Возвращаются только теги `option`, вам все еще нужно обернуть результат в обычный HTML-тег `select`.

##### `options_from_collection_for_select`
Возвращает строку тегов option, собранную с помощью итерации по collection и назначая результат вызова value_method как значение option и text_method как текст option.

##### options_from_collection_for_select(collection, value_method, text_method, selected = nil)

Например, представим цикл, проходящий по каждому человеку в `@project.people` для создания тега ввода:
```
options_from_collection_for_select(@project.people, "id", "name")
# => <option value="#{person.id}">#{person.name}</option>
```
> Возвращаются только теги `option`, вам все еще нужно обернуть результат в обычный HTML-тег `select`.

##### `select`
Создает тег `select` и ряд связанных тегов option для предоставленного объекта и метода.

Пример:
```
select("article", "person_id", Person.all.collect { |p| [ p.name, p.id ] }, { include_blank: true })
```
Если `@article.person_id` — 1, это выдаст:
```
<select name="article[person_id]">
  <option value=""></option>
  <option value="1" selected="selected">David</option>
  <option value="2">Eileen</option>
  <option value="3">Rafael</option>
</select>
```
##### `time_zone_options_for_select`
Возвращает строку тегов `option` для практически любой временной зоны в мире.

##### `time_zone_select`
Возвращает теги `select` и `option` для заданного объекта и метода, используя `time_zone_options_for_select` для создания списка тегов `option`.
```
time_zone_select("user", "time_zone")
```

##### `date_field`
Возвращает тег `input` типа "date" с учетом доступа к определенному атрибуту.
```
date_field("user", "dob")
```

#### FormTagHelper
Предоставляет ряд методов для создания тегов форм, которые не зависят от объекта Active Record, назначенного шаблону, как делает `FormHelper`. Вместо этого вы предоставляете вручную имена и значения

##### `check_box_tag`
Создает тег поля ввода формы в виде чекбокса.
```
check_box_tag 'accept'
# => <input id="accept" name="accept" type="checkbox" value="1" />
```

##### `field_set_tag`
Создает `fieldset` для группировки элементов формы HTML.
```
<%= field_set_tag do %>
  <p><%= text_field_tag 'name' %></p>
<% end %>
# => <fieldset><p><input id="name" name="name" type="text" /></p></fieldset>
```

##### `file_field_tag`
Создает поле для загрузки файла.
```
<%= form_tag({ action:"post" }, multipart: true) do %>
  <label for="file">File to Upload</label> <%= file_field_tag "file" %>
  <%= submit_tag %>
<% end %>
```
Примерный результат:
```
file_field_tag 'attachment'
# => <input id="attachment" name="attachment" type="file" />
```

##### `form_tag`
Открывает тег `form`, указывающий `action` по URL-адресу, настроенный с помощью `url_for_options`, как `ActionController::Base#url_for`.
```
<%= form_tag '/articles' do %>
  <div><%= submit_tag 'Save' %></div>
<% end %>
# => <form action="/articles" method="post"><div><input type="submit" name="submit" value="Save" /></div></form>
```

##### `hidden_field_tag`
Создает скрытое поле `input`, используемое для передачи данных, которые будут потеряны из-за протокола без сохранения состояния HTTP, или данные, которые должны быть скрыты от пользователя.
```
hidden_field_tag 'token', 'VUBJKB23UIVI1UU1VOBVI@'
# => <input id="token" name="token" type="hidden" value="VUBJKB23UIVI1UU1VOBVI@" />
```

##### `image_submit_tag`
Отображает изображение, при нажатии на которое будет отправлена форма.
```
image_submit_tag("login.png")
# => <input src="/images/login.png" type="image" />
```

##### `label_tag`
Создает тег `label`.
```
label_tag 'name'
# => <label for="name">Name</label>
```

##### `password_field_tag`
Создает поле для ввода пароля, скрытое текстовое поле, которое спрячет то, что вводит пользователь символами маски.
```
password_field_tag 'pass'
# => <input id="pass" name="pass" type="password" />
```

##### `radio_button_tag`
Создает радиокнопку; используйте группу радиокнопок с одинаковым именем, чтобы пользователи могли выбирать из группы опций.
```
radio_button_tag 'favorite_color', 'maroon'
# => <input id="favorite_color_maroon" name="favorite_color" type="radio" value="maroon" />
```
##### `select_tag`
Создает выпадающий список.
```
select_tag "people", "<option>David</option>"
# => <select id="people" name="people"><option>David</option></select>
```
##### `submit_tag`
Создает кнопку для отправки формы с текстом-заголовком.
```
submit_tag "Publish this article"
# => <input name="commit" type="submit" value="Publish this article" />
```
##### `text_area_tag`
Создает область ввода текста; используйте `textarea` для длинного ввода текста, такого как статьи в блоге или описания.
```
text_area_tag 'article'
# => <textarea id="article" name="article"></textarea>
```
##### `text_field_tag`

Создает стандартное поле ввода текста; используйте их для ввода небольших кусочков текста, таких как имя пользователя или поисковый запрос.
```
text_field_tag 'name'
# => <input id="name" name="name" type="text" />
```
##### `email_field_tag`
Создает стандартное поле ввода с типом `email`.
```
email_field_tag 'email'
# => <input id="email" name="email" type="email" />
```
##### `url_field_tag`
Создает стандартное поле ввода с типом `url`.
```
url_field_tag 'url'
# => <input id="url" name="url" type="url" />
```
##### `date_field_tag`
Создает стандартное поле ввода с типом `date`.
```
date_field_tag "dob"
# => <input id="dob" name="dob" type="date" />
```

#### JavaScriptHelper
Предоставляет функциональность для работы с JavaScript в ваших вьюхах.

##### `escape_javascript`
Экранирует переводы строк и одиночные и двойные кавычки во фрагментах JavaScript.

##### `javascript_tag`
Возвращает тег JavaScript, оборачивающий предоставленный код.
```
javascript_tag "alert('All is good')"

<script>
//<![CDATA[
alert('All is good')
//]]>
</script>
```

#### NumberHelper
Предоставляет методы для конвертации чисел в форматированные строки. Методы предоставлены для телефонных номеров, валют, процентов, позиционных систем счисления и размеров файла.

##### `number_to_currency`
Форматирует число в строку с символом валюты (например, $13.65).
```
number_to_currency(1234567890.50) # => $1,234,567,890.50
```

##### `number_to_human_size`
Форматирует размер в байтах в более понятное представление; полезно для показа размеров файла пользователям.
```
number_to_human_size(1234)          # => 1.2 KB
number_to_human_size(1234567)       # => 1.2 MB
```

##### `number_to_percentage`
Форматирует число в строку с символом процента.
```
number_to_percentage(100, precision: 0)        # => 100%
```

##### `number_to_phone`
Форматирует число в телефонный номер (по умолчанию США).
```
number_to_phone(1235551234) # => 123-555-1234
```

##### `number_with_delimiter`
Форматирует число с сгруппированными тысячами, используя разделитель.
```
number_with_delimiter(12345678) # => 12,345,678
```

##### `number_with_precision`
Форматирует число с помощью определенного уровня точности, по умолчанию 3.
```
number_with_precision(111.2345)                # => 111.235
number_with_precision(111.2345, precision: 2)  # => 111.23
```

#### SanitizeHelper
Модуль SanitizeHelper предоставляет набор методов для очистки текста от нежелательных элементов HTML.

##### `sanitize`
Хелпер `sanitize` экранирует все теги HTML и удаляет все атрибуты, которые не разрешены явно.
```
sanitize @article.body
```
Если переданы опции или `:attributes`, или `:tags`, разрешены только упомянутые теги и атрибуты, и ничего более.
```
sanitize @article.body, tags: %w(table tr td), attributes: %w(id class style)
```
Чтобы изменить значения по умолчанию для многократного использования, например, добавить теги таблиц к значениям по умолчанию:
```
class Application < Rails::Application
  config.action_view.sanitized_allowed_tags = 'table', 'tr', 'td'
end
```

##### `sanitize_css(style)`
Экранирует блок кода CSS.

##### `strip_links(html)`
Обрезает все теги ссылок в тексте, оставляя только текст ссылки.
```
strip_links('<a href="https://rubyonrails.org">Ruby on Rails</a>')
# => Ruby on Rails

strip_links('emails to <a href="mailto:me@email.com">me@email.com</a>.')
# => emails to me@email.com.

strip_links('Blog: <a href="http://myblog.com/">Visit</a>.')
# => Blog: Visit.
```
##### `strip_tags(html)`
Обрезает все теги HTML из `html`, включая комментарии. Эта функция доступна, если подключен гем `rails-html-sanitizer`.
```
strip_tags("Strip <i>these</i> tags!")
# => Strip these tags!

strip_tags("<b>Bold</b> no more!  <a href='more.html'>See more</a>")
# => Bold no more!  See more
```
NB: Результат все еще может содержать неэкранированные символы '<', '>', '&' и путать браузеры.

#### CsrfHelper
Возвращает метатеги "csrf-param" и "csrf-token" с, соответственно, именами параметра и токена против межсайтовой подделки запроса.
```
<%= csrf_meta_tags %>
```
> Обычные формы создают скрытые поля, поэтому они не используют эти теги.

### Локализованные вьюхи <a name="3.1.7"></a>
В Action View есть возможность рендерить различные шаблоны в зависимости от текущей локали.

Например, предположим, что у вас есть `ArticlesController` с экшном `show`. По умолчанию вызов этого экшна отрендерит `app/views/articles/show.html.erb`. Но если вы установите `I18n.locale = :de`, то вместо него будет отрендерен `app/views/articles/show.de.html.erb`. Если локализованный шаблон отсутствует, будет использована недекорированная версия. Это означает, что не нужно предоставлять локализованные вьюхи для всех случаев, но они будут предпочтительными и будут использоваться, если станут доступны.

Ту же технику можно использовать для локализации страниц ошибок в директории `public`. Например, установка `I18n.locale = :de` и создание `public/500.de.html` и `public/404.de.html` позволит иметь локализованные страницы ошибок.

Так как Rails не ограничивает символы, используемые для установления `I18n.locale`, эту систему можно использовать для отображения различного содержимого, зависящего от чего-либо иного. Например, предположим у вас есть пользователи "expert", которые должны видеть страницы иные, чем пользователи "normal". Можно добавить следующее в `app/controllers/application.rb`:
```
before_action :set_expert_locale

def set_expert_locale
  I18n.locale = :expert if current_user.expert?
end
```
Затем можно добавить специальные вьюхи, такие как `app/views/articles/show.expert.html.erb` которые будут отображены только пользователям `expert`.

## Макеты и рендеринг в Rails <a name="3.2"></a>

### Обзор: как кусочки складываются вместе <a name="3.2.1"></a>
Это руководство сосредотачивается на взаимодействии между контроллером и вьюхой (представлением) в треугольнике модель-представление-контроллер (MVC). Как вы знаете, контроллер ответственен за управление целым процессом обслуживания запросов в Rails, хотя обычно любой серьезный код переносится в модель. Но когда приходит время послать отклик обратно пользователю, контроллер передает все вьюхе. Именно этой передаче посвящено данное руководство.

В общих чертах все связано с решением, что же должно быть послано как отклик, и вызовом подходящего метода для создания этого отклика. Если откликом является полноценная вьюха, Rails также проводит дополнительную работу по упаковыванию вьюхи в макет и, возможно, по вставке частичных вьюх. В общем, все эти этапы вы увидите сами в следующих разделах.

### Создание откликов <a name="3.2.2"></a>
С точки зрения контроллера есть три способа создать отклик HTTP:
* Вызвать `render` для создания полного отклика, возвращаемого браузеру
* Вызвать `redirect_to` для передачи браузеру кода переадресации HTTP
* Вызвать `head` для создания отклика, включающего только заголовки HTTP, возвращаемого браузеру 

#### Рендеринг по умолчанию: соглашения по конфигурации в действии
Вы уже слышали, что Rails содействует принципу "соглашения по конфигурации". Рендеринг по умолчанию - прекрасный пример этого. По умолчанию контроллеры в Rails автоматически рендерят вьюхи с именами, соответствующими валидным маршрутам. 
Итак, в нашей вьюхе мы хотим отобразить свойства всех книг, это делается с помощью шаблона ERB, подобного следующему:
```
<h1>Listing Books</h1>

<table>
  <thead>
    <tr>
      <th>Title</th>
      <th>Content</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <% @books.each do |book| %>
      <tr>
        <td><%= book.title %></td>
        <td><%= book.content %></td>
        <td><%= link_to "Show", book %></td>
        <td><%= link_to "Edit", edit_book_path(book) %></td>
        <td><%= link_to "Destroy", book, method: :delete, data: { confirm: "Are you sure?" } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to "New book", new_book_path %>
```
> Фактически рендеринг осуществляется вложенными классами модуля `ActionView::Template::Handlers`. Мы не будем углубляться в этот процесс, но важно знать, что расширение файла вьюхи контролирует выбор обработчика шаблона.

#### Использование `render`
Во многих случаях метод `ActionController::Base#render` выполняет большую работу по рендерингу содержимого Вашего приложения для использования в браузере. Имеются различные способы настройки возможностей render. Вы можете рендерить вьюху по умолчанию для шаблона Rails, или определенный шаблон, или файл, или встроенный код, или совсем ничего. Можно рендерить текст, JSON или XML. Также можно определить тип содержимого или статус HTTP отрендеренного отклика.

Если хотите увидеть точные результаты вызова `render` без необходимости проверять это в браузере, можете вызвать `render_to_string`. Этот метод принимает те же самые опции, что и render, но возвращает строку вместо отправки отклика обратно браузеру.

##### Рендеринг вьюхи экшна

Если хотите отрендерить вьюху, соответствующую другому шаблону этого же контроллера, можно использовать `render` с именем вьюхи:
```
def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render "edit"
  end
end
```
Если вызов `update` проваливается, вызов экшна `update` в этом контроллере отрендерит шаблон `edit.html.erb`, принадлежащий тому же контроллеру.

Если хотите, можете использовать символ вместо строки для определения экшна для рендеринга:
```
def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render :edit
  end
end
```

##### Рендеринг шаблона экшна из другого контроллера

Что, если вы хотите отрендерить шаблон из абсолютно другого контроллера? Это можно также сделать с `render`, который принимает полный путь шаблона для рендеринга (относительно `app/views`). Например, если запускаем код в `AdminProductsController` который находится в `app/controllers/admin`, можете отрендерить результат экшна в шаблон в `app/views/products` следующим образом:
```
render "products/show"
```
Rails знает, что эта вьюха принадлежит другому контроллеру, поскольку содержит символ слэша в строке. Если хотите быть точными, можете использовать опцию `:template` (которая требовалась в Rails 2.2 и более ранних):
```
render template: "products/show"
```

##### Оборачивание
Вышеописанные три метода рендеринга (рендеринг другого шаблона в контроллере, рендеринг шаблона в другом контроллере и рендеринг произвольного файла в файловой системе) на самом деле являются вариантами одного и того же экшна.

Фактически в классе `BooksController`, в экшне `update`, в котором мы хотим отрендерить шаблон `edit`, если книга не была успешно обновлена, все нижеследующие вызовы отрендерят шаблон `edit.html.erb` в директории `views/books`:
```
render :edit
render action: :edit
render "edit"
render action: "edit"
render "books/edit"
render template: "books/edit"
```
Какой из них вы будете использовать - это вопрос стиля и соглашений, но практическое правило заключается в использовании простейшего, который больше подходит по стилю написания вашего кода.

##### Использование `render` с `:inline`
Метод `render` вполне может обойтись без вьюхи, если вы используете опцию `:inline` для поддержки ERB, как части вызова метода. Это вполне валидно:
```
render inline: "<% products.each do |p| %><p><%= p.name %></p><% end %>"
```
> Должно быть серьезное основание для использования этой опции. Вкрапление ERB в контроллер нарушает MVC ориентированность Rails и создает трудности для других разработчиков в следовании логике вашего проекта. Вместо этого используйте отдельную erb-вьюху.

По умолчанию встроенный рендеринг использует ERB. Можете принудить использовать вместо этого `Builder` с помощью опции `:type`:
```
render inline: "xml.p {'Horrid coding practice!'}", type: :builder
```

##### Рендеринг текста

Вы можете послать простой текст - совсем без разметки - обратно браузеру с использованием опции `:plain` в `render`:
```
render plain: "OK"
```
> Рендеринг чистого текста наиболее полезен, когда вы делаете Ajax-отклик или отвечаете на запросы веб-сервиса, ожидающего что-то иное, чем HTML.

> По умолчанию при использовании опции `:plain` текст рендерится без использования текущего макета. Если хотите, чтобы Rails вложил текст в текущий макет, необходимо добавить опцию `layout: true` и использовать расширение `.text.erb` для файла макета.

##### Рендеринг HTML
Вы можете вернуть HTML, используя опцию `:html` метода `render`:
```
render html: helpers.tag.strong('Not Found')
```

> Это полезно когда вы хотите отрендерить небольшой кусочек HTML-кода. Однако, если у вас достаточно сложная разметка, стоит рассмотреть выделение её в файл шаблона.

> Когда используется опция `html:`, HTML объекты будут экранироваться, если строка не состоит из API, поддерживающих `html_safe`.

##### Рендеринг JSON
JSON - это формат данных JavaScript, используемый многими библиотеками Ajax. Rails имеет встроенную поддержку для преобразования объектов в JSON и рендеринга этого JSON обратно браузеру:
```
render json: @product
```
> Не нужно вызывать `to_json` в объекте, который хотите рендерить. Если используется опция `:json`, `render` автоматически вызовет `to_json` за вас.

##### Рендеринг XML
Rails также имеет встроенную поддержку для преобразования объектов в XML и рендеринга этого XML обратно вызывающему:
```
render xml: @product
```
Не нужно вызывать `to_xml` в объекте, который хотите рендерить. Если используется опция `:xml`, render автоматически вызовет `to_xml` за вас.

##### Рендеринг внешнего JavaScript
Rails может рендерить чистый JavaScript:
```
render js: "alert('Hello Rails');"
```
Это пошлет указанную строку в браузер с типом MIME `text/javascript`.

##### Рендеринг необработанного содержимого
Вы можете вернуть необработанный текст, без установки типа содержимого, используя опцию `:body`, метода `render`:
```
render body: "raw"
```
> Эта опция должна использоваться, только если не важен тип содержимого отклика. Использование `:plain` или `:html` уместнее в большинстве случаев.

> Возвращенным откликом от этой опции будет `text/plain` (если не будет переопределен), так как это тип содержимого по умолчанию у отклика `Action Dispatch`.

##### Рендеринг необработанного файла
Rails может рендерить необработанный файл по абсолютному пути. Это полезно для условного рендеринга статичных файлов, таких как страницы ошибок.
```
render file: "#{Rails.root}/public/404.html", layout: false
```
Это отрендерит необработанный файл (ERB или другие обработчики не поддерживаются). По умолчанию файл рендерится с использованием текущего макета.

> Использование опции `:file` в комбинации с данными, введенными пользователем, может привести к проблемам безопасности, так как злоумышленник может использовать этот экшн для доступа к чувствительным, с точки зрения безопасности, файлам вашей файловой системы.

> `send_file` часто является более быстрым и лучшим вариантом, если макет не требуется.

##### Опции для render
Вызов метода render как правило принимает шесть опций:
* `:content_type`
* `:layout`
* `:location`
* `:status`
* `:formats`
* `:variants` 

###### Опция `:content_type`
По умолчанию Rails будет обрабатывать результаты операции рендеринга с типом содержимого MIME `text/html` (или `application/json`, если используется опция `:json`, или `application/xml` для опции `:xml`). Иногда бывает так, что нужно изменить это, и тогда необходимо настроить опцию `:content_type`:
```
render template: "feed", content_type: "application/rss"
```

###### Опция `:layout`
С большинством опций для render, отрендеренное содержимое отображается как часть текущего макета.
Опция `:layout` нужна, чтобы сообщить Rails о необходимости использовать определенный файл как макет для текущего экшна:
```
render layout: "special_layout"
```
Также можно сообщить Rails, что требуется рендерить вообще без макета:
```
render layout: false
```

###### Опция `:location`
Опцию `:location` можно использовать, чтобы установить заголовок HTTP Location:
```
render xml: photo, location: photo_url(photo)
```

###### Опция `:status`

Rails автоматически сгенерирует отклик с правильным кодом статуса HTML (в большинстве случаев равный 200 OK). Опцию `:status` можно использовать, чтобы изменить это:
```
render status: 500
render status: :forbidden
```
> Если попытаться отрендерить содержимое наряду с кодом статуса без содержимого (100-199, 204, 205 или 304), он будет исключён из отклика.

###### Опция `:formats`

Rails использует формат, определённый в запросе (или `:html` по умолчанию). Вы можете изменить его, передав в опцию `:formats` символ или массив:
```
render formats: :xml
render formats: [:json, :xml]
```
Если шаблон с указанным форматом не существует, вызывается ошибка `ActionView::MissingTemplate`.

###### Опция `:variants`
Она сообщает Rails искать варианты шаблона того же формата. Можно указать список вариантов, передав опции `:variants` символ или массив.

Пример использования.
```
# called in HomeController#index
render variants: [:mobile, :desktop]
```
С таком набором вариантов, Rails будет искать следующий набор шаблонов и использовать первый из существующих.
* `app/views/home/index.html+mobile.erb`
* `app/views/home/index.html+desktop.erb`
* `app/views/home/index.html.erb`
Если шаблон с указанным форматом не существует, будет вызвана ошибка `ActionView::MissingTemplate`.

Вместо указания варианта на вызове `render`, его также можно установить на объекте `request` в экшне контроллера.
```
def index
  request.variant = determine_variant
end

private

def determine_variant
  variant = nil
  # некоторый код для определения варианта(ов) для использования
  variant = :mobile if session[:use_mobile]

  variant    
end
```

###### Поиск макетов
Чтобы найти текущий макет, Rails сначала смотрит файл в `app/views/layouts` с именем, таким же, как имя контроллера. Например, рендеринг экшнов из класса `PhotosController` будет использовать `/app/views/layouts/photos.html.erb` (или `app/views/layouts/photos.builder`). Если такого макета нет, Rails будет использовать `/app/views/layouts/application.html.erb` или `/app/views/layouts/application.builder`. Если макет `.erb` отсутствует, Rails будет использовать макет `.builder`, если таковой имеется. Rails также предоставляет несколько способов для более точного назначения определенных макетов отдельным контроллерам и экшнам.

###### Определение макетов для контроллеров
Вы можете переопределить дефолтные соглашения по макетам в контроллере, используя объявление `layout`. Например:
```
class ProductsController < ApplicationController
  layout "inventory"
  #...
end
```
С этим объявлением все вьюхи, отрендеренные `ProductsController`, будут использовать `app/views/layouts/inventory.html.erb` как макет.

Чтобы привязать определенный макет к приложению в целом, используйте объявление `layout` в классе `ApplicationController`:
```
class ApplicationController < ActionController::Base
  layout "main"
  #...
end
```
С этим объявлением каждая из вьюх во всем приложении будет использовать `app/views/layouts/main.html.erb` как макет.

###### Выбор макетов во время выполнения
Можно использовать символ для отсрочки выбора макета до тех пор, пока не будет обработан запрос:
```
class ProductsController < ApplicationController
  layout :products_layout

  def show
    @product = Product.find(params[:id])
  end

  private
    def products_layout
      @current_user.special? ? "special" : "products"
    end
end
```
Теперь, если текущий пользователь является специальным, он получит специальный макет при просмотре продукта.

Можно даже использовать встроенный метод, такой как `Proc`, для определения макета. Например, если передать объект `Proc`, то блоку, которому вы передаете `Proc`, будет предоставлен экземпляр `controller`, поэтому макет может быть определен, основываясь на текущем запросе:
```
class ProductsController < ApplicationController
  layout Proc.new { |controller| controller.request.xhr? ? "popup" : "application" }
end
```

###### Условные макеты
Макеты, определенные на уровне контроллера, поддерживают опции `:only` и `:except`. Эти опции принимают либо имя метода, либо массив имен методов, соответствующих именам методов в контроллере:
```
class ProductsController < ApplicationController
  layout "product", except: [:index, :rss]
end
```
С таким объявлением макет `product` будет использован везде, кроме методов `rss` и `index`.

###### Наследование макета

Объявление макета ниже по иерархии и более специфическое объявление макета всегда переопределяет более общие. 

###### Наследование шаблона
Следуя логике наследования макета, если шаблон или партиал не найдены по обычному пути, контроллер будет искать шаблон или партиал для рендеринга по цепочке наследования. Например:
```
# in app/controllers/application_controller
class ApplicationController < ActionController::Base
end

# in app/controllers/admin_controller
class AdminController < ApplicationController
end

# in app/controllers/admin/products_controller
class Admin::ProductsController < AdminController
  def index
  end
end
```
Порядок поиска экшна admin/products#index будет такой:
* `app/views/admin/products/`
* `app/views/admin/`
* `app/views/application/` 

Это делает `app/views/application/` хорошим местом для общих партиалов, которые затем могут быть отрендерены в ERB следующим образом:
```
<%# app/views/admin/products/index.html.erb %>
<%= render @products || "empty_list" %>

<%# app/views/application/_empty_list.html.erb %>
There are no items in this list <em>yet</em>.
```

###### Избегание ошибок двойного рендеринга
Рано или поздно, большинство разработчиков на Rails увидят сообщение об ошибке "Can only render or redirect once per action". Хоть такое и раздражает, это относительно просто правится. Обычно такое происходит в связи с фундаментальным непониманием метода работы `render`.

Например, вот некоторый код, который вызовет эту ошибку:
```
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
  render action: "regular_show"
end
```
Если `@book.special?` вычисляется как `true`, Rails начинает процесс рендеринга, выгружая переменную `@book` во вьюху `special_show`. Но это не остановит от выполнения остальной код в экшне `show`, и когда Rails достигнет конца экшна, он начнет рендерить вьюху `show` - и выдаст ошибку. Решение простое: убедитесь, что у вас есть только один вызов `render` или `redirect` за один проход. Еще может помочь такая вещь, как `and return`. Вот исправленная версия метода:
```
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show" and return
  end
  render action: "regular_show"
end
```
Убедитесь, что используете `and return` вместо `&& return`, поскольку `&& return` не будет работать в связи с приоритетом операторов в языке Ruby.

Отметьте, что неявный рендер, выполняемый `ActionController`, определяет, был ли вызван render поэтому следующий код будет работать без проблем:
```
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
end
```
Это отрендерит книгу (book) с `special?`, заданным с помощью шаблона `special_show`, в то время как остальные книги будут рендериться с дефолтным шаблоном `show`.

#### Использование `redirect_to`
Другой способ управлять возвратом отклика на HTTP-запрос - с помощью `redirect_to`. Как вы видели, render сообщает Rails, какую вьюху (или иной ассет) использовать при построении отклика. Метод `redirect_to` делает нечто совершенно отличное: он говорит браузеру послать новый запрос по другому URL. Например, можно перенаправить из любого места, где сейчас выполняется код, к экшну `index` фотографий вашего приложения с помощью этого вызова:
```
redirect_to photos_url
```
Можно использовать `redirect_back`, чтобы вернуть пользователя на страницу с которой он только что пришел. Это место расположения вытаскивается из заголовка HTTP_REFERER, который не обязательно будет установлен браузером, поэтому нужно предоставить `fallback_location` для использования в таком случае.
```
redirect_back(fallback_location: root_path)
```

> `redirect_to` и `redirect_back` не прерывают и не возвращают из выполняемого метода немедленно, а просто устанавливают отклики HTTP. Выражения, следующие после них в методе, будут выполнены. При необходимости можно прервать явным `return` или любым другим механизмом прерывания.

##### Получение различного кода статуса перенаправления

Rails использует код статуса HTTP 302, временное перенаправление, при вызове `redirect_to`. Если хотите использовать иной код статуса, возможно 301, постоянное перенаправление, можете использовать опцию `:status`:
```
redirect_to photos_path, status: 301
```
Подобно опции `:status` для render, `:status` для `redirect_to` принимает и числовые, и символьные обозначения заголовка.

##### Различие между `render` и `redirect_to`
Иногда неопытные разработчики думают о `redirect_to` как о разновидности команды `goto`, перемещающую выполнение из одного места в другое в вашем коде Rails. Это не верно. Ваш код останавливается и ждет нового запроса от браузера. Просто получается так, что вы говорите браузеру, какой запрос он должен сделать следующим, возвращая код статуса HTTP 302.

Рассмотрим эти экшны, чтобы увидеть разницу:
```
def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    render action: "index"
  end
end
```
С кодом в такой форме, вероятно, будет проблема, если переменная `@book` равна `nil`. Помните, `render :action` **не запускает какой-либо код в указанном экшне**, и таким образом ничего не будет присвоено переменной `@books`, которую, возможно, потребует вьюха `index`. Один из способов исправить это - использовать перенаправление вместо рендеринга:
```
def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    redirect_to action: :index
  end
end
```

С помощью этого кода браузер сделает новый запрос для индексной страницы, код в методе `index` запустится, и все будет хорошо.

Единственный недостаток этого кода в том, что он требует круговорот через браузер: браузер запрашивает экшн `show` с помощью `/books/1`, и контроллер обнаруживает, что книг нет, поэтому отсылает отклик-перенаправление 301 браузеру, сообщающий перейти на `/books/`, браузер выполняет и посылает новый запрос контроллеру, теперь запрашивая экшн `index`, затем контроллер получает все книги в базе данных и рендерит шаблон `index`, отсылает его обратно браузеру, который затем показывает его на экране.

Пока это небольшое приложение, такая добавленная задержка не может быть проблемой, но иногда стоит подумать о том, является ли время отклика проблемой. Можем продемонстрировать один из способов управления этим с помощью хитрого примера:
```
def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    @books = Book.all
    flash.now[:alert] = "Your book was not found"
    render "index"
  end
end
```
Это обнаружит, что нет книг с определенным ID, заполнит переменную экземпляра @books всеми книгами в модели, и затем напрямую отрендерит шаблон `index.html.erb`, возвратив его браузеру с предупреждающим сообщением в `flash`, сообщающим пользователю, что произошло.

#### Использование `head` для создания отклика, содержащего только заголовок
Метод `head` может использоваться для отправки браузеру откликов, содержащих только заголовки. Метод `head` принимает число или символ (смотрите таблицу соответствия), представляющие код статуса HTTP. Аргумент опций интерпретируется как хэш заголовков имен и значений. Например, можно возвратить только заголовок ошибки:
```
head :bad_request
```
Это создаст следующий заголовок:
```
HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
```
Или можете использовать другие заголовки HTTP для передачи другой информации:
```
head :created, location: photo_path(@photo)
```
Что создаст:
```
HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
```

### Структурирование макетов <a name="3.2.3"></a>
В макетах у вас есть доступ к трем инструментам для объединения различных кусочков результата для формирования общего отклика:
* Теги ассетов
* `yield` и `content_for`
* Партиалы 

#### Хелперы ассетных тегов
Хелперы ассетных тегов предоставляют методы для генерации HTML, связывающие вьюхи с лентами новостей, JavaScript, таблицами стилей, изображениями, видео и аудио. В Rails доступно шесть хелперов ассетных тегов:
* `auto_discovery_link_tag`
* `javascript_include_tag`
* `stylesheet_link_tag`
* `image_tag`
* `video_tag`
* `audio_tag` 
Эти теги можно использовать в макетах или других вьюхах, хотя `auto_discovery_link_tag`, `javascript_include_tag` и `stylesheet_link_tag` как правило используются в разделе `<head>` макета.

> Хелперы ассетных тегов не проверяют существование ассетов по заданному месту расположения; они просто предполагают, что вы знаете, что делаете, и генерируют ссылку.

##### Присоединение каналов с помощью `auto_discovery_link_tag`

Хелпер `auto_discovery_link_tag` создает HTML-код, который большинство браузеров и агрегаторов новостей могут использовать для определения наличия каналов RSS, Atom или JSON лент. Он принимает тип ссылки (`:rss`, `:atom` или `:json`), хэш опций, которые передаются через `url_for`, и хэш опций для тега:
```
<%= auto_discovery_link_tag(:rss, {action: "feed"},
  {title: "RSS Feed"}) %>
```
Вот три опции тега, доступные для `auto_discovery_link_tag`:
* `:rel` определяет значение rel в ссылке. Значение по умолчанию "alternate"
* `:type` определяет явный тип MIME. Rails генерирует подходящий тип MIME автоматически
* `:title` определяет заголовок ссылки. Значение по умолчанию это значение `:type` в верхнем регистре, например, "ATOM" или "RSS". 

##### Присоединение файлов JavaScript с помощью `javascript_include_tag`
Хелпер `javascript_include_tag` возвращает HTML-тег script для каждого предоставленного источника.

При использовании Rails с включенным Asset Pipeline, этот хелпер сгенерирует ссылку на `/assets/javascripts/`, а не на `public/javascripts`, которая использовалась в более ранних версиях Rails. Затем эта ссылка обслуживается файлопроводом (`asset pipeline`).

Файл JavaScript в приложении Rails или Rails Engine размещается в одном из трех мест расположения: `app/assets`, `lib/assets` или `vendor/assets`.
Можно определить полный путь относительно корня документа или URL, по желанию. Например, сослаться на файл JavaScript, находящийся в директории с именем javascripts в одной из `app/assets`, `lib/assets` или `vendor/assets`, можно так:
```
<%= javascript_include_tag "main" %>
```
Rails тогда выдаст такой тег script:
```
<script src='/assets/main.js'></script>
```
Затем запрос к этому ассету будет обслужен гемом `Sprockets`.

Чтобы включить несколько файлов, таких как `app/assets/javascripts/main.js` и `app/assets/javascripts/columns.js` за один раз:
```
<%= javascript_include_tag "main", "columns" %>
```
Чтобы включить `app/assets/javascripts/main.js` и `app/assets/javascripts/photos/columns.js`:
```
<%= javascript_include_tag "main", "/photos/columns" %>
```
Чтобы включить `http://example.com/main.js`:
```
<%= javascript_include_tag "http://example.com/main.js" %>
```

##### Присоединение файлов CSS с помощью `stylesheet_link_tag`
Хелпер `stylesheet_link_tag` возвращает HTML-тег <link> для каждого предоставленного источника.

При использовании Rails с включенным "Asset Pipeline", этот хелпер сгенерирует ссылку на `/assets/stylesheets/`. Эта ссылка будет затем обработана гемом `Sprockets`. Файл таблицы стилей может быть размещен в одном из трех мест расположения: `app/assets`, `lib/assets` или `vendor/assets`.

Можно определить полный путь относительно корня документа или URL. Например, на файл таблицы стилей в директории `stylesheets`, размещенной в одной из `app/assets`, `lib/assets` или `vendor/assets`, можно сослаться так:
```
<%= stylesheet_link_tag "main" %>
```
Чтобы включить `app/assets/stylesheets/main.css` и `app/assets/stylesheets/columns.css`:
```
<%= stylesheet_link_tag "main", "columns" %>
```
Чтобы включить `app/assets/stylesheets/main.css` и `app/assets/stylesheets/photos/columns.css`:
```
<%= stylesheet_link_tag "main", "/photos/columns" %>
```
Чтобы включить `http://example.com/main.css`:
```
<%= stylesheet_link_tag "http://example.com/main.css" %>
```
По умолчанию `stylesheet_link_tag` создает ссылки с `media="screen" rel="stylesheet"`. Можно переопределить любое из этих дефолтных значений, указав соответствующую опцию (`:media`, `:rel`):
```
<%= stylesheet_link_tag "main_print", media: "print" %>
```

##### Присоединение изображений с помощью `image_tag`
Хелпер `image_tag` создает HTML-тег <img /> для определенного файла. По умолчанию файлы загружаются из `public/images`.

Обратите внимание, что нужно указывать расширение изображения.
```
<%= image_tag "header.png" %>
```
Вы можете предоставить путь к изображению, если желаете:
```
<%= image_tag "icons/delete.gif" %>
```
Вы можете предоставить хэш дополнительных опций HTML:
```
<%= image_tag "icons/delete.gif", {height: 45} %>
```
Или альтернативный текст, если пользователь отключил показ изображений в браузере. Если вы не определили явно тег `alt`, по умолчанию будет указано имя файла с большой буквы и без расширения. Например, эти два тега изображения возвратят одинаковый код:
```
<%= image_tag "home.gif" %>
<%= image_tag "home.gif", alt: "Home" %>
```
Можете указать специальный тег `size` в формате "{width}x{height}":
```
<%= image_tag "home.gif", size: "50x20" %>
```
В дополнение к вышеописанным специальным тегам, можно предоставить итоговый хэш стандартных опций HTML, таких как `:class` или `:id`, или `:name`:
```
<%= image_tag "home.gif", alt: "Go Home",
                          id: "HomeImage",
                          class: "nav_bar" %>
```

##### Присоединение видео с помощью `video_tag`
Хелпер `video_tag` создает тег HTML 5 `<video>` для определенного файла. По умолчанию файлы загружаются из `public/videos`.
```
<%= video_tag "movie.ogg" %>
```
Создаст
```
<video src="/videos/movie.ogg" />
```
Подобно `image_tag`, можно предоставить путь или абсолютный, или относительный к директории `public/videos`. Дополнительно можно определить опцию `size`: "#{width}x#{height}", как и в `image_tag`. Теги видео также могут иметь любые опции HTML, определенные в конце (`id`, `class` и др.).

Тег видео также поддерживает все HTML-опции <video> через хэш HTML-опций, включая:
* `poster`: "image_name.png", предоставляет изображение, которое будет отображаться вместо видео прежде, чем оно начнет проигрываться.
* `autoplay`: true, запускает проигрывание видео при загрузке страницы.
* `loop`: true, запускает видео сначала, как только оно достигает конца.
* `controls`: true, предоставляет пользователю поддерживаемую браузером панель управления для взаимодействия с видео.
* `autobuffer`: true, файл видео предварительно загружается для пользователя при загрузке страницы. 

Также можно определить несколько видео для проигрывания, передав массив видео в `video_tag`:
```
<%= video_tag ["trailer.ogg", "movie.ogg"] %>
```
Это создаст:
```
<video>
  <source src="/videos/trailer.ogg" />
  <source src="/videos/movie.ogg" />
</video>
```
##### Присоединение аудиофайлов с помощью `audio_tag`
Хелпер `audio_tag` создает тег HTML 5 `<audio>` для определенного файла. По умолчанию файлы загружаются из `public/audios`.
```
<%= audio_tag "music.mp3" %>
```
Если хотите, можете предоставить путь к аудио файлу:
```
<%= audio_tag "music/first_song.mp3" %>
```
Также можно предоставить хэш дополнительных опций, таких как `:id`, `:class` и т.д.

Подобно `video_tag`, `audio_tag` имеет специальные опции:
* `autoplay`: true, начинает воспроизведение аудио при загрузке страницы
* `controls`: true, предоставляет пользователю поддерживаемую браузером панель управления для взаимодействия с аудио.
* `autobuffer`: true, файл аудио предварительно загружается для пользователя при загрузке страницы. 

#### Понимание `yield`
В контексте макета, `yield` определяет раздел, где должно быть вставлено содержимое из вьюхи. Самый простой способ его использования - это иметь один `yield` там, куда вставится все содержимое вьюхи, которая в настоящий момент рендерится:
```
<html>
  <head>
  </head>
  <body>
  <%= yield %>
  </body>
</html>
```
Также можете создать макет с несколькими разделами `yield`:
```
<html>
  <head>
  <%= yield :head %>
  </head>
  <body>
  <%= yield %>
  </body>
</html>
```
Основное тело вьюхи всегда рендериться в неименованный `yield`. Чтобы рендерить содержимое в именованный `yield`, используйте метод `content_for`.

#### Использование метода `content_for`
Метод `content_for` позволяет вставлять содержимое в именованный блок `yield` в макете. Например, эта вьюха будет работать с макетом, который вы только что видели:
```
<% content_for :head do %>
  <title>A simple page</title>
<% end %>

<p>Hello, Rails!</p>
```
Результат рендеринга этой страницы в макет будет таким HTML:
```
<html>
  <head>
  <title>A simple page</title>
  </head>
  <body>
  <p>Hello, Rails!</p>
  </body>
</html>
```
Метод `content_for` может помочь, когда макет содержит отдельные разделы, такие как боковые панели или футеры, в которые нужно вставить свои блоки содержимого. Это также полезно при вставке тегов, загружающих специфичные для страницы файлы JavaScript или css в хедер макета в целом.

#### Использование партиалов
Частичные шаблоны - также называемые "партиалы" - являются еще одним подходом к разделению процесса рендеринга на более управляемые кусочки. С партиалами можно перемещать код для рендеринга определенных частей отклика в свои отдельные файлы.

##### Именование партиалов
Чтобы отрендерить партиал как часть вьюхи, используем метод render внутри вьюхи:
```
<%= render "menu" %>
```
Это отрендерит файл, названный `_menu.html.erb` в этом месте в пределах рендерящейся вьюхи. Обратите внимание на начальный символ подчеркивания: файлы партиалов начинаются со знака подчеркивания, чтобы отличать их от обычных вьюх, несмотря на то, что в вызове они указаны без подчеркивания. Это справедливо даже тогда, когда партиалы вызываются из другой папки:
```
<%= render "shared/menu" %>
```
Этот код вытянет партиал из `app/views/shared/_menu.html.erb`.

Использование партиалов для упрощения вьюх

Один из способов применения партиалов это использоваться их как эквивалент подпрограмм: способ переместить часть разметки из вьюхи так, чтобы можно было легче понять, что там происходит. Например, у вас может быть такая вьюха:
```
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
...

<%= render "shared/footer" %>
```
Здесь партиалы `_ad_banner.html.erb` и `_footer.html.erb` могут содержать контент, общий для многих страниц приложения. Нет необходимости видеть код этих разделов, чтобы сконцентрироваться на определенной странице.

Как видно из предыдущих разделов данного руководства, `yield` является очень мощным инструментом для очистки ваших макетов. Имейте в виду, что это чистый Ruby, так что можно использовать его практически везде. Например, его можно использовать для соблюдения принципа DRY при определении макета формы для нескольких похожих ресурсов:
```
    users/index.html.erb

    <%= render "shared/search_filters", search: @q do |f| %>
      <p>
        Name contains: <%= f.text_field :name_contains %>
      </p>
    <% end %>

    roles/index.html.erb

    <%= render "shared/search_filters", search: @q do |f| %>
      <p>
        Title contains: <%= f.text_field :title_contains %>
      </p>
    <% end %>

    shared/_search_filters.html.erb

    <%= form_for(search) do |f| %>
      <h1>Search form:</h1>
      <fieldset>
        <%= yield f %>
      </fieldset>
      <p>
        <%= f.submit "Search" %>
      </p>
    <% end %>
```
> Для содержимого, общего для всех страниц приложения, можно использовать партиалы прямо в макетах.

##### Макеты партиала
Партиал может использовать свой собственный файл макета, подобно тому, как вьюха может использовать макет. Например, можете вызвать подобный партиал:
```
<%= render partial: "link_area", layout: "graybar" %>
```
Это найдет партиал с именем `_link_area.html.erb` и отрендерит его, используя макет` _graybar.html.erb`. Отметьте, что макеты для партиалов также начинаются с подчеркивания, как и обычные партиалы, и размещаются в той же папке с партиалами, которым они принадлежат (не в основной папке `layouts`).

Также отметьте, что явное указание `partial` необходимо, когда передаются дополнительные опции, такие как `layout`

##### Передача локальных переменных

В партиалы также можно передавать локальные переменные, что делает их более мощными и гибкими. Например, можете использовать такую технику для уменьшения дублирования между страницами `new` и `edit`, сохранив немного различающееся содержимое:
```
    new.html.erb

    <h1>New zone</h1>
    <%= render partial: "form", locals: {zone: @zone} %>

    edit.html.erb

    <h1>Editing zone</h1>
    <%= render partial: "form", locals: {zone: @zone} %>

    _form.html.erb

    <%= form_for(zone) do |f| %>
      <p>
        <b>Zone name</b><br>
        <%= f.text_field :name %>
      </p>
      <p>
        <%= f.submit %>
      </p>
    <% end %>
```
Хотя тот же самый партиал будет отрендерен в обоих вьюхах, Action View отправит хелпер, который возвратит "Create Zone" для экшна new и "Update Zone" для экшна `edit`.

**Для передачи локальной переменной в партиал только в особых случаях, используйте `local_assigns`**.
```
    index.html.erb 

  <%= render user.articles %>

    show.html.erb 

  <%= render article, full: true %>

    _article.html.erb 

  <h2><%= article.title %></h2>

  <% if local_assigns[:full] %>
    <%= simple_format article.body %>
  <% else %>
    <%= truncate article.body %>
  <% end %>
```
Таким образом, можно использовать партиал без необходимости объявления всех локальных переменных.

Каждый партиал также имеет локальную переменную с именем, как у партиала (без начального символа подчеркивания). Можете передать объект в эту локальную переменную через опцию `:object`:
```
<%= render partial: "customer", object: @new_customer %>
```
В партиале `customer` переменная `customer` будет указывать на `@new_customer` из родительской вьюхи.

Если есть экземпляр модели для рендеринга в партиале, можно использовать сокращенный синтаксис:
```
<%= render @customer %>
```
Предположим, что переменная экземпляра `@customer` содержит экземпляр модели `Customer`. Эта переменная будет использовать `_customer.html.erb` для рендеринга модели и передаст локальную переменную `customer` в партиал, на который будет ссылаться на переменная экземпляра `@customer` в родительской вьюхе.

##### Рендеринг коллекций

Партиалы часто используют для рендеринга коллекций. Когда коллекция передается в партиал с помощью опции `:collection`, партиал будет вставлен один раз для каждого члена коллекции:
```
    index.html.erb

    <h1>Products</h1>
    <%= render partial: "product", collection: @products %>

    _product.html.erb

    <p>Product Name: <%= product.name %></p>
```
Когда партиал вызывается с коллекцией во множественном числе, то каждый отдельный экземпляр партиала имеет доступ к члену коллекции, подлежащей рендерингу, через переменную с именем партиала. В нашем случает партиал `_product`, и в партиале `_product` можете обращаться к `product` для получения экземпляра, который рендерится.

Имеется также сокращенная запись для этого. Предположив, что `@products` является коллекцией экземпляров `Product`, можно просто написать так в `index.html.erb` и получить аналогичный результат:
```
<h1>Products</h1>
<%= render @products %>
```
Rails определяет имя партиала, изучая имя модели в коллекции. Фактически, можно даже создать гетерогенную коллекцию и рендерить ее таким образом, и Rails подберет подходящий партиал для каждого члена коллекции:
```
    index.html.erb

    <h1>Contacts</h1>
    <%= render [customer1, employee1, customer2, employee2] %>

    customers/_customer.html.erb

    <p>Customer: <%= customer.name %></p>

    employees/_employee.html.erb

    <p>Employee: <%= employee.name %></p>
```
В этом случае Rails использует партиалы `customer` или `employee` по мере необходимости для каждого члена коллекции.

В случае, если коллекция пустая, `render` возвратит `nil`, поэтому очень просто предоставить альтернативное содержимое.
```
<h1>Products</h1>
<%= render(@products) || "There are no products available." %>
```
##### Локальные переменные

Чтобы использовать пользовательские имена локальных переменных в партиале, определите опцию `:as` в вызове партиала:
```
<%= render partial: "product", collection: @products, as: :item %>
```
С этим изменением можете получить доступ к экземпляру коллекции `@products` через локальную переменную `item` в партиале.

Также можно передавать произвольные локальные переменные в любой партиал, который рендерится с помощью опции `locals: {}`:
```
<%= render partial: "product", collection: @products,
           as: :item, locals: {title: "Products Page"} %>
```
В этом случае, партиал имеет доступ к локальной переменной `title` со значением "Products Page".

> Rails также создает переменную счетчика, доступную в партиале, вызываемом коллекцией, названную именем заголовка партиала с добавленным `_counter`. Например, при рендеринге коллекции `@products` партиал `_product.html.erb` может получить доступ к переменной `product_counter`, которая индексирует количество раз, сколько оно было отрендерено во внешнюю вьюху. Отметьте, что это также применимо, когда имя партиала было изменено с помощью опции `as:`. Например, переменная счетчика для вышеуказанного кода будет `item_counter`.

Также можно определить второй партиал, который будет отрендерен между экземплярами главного партиала, используя опцию `:spacer_template`.

##### Разделяющие шаблоны
```
<%= render partial: @products, spacer_template: "product_ruler" %>
```
Rails отрендерит партиал `_product_ruler` (без переданных в него данных) между каждой парой партиалов `_product`.

##### Макеты коллекции партиала

При рендеринге коллекций также возможно использовать опцию `:layout`:
```
<%= render partial: "product", collection: @products, layout: "special_layout" %>
```
Макет будет отрендерен вместе с партиалом для каждого элемента коллекции. Переменные текущего объекта и `object_counter` также будут доступны в макете, как это происходит в партиале.

##### Использование вложенных макетов

Возможно, ваше приложение потребует макет, немного отличающийся от обычного макета приложения, для поддержки одного определенного контроллера. Вместо повторения главного макета и редактирования его, можете выполнить это с помощью вложенных макетов (иногда называемых подшаблонами). Вот пример:

Предположим, имеется макет `ApplicationController`:
```
    app/views/layouts/application.html.erb

    <html>
    <head>
      <title><%= @page_title or "Page Title" %></title>
      <%= stylesheet_link_tag "layout" %>
      <style><%= yield :stylesheets %></style>
    </head>
    <body>
      <div id="top_menu">Top menu items here</div>
      <div id="menu">Menu items here</div>
      <div id="content"><%= content_for?(:content) ? yield(:content) : yield %></div>
    </body>
    </html>
```
На страницах, сгенерированных `NewsController`, допустим, нужно спрятать верхнее меню и добавить правое меню:
```
    app/views/layouts/news.html.erb

    <% content_for :stylesheets do %>
      #top_menu {display: none}
      #right_menu {float: right; background-color: yellow; color: black}
    <% end %>
    <% content_for :content do %>
      <div id="right_menu">Right menu items here</div>
      <%= content_for?(:news_content) ? yield(:news_content) : yield %>
    <% end %>
    <%= render template: "layouts/application" %>
```
Вот и все. Вьюхи News будут использовать новый макет, прячущий верхнее меню и добавляющий новое правое меню в "content" `div`.

Существует несколько способов получения похожих результатов с различными подшаблонными схемами, используя эту технику. Отметьте, что нет ограничений на уровень вложенности. Можно использовать метод `ActionView::render` через `render template: 'layouts/news'`, чтобы создать новый макет на основе макета `News`. Если есть уверенность, что не понадобятся подшаблоны для макета `News`, можно заменить строку `content_for?(:news_content) ? yield(:news_content) : yield` простым `yield`.

## Хелперы форм в Action View <a name="3.3"></a>
### Разбираемся с простыми формами <a name="3.3.1"></a>
Главный хелпер форм - это `form_with`.
```
<%= form_with do %>
  Содержимое формы
<% end %>
```
При подобном вызове без аргументов, он создает тег формы, который при отправке сформирует POST-запрос на текущую страницу. Например, предположим текущая страница является домашней, тогда сгенерированный HTML будет выглядеть следующим образом (некоторые разрывы строчек добавлены для читаемости):
```
<form accept-charset="UTF-8" action="/" data-remote="true" method="post">
  <input name="authenticity_token" type="hidden" value="J7CBxfHalt49OSHp27hblqK20c9PgwJ108nDHX/8Cts=" />
  Содержимое формы
</form>
```
Можно увидеть, что HTML содержит элемент `input` с типом `hidden`. Этот `input` важен, поскольку без него форма, у которой action не "GET", не может быть успешно отправлена. Скрытый элемент `input` с именем `authenticity_token` является особенностью безопасности Rails, называемой защитой от межсайтовой подделки запроса, и хелперы форм генерируют его для каждой формы, у которых action не "GET" (при условии, что эта особенность безопасности включена).

#### Характерная форма 
Одной из наиболее простых форм, встречающихся в вебе, является форма поиска. Эта форма содержит:
* элемент формы с методом "GET",
* метку для поля ввода,
* элемент поля ввода текста и
* элемент отправки. 

Чтобы создать эту форму, используем, соответственно, `form_with`, `label_tag`, `text_field_tag` и `submit_tag`. Как здесь:
```
<%= form_with(url: "/search", method: "get") do %>
  <%= label_tag(:q, "Search for:") %>
  <%= text_field_tag(:q) %>
  <%= submit_tag("Search") %>
<% end %>
```
Это сгенерирует следующий HTML:
```
<form accept-charset="UTF-8" action="/search" data-remote="true" method="get">
  <label for="q">Search for:</label>
  <input id="q" name="q" type="text" />
  <input name="commit" type="submit" value="Search" data-disable-with="Search" />
</form>
```
> Передача `url: my_specified_path` в `form_with` сообщает форме, куда осуществлять запрос. Однако, как объясняется ниже, в форму также можно передавать объекты ActiveRecord.

> Для каждого поля ввода формы генерируется атрибут ID из его имени ("q" в примере). Эти ID могут быть очень полезны для стилизации CSS или управления элементами форм с помощью JavaScript.

> Используйте "GET" как метод для форм поиска. Это позволяет пользователям добавлять в закладки определенный поиск и потом возвращаться к нему. В более общем смысле Rails призывает вас использовать правильный метод HTTP для экшна.

#### Хелперы для генерации элементов формы
##### Чекбоксы
Чекбоксы - это элементы управления формой, которые дают пользователю ряд опций, которые он может включить или выключить:
```
<%= check_box_tag(:pet_dog) %>
<%= label_tag(:pet_dog, "I own a dog") %>
<%= check_box_tag(:pet_cat) %>
<%= label_tag(:pet_cat, "I own a cat") %>
```
Это сгенерирует следующее:
```
<input id="pet_dog" name="pet_dog" type="checkbox" value="1" />
<label for="pet_dog">I own a dog</label>
<input id="pet_cat" name="pet_cat" type="checkbox" value="1" />
<label for="pet_cat">I own a cat</label>
```
Первый параметр у `check_box_tag` - это, разумеется, имя поля ввода. Второй параметр - это, естественно, значение поля ввода. Это значение будет включено в данные формы (и будет присутствовать в params), когда чекбокс нажат.

##### Радиокнопки
Радиокнопки, чем-то похожие на чекбоксы, являются элементами управления, которые определяют набор взаимоисключающих опций (т.е. пользователь может выбрать только одну):
```
<%= radio_button_tag(:age, "child") %>
<%= label_tag(:age_child, "I am younger than 21") %>
<%= radio_button_tag(:age, "adult") %>
<%= label_tag(:age_adult, "I am over 21") %>
```
Результат:
```
<input id="age_child" name="age" type="radio" value="child" />
<label for="age_child">I am younger than 21</label>
<input id="age_adult" name="age" type="radio" value="adult" />
<label for="age_adult">I am over 21</label>
```
Как и у `check_box_tag`, второй параметр для `radio_button_tag` - это значение поля ввода. Так как эти две радиокнопки имеют одинаковое имя (`age`), пользователь может выбрать одну, и `params[:age]` будет содержать или "child", или "adult".

> Всегда используйте метки (labels) для чекбоксов и радиокнопок. Они связывают текст с определенной опцией и, предоставляя большее пространство для клика, упрощают выбор пользователем нужного пункта радиокнопки.

#### Другие интересные хелперы
Среди других элементов управления формой стоит упомянуть текстовые области и следующие поля: паролей, скрытые, поиска, ввода телефона, даты, времени, цвета, локальных даты-времени, месяца, недели, url, email, числовые и интервалов:
```
<%= text_area_tag(:message, "Hi, nice site", size: "24x6") %>
<%= password_field_tag(:password) %>
<%= hidden_field_tag(:parent_id, "5") %>
<%= search_field(:user, :name) %>
<%= telephone_field(:user, :phone) %>
<%= date_field(:user, :born_on) %>
<%= datetime_local_field(:user, :graduation_day) %>
<%= month_field(:user, :birthday_month) %>
<%= week_field(:user, :birthday_week) %>
<%= url_field(:user, :homepage) %>
<%= email_field(:user, :address) %>
<%= color_field(:user, :favorite_color) %>
<%= time_field(:task, :started_at) %>
<%= number_field(:product, :price, in: 1.0..20.0, step: 0.5) %>
<%= range_field(:product, :discount, in: 1..100) %>
```
Результат:
```
<textarea id="message" name="message" cols="24" rows="6">Hi, nice site</textarea>
<input id="password" name="password" type="password" />
<input id="parent_id" name="parent_id" type="hidden" value="5" />
<input id="user_name" name="user[name]" type="search" />
<input id="user_phone" name="user[phone]" type="tel" />
<input id="user_born_on" name="user[born_on]" type="date" />
<input id="user_graduation_day" name="user[graduation_day]" type="datetime-local" />
<input id="user_birthday_month" name="user[birthday_month]" type="month" />
<input id="user_birthday_week" name="user[birthday_week]" type="week" />
<input id="user_homepage" name="user[homepage]" type="url" />
<input id="user_address" name="user[address]" type="email" />
<input id="user_favorite_color" name="user[favorite_color]" type="color" value="#000000" />
<input id="task_started_at" name="task[started_at]" type="time" />
<input id="product_price" max="20.0" min="1.0" name="product[price]" step="0.5" type="number" />
<input id="product_discount" max="100" min="1" name="product[discount]" type="range" />
```
Скрытые поля не отображаются пользователю, вместо этого они содержат данные, как и любое текстовое поле. Их значения могут быть изменены с помощью JavaScript.

> Поля поиска, ввода телефона, даты, времени, цвета, даты-времени, локальных даты-времени, месяца, недели, url, email, числовые и интервалов - это элементы управления HTML5. Если необходимо, чтобы у вашего приложения была совместимость со старыми браузерами, вам необходим HTML5 polyfill (предоставляемый с помощью CSS и/или JavaScript). Хотя в таких решениях нет недостатка, популярным инструментом на сегодняшний момент является Modernizr, предоставляющий простой способ добавить функциональность, основанной на обнаружении установленных особенностей HTML5.

> Если используются поля для ввода пароля (для любых целей), вы можете настроить свое приложение для предотвращения появления их значений в логах приложения.

### Работаем с объектами модели <a name="3.3.2"></a>
#### Хелперы объекта модели
Если ваш контроллер определил @person и имя этой персоны Henry, тогда форма, содержащая:
```
<%= text_field(:person, :name) %>
```
выдаст подобный результат
```
<input id="person_name" name="person[name]" type="text" value="Henry" />
```
После подтверждения формы, значение, введенное пользователем, будет храниться в `params[:person][:name]`.

> Необходимо передавать имя переменной экземпляра, т.е. `:person` или "person", а не фактический экземпляр объекта вашей модели.

Rails предоставляет хелперы для отображения ошибок валидации, связанных с объектом модели.

#### Привязывание формы к объекту
Допустим у нас есть контроллер для работы со статьями app/controllers/articles_controller.rb:

def new
  @article = Article.new
end

Соответствующая вьюха app/views/articles/new.html.erb, использующая form_with, выглядит так:

<%= form_with model: @article, class: "nifty_form" do |f| %>
  <%= f.text_field :title %>
  <%= f.text_area :body, size: "60x12" %>
  <%= f.submit "Create" %>
<% end %>

Следует отметить несколько вещей:
* `@article` - это фактический объект, который редактируется.
* Здесь есть одиночный хэш опций. Опции HTML передаются в хэше `:html`. Также для формы можно предоставить опцию `:namespace`, чтобы быть уверенным в уникальности атрибутов `id` элементов формы. Генерируемые для HTML `id` будут начинаться с префикса, заданного атрибутом пространства имен, плюс подчеркивание.
* Метод `form_with` предоставляет объект `form builder` (переменная f).
* Если хотите направить запрос формы на определенный `url`, вместо этого следует использовать `form_with url: my_nifty_url_path`. Подробнее об опциях, которые принимает `form_with`, можно узнать в документации API.
* Методы создания элементов управления формой вызываются для объекта `form builder f`. 

Итоговый HTML:
```
<form class="nifty_form" action="/articles" accept-charset="UTF-8" data-remote="true" method="post">
  <input type="hidden" name="authenticity_token" value="NRkFyRWxdYNfUg7vYxLOp2SLf93lvnl+QwDWorR42Dp6yZXPhHEb6arhDOIWcqGit8jfnrPwL781/xlrzj63TA==" />
  <input type="text" name="article[title]" id="article_title" />
  <textarea name="article[body]" id="article_body" cols="60" rows="12"></textarea>
  <input type="submit" name="commit" value="Create" data-disable-with="Create" />
</form>
```
Объект, переданный как `:model` в `form_with`, контролирует ключ, используемый в params для доступа к значениям формы. В примере имя `article`, и поэтому все поля ввода имеют имена формы `article[attribute_name]`. Соответственно, в экшне `create` хэш `params[:article]` имеет ключи `:title` и `:body`. 

> По соглашению, поля ввода будут отражать атрибуты модели. Однако, это необязательно! Если имеется иная необходимая информация, ее можно включить в форму, также как атрибут, и она будет доступна как `params[:article][:my_nifty_non_attribute_input]`.

Методы хелпера, вызываемые из `form builder`, идентичны хелперам объекта модели, за исключением того, что не нужно указывать, какой объект будет редактироваться, так как это уже регулируется в `form builder`.

**Можно создать подобное привязывание без фактического создания тега `<form>`** с помощью хелпера `fields_for`. Это полезно для редактирования дополнительных объектов модели в той же форме. Например, если имеется модель `Person` со связанной моделью `ContactDetail`, можно создать форму для создания обеих моделей подобным образом:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.text_field :name %>
  <%= fields_for :contact_detail, @person.contact_detail do |contact_detail_form| %>
    <%= contact_detail_form.text_field :phone_number %>
  <% end %>
<% end %>
```
которая выдаст такой результат:
```
<form action="/people" accept-charset="UTF-8" data-remote="true" method="post">
  <input type="hidden" name="authenticity_token" value="bL13x72pldyDD8bgtkjKQakJCpd4A8JdXGbfksxBDHdf1uC0kCMqe2tvVdUYfidJt0fj3ihC4NxiVHv8GVYxJA==" />
  <input type="text" name="person[name]" id="person_name" />
  <input type="text" name="contact_detail[phone_number]" id="contact_detail_phone_number" />
</form>
```
Объект, предоставляемый `fields_for` - это `form builder`, подобный тому, который предоставляется `form_with`.

#### Положитесь на идентификацию записи
Модель `Article` непосредственно доступна пользователям приложения, и таким образом, следуя лучшим рекомендациям разработки на Rails, вы должны объявить ее как ресурс.
```
resources :articles
```
Когда работаем с ресурсами RESTful, вызовы `form_with` становятся значительно проще, если они основываются на идентификации записи. Вкратце, вы должны всего лишь передать экземпляр модели и позволить Rails выяснить имя модели и остальное:
```
## Создание новой статьи
# длинный стиль:
form_with(model: @article, url: articles_path)
# короткий стиль:
form_with(model: @article)

## Редактирование существующей статьи
# длинный стиль:
form_with(model: @article, url: article_path(@article), method: "patch")
# короткий стиль:
form_with(model: @article)
```
Отметьте, что вызов короткого стиля `form_with` является идентичным, независимо от того, запись новая или уже существует. Идентификация записи достаточно сообразительная, чтобы выяснить, новая ли запись, запрашивая `record.new_record?`. Она также выбирает правильный путь для подтверждения и имя, основанное на классе объекта.

> Когда используется STI (наследование с единой таблицей) с вашими моделями, нельзя полагаться на идентификацию записей подкласса, если только их родительский класс определен ресурсом. Необходимо явно указывать `:url` и `:scope` (имя модели).

##### Работаем с пространствами имен
Если создать пространство имен для маршрутов, `form_with` также можно изящно сократить. Если в приложении есть пространство имен `admin`, то
```
form_with model: [:admin, @article]
```
создаст форму, которая передается `ArticlesController` в пространстве имен `admin` (передача в `admin_article_path(@article)` в случае с обновлением). Если у вас несколько уровней пространства имен, тогда синтаксис подобный:
```
form_with model: [:admin, :management, @article]
```
#### Как формы работают с методами `PATCH`, `PUT` или `DELETE?`
Фреймворк Rails поддерживает стиль RESTful в ваших приложениях, что подразумевает частое использование запросов "PATCH", "PUT" и "DELETE" (помимо "GET" и "POST"). Однако, большинство браузеров не поддерживают методы, отличные от "GET" и "POST", когда дело доходит до подтверждения форм.

Rails работает с этой проблемой, эмулируя другие методы с помощью POST со скрытым полем, названным "`_method`", который установлен для отображение желаемого метода:
```
form_with(url: search_path, method: "patch")
```
Результат:
```
<form accept-charset="UTF-8" action="/search" data-remote="true" method="post">
  <input name="_method" type="hidden" value="patch" />
  <input name="authenticity_token" type="hidden" value="f755bb0ed134b76c432144748a6d4b7a7ddf2b71" />
  ...
</form>
```
При парсинге данных, отправленных с помощью POST, Rails принимает во внимание специальный параметр `_method` и ведет себя так, как будто бы в нем был определен этот метод HTTP ("PATCH" в этом примере).

> Все формы с использованием `form_with` по умолчанию реализуют `remote: true`. Эти формы будут отправлять данные с помощью запроса XHR (Ajax). Чтобы это отключить, добавьте local: true.

### Легкое создание списков выбора <a name="3.3.3"></a>
#### Теги `Select` и `Option`
Наиболее простой хелпер - это `select_tag`, который, как следует из имени, просто сгенерирует тег SELECT, инкапсулирующий строку `option` (пунктов списка):
```
<%= select_tag(:city_id, raw('<option value="1">Lisbon</option><option value="2">Madrid</option><option value="3">Berlin</option>')) %>
```
Это закладывает начало, но пока еще динамически не создает теги пунктов списка. Можно сгенерировать теги пунктов с помощью хелпера `options_for_select`:
```
<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>
```
Результат:
```
<option value="1">Lisbon</option>
<option value="2">Madrid</option>
<option value="3">Berlin</option>
```
Первый аргумент для `options_for_select` - это вложенный массив, в котором каждый элемент содержит два элемента: текст пункта списка (название города) и значение пункта списка (id города). Значение пункта списка - это то, что будет передано в контроллер. Часто бывает, что значение - это `id` соответствующего объекта базы данных, но это не всегда так.

Зная это, вы можете комбинировать `select_tag` и `options_for_select` для достижения желаемой полной разметки:
```
<%= select_tag(:city_id, options_for_select(...)) %>
```
`options_for_select` позволяет предварительно выбрать пункт списка, передав его значение.
```
<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]], 2) %>
```
Результат:
```
<option value="1">Lisbon</option>
<option value="2" selected="selected">Madrid</option>
<option value="3">Berlin</option>
```
Всякий раз, когда Rails видит, что внутреннее значение сгенерированного пункта списка соответствует этому значению, он добавит атрибут `selected` к этому пункту.

С помощью хэшей можно добавить произвольные атрибуты в `option`:
```
<%= options_for_select(
  [
    ['Lisbon', 1, { 'data-size' => '2.8 million' }],
    ['Madrid', 2, { 'data-size' => '3.2 million' }],
    ['Berlin', 3, { 'data-size' => '3.4 million' }]
  ], 2
) %>
```
Результат:
```
<option value="1" data-size="2.8 million">Lisbon</option>
<option value="2" selected="selected" data-size="3.2 million">Madrid</option>
<option value="3" data-size="3.4 million">Berlin</option>
```
#### Списки выбора для работы с объектами модели
В большинстве случаев элементы управления формой будут связаны с определенной моделью, и, как вы, наверное, и ожидали, Rails предоставляет хелперы, предназначенные для этой цели. Как в случае с другими хелперами форм, когда работаете с объектами модели, суффикс `_tag` отбрасывается от `select_tag`:

Если ваш контроллер определил `@person`, и `city_id` этого `person` равен 2:
```
@person = Person.new(city_id: 2)
```
```
+<%= select(:person, :city_id, [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>
```
Создаст результат, подобный следующему
```
<select name="person[city_id]" id="person_city_id">
  <option value="1">Lisbon</option>
  <option value="2" selected="selected">Madrid</option>
  <option value="3">Berlin</option>
</select>
```
Отметьте, что третий параметр - массив пунктов списка - имеет тот же самый тип аргумента, что мы передавали в `options_for_select`. Одно из преимуществ заключается в том, что не стоит беспокоиться об предварительном выборе правильного города, если пользователь уже выбрал его - Rails сделает это за вас, прочитав из атрибута `@person.city_id`.

Как и в других хелперах, если хотите использовать хелпер `select` в `form builder` с областью видимостью объекта `@person`, синтаксис будет такой:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.select(:city_id, [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>
<% end %>
```
В хелпер `select` также можно передать блок:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.select(:city_id) do %>
    <% [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]].each do |c| %>
      <%= content_tag(:option, c.first, value: c.last) %>
    <% end %>
  <% end %>
<% end %>
```
> При использовании `select`, или подобных хелперов, чтобы установить связь `belongs_to`, необходимо передать имя внешнего ключа (в примере выше city_id), а не само имя связи.

> Когда отсутствует `:include_blank` или `:prompt`, `:include_blank` принудительно становится true, если атрибут `required` - true, отображаемый `size` - 1 и `multiple` не равен `true`.

#### Теги пункта списка из коллекции произвольных объектов

Генерация тегов пунктов списка с помощью `options_for_select` требует, чтобы был создан массив, содержащий текст и значение для каждого пункта. Но что, если есть модель `City` (вероятно даже модель Active Record) и нужно сгенерировать теги пунктов списка из коллекции этих объектов? Одним из решений будет сделать вложенный массив с помощью итераций по ним:
```
<% cities_array = City.all.map { |city| [city.name, city.id] } %>
<%= options_for_select(cities_array) %>
```
Хотя это и валидное решение, но Rails предоставляет менее сложную альтернативу: `options_from_collection_for_select`. Этот хелпер принимает коллекцию произвольных объектов и два дополнительных аргумента: имена методов для считывания значений `value` и `text` пункта списка, соответственно:
```
<%= options_from_collection_for_select(City.all, :id, :name) %>
```
Как следует из имени хелпера, это генерирует только теги пункта списка. Для генерации работающего списка выбора, необходимо использовать `collection_select`.
```
<%= collection_select(:person, :city_id, City.all, :id, :name) %>
```
Как и с другими хелперами, если нужно использовать хелпер `collection_select` в связке с `form builder`, привязанным к объекту `@person`, синтаксис будет следующим:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.collection_select(:city_id, City.all, :id, :name) %>
<% end %>
```
> Пары, переданные в `options_for_select` должны сперва иметь текст, затем значение, однако для `options_from_collection_for_select` первый аргумент - это метод для значения, а второй аргумент - метод для текста.

#### Выбор часового пояса и страны
Для управления поддержкой часовых поясов в Rails, можно спрашивать своих пользователей, в какой зоне они находятся. Это потребует сгенерировать пункты списка из списка предопределенных объектов `ActiveSupport::TimeZone`, используя `collection_select`, но можно просто использовать хелпер `time_zone_select`, который уже все это содержит:
```
<%= time_zone_select(:person, :time_zone) %>
```
Также есть хелпер `time_zone_options_for_select` для ручного (и поэтому гибко настраиваемого) способа осуществления этого. Читайте документацию по API, чтобы узнать о доступных аргументах для этих двух методов.

В Rails раньше был хелпер `country_select` для выбора стран, но сейчас он вынесен во внешний плагин `country_select`.

### Использование хелперов даты и времени <a name="3.3.4"></a>
Можно не использовать хелперы форм, генерирующие поля ввода даты и времени HTML5, а использовать альтернативные хелперы даты и времени. Эти хелперы даты и времени отличаются от остальных хелперов форм в двух важных аспектах:
* Дата и время не представлены отдельным элементом ввода. Вместо них есть несколько, один на каждый компонент (год, месяц, день и т.д.), и поэтому нет одного значения в хэше params с вашими датой и временем.
* Другие хелперы используют суффикс `_tag` для обозначения, является ли хелпер скелетным, либо работает на основе объектов модели. Что касается дат и времени, `select_date`, `select_time` и `select_datetime` - это скелетные хелперы, а `date_select`, `time_select` и `datetime_select` - это эквивалентные хелперы объекта модели. 

Оба эти семейства хелперов создадут ряд списков выбора для различных компонентов (год, месяц, день и т.д.)

#### Скелетные хелперы
Семейство хелперов `select_*` принимает как первый аргумент экземпляр `Date`, `Time` или `DateTime`, который используется как текущее выбранное значение. Можете опустить этот параметр в случае, если используется текущая дата. Например:
```
<%= select_date Date.today, prefix: :start_date %>
```
выведет (с опущенными для краткости начальными значениями пунктов списка)
```
<select id="start_date_year" name="start_date[year]">
</select>
<select id="start_date_month" name="start_date[month]">
</select>
<select id="start_date_day" name="start_date[day]">
</select>
```
Эти элементы ввода приведут к тому, что `params[:start_date]` будет хэшем с ключами `:year`, `:month`, `:day`. Чтобы получить фактический объект `Date`, `Time` или `DateTime`, необходимо извлечь эти значения и передать их в подходящий конструктор, например:
```
Date.civil(params[:start_date][:year].to_i, params[:start_date][:month].to_i, params[:start_date][:day].to_i)
```
Опция `:prefix` это ключ, используемый для получения хэша компонентов даты из хэша params. Здесь она была установлена как `start_date`, если опущена, то по умолчанию равна `date`.

#### Хелперы объекта модели
`select_date` не очень хорошо работает с формами, обновляющими или создающими объекты Active Record, так как Active Record ожидает, что каждый элемент хэша params соответствует одному атрибуту. Хелперы объекта модели для даты и времени возвращает параметры со специальными именами, и когда Active Record видит параметры с такими именами, он знает, что они должны быть скомбинированы с другими параметрами, и передает конструктору значения, соответствующему типу столбца. Например:
```
<%= date_select :person, :birth_date %>
```
выдаст (с опущенными для краткости начальными значениями пунктов списка)
```
<select id="person_birth_date_1i" name="person[birth_date(1i)]">
</select>
<select id="person_birth_date_2i" name="person[birth_date(2i)]">
</select>
<select id="person_birth_date_3i" name="person[birth_date(3i)]">
</select>
```
что приведет к такому результату в хэше params
```
{'person' => {'birth_date(1i)' => '2008', 'birth_date(2i)' => '11', 'birth_date(3i)' => '22'}}
```
Когда это передано в `Person.new` (или `update`), Active Record отмечает, что все эти параметры должны быть использованы для конструирования атрибута `birth_date` и использует суффиксную информацию для определения, в каком порядке должен передать эти параметры в такие функции, как `Date.civil`.

#### Общие опции
Оба семейства хелперов используют одинаковый базовый набор функций для генерации индивидуальных тегов `select`, таким образом, они оба принимают в основном одинаковые опции. В частности, по умолчанию Rails сгенерирует пункты списка года как текущий год плюс/минус пять лет. Если это неподходящий интервал, опции `:start_year` и `:end_year` переопределяют это. Для полного списка доступных опции обратитесь к документации по API.

Как правило, следует использовать `date_select` при работе с объектами модели и `select_date` в иных случаях, например, таких как форма поиска, которая фильтрует результаты по дате.

#### Индивидуальные компоненты
Иногда необходимо отобразить лишь одиночный компонент даты, такой как год или месяц. Rails предоставляет ряд хелперов для этого, по одному для каждого компонента `select_year`, `select_month`, `select_day`, `select_hour`, `select_minute`, `select_second`. Эти хелперы достаточно простые. По умолчанию они сгенерируют поле ввода, названное по имени компонента времени (например, "year" для `select_year`, "month" для `select_month` и т.д.), хотя это может быть переопределено в опции `:field_name`. Опция `:prefix` работает так же, как работает для `select_date` и `select_time` и имеет такое же значение по умолчанию.

Первый параметр определяет значение даты, которое будет предложено для выбора (соответствующий элемент может быть извлечен из экземпляра Date, Time или DateTime), либо сразу задается числовым значением. Например:
```
<%= select_year(2009) %>
<%= select_year(Time.new(2009)) %>
```
создадут одинаковый результат, и значение, выбранное пользователем, может быть получено как `params[:date][:year]`.

### Загрузка файлов <a name="3.3.5"></a>
Частой задачей является загрузка некоторого файла, аватарки или файла CSV, содержащего информацию для обработки. Самое важное, это помнить при загрузке файла, что атрибут enctype формы должен быть установлен как "multipart/form-data". Если используете `form_with с :model`, это будет выполнено автоматически. Если используете `form_with без :model`, нужно установить это самому, как в следующем примере.

Следующие две формы обе загружают файл.
```
<%= form_with(url: {action: :upload}, multipart: true) do %>
  <%= file_field_tag 'picture' %>
<% end %>

<%= form_with model: @person do |f| %>
  <%= f.file_field :picture %>
<% end %>
```
Rails предоставляет обычную пару хелперов: скелетный `file_field_tag` и модельно-ориентированный `file_field`. Как и следует ожидать, в первом случае загруженный файл находится в `params[:picture]`, а во втором случае - в `params[:person][:picture]`.

#### Что имеем загруженным
Объект в хэше `params` - это экземпляр `ActionDispatch::Http::UploadedFile`. Следующий образец кода сохраняет загруженное содержимое в `#{Rails.root}/public/uploads` под тем же именем, что и исходный файл.
```
def upload
  uploaded_file = params[:picture]
  File.open(Rails.root.join('public', 'uploads', uploaded_file.original_filename), 'wb') do |file|
    file.write(uploaded_file.read)
  end
end
```
Как только файл был загружен, появляется множество потенциальных задач, начиная от того, где хранить файлы (на диске, Amazon S3 и т.д.), как связать их с моделями, изменить размер файлов изображений и сгенерировать миниатюры. Для помощи с такими задачами разработан Active Storage.

### Настройка Form Builder <a name="3.3.6"></a>
Объект, который передается от `form_with` и `fields_for`, - это экземпляр `ActionView::Helpers::FormBuilder`. `Form builder` инкапсулирует представление элементов формы для отдельного объекта. Хотя, конечно, можно писать хелперы для своих форм обычным способом, так же как можно объявить подкласс `ActionView::Helpers::FormBuilder` и добавить хелперы туда. Например:
```
<%= form_with model: @person do |f| %>
  <%= text_field_with_label f, :first_name %>
<% end %>
```
может быть заменено этим
```
<%= form_with model: @person, builder: LabellingFormBuilder do |f| %>
  <%= f.text_field :first_name %>
<% end %>
```
через определение класса `LabellingFormBuilder` подобным образом:
```
class LabellingFormBuilder < ActionView::Helpers::FormBuilder
  def text_field(attribute, options={})
    label(attribute) + super
  end
end
```
Если это используется часто, можно определить хелпер `labeled_form_with` который автоматически определяет опцию `builder: LabellingFormBuilder`:
```
def labeled_form_with(model: nil, scope: nil, url: nil, format: nil, **options, &block)
  options.merge! builder: LabellingFormBuilder
  form_with model: model, scope: scope, url: url, format: format, **options, &block
end
```
Form builder также определяет, что произойдет, если вы сделаете
```
<%= render partial: f %>
```
Если f - это экземпляр `ActionView::Helpers::FormBuilder`, тогда это отрендерит партиал `form`, установив объект партиала как `form builder`. Если у `form builder` есть класс `LabellingFormBuilder`, тогда вместо него будет отрендерен партиал `labelling_form`.

### Понимание соглашений по именованию параметров <a name="3.3.7"></a>
Значения из форм могут быть на верхнем уровне хэша params или вложены в другой хэш. Например, в стандартном экшне `create` для модели `Person`, `params[:person]` будет обычно хэшем всех атрибутов для создания персоны. Хэш `params` может также содержать массивы, массивы хэшей и тому подобное.

В основном формы HTML не знают о каких-либо структурировании данных, все, что они генерируют - это пары имя-значение, где пары являются обычными строками. Массивы и хэши, которые можно увидеть в своем приложении, - это результат некоторых соглашений по именованию параметров, которые использует Rails.

#### Базовые структуры
Две базовые структуры - это массивы и хэши. Хэши отражают синтаксис, используемый для доступа к значению в params. Например, если форма содержит
```
<input id="person_name" name="person[name]" type="text" value="Henry"/>
```
хэш `params` будет содержать
```
{'person' => {'name' => 'Henry'}}
```
и `params[:person][:name]` получит отправленное значение в контроллере.

Хэши могут быть вложены на столько уровней, сколько требуется, например:
```
<input id="person_address_city" name="person[address][city]" type="text" value="New York"/>
```
вернет такой хэш params
```
{'person' => {'address' => {'city' => 'New York'}}}
```
Обычно Rails игнорирует дублирующиеся имена параметра. Если имя параметра содержит пустой набор квадратных скобок `[]`, то они будут накоплены в массиве. Если нужно, чтобы пользователи могли оставить несколько телефонных номеров, можно поместить это в форму:
```
<input name="person[phone_number][]" type="text"/>
<input name="person[phone_number][]" type="text"/>
<input name="person[phone_number][]" type="text"/>
```
Что приведет к тому, что `params[:person][:phone_number]` будет массивом, содержащим введенные телефонные номера.

#### Комбинируем их
Можно смешивать и сочетать эти две концепции. Один из элементов хэша может быть массивом, как в предыдущем примере, или вы можете иметь массив хэшей. Например, форма может позволить вам создать любое количество адресов, повторяя следующий фрагмент кода
```
<input name="person[addresses][][line1]" type="text"/>
<input name="person[addresses][][line2]" type="text"/>
<input name="person[addresses][][city]" type="text"/>
<input name="person[addresses][][line1]" type="text"/>
<input name="person[addresses][][line2]" type="text"/>
<input name="person[addresses][][city]" type="text"/>
```
Это приведет к тому, что `params[:person][:addresses]` будет массивом хэшей с ключами line1, line2 и city.

Однако, имеется ограничение, в то время как хэши могут быть вложены произвольно, является допустимым только один уровень "массивности". Массивы обычно могут быть заменены хэшами; например, вместо массива объектов модели можно иметь хэш объектов модели с ключами, равными их `id`, индексу массива или любому другому параметру.

> Параметры массива не очень хорошо работают с хелпером `check_box`. В соответствии со спецификацией HTML, невыбранные чекбоксы не возвращают значения. Хелпер `check_box` обходит это, создавая вспомогательное скрытое поле с тем же именем. Если чекбокс не нажат, подтверждается только скрытое поле, а если он нажат, то они оба подтверждаются, но значение от чекбокса получает приоритет.

#### Использование хелперов форм
Предыдущие разделы совсем не использовали хелперы Rails. Хотя можно создавать имена полей ввода самому и передавать их напрямую хелперам, таким как `text_field_tag`, Rails также предоставляет поддержку на более высоком уровне. В вашем распоряжении имеются два инструмента: параметр имени для `form_with` и `fields_for`, и опция `:index`, принимаемая этими хелперами.

Вы возможно захотите рендерить форму с набором полей ввода для каждого адреса человека. Например:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.text_field :name %>
  <% @person.addresses.each do |address| %>
    <%= person_form.fields_for address, index: address.id do |address_form| %>
      <%= address_form.text_field :city %>
    <% end %>
  <% end %>
<% end %>
```
Предположим, у кого-то есть два адреса с id 23 и 45, это создаст что-то подобное:
```
<form accept-charset="UTF-8" action="/people/1" data-remote="true" method="post">
  <input name="_method" type="hidden" value="patch" />
  <input id="person_name" name="person[name]" type="text" />
  <input id="person_address_23_city" name="person[address][23][city]" type="text" />
  <input id="person_address_45_city" name="person[address][45][city]" type="text" />
</form>
```
Это приведет к тому, что хэш params будет выглядеть так
```
{'person' => {'name' => 'Bob', 'address' => {'23' => {'city' => 'Paris'}, '45' => {'city' => 'London'}}}}
```
Rails знает, что все эти поля ввода должны быть частью хэша person, так как `fields_for` вызывается для первого `form builder`. Определив опцию `:index`, сообщается Rails, что вместо именования полей ввода `person[address][city]`, он должен вставить индекс, заключенный в `[]`, между `address` и `city`. Это часто бывает полезно, так как тогда просто обнаружить, какая запись `Address` должна быть модифицирована. Также можно передавать числа с некоторым другим значением, строками или даже `nil` (который приведет к созданию параметра в массиве).

Чтобы создать более замысловатые вложения, можно явно указать первую часть имени поля ввода (`person[address]` в предыдущем примере):
```
<%= fields_for 'person[address][primary]', address, index: address.id do |address_form| %>
  <%= address_form.text_field :city %>
<% end %>
```
создаст такие поля ввода
```
<input id="person_address_primary_1_city" name="person[address][primary][1][city]" type="text" value="Bologna" />
```
Как правило, конечное имя поля ввода - это сцепление имени, переданного в `fields_for/form_with`, значения индекса и имени атрибута. Можно также передать опцию `:index` прямо в хелперы, такие как `text_field`, но обычно будет меньше повторов, если определить это на уровне `form builder`, а не для отдельных элементах управления `input`.

Как ярлык вы можете добавить `[]` к имени и опустить опцию `:index`. Это то же самое, что определение `index: address.id`, таким образом
```
<%= fields_for 'person[address][primary][]', address do |address_form| %>
  <%= address_form.text_field :city %>
<% end %>
```
создаст абсолютно тот же результат, что и предыдущий пример.

### Формы к внешним ресурсам <a name="3.3.8"></a>
Хелперы форм Rails можно использовать и для создания форм для передачи данных внешнему ресурсу. Однако, иногда необходимо установить `authenticity_token` для ресурса; это можно осуществить, передав параметр `authenticity_token: 'your_external_token'` в опциях `form_with`:
```
<%= form_with url: 'http://farfar.away/form', authenticity_token: 'external_token' do %>
  Form contents
<% end %>
```
Иногда при отправке данных внешнему ресурсу, такому как платежный шлюз, поля, которые можно использовать в форме, ограничены внешним API, и генерация `authenticity_token` нежелательна. Чтобы не посылать токен, просто передайте false в опцию `:authenticity_token`:
```
<%= form_with url: 'http://farfar.away/form', authenticity_token: false do %>
  Form contents
<% end %>
```

### Создание сложных форм <a name="3.3.9"></a>
Многие приложения выходят за рамки простых форм, редактирующих одиночные объекты. Например, при создании `Person` можно позволить пользователю (в той же самой форме) создать несколько записей адресов (домашний, рабочий и т.д.). При последующем редактировании этого person, пользователю должно быть доступно добавление, удаление или правка адреса, если это необходимо.

#### Настройка модели
Active Record предоставляет поддержку на уровне модели с помощью метода `accepts_nested_attributes_for`:
```
class Person < ApplicationRecord
  has_many :addresses, inverse_of: :person
  accepts_nested_attributes_for :addresses

end

class Address < ApplicationRecord
  belongs_to :person
end
```
Это создаст метод `addresses_attributes=` в `Person`, позволяющий создавать, обновлять и (опционально) уничтожать адреса.

#### Вложенные формы
Следующая форма позволяет пользователю создать `Person` и связанные с ним адреса.
```
<%= form_with model: @person do |f| %>
  Addresses:
  <ul>
    <%= f.fields_for :addresses do |addresses_form| %>
      <li>
        <%= addresses_form.label :kind %>
        <%= addresses_form.text_field :kind %>

        <%= addresses_form.label :street %>
        <%= addresses_form.text_field :street %>
        ...
      </li>
    <% end %>
  </ul>
<% end %>
```
Когда связь принимает вложенные атрибуты, `fields_for` рендерит свой блок для каждого элемента связи. В частности, если у person нет адресов, он ничего не рендерит. Обычным паттерном для контроллера является построение одного или более пустых дочерних элементов, чтобы как минимум один набор полей был показан пользователю. Следующий пример покажет 2 набора полей адресов в форме нового `person`.
```
def new
  @person = Person.new
  2.times { @person.addresses.build }
end
```
`fields_for` вкладывает `form builder`. Имя параметра будет таким, какое ожидает `accepts_nested_attributes_for`. К примеру, при создании пользователя с 2 адресами, отправленные параметры будут выглядеть так
```
{
  'person' => {
    'name' => 'John Doe',
    'addresses_attributes' => {
      '0' => {
        'kind' => 'Home',
        'street' => '221b Baker Street'
      },
      '1' => {
        'kind' => 'Office',
        'street' => '31 Spooner Street'
      }
    }
  }
}
```
Ключи хэша `:addresses_attributes` не важны, они всего лишь должны быть различными для каждого адреса.

Если связанный объект уже сохранен, `fields_for` автоматически генерирует скрытое поле с id сохраненной записи. Это можно отключить, передав `include_id: false` в `fields_for`.

#### Контроллер
Как обычно, в контроллере необходимо объявить разрешенные параметры, перед их передачей в модель:
```
def create
  @person = Person.new(person_params)
  # ...
end

private
  def person_params
    params.require(:person).permit(:name, addresses_attributes: [:id, :kind, :street])
  end
```

#### Удаление объектов
Можно позволить пользователям удалять связанные объекты, передав `allow_destroy: true` в `accepts_nested_attributes_for`
```
class Person < ApplicationRecord
  has_many :addresses
  accepts_nested_attributes_for :addresses, allow_destroy: true
end
```
Если хэш атрибутов для объекта содержит ключ `_destroy` со значением, вычисляющимся как 'true' (например, 1, '1', true или 'true'), тогда объект будет уничтожен. Эта форма позволяет пользователям удалять адреса:
```
<%= form_with model: @person do |f| %>
  Addresses:
  <ul>
    <%= f.fields_for :addresses do |addresses_form| %>
      <li>
        <%= addresses_form.check_box :_destroy %>
        <%= addresses_form.label :kind %>
        <%= addresses_form.text_field :kind %>
        ...
      </li>
    <% end %>
  </ul>
<% end %>
```
Не забудьте обновить список разрешенных параметров в вашем контроллере, а также включить туда поле `_destroy`:
```
def person_params
  params.require(:person).
    permit(:name, addresses_attributes: [:id, :kind, :street, :_destroy])
end
```

#### Предотвращение пустых записей
Часто полезно игнорировать наборы полей, которые пользователь не заполнял. Этим можно управлять, передав `:reject_if proc` в `accepts_nested_attributes_for`. Этот proc будет вызван для каждого хэша атрибутов, отправляемого формой. Если `proc` возвращает false, тогда Active Record не создаст связанный объект для этого хэша. Следующий пример пытается создать адрес, если установлен атрибут `kind`.
```
class Person < ApplicationRecord
  has_many :addresses
  accepts_nested_attributes_for :addresses, reject_if: lambda {|attributes| attributes['kind'].blank?}
end
```
Вместо этого для удобства можно передать символ `:all_blank`, который создаст `proc`, который отвергнет записи, когда все атрибуты пустые, за исключением любого значения для `_destroy`.

#### Добавление полей на лету
Вместо того, чтобы рендерить несколько наборов полей раньше времени, можно добавить их только тогда, когда пользователь нажимает на кнопку 'Добавить новый адрес'. Rails не предоставляет какой-либо встроенной поддержки для этого. При генерации новых наборов полей следует убедиться, что ключ связанного массива уникальный - наиболее распространенным выбором является текущий JavaScript date (миллисекунды после epoch).

### Использование `form_for` и `form_tag` <a name="3.3.10"></a>
До того, как `form_with` был представлен в Rails 5.1, его функционал был разделен между `form_tag` и `form_for`. Последние сейчас мягко устаревшие. Документация по их использованию находится в старых версиях этого руководства.



# Контроллеры <a name="4"></a>
## Обзор Action Controller <a name="4.1"></a>
### Что делает контроллер? <a name="4.1.1"></a>
После того, как роутер определит, какой контроллер использовать для обработки запроса, контроллер ответственен за осмысление запроса и генерацию подходящего ответа.
Для большинства приложений, основанных на RESTful, контроллер получает запрос (это невидимо для вас, как для разработчика), извлекает или сохраняет данные в модели и использует вьюху для создания результирующего HTML. Если контроллеру необходимо работать немного по-другому, не проблема, это всего лишь наиболее распространенный способ работы контроллера.

Таким образом, контроллер можно рассматривать как посредника между моделями и вьюхами. Он делает данные модели доступными вьюхе, так что она может отображать эти данные пользователю, и он сохраняет или обновляет данные от пользователя в модель.

### Соглашение по именованию контроллеров <a name="4.1.2"></a>
Соглашение по именованию контроллеров в Rails устанавливает предпочтение множественного числа в последнем слове имени контроллера, хотя строго это не требуется (например, ApplicationController). К примеру, `ClientsController` более предпочтителен, чем `ClientController`, `SiteAdminsController` более предпочтителен, чем `SiteAdminController` или `SitesAdminsController`, и так далее.

Следование этому соглашению позволяет вам использовать генераторы маршрутов по умолчанию (например, `resources` и т.п.) без необходимости определять каждый `:path` или `:controller`, и сохраняет последовательным использование хелперов URL и путей во всем вашем приложении.

### Методы и экшны <a name="4.1.3"></a>
Контроллер - это класс Ruby, унаследованный от `ApplicationController` и содержащий методы, как и любой другой класс. Когда ваше приложение получает запрос, роутинг определяет, какой контроллер и экшн нужно запустить, затем Rails создает экземпляр этого контроллера и запускает метод с именем, как у экшна.
```
class ClientsController < ApplicationController
  def new
  end
end
```
В качестве примера, если пользователь перейдет на `/clients/new` в приложении, чтобы добавить нового клиента, Rails создаст экземпляр `ClientsController` и вызовет метод `new`. Отметьте, что пустой метод из вышеприведенного примера будет прекрасно работать, так как Rails по умолчанию отрендерит вьюху `new.html.erb`, если в экшне не будет указано иное. При создании нового `Client`, метод new может сделать переменную экземпляра `@client` доступной во вьюхе:
```
def new
  @client = Client.new
end
```
`ApplicationController` унаследован от `ActionController::Base`, который определяет несколько полезных методов. Это руководство раскроет часть из них, но если вы любопытны, можете увидеть их все в документации по API.

Только `public` методы могут быть вызваны как экшны. Хорошей практикой является уменьшение области видимости методов (при помощи `private` или `protected`), не предназначенных быть экшнами, таких как вспомогательные методы и фильтры.

### Параметры
Возможно, вы хотите получить доступ к данным, посланным пользователем, или к другим параметрам в экшнах вашего контроллера. Существует два типа параметров, доступных в веб-приложениях. Первый - это параметры, посланные как часть URL, называемые параметрами строки запроса. Строка запроса всегда следует после "?" в URL. Второй тип параметров обычно упоминается как данные POST. Эта информация обычно приходит из формы HTML, заполняемой пользователем. Эти параметры еще называют данными POST, так как могут быть посланы только как часть HTTP-запроса метода POST. Rails не делает каких-либо различий между строковыми параметрами и параметрами POST, и они оба доступны в хэше params в вашем контроллере:
```
class ClientsController < ApplicationController
  # Этот экшн использует параметры строки запроса, потому что он
  # запускается HTTP-запросом метода GET, но это не влияет на
  # способ, с помощью которого можно получить доступ к ним.
  # URL для этого экшна выглядит как этот, запрашивающий список
  # активированных клиентов: /clients?status=activated
  def index
    if params[:status] == "activated"
      @clients = Client.activated
    else
      @clients = Client.inactivated
    end
  end

  # Этот экшн использует параметры POST. Они, скорее всего, пришли от
  # формы HTML, которую подтвердил пользователь. URL для этого
  # RESTful запроса будет "/clients", и данные будут посланы
  # как часть тела запроса.
  def create
    @client = Client.new(params[:client])
    if @client.save
      redirect_to @client
    else
      # Эта строчка переопределяет поведение рендеринга по умолчанию,
      # который отрендерил бы вьюху "create".
      render "new"
    end
  end
end
```

#### Параметры в хэше и в массиве
Хэш `params` не ограничен одномерными ключами и значениями. Он может содержать вложенные массивы и хэши. Чтобы послать массив значений, добавьте пустую пару квадратных скобок "[]" к имени ключа:
```
GET /clients?ids[]=1&ids[]=2&ids[]=3
```
> Фактический URL в этом примере будет перекодирован как "/clients?ids%5b%5d=1&ids%5b%5d=2&ids%5b%5b=3", так как "[" и "]" недопустимы в URL. В основном, вам не придется беспокоиться об этом, так как браузер позаботится об этом за вас, а Rails декодирует это обратно, когда получит, но если вы когда-нибудь будете отправлять эти запросы вручную, имейте это в виду.

Значение `params[:ids]` теперь будет `["1", "2", "3"]`. Отметьте, что значения параметра всегда строковое; Rails не делает попыток угадать или предсказать тип.

> Значения, такие как `[nil]` или `[nil, nil, ...]` в `params` по умолчанию заменяются на `[]` по причине безопасности.

Чтобы послать хэш, следует заключить имя ключа в скобки:
```
<form accept-charset="UTF-8" action="/clients" method="post">
  <input type="text" name="client[name]" value="Acme" />
  <input type="text" name="client[phone]" value="12345" />
  <input type="text" name="client[address][postcode]" value="12345" />
  <input type="text" name="client[address][city]" value="Carrot City" />
</form>
```
Когда эта форма будет подтверждена, значение `params[:client]` будет `{ "name" => "Acme", "phone" => "12345", "address" => { "postcode" => "12345", "city" => "Carrot City" } }`. Обратите внимание на вложенный хэш в `params[:client][:address]`.

Объект params ведет себя как хэш, но позволяет взаимозаменяемо использовать символы и строки как ключи.

#### Параметры JSON
Если вы пишете приложение веб-сервиса, возможно вам более комфортно принимать параметры в формате JSON. Если заголовок `"Content-Type"` вашего запроса установлен в `"application/json"`, Rails автоматически загружает ваши параметры в хэш params, к которому можно получить доступ обычным образом.

Так, к примеру, если вы пошлете такое содержимое JSON:
```
{ "company": { "name": "acme", "address": "123 Carrot Street" } }
```
Ваш контроллер будет получать `params[:company]` как `{ "name" => "acme", "address" => "123 Carrot Street" }`.

Также, если включите `config.wrap_parameters` в своем инициализаторе или вызовете wrap_parameters в своем контроллере, можно безопасно опустить корневой элемент в параметре JSON. Параметры будут клонированы и обернуты в ключ, соответствующий по умолчанию имени вашего контроллера. Таким образом, вышеупомянутый запрос JSON может быть записан как:
```
{ "name": "acme", "address": "123 Carrot Street" }
```
И предположим, что мы посылаем данные в `CompaniesController`, тогда он будет обернут в ключ `:company` следующим образом:
```
{ name: "acme", address: "123 Carrot Street", company: { name: "acme", address: "123 Carrot Street" } }
```
Вы сможете настроить имя ключа или определенные параметры, которые вы хотите обернуть, ознакомившись с документацией по API.

> Поддержка парсинга параметров XML была извлечена в гем `actionpack-xml_parser`.

#### Параметры роутинга
Хэш params будет всегда содержать ключи `:controller` и `:action`, но следует использовать методы `controller_name` и `action_name` вместо них для доступа к этим значениям. Любой другой параметр, определенный роутингом, такой как `:id`, также будет доступен. Например, рассмотрим перечень клиентов, где список может быть показан либо для активных, либо для неактивных клиентов. Мы можем добавить маршрут, который перехватывает параметр `:status` в "красивом" URL:
```
get '/clients/:status' => 'clients#index', foo: 'bar'
```
В этом случае, когда пользователь откроет URL `/clients/active`, `params[:status]` будет установлен в "active". Когда использован этот маршрут, `params[:foo]` также будет установлен в "bar", как будто он был передан в строке запроса. Ваш контроллер также получит `params[:action]` как "index" и `params[:controller]` как "clients".

#### `default_url_options`
Можно установить глобальные параметры по умолчанию для генерации URL, определив в контроллере метод по имени `default_url_options`. Этот метод должен возвращать хэш с желаемыми значениями по умолчанию, ключи которого должны быть символами:
```
class ApplicationController < ActionController::Base
  def default_url_options
    # /ru/clients/hub
    # GET /:locale/clients/hub возвращает локаль
    # возможно я не так понял
    { locale: I18n.locale }
  end
end
```
Эти опции будут использованы как начальная точка при генерации URL, поэтому они могут быть переопределены опциями, переданными в `url_for`.

Если определить `default_url_options` в `ApplicationController`, как это показано в вышеприведенном примере, эти значения по умолчанию будут использованы для генерации всех URL. Этот метод также может быть определен в одном отдельном контроллере, и в этом случае он влияет только на URL, сгенерированные в нем.

В данном запросе, на самом деле, метод не вызывается для каждого сгенерированного URL; для повышения производительности, возвращаемый хэш кэшируется, метод выполняется не более одного раза за запрос.

#### Strong Parameters
С помощью сильных параметров (strong parameters) параметры Action Controller запрещены к использованию в массовых назначениях Active Model до тех пор, пока они не добавлены в белый список. Это означает, что нужно будет принять осознанное решение о том, какие атрибуты будут доступны для массового обновления. Это лучший способ предотвратить случайную уязвимость, позволяющую пользователям обновлять чувствительные атрибуты модели.

Кроме того, параметры могут быть помечены как обязательные и будут проходить через предопределенные raise/rescue, что приведет к 400 Bad Request, если не будут переданы все обязательные параметры.
```
class PeopleController < ActionController::Base
  # Это вызовет исключение ActiveModel::ForbiddenAttributesError,
  # так как используется массовое назначение без явного шага permit.
  def create
    Person.create(params[:person])
  end

  # Это будет выполняться должным образом, пока в параметрах есть ключ person, иначе будет
  # вызвано исключение ActionController::ParameterMissing, которое будет
  # поймано в ActionController::Base и превращено в ошибку 400 Bad Request.
  def update
    person = current_account.people.find(params[:id])
    person.update!(person_params)
    redirect_to person
  end

  private
    # Использование приватного метода для инкапсуляции разрешенных параметров -
    # это всего лишь хороший паттерн, с помощью которого можно повторно
    # использовать тот же самый список разрешений при создании и обновлении.
    # Этот метод также можно адаптировать к проверке разрешенных атрибутов для
    # каждого пользователя.
    def person_params
      params.require(:person).permit(:name, :age)
    end
end
```
#####  Разрешенные скалярные значения
Для данного
```
params.permit(:id)
```
ключ `:id` пройдет проверку белым списком, если он появится в `params` и будет иметь разрешенное скалярное значение. В ином случае ключ будет отфильтрован, таким образом, массивы, хэши и любые другие объекты не смогут быть переданы.

Разрешенные скалярные типы следующие `String, Symbol, NilClass, Numeric, TrueClass, FalseClass, Date, Time, DateTime, StringIO, IO, ActionDispatch::Http::UploadedFile и Rack::Test::UploadedFile`.

Чтобы объявить, что значение в params должно быть массивом разрешенных скалярных значений, свяжите ключ с пустым массивом:
```
params.permit(id: [])
```
Иногда невозможно или неудобно объявлять валидные ключи параметров хэша или его внутреннюю структуру. Просто укажите пустой хэш:
```
params.permit(preferences: {})
```
но будьте осторожны, так это открывает возможность произвольного ввода. В этом случае `permit` гарантирует, что значения в возвращаемой структуре являются разрешенными скалярными величинами и отфильтровывает все иное.

Чтобы добавить в белый список полный хэш параметров, может быть использован метод `permit!`
```
params.require(:log_entry).permit!
```
Это помечает хэш параметров `:log_entry` и любые вложенные хэши как разрешенные, и не проверяет разрешенные скалярные величины, принимается все. Следует соблюдать предельную осторожность при использовании `permit!`, так как он позволит массовое назначение всех текущих и будущих атрибутов модели.

##### Вложенные параметры
Также можно использовать `permit` c вложенными параметрами, например:
```
params.permit(:name, { emails: [] },
              friends: [ :name,
                         { family: [ :name ], hobbies: [] }])
```
Это объявление поместит в белый список атрибуты `name`, `emails` и `friends`. Ожидается, что `emails` будет массивом разрешенных скалярных значений, и что `friends` будет массивом ресурсов с определенными атрибутами: у них будет атрибут name (допустимо любое скалярное значение), атрибут `hobbies` как массив разрешенных скалярных значений, и атрибут `family`, который может иметь только name (также допустимо любое скалярное значение).

##### Дополнительные примеры
Возможно вы захотите использовать разрешенные атрибуты в экшне `new`. В этой связи возникает проблема, из-за которой нельзя использовать `require` на корневом ключе, так как обычно он не существует при вызове `new`:
```
# используя `fetch`, можно предоставить значение по умолчанию и использовать
# далее Strong Parameters API.
params.fetch(:blog, {}).permit(:title, :author)
```
Метод класса модели `accepts_nested_attributes_for` позволяет обновлять и удалять связанные записи. Он основывается на параметрах `id` и `_destroy`:
```
# permit :id и :_destroy
params.require(:author).permit(:name, books_attributes: [:title, :id, :_destroy])
```
Хэши с числовыми ключами трактуются по-другому, и можно объявить атрибуты так, как будто они являются прямыми детьми. Такой тип параметров можно получить при использовании `accepts_nested_attributes_for` в сочетании со связью `has_many`:
```
# Чтобы добавить в белый список следующие данные:
# {"book" => {"title" => "Some Book",
#             "chapters_attributes" => { "1" => {"title" => "First Chapter"},
#                                        "2" => {"title" => "Second Chapter"}}}}

params.require(:book).permit(:title, chapters_attributes: [:title])
```
##### За пределами области видимости Strong Parameters
Strong parameter API был разработан для наиболее общих вариантов использования. Это не панацея от всех ваших проблем белого списка. Однако можно легко смешивать API с вашим собственным кодом для адаптации к вашей ситуации.

Рассмотрим ситуацию, когда есть параметры, представляющие имя продукта, и хэш произвольных данных, связанных с этим продуктом, и нужно поместить в белый список атрибут name продукта, а также весь хэш данных. API в strong parameters не позволит явно добавить в белый список весь вложенный хэш с любыми ключами, но можно использовать ключи вложенного хэша для объявления, что следует добавить в белый список:
```
def product_params
  params.require(:product).permit(:name, data: params[:product][:data].try(:keys))
end
```

###  Сессия <a name="4.1.5"></a>
В приложении есть сессия для каждого пользователя, в которой можно хранить небольшие объемы данных, которые будут персистентными между запросами. Сессия доступна только в контроллере и во вьюхе, и может использовать один из нескольких механизмов хранения:
* `ActionDispatch::Session::CookieStore` - Хранит все на клиенте.
* `ActionDispatch::Session::CacheStore` - Хранит данные в кэше Rails.
* `ActionDispatch::Session::ActiveRecordStore` - Хранит данные в базе данных с использованием Active Record. (требует гем `activerecord-session_store`).
* `ActionDispatch::Session::MemCacheStore` - Хранит данные в кластере memcached (эта устаревшая реализация, вместо нее рассмотрите использование `CacheStore`). 

Все хранилища сессии используют куки для хранения уникального ID каждой сессии (вы должны использовать куки, Rails не позволяет передавать ID сессии в URL, так как это менее безопасно).

В большинстве хранилищ этот ID используется для поиска данных сессии на сервере, в т.ч. в таблице базы данных. Имеется одно исключение, это дефолтное и рекомендуемое хранилище сессии - `CookieStore` - которое хранит все данные сессии в куки (ID остается по-прежнему доступным, если он нужен). Преимущества его заключаются в легкости, отсутствии необходимости настройки для нового приложения в порядке использования сессии. Данные в куки криптографически подписаны, что делает их защищенными от взлома. И они также зашифрованы, таким образом любой получивший к ним доступ, не сможет прочитать их содержимое (Rails не примет их, если они были отредактированы).

CookieStore могут хранить около 4 Кбайт данных - намного меньше, чем остальные - но этого обычно хватает. Хранение большего количества данных в сессии не рекомендуется, вне зависимости от того, какое хранилище сессии используется в приложении. Особенно следует избегать хранения в сессии сложных объектов (ничего, кроме базовых объектов Ruby, наиболее распространенным примером является экземпляры модели), так как сервер может не собрать их между запросами, что приведет к ошибке.

Если пользовательские сессии не хранят критически важные данные или нет необходимости в ее сохранности на долгий период (скажем, если она используется только для флеш-сообщений), можно рассмотреть использование `ActionDispatch::Session::CacheStore`. Он сохранит сессии с использованием реализации кэша, которая была настроена для приложения. Преимущество этого заключается в том, что для хранения сессий можно использовать существующую инфраструктуру кэширования без необходимости дополнительных настроек или администрирования. Недостатком, разумеется, является то, что сессии будут недолговечными и могут исчезнуть в любое время.

Читайте подробнее о хранении сессий в руководстве Безопасность приложений на Rails.

Если вы нуждаетесь в другом механизме хранения сессий, измените его в инициализаторе:
```
# Use the database for sessions instead of the cookie-based default,
# which shouldn't be used to store highly confidential information
# (create the session table with "rails g active_record:session_migration")
# Rails.application.config.session_store :active_record_store
```
Rails устанавливает ключ сессии (имя куки) при подписании данных сессии. Он также может быть изменен в инициализаторе:
```
# Be sure to restart your server when you modify this file.
Rails.application.config.session_store :cookie_store, key: '_your_app_session'
```
Можете также передать ключ `:domain` и определить имя домена для куки:
```
# Be sure to restart your server when you modify this file.
Rails.application.config.session_store :cookie_store, key: '_your_app_session', domain: ".example.com"
```
Rails устанавливает (для CookieStore) секретный ключ, используемый для подписания данных сессии, в `config/credentials.yml.enc`. Он может быть изменен с помощью `bin/rails credentials:edit`.
```
# aws:
#   access_key_id: 123
#   secret_access_key: 345

# Used as the base secret for all MessageVerifiers in Rails, including the one protecting cookies.
secret_key_base: 492f...
```
> Изменение `secret_key_base` при использовании `CookieStore` делает все предыдущие сессии невалидными.

#### Доступ к сессии
В контроллере можно получить доступ к сессии с помощью метода экземпляра `session`.

Сессии лениво загружаются. Если не получать доступ к сессиям в коде экшна, они не будут загружаться. Следовательно, никогда не придется отключать сессии, просто не обращайтесь к ним, и они будут выполнять свое задание.

Значения сессии хранятся, используя пары ключ/значение, подобно хэшу:
```
class ApplicationController < ActionController::Base

  private

  # Находим пользователя с ID, хранящимся в сессии с ключом
  # :current_user_id Это обычный способ обрабатывать вход пользователя
  # в приложении на Rails; вход устанавливает значение сессии, а
  # выход убирает его.
  def current_user
    @_current_user ||= session[:current_user_id] &&
      User.find_by(id: session[:current_user_id])
  end
end
```
Чтобы что-то хранить в сессии, просто присвойте это ключу, как в хэше:
```
class LoginsController < ApplicationController
  # "Создаем" логин (при входе пользователя)
  def create
    if user = User.authenticate(params[:username], params[:password])
      # Сохраняем ID пользователя в сессии, так что он может быть использован
      # в последующих запросах
      session[:current_user_id] = user.id
      redirect_to root_url
    end
  end
end
```
Чтобы убрать что-то из сессии, удалите пару ключ/значение:
```
class LoginsController < ApplicationController
  # "Удаляем" логин (при выходе пользователя)
  def destroy
    # Убираем id пользователя из сессии
    session.delete(:current_user_id)
    # Очистить мемоизированного текущего пользователя
    @_current_user = nil
    redirect_to root_url
  end
end
```
Для сброса текущей сессии, используйте `reset_session`.

#### Flash
Flash - это специальная часть сессии, которая очищается с каждым запросом. Это означает, что сохраненные там значения будут доступны только в следующем запросе, что полезно для передачи сообщений об ошибках и т.п.

Доступ к нему можно получить так же, как к сессии, подобно хэшу (это экземпляр FlashHash).

Давайте рассмотрим случай логаута в качестве примера. Контроллер может послать сообщение, которое будет отображено пользователю при следующем запросе:
```
class LoginsController < ApplicationController
  def destroy
    session.delete(:current_user_id)
    flash[:notice] = "You have successfully logged out."
    redirect_to root_url
  end
end
```
Отметьте, что также возможно назначить сообщение флэш как часть перенаправления. Можно назначить `:notice`, `:alert` или общего назначения `:flash`:
```
redirect_to root_url, notice: "You have successfully logged out."
redirect_to root_url, alert: "You're stuck here!"
redirect_to root_url, flash: { referral_code: 1234 }
```
Экшн destroy перенаправляет на `root_url` приложения, где будет отображено сообщение. Отметьте, что от следующего экшна полностью зависит решение, будет ли он или не будет что-то делать с тем, что предыдущий экшн вложил во `flash`. Принято отображать любые сообщения об ошибке или уведомления из `flash` в макете приложения:
```
<html>
  <!-- <head/> -->
  <body>
    <% flash.each do |name, msg| -%>
      <%= content_tag :div, msg, class: name %>
    <% end -%>

    <!-- дальнейшее содержимое -->
  </body>
</html>
```
В этом случае, если экшн установил сообщения уведомления или предупреждения, макет отобразит их автоматически.

Можно передать все, что только сессия может хранить; вы не ограничены уведомлениями или предупреждениями:
```
<% if flash[:just_signed_up] %>
  <p class="welcome">Welcome to our site!</p>
<% end %>
```
Если хотите, чтобы значение `flash` было перенесено в другой запрос, используйте метод `keep`:
```
class MainController < ApplicationController
  # Давайте скажем этому экшну, соответствующему root_url, что хотим
  # все запросы сюда перенаправить на UsersController#index. Если
  # экшн установил flash и направил сюда, значения в нормальной ситуации
  # будут потеряны, когда произойдет другой редирект, но Вы можете
  # использовать 'keep', чтобы сделать его персистентным для другого запроса.
  def index
    # Все значения flash будут персистентными.
    flash.keep

    # Можете также использовать ключ для сохранения определенных значений.
    # flash.keep(:notice)
    redirect_to users_url
  end
end
```

##### `flash.now`
По умолчанию, добавление значений во `flash` делает их доступными для следующего запроса, но иногда хочется иметь доступ к этим значениям в том же запросе. Например, если экшн `create` проваливается при сохранении ресурса, и будет отрендерен непосредственно макет new, что не приведет к новому запросу, но все равно можно отобразить сообщение, используя `flash`. Чтобы это сделать, используйте `flash.now` так же, как используете обычный `flash`:
```
class ClientsController < ApplicationController
  def create
    @client = Client.new(params[:client])
    if @client.save
      # ...
    else
      flash.now[:error] = "Could not save client"
      render action: "new"
    end
  end
end
```

### Куки <a name="4.1.6"></a>
Приложение может хранить небольшое количество данных у клиента - в так называемых куки - которые будут персистентными между запросами и даже сессиями. Rails обеспечивает простой доступ к куки посредством метода `cookies`, который - очень похож на `session` - и работает как хэш:
```
class CommentsController < ApplicationController
  def new
    # Автозаполнение имени комментатора, если оно хранится в куки.
    @comment = Comment.new(author: cookies[:commenter_name])
  end

  def create
    @comment = Comment.new(params[:comment])
    if @comment.save
      flash[:notice] = "Thanks for your comment!"
      if params[:remember_name]
        # Запоминаем имя комментатора.
        cookies[:commenter_name] = @comment.author
      else
        # Удаляем из куки имя комментатора, если оно есть.
        cookies.delete(:commenter_name)
      end
      redirect_to @comment.article
    else
      render action: "new"
    end
  end
end
```
Отметьте, что если для удаления значений сессии ключ устанавливается в nil, то для удаления значений куки следует использовать `cookies.delete(:key)`.

Rails также предоставляет подписанные куки и зашифрованные куки для хранения чувствительных данных. В подписанные куки добавляется криптографическая сигнатура значений куки для защиты их целостности. Зашифрованные куки шифруют значения в дополнение к их подписи, поэтому они не могут быть прочитаны пользователем. За подробностями обратитесь к документации API.

Эти специальные куки используют сериализатор для сериализации назначенных значений в строки и десериализации их в объекты Ruby при чтении.

Можно определить, какой сериализатор использовать:
```
Rails.application.config.action_dispatch.cookies_serializer = :json
```
Для новых приложений сериализатором по умолчанию является `:json`. Для совместимости со старыми приложениями с существующими куки, используется `:marshal`, когда не определена опция `serializer`.

Также можно установить этой опции ``:hybrid`, в этом случае Rails десериализует существующие (сериализованные Marshal) куки при чтении и перезапишет их в формате JSON. Это полезно при миграции существующих приложений на сериализатор `:json`.

Также возможно передать произвольный сериализатор, откликающийся на `load` и `dump`:
```
Rails.application.config.action_dispatch.cookies_serializer = MyCustomSerializer
```
При использовании сериализатора `:json` или `:hybrid`, следует знать, что не все объекты Ruby могут быть сериализованы как JSON. Например, объекты `Date` и `Time` будут сериализованы как строки, и у хэшей ключи будут преобразованы в строки.
```
class CookiesController < ApplicationController
  def set_cookie
    cookies.encrypted[:expiration_date] = Date.tomorrow # => Thu, 20 Mar 2014
    redirect_to action: 'read_cookie'
  end

  def read_cookie
    cookies.encrypted[:expiration_date] # => "2014-03-20"
  end
end
```
Желательно, чтобы в куки хранились только простые данные (строки и числа). Если храните сложные объекты, вам необходимо преобразовывать вручную при чтении значений в последующих запросах.

Если вы храните сессию в куки, все перечисленное также применяется к хэшам `session` и `flash`.

### Рендеринг данных XML и JSON <a name="4.1.7"></a>
ActionController позволяет очень просто рендерить данные XML или JSON. Если сгенерируете контроллер с помощью скаффолда, то он будет выглядеть следующим образом.
```
class UsersController < ApplicationController
  def index
    @users = User.all
    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render xml: @users }
      format.json { render json: @users }
    end
  end
end
```
Отметьте, что в вышеописанном коде использован `render xml: @users`, а не `render xml: @users.to_xml`. Если объект не String, то Rails автоматически вызовет `to_xml`.

### Фильтры <a name="4.1.8"></a>
Фильтры - это методы, которые запускаются "до", "после" или "до и после" экшна контроллера.

Фильтры наследуются, поэтому, если вы установите фильтр в `ApplicationController`, он будет запущен в каждом контроллере вашего приложения.

Фильтры "before" могут прерывать цикл запроса. Обычный фильтр "before" - это, например, тот, который требует, чтобы пользователь был авторизован для запуска экшна. Метод фильтра можно определить следующим образом:
```
class ApplicationController < ActionController::Base
  before_action :require_login

  private

  def require_login
    unless logged_in?
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url # прерывает цикл запроса
    end
  end
end
```
Метод просто записывает сообщение об ошибке во `flash` и перенаправляет на форму авторизации, если пользователь не авторизовался. Если фильтр "before" рендерит или перенаправляет, экшн не запустится. Если есть дополнительные фильтры в очереди, они также будут отменены.

В этом примере фильтр добавлен в `ApplicationController`, и поэтому все контроллеры в приложении наследуют его. Это приводит к тому, что всё в приложении требует, чтобы пользователь был авторизован, чтобы пользоваться им. По понятным причинам (пользователь не сможет зарегистрироваться в первую очередь!), не все контроллеры или экшны должны требовать его. Вы можете не допустить запуск этого фильтра перед определенными экшнами с помощью `skip_before_action`:
```
class LoginsController < ApplicationController
  skip_before_action :require_login, only: [:new, :create]
end
```
Теперь, экшны `LoginsController` `new` и `create` будут работать как раньше, без требования к пользователю быть зарегистрированным. Опция `:only` используется для пропуска фильтра только для этих экшнов, а также есть опция `:except`, которая работает наоборот. Эти опции можно использовать и при добавлении фильтров, поэтому необходимо добавить фильтр, который запускается только для выбранных экшнов в первую очередь.

> Вызов одного и того же фильтра несколько раз с разными опциями не будет работать, поскольку последнее определение фильтра перезапишет предыдущие.

#### After фильтры и around фильтры
В дополнение к фильтрам "before", можно запустить фильтры после того, как экшн был выполнен, или "и до, и после".

Фильтры "after" похожи на "before", но поскольку экшн уже был запущен, у них есть доступ к данным отклика, которые будут отосланы клиенту. Очевидно, фильтры "after" не могут остановить экшн от запуска. Обратите внимание, что фильтры "after" выполняются только после успешного выполнения экшна, но не при возникновении исключения в цикле запроса.

Фильтры "around" ответственны за запуск связанных с ними экшнов с помощью `yield`, подобно тому, как работают промежуточные программы Rack.

Например, на веб-сайте, где для изменений есть процедура утверждения информации, администратор может легко их просмотреть, просто применив их внутри транзакции:
```
class ChangesController < ApplicationController
  around_action :wrap_in_transaction, only: :show

  private

  def wrap_in_transaction
    ActiveRecord::Base.transaction do
      begin
        yield
      ensure
        raise ActiveRecord::Rollback
      end
    end
  end
end
```
Отметьте, что фильтры "around" также оборачивают рендеринг. В частности, если в вышеуказанном примере вьюха сама начнет считывать из базы данных (например через скоуп), она это осуществит внутри транзакции, предоставив, таким образом, данные для предварительного просмотра.

Можно не вызывать `yield` и создать отклик самостоятельно, в этом случае экшн не будет запущен.

#### Другие способы использования фильтров
Хотя наиболее распространенный способ использование фильтров - это создание `private` методов и использование `*_action` для их добавления, есть два других способа делать то же самое.

Первый - это использовать блок прямо в методах `*_action`. Блок получает контроллер как аргумент. Фильтр `require_login` может быть переписан с использованием блока:
```
class ApplicationController < ActionController::Base
  before_action do |controller|
    unless controller.send(:logged_in?)
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url
    end
  end
end
```
Отметьте, что фильтр в этом случае использует метод send, так как `logged_in?` является `private`, и фильтр не запустится в области видимости контроллера. Это не рекомендуемый способ применения такого особого фильтра, но в простых задачах он может быть полезен.

Второй способ - это использовать класс (фактически, подойдет любой объект, реагирующий правильными методами) для управления фильтрацией. Это полезно для более сложных задач, которые не могут быть осуществлены предыдущими двумя способами по причине трудности читаемости и повторного использования. Как пример, можете переписать фильтр авторизации снова, использовав класс:
```
class ApplicationController < ActionController::Base
  before_action LoginFilter
end

class LoginFilter
  def self.before(controller)
    unless controller.send(:logged_in?)
      controller.flash[:error] = "You must be logged in to access this section"
      controller.redirect_to controller.new_login_url
    end
  end
end
```
Опять же, это не идеальный пример для этого фильтра, поскольку он не запускается в области видимости контроллера, а получает контроллер как аргумент. Класс фильтра должен реализовывать метод с тем же именем, что и фильтр, поэтому для фильтра `before_action` класс должен реализовать метод `before`, и так далее. Метод around должен иметь `yield` для выполнения экшна.

### Защита от подделки запроса <a name="4.1.9"></a>
Межсайтовая подделка запроса (CSRF, Cross-Site Request Forgery) - это тип атаки, в которой сайт обманом заставляет пользователя сделать запрос на другой сайт, возможно, добавляя, модифицируя или удаляя данные на этом сайте без ведома или прав доступа пользователя.

Первый шаг, чтобы избежать это - убедиться, что все "разрушительные" экшны (создание, обновление и уничтожение) могут быть доступны только не-GET-запросам. Если вы следуете соглашениям RESTful, то уже делаете это. Однако, сайт злоумышленника может также легко послать не-GET-запрос на ваш сайт, поэтому и необходима защита от подделки запроса. Как сказано в названии, он защищает от подделки запроса.

Это можно сделать, добавив неугадываемый токен, известный только вашему серверу, в каждый запрос. При этом способе, если запрос приходит без подходящего токена, ему будет отказано в доступе.

Если вы генерируете подобную форму:
```
<%= form_with model: @user, local: true do |form| %>
  <%= form.text_field :username %>
  <%= form.text_field :password %>
<% end %>
```
то увидите, как токен будет добавлен в скрытое поле:
```
<form accept-charset="UTF-8" action="/users/1" method="post">
<input type="hidden"
       value="67250ab105eb5ad10851c00a5621854a23af5489"
       name="authenticity_token"/>
<!-- fields -->
</form>
```
Rails добавит этот токен в каждую форму, генерируемую с помощью хелперов форм, таким образом, большую часть времени можете об этом не беспокоиться. Если вы пишете формы вручную или хотите добавить токен по другой причине, это можно сделать, используя метод `form_authenticity_token`:

`form_authenticity_token` генерирует валидный аутентификационный токен. Его полезно размещать в тех местах, куда Rails не добавляет его автоматически, например в произвольные вызовы Ajax.

В руководстве Безопасность приложений на Rails имеется более подробная информация об этом, и множество других вопросов, посвященных безопасности, которые вы должны принимать во внимание при разработке веб-приложения.

### Объекты Request и Response <a name="4.1.10"></a>
В каждом контроллере есть два акцессор-метода, указывающих на объекты запроса и отклика, связанные с циклом запроса, находящегося в текущее время на стадии выполнения. Метод request содержит экземпляр `ActionDispatch::Request`, а метод `response` возвращает объект отклика, представляющий то, что будет отправлено обратно на клиента.

#### Объект `request`
Объект `request` содержит множество полезной информации о запросе, полученном с клиента. Чтобы получить полный перечень доступных методов, обратитесь к документации по Rails API и документации по Rack. В числе свойств, доступных для этого объекта, следующие:

|Свойство | Назначение |
|---------|------------|
| `host` 	| Имя хоста, используемого для этого запроса. |
| `domain(n=2)` | Первые n сегментов имени хоста, начиная справа (домен верхнего уровня).|
| `format` | 	Тип содержимого, запрошенного с клиента. |
| `method` | 	Метод HTTP, использованного для запроса. |
| `get?`, `post?`, `patch?`, `put?`, `delete?`, `head?` | Возвращает `true`, если метод HTTP - это GET/POST/PATCH/PUT/DELETE/HEAD. |
| `headers` |	Возвращает хэш, содержащий заголовки, связанные с запросом. |
| `port` | Номер порта (целое число), использованного для запроса. |
| `protocol` | Возвращает строку, содержащую использованный протокол плюс "://", например "http://". |
| `query_string` | 	Часть URL со строкой запроса, т.е. все после "?". |
| `remote_ip` |	Адрес IP клиента. |
| `url` | Полный URL, использованный для запроса. |

##### `path_parameters`, `query_parameters` и `request_parameters`
Rails собирает все параметры, посланные вместе с запросом, в хэше `params`, были ли они посланы как часть строки запроса, либо в теле запроса `post`. У объекта `request` имеется три акцессора, которые предоставляют доступ к этим параметрам в зависимости от того, откуда они пришли. Хэш `query_parameters` содержит параметры, посланные как часть строки запроса, в то время как хэш `request_parameters` содержит параметры, посланные как часть тела `post`. Хэш `path_parameters` содержит параметры, распознанные роутингом как часть пути, ведущего к определенному контроллеру и экшну.


#### Объект `response`

Объект `response` (отклик) обычно не используется напрямую, а создается во время выполнения экшна и рендеринга данных, которые посылаются обратно пользователю, но иногда - например, в последующем фильтре - бывает полезно иметь доступ к отклику напрямую. Некоторые из этих акцессор-методов имеют сеттеры, позволяющие изменять их значения. Чтобы получить полный перечень доступных методов, обратитесь к документации по Rails API и документации по Rack.

| Свойство | Назначение |
|----------|------------|
| `body` 	 | Это строка данных, которая будет возвращена клиенту. Чаще всего это HTML. |
| `status` |	Код статуса HTTP для отклика, например 200 для успешного запроса или 404 для ненайденного файла. |
| `location` | URL, по которому клиент будет перенаправлен, если указан. |
| `content_type` | Тип содержимого отклика. |
| `charset` |	Кодировка, используемая для отклика. По умолчанию это "utf-8". |
| `headers` | Заголовки, используемые для отклика. |

##### Установка пользовательских заголовков
Если хотите установить произвольные заголовки для отклика, то `response.headers` - как раз то место, что нужно. Атрибут `headers` - это хэш, который связывает имена заголовков с их значениями, а Rails устанавливает некоторые из них автоматически. Если нужно добавить или изменить заголовок, просто назначьте его `response.headers` следующим образом:
```
response.headers["Content-Type"] = "application/pdf"
```
В вышеприведенном случае более очевидным было бы использование сеттера `content_type`.

### Аутентификации HTTP <a name="4.1.11"></a>
Rails поставляется с двумя встроенными механизмами аутентификации HTTP:
* Базовая аутентификация
* Дайджест-аутентификация 

#### Базовая аутентификация HTTP
Базовая аутентификация HTTP - это аутентификационная схема, поддерживаемая большинством браузеров и других клиентов HTTP. Как пример, рассмотрим раздел администрирования, который доступен только при вводе имени пользователя и пароля в основном диалоговом окне браузера. Использование встроенной аутентификации достаточно простое и требует использования одного метода `http_basic_authenticate_with`.
```
class AdminsController < ApplicationController
  http_basic_authenticate_with name: "humbaba", password: "5baa61e4"
end
```
Благодаря этому можно создавать именованные контроллеры, наследуемые от `AdminsController`. Таким образом, предварительный фильтр будет запущен для всех экшнов в этих контроллерах, защищая их с помощью базовой аутентификации HTTP.

#### Дайджест-аутентификация HTTP
Дайджест-аутентификация HTTP превосходит базовую аутентификацию, так как она не требует от клиента посылать незашифрованный пароль по сети (хотя базовая аутентификация HTTP безопасна через HTTPS). Использовать дайджест-аутентификацию с Rails просто, и это потребует только один метод `authenticate_or_request_with_http_digest`.
```
class AdminsController < ApplicationController
  USERS = { "lifo" => "world" }

  before_action :authenticate

  private

    def authenticate
      authenticate_or_request_with_http_digest do |username|
        USERS[username]
      end
    end
end
```
Как мы видим из примера, блок `authenticate_or_request_with_http_digest` принимает только один аргумент - имя пользователя. И блок возвращает пароль. Возврат `false` или `nil` из `authenticate_or_request_with_http_digest` вызовет провал аутентификации.

### Потоки и загрузка файлов <a name="4.1.12"></a>
Иногда хочется послать пользователю файл вместо рендеринга страницы HTML. Все контроллеры в Rails имеют методы `send_data` и `send_file`, которые направляют данные на клиента. `send_file` - это удобный метод, который позволяет указать имя файла на диске, а он направит содержимое этого файла вам.

Чтобы направить данные на клиента, используйте `send_data`:
```
require "prawn"
class ClientsController < ApplicationController
  # Генерирует документ PDF с информацией на клиента и возвращает
  # его. Пользователь получает PDF как загрузку файла.
  def download_pdf
    client = Client.find(params[:id])
    send_data generate_pdf(client),
              filename: "#{client.name}.pdf",
              type: "application/pdf"
  end

  private

    def generate_pdf(client)
      Prawn::Document.new do
        text client.name, align: :center
        text "Address: #{client.address}"
        text "Email: #{client.email}"
      end.render
    end
end
```
Экшн `download_pdf` в примере вызовет private метод, который фактически сгенерирует документ PDF и возвратит его как строку. Эта строка будет направлена клиенту как загрузка файла, и пользователю будет предложено имя файла. Иногда при потоковой передаче файлов пользователю может не потребоваться загрузка файла. Возьмите, например, изображения, которые могут быть встроены в страницы HTML. Чтобы сказать браузеру, что файл не предназначен для скачивания, нужно установить опцию `:disposition` как "inline". Противоположное дефолтное значение этой опции - "attachment".

####  Отправка файлов
Если хотите отправить файл, уже существующий на диске, используйте метод `send_file`.
```
class ClientsController < ApplicationController
  # Потоковая передача файла, который уже был сгенерирован и сохранен на диск.
  def download_pdf
    client = Client.find(params[:id])
    send_file("#{Rails.root}/files/clients/#{client.id}.pdf",
              filename: "#{client.name}.pdf",
              type: "application/pdf")
  end
end
```
Это прочтет и передаст файл блоками в 4 Кбайт за раз, избегая загрузки в память сразу целого файла. Можно отключить потоковую передачу с помощью опции `:stream` или отрегулировать размер блока с помощью опции `:buffer_size`.

Если не указан `:type`, он будет определяться по расширению файла, указанного в `:filename`. Если для расширения не зарегистрирован тип содержимого, будет использован `application/octet-stream`.

> Будьте осторожны, когда используете данные, пришедшие с клиента (params, куки и т.д.), для обнаружения файла на диске, так как есть риск безопасности в том, что кто-то может получить доступ к файлам, к которым иметь он не должен.

> Не рекомендуется передавать в потоке статичные файлы через Rails, если можно вместо этого разместить их в папке public на веб-сервере. Более эффективно разрешить пользователям скачивать файлы напрямую, используя Apache или другой веб-сервер, сохраняя запрос от ненужного прогона через весь стек Rails.

#### Загрузка RESTful
Хотя `send_data` работает прекрасно, если вы создаете приложение на принципах RESTful, наличие отдельных экшнов для загрузок файла обычно не требуется. В терминологии REST файл PDF из вышеприведенного примера можно рассматривать еще одним представлением ресурса client. Rails предоставляет простой и наглядный способ осуществления загрузок в стиле RESTful. Вот как можно переписать пример, чтобы загрузка PDF была частью экшна show без какой-либо потоковой передачи:
```
class ClientsController < ApplicationController
  # Пользователь может запросить получение этого ресурса как HTML или PDF.
  def show
    @client = Client.find(params[:id])

    respond_to do |format|
      format.html
      format.pdf { render pdf: generate_pdf(@client) }
    end
  end
end
```
Для того, чтобы этот пример заработал, нужно добавить PDF тип MIME в Rails. Это можно сделать, добавив следующую строчку в файл `config/initializers/mime_types.rb`:
```
Mime::Type.register "application/pdf", :pdf
```
> Конфигурационные файлы не перезагружаются с каждым запросом, поэтому необходимо перезапустить сервер для того, чтобы изменения вступили в силу.

Теперь пользователь может запрашивать получение версии в PDF, просто добавив ".pdf" в URL:
```
GET /clients/1.pdf
```

#### Live Streaming произвольных данных
Rails позволяет отдавать в потоке не только файлы. Фактически, в объекте отклика можно отдать все, что хотите. Модуль `ActionController::Live` позволяет создать персистентное соединение с браузером. Используя этот модуль, можно послать в браузер произвольные данные в определенные моменты времени.

##### Подключение Live Streaming
Включение `ActionController::Live` в класс вашего контроллера предоставит всем экшнам контроллера возможность отдавать данные в потоке. Этот модуль можно включить следующим образом:
```
class MyController < ActionController::Base
  include ActionController::Live

  def stream
    response.headers['Content-Type'] = 'text/event-stream'
    100.times {
      response.stream.write "hello world\n"
      sleep 1
    }
  ensure
    response.stream.close
  end
end
```
Вышеприведенный код будет поддерживать персистентное соединение с браузером и пошлет 100 сообщений "hello world\n", раз в секунду каждое.

В вышеприведенном примере нужно обратить внимание на ряд вещей. Необходимо убедиться, что потоковый отклик будет закрыт. Если забыть закрыть, поток оставит навсегда открытым сокет. Также необходимо установить тип содержимого `text/event-stream` до записи в поток отклика. Это так, потому что заголовки не могут быть записаны после того, как отклик был совершен (когда `response.committed?` возвращает истинное значение), которое возникает, когда вызывается `write` или `commit` для потокового отклика.

##### Пример использования
Предположим, мы создаем машину караоке, и пользователь хочет получить слова для определенной песни. В каждом Song имеется определенное количество строчек, и у каждой строчки есть время `num_beats` для завершения пения.

Если мы хотим возвращать слова по принципу караоке (посылая строчку, только когда певец закончил предыдущую), можно использовать `ActionController::Live` следующим образом:
```
class LyricsController < ActionController::Base
  include ActionController::Live

  def show
    response.headers['Content-Type'] = 'text/event-stream'
    song = Song.find(params[:id])

    song.each do |line|
      response.stream.write line.lyrics
      sleep line.num_beats
    end
  ensure
    response.stream.close
  end
end
```
Вышеприведенный код посылает следующую строчку только после того, как певец завершил предыдущую строчку.

##### Обсуждение потоковой передачи
Потоковая передача произвольных данных – чрезвычайно мощный инструмент. Как показано в предыдущих примерах, можно выбирать, когда и что посылать в потоковом отклике. Однако, также необходимо отметить следующие вещи:
* Каждый потоковый отклик создает новый тред и копирует тредовые локальные переменные из текущего треда. Наличие большого количество тредовых локальных переменных может отрицательно сказаться на производительности. Большое количество тредов также препятствует производительности.
* Незакрытие потокового отклика оставит соответствующий сокет открытым навсегда. Убедитесь, что вызываете close при использовании потокового отклика.
* Серверы WEBrick буферизируют все отклики, поэтому включение `ActionController::Live` не будет работать. Необходимо использовать веб-сервер, не буферизирующий отклики автоматически. 
    
### Фильтрация лога <a name="4.1.13"></a>
Rails ведет лог-файл для каждой среды в папке `log`. Это чрезвычайно полезно при отладке того, что происходит в приложении, но в реальной жизни может быть не нужно хранение каждого бита информации в лог-файле.
    
#### Фильтрация параметров
Можно фильтровать чувствительные параметры запроса в файлах лога, присоединив их к `config.filter_parameters` в настройках приложения. Эти параметры будут помечены в логе как [FILTERED].
```
config.filter_parameters << :password
```
Предоставленные параметры будут отфильтрованы с помощью частично соответствующего регулярного выражения. По умолчанию Rails добавляет `:password` в соответствующем инициализаторе (`initializers/filter_parameter_logging.rb`) и заботится о типичных параметрах приложения `password` и `password_confirmation`.

#### Фильтрация редиректов
Иногда нужно фильтровать из файлов лога некоторые чувствительные места расположения, на которые перенаправляет приложение. Это можно осуществить с использованием конфигурационной опции `config.filter_redirect`:
```
config.filter_redirect << 's3.amazonaws.com'
```
Ей можно передать строку, регулярное выражение или массив из них.
```
config.filter_redirect.concat ['s3.amazonaws.com', /private_path/]
```
Соответствующие URL будут помечены как '[FILTERED]'.

### Обработка ошибок <a name="4.1.14"></a>
Скорее всего, ваше приложение будет содержать программные ошибки или, другими словами, вызывать исключения, которые нужно обработать. Например, если пользователь переходит по ссылке на ресурс, который больше не существует в базе данных, Active Record вызовет исключение `ActiveRecord::RecordNotFound`.

Дефолтный обработчик исключений Rails отображает сообщение "500 Server Error" для всех исключений. Если запрос сделан локально, отображается прекрасная трассировка и добавляется дополнительная информация, чтобы можно было выяснить, что пошло не так, и разобраться с этим. Если запрос был удаленным, Rails отобразит пользователю лишь простое сообщение "500 Server Error", или "404 Not Found", если была проблема с роутингом или запись не была найдена. Иногда может понадобиться настроить, как эти ошибки будут перехвачены и как они будут отображены пользователю. В приложении на Rails доступны несколько уровней обработки исключений:

#### Дефолтные шаблоны 500 и 404
По умолчанию приложение в среде `production` будет рендерить или 404, или 500 сообщение об ошибке, в среде development будут вызываться все необрабатываемые исключения. Эти сообщения содержатся в статичных файлах HTML в папке public, в 404.html и 500.html соответственно. Можно настроить эти файлы, добавив дополнительную информацию и стили, но помните, что они статичные; т.е. нельзя использовать ERB, SCSS, CoffeeScript или макеты для них.

#### `rescue_from`
Если хотите сделать нечто более сложное при перехвате ошибок, можете использовать `rescue_from`, который обрабатывает исключения определенного типа (или нескольких типов) во всем контроллере и его подклассах.

Когда возникает исключение, которое перехватывается директивой `rescue_from`, объект исключения передается в обработчик. Обработчик может быть методом или объектом `Proc`, переданным опции `:with`. Также можно использовать блок вместо объекта `Proc`.

Вот как можно использовать `rescue_from` для перехвата всех ошибок `ActiveRecord::RecordNotFound` и что-то с ними делать.
```
class ApplicationController < ActionController::Base
  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found

  private

    def record_not_found
      render plain: "404 Not Found", status: 404
    end
end
```
Конечно, этот пример далеко недоработан, и ничуть не улучшает обработку исключений по умолчанию, но раз вы уже перехватили все эти исключения, то вольны делать с ними все, что хотите. Например, можете создать свои классы исключений, которые будут вызваны, когда у пользователя нет доступа в определенные разделы вашего приложения:
```
class ApplicationController < ActionController::Base
  rescue_from User::NotAuthorized, with: :user_not_authorized

  private

    def user_not_authorized
      flash[:error] = "You don't have access to this section."
      redirect_back(fallback_location: root_path)
    end
end

class ClientsController < ApplicationController
  # Проверим, что пользователь имеет права авторизации для доступа к клиентам.
  before_action :check_authorization

  # Отметьте, как экшны не беспокоятся об авторизационных делах.
  def edit
    @client = Client.find(params[:id])
  end

  private

    # Если пользователь не авторизован, просто вызываем исключение.
    def check_authorization
      raise User::NotAuthorized unless current_user.admin?
    end
end
```
> Использование `rescue_from` c `Exception` или `StandardError` вызовет серьезные побочные эффекты, поскольку это препятствует Rails правильно обрабатывать исключения. Таким образом, это не рекомендуется делать, если нет для того веской причины.

> При запуске в среде running production все ошибки `ActiveRecord::RecordNotFound` рендерят страницу ошибки 404. Если вам не нужно другое поведение, их не нужно обрабатывать.

> Некоторые исключения перехватываемы только из класса `ApplicationController`, так как они вызываются до того, как контроллер будет инициализирован и экшны будут выполнены.

### Навязывание протокола HTTPS <a name="4.1.15"></a>
Если необходимо обеспечить доступ к определенному контроллеру только через HTTPS, нужно сделать это, включив промежуточную программу `ActionDispatch::SSL` через `config.force_ssl` в конфигурациях среды.



## Роутинг в Rails <a name="4.2"></a>
### Цель роутера Rails <a name="4.2.1"></a>
Роутер Rails распознает URL и направляет его в экшн контроллера или в приложение Rack. Он также может генерировать пути и URL, избегая необходимость жестко прописывать строки в ваших вьюхах.

#### Соединение URL с кодом
Когда ваше приложение на Rails получает входящий запрос для:
```
GET /patients/17
```
оно опрашивает роутер на предмет соответствия экшну контроллера. Если первый соответствующий маршрут это:
```
get '/patients/:id', to: 'patients#show'
```
то запрос будет направлен в контроллер `patients` в экшн `show` с `{ id: '17' }` в `params`.

> Rails здесь использует именование в змеином_регистре (snake_case) для имен контроллера, если имя контроллера состоит из несколько слов, то, например, `MonsterTrucksController` необходимо использовать как `monster_trucks#show`.

#### Создание URL из кода
Также можно генерировать пути и URL. Если вышеуказанный маршрут модифицировать на:
```
get '/patients/:id', to: 'patients#show', as: 'patient'
```
и ваше приложение содержит код в контроллере:
```
@patient = Patient.find(params[:id])
```
и такой в соответствующей вьюхе:
```
<%= link_to 'Patient Record', patient_path(@patient) %>
```
тогда роутер сгенерирует путь `/patients/17`. Это увеличит устойчивость вашей вьюхи и упростит код для понимания. Отметьте, что id не нужно указывать в маршрутном хелпере.

#### Настройка маршрутизатора Rails
Маршруты для приложения или engine располагаются в файле `config/routes.rb` и обычно выглядят так:
```
Rails.application.routes.draw do
  resources :brands, only: [:index, :show] do
    resources :products, only: [:index, :show]
  end

  resource :basket, only: [:show, :update, :destroy]

  resolve("Basket") { route_for(:basket) }
end
```
Поскольку это обычный исходный файл Ruby, можно использовать все его особенности, чтобы помочь определять маршруты, но необходимо быть осторожным с именами переменных, так как они могут конфликтовать с методами DSL маршрутизатора.

> Блок `Rails.application.routes.draw do ... end`, который оборачивает определения маршрутов, требует создания области видимости для DSL маршрутизатора и не должен быть удален.

### Ресурсный роутинг <a name="4.2.2"></a>
Вместо объявления отдельных маршрутов для экшнов, ресурсный маршрут объявляет их одной строчкой кода.

#### Ресурсы в вебе
Браузеры запрашивают страницы от Rails, выполняя запрос по URL, используя определенный метод HTTP, такой как GET, POST, PATCH, PUT и DELETE. Каждый метод - это запрос на выполнение операции с ресурсом. Ресурсный маршрут соединяет несколько родственных запросов с экшнами в одном контроллере.

Когда приложение на Rails получает входящий запрос для:
```
DELETE /photos/17
```
оно просит роутер соединить его с экшном контроллера. Если первый соответствующий маршрут такой:
```
resources :photos
```
Rails будет направлять этот запрос в экшн `destroy` контроллера `photos` с `{ id: '17' }` в `params`.

#### CRUD, методы и экшны
В Rails ресурсный маршрут предоставляет сопоставление между методами HTTP и URL к экшнам контроллера. По соглашению, каждый экшн также соединяется с определенной операцией CRUD в базе данных. Одна запись в файле роутинга, такая как:
```
resources :photos
```
создает семь различных маршрутов в приложении, все сопоставления с контроллером Photos:
| Метод HTTP | Путь | Контроллер#Экшн | Использование |
|------------|------|-----------------|---------------|
| GET        | /photos | photos#index |	отображает список всех фото |
| GET        | /photos/new | photos#new | возвращает форму HTML для создания нового фото |
| POST       | /photos | photos#create | создает новое фото |
| GET        | /photos/:id | photos#show | отображает определенное фото |
| GET 	     | /photos/:id/edit | photos#edit | возвращает форму HTML для редактирования фото |
| PATCH/PUT  | /photos/:id | photos#update | обновляет определенное фото |
| DELETE     | /photos/:id | photos#destroy | удаляет определенное фото |

> Поскольку роутер использует как метод HTTP, так и URL, для сопоставления с входящими запросами, четыре URL соединяют с семью различными экшнами.

> Маршруты Rails сравниваются в том порядке, в котором они определены, поэтому, если имеется `resources :photos` до `get 'photos/poll'` маршрут для экшна `show` в строчке `resources` совпадет до строчки `get`. Чтобы это исправить, переместите строчку `get` выше строчки `resources`, чтобы она сравнивалась первой.

#### Путь и хелперы URL
Создание ресурсного маршрута также сделает доступными множество хелперов в контроллере вашего приложения. В случае с `resources :photos`:
* `photos_path` возвращает `/photos`
* `new_photo_path` возвращает `/photos/new`
* `edit_photo_path(:id)` возвращает `/photos/:id/edit` (например, `edit_photo_path(10)` возвращает `/photos/10/edit`)
* `photo_path(:id)` возвращает `/photos/:id` (например, `photo_path(10)` возвращает `/photos/10`) 

Каждый из этих хелперов имеет соответствующий хелпер `_url` (такой как `photos_url`), который возвращает тот же путь с добавленными текущими хостом, портом и префиксом пути.

#### Определение нескольких ресурсов одновременно
Если необходимо создать маршруты для более чем одного ресурса, можете сократить ввод, определив их в одном вызове `resources`:
```
resources :photos, :books, :videos
```
Это приведет к такому же результату, как и:
```
resources :photos
resources :books
resources :videos
```
#### Одиночные ресурсы
Иногда имеется ресурс, который клиенты всегда просматривают без ссылки на ID. Обычный пример, `/profile` всегда показывает профиль текущего зарегистрированного пользователя. Для этого можно использовать одиночный ресурс, чтобы связать `/profile` (а не `/profile/:id`) с экшном `show`:
```
get 'profile', to: 'users#show'
```
Передавая `String` в `to:` ожидается следующий формат - `controller#action`. Когда используется `Symbol`, опция `to:` должна быть заменена на `action:`. Когда используется `String` без `#`, опция `to:` должна быть заменена на `controller:`:
```
get 'profile', action: :show, controller: 'users'
```
Этот ресурсный маршрут:
```
resource :geocoder
resolve('Geocoder') { [:geocoder] }
```
создаст шесть различных маршрутов в приложении, все сопоставления с контроллером `Geocoders`:

| Метод HTTP  |	Путь | Контроллер#Экшн | Использование |
|-------------|------|-----------------|---------------|
| GET         | /geocoder/new | geocoders#new | возвращает форму HTML для создания нового геокодера |
| POST        | /geocoder | geocoders#create | создает новый геокодер |
| GET         | /geocoder | geocoders#show | отображает один и только один ресурс геокодера |
| GET         | /geocoder/edit | geocoders#edit | возвращает форму HTML для редактирования геокодера |
| PATCH/PUT   | /geocoder | geocoders#update | обновляет один и только один ресурс геокодера |
| DELETE      | /geocoder | geocoders#destroy | удаляет ресурс геокодера |

> Поскольку вы можете захотеть использовать один и тот же контроллер и для одиночного маршрута (`/account`), и для множественного маршрута (`/accounts/45`), одиночные ресурсы ведут на множественные контроллеры. По этой причине, например, `resource :photo` и `resources :photos` создадут и одиночные, и множественные маршруты, привязанные к одному и тому же контроллеру (`PhotosController`).

Одиночный ресурсный маршрут генерирует эти хелперы:
* `new_geocoder_path` возвращает `/geocoder/new`
* `edit_geocoder_path` возвращает `/geocoder/edit`
* `geocoder_path` возвращает `/geocoder` 

Как и в случае с множественными ресурсами, те же хелперы, оканчивающиеся на `_url` также включают хост, порт и префикс пути.

#### Пространство имен контроллера и роутинг
Возможно, вы захотите организовать группы контроллеров в пространстве имен. Чаще всего группируют административные контроллеры в пространство имен `Admin::`. Следует поместить эти контроллеры в директорию `app/controllers/admin` и затем можно сгруппировать их вместе в роутере:
```
namespace :admin do
  resources :articles, :comments
end
```
Это создаст ряд маршрутов для каждого контроллера `articles` и `comments`. Например `admin/articles`

Если хотите маршрут `/articles` (без префикса `/admin`) к `Admin::ArticlesController`, можете использовать:
```
scope module: 'admin' do
  resources :articles, :comments
end
```
или для отдельного случая:
```
resources :articles, module: 'admin'
```
Если хотите маршрут `/admin/articles` к `ArticlesController` (без префикса модуля `Admin::`), можно использовать:
```
scope '/admin' do
  resources :articles, :comments
end
```
или для отдельного случая:
```
resources :articles, path: '/admin/articles'
```
> Если хотите использовать другое пространство имен контроллера в блоке `namespace`, можно указать абсолютный путь контроллера, т.е: `get '/foo'`, `to: '/foo#index'`.

#### Вложенные ресурсы
Нормально иметь ресурсы, которые логически подчинены другим ресурсам. Например, предположим ваше приложение включает эти модели:
```
class Magazine < ApplicationRecord
  has_many :ads
end

class Ad < ApplicationRecord
  belongs_to :magazine
end
```
Вложенные маршруты позволяют захватить эти отношения в вашем роутинге. В этом случае можете включить такое объявление маршрута:
```
resources :magazines do
  resources :ads
end
```
В дополнение к маршрутам для magazines, это объявление также создаст маршруты для `ads` в `AdsController`. URL с ad требует magazine:

| Метод HTTP | Путь |	Контроллер#Экшн | Использование |
|------------|------|-----------------|---------------|
| GET        | /magazines/:magazine_id/ads | ads#index | отображает список всех ads для определенного magazine |
| GET        | /magazines/:magazine_id/ads/new | ads#new | возвращает форму HTML для создания новой ad, принадлежащей определенному magazine |
| POST       | /magazines/:magazine_id/ads | ads#create | создает новую ad, принадлежащую указанному magazine |
| GET        | /magazines/:magazine_id/ads/:id | ads#show | отражает определенную ad, принадлежащую определенному magazine |
| GET        | /magazines/:magazine_id/ads/:id/edit | ads#edit | возвращает форму HTML для редактирования ad, принадлежащей определенному magazine |
| PATCH/PUT  | /magazines/:magazine_id/ads/:id | ads#update | обновляет определенную ad, принадлежащую определенному magazine |
| DELETE     | /magazines/:magazine_id/ads/:id | ads#destroy | удаляет определенную ad, принадлежащую определенному magazine |

Также будут созданы маршрутные хелперы, такие как `magazine_ads_url` и `edit_magazine_ad_path`. Эти хелперы принимают экземпляр `Magazine` как первый параметр (`magazine_ads_url(@magazine)`).

##### Ограничения для вложения
Вы можете вкладывать ресурсы в другие вложенные ресурсы, если хотите. Например:
```
resources :publishers do
  resources :magazines do
    resources :photos
  end
end
```
Глубоко вложенные ресурсы быстро становятся громоздкими. В этом случае, например, приложение будет распознавать пути, такие как:
```
/publishers/1/magazines/2/photos/3
```
Соответствующий маршрутный хелпер будет `publisher_magazine_photo_url`, требующий определения объектов на всех трех уровнях. Действительно, эта ситуация достаточно запутана, так что в статье Jamis Buck предлагает правило хорошей разработки на Rails:

> Ресурсы никогда не должны быть вложены глубже, чем на 1 уровень.

##### Мелкое вложение
Один из способов избежать глубокой вложенности (как рекомендовано выше) состоит в том, чтобы генерировать экшны коллекции в области видимости родителя, получая представление об иерархии, но не вкладывать экшны элементов. Другими словами, создавать маршруты с минимальным количеством информации для однозначной идентификации ресурса, например так:
```
resources :articles do
  resources :comments, only: [:index, :new, :create]
end
resources :comments, only: [:show, :edit, :update, :destroy]
```
Эта идея балансирует на грани между наглядностью маршрутов и глубоким вложением. Существует сокращенный синтаксис для получения подобного с помощью опции `:shallow`:
```
resources :articles do
  resources :comments, shallow: true
end
```
Это сгенерирует те же самые маршруты из первого примера. Также можно определить опцию `:shallow` в родительском ресурсе, в этом случае все вложенные ресурсы будут мелкие:
```
resources :articles, shallow: true do
  resources :comments
  resources :quotes
  resources :drafts
end
```
Метод `shallow` в DSL создает область видимости, в котором каждое вложение мелкое. Это генерирует те же самые маршруты из предыдущего примера:
```
shallow do
  resources :articles do
    resources :comments
    resources :quotes
    resources :drafts
  end
end
```
**Также существуют две опции для `scope` для настройки мелких маршрутов**. `:shallow_path` добавляет к путям элемента префикс с указанным параметром:
```
scope shallow_path: "sekret" do
  resources :articles do
    resources :comments, shallow: true
  end
end
```
Для ресурса комментариев будут сгенерированы следующие маршруты:

| Метод HTTP | Путь | Контроллер#Экшн | Именованный хелпер маршрута |
|------------|------|-----------------|-----------------------------|
| GET 	     | /articles/:article_id/comments(.:format) | comments#index | article_comments_path |
| POST       | /articles/:article_id/comments(.:format) | comments#create | article_comments_path |
| GET        | /articles/:article_id/comments/new(.:format) | comments#new 	new_article_comment_path |
| GET        | /sekret/comments/:id/edit(.:format) | comments#edit | edit_comment_path |
| GET        | /sekret/comments/:id(.:format) | comments#show | comment_path |
| PATCH/PUT  | /sekret/comments/:id(.:format) | comments#update | comment_path |
| DELETE  	 | /sekret/comments/:id(.:format) | comments#destroy | comment_path |

**Опция `:shallow_prefix` добавляет указанный параметр к именованным хелперам маршрута**:
```
scope shallow_prefix: "sekret" do
  resources :articles do
    resources :comments, shallow: true
  end
end
```
Для ресурса комментариев будут сгенерированы следующие маршруты:

| Метод HTTP | Путь | Контроллер#Экшн | Именованный хелпер маршрута |
|------------|------|-----------------|-----------------------------|
| GET | /articles/:article_id/comments(.:format) | comments#index | article_comments_path |
| POST | /articles/:article_id/comments(.:format) | comments#create | article_comments_path |
| GET | /articles/:article_id/comments/new(.:format) | comments#new | new_article_comment_path |
| GET | /comments/:id/edit(.:format) | comments#edit | **edit_sekret_comment_path** |
| GET | /comments/:id(.:format) | comments#show | sekret_comment_path |
| PATCH/PUT | /comments/:id(.:format) | comments#update | sekret_comment_path |
| DELETE | /comments/:id(.:format) | comments#destroy | sekret_comment_path |

#### Концерны маршрутов
Концерны маршрутов позволяют объявлять общие маршруты, которые затем могут быть повторно использованы внутри других ресурсов и маршрутов. Чтобы определить концерн:
```
concern :commentable do
  resources :comments
end

concern :image_attachable do
  resources :images, only: :index
end
```
Эти концерны могут быть использованы в ресурсах, чтобы избежать дублирования кода и разделить поведение между несколькими маршрутами:
```
resources :messages, concerns: :commentable

resources :articles, concerns: [:commentable, :image_attachable]
```
Вышеуказанное эквивалентно:
```
resources :messages do
  resources :comments
end

resources :articles do
  resources :comments
  resources :images, only: :index
end
```
Также их можно использовать в любом месте внутри маршрутов, например, в вызове `scope` или `namespace`:
```
namespace :articles do
  concerns :commentable
end
```

#### Создание путей и URL из объектов
В дополнение к использованию маршрутных хелперов, Rails может также создавать пути и URL из массива параметров. Например, предположим, у вас есть этот набор маршрутов:
```
resources :magazines do
  resources :ads
end
```
При использовании `magazine_ad_path`, можно передать экземпляры `Magazine` и `Ad` вместо числовых ID:
```
<%= link_to 'Ad details', magazine_ad_path(@magazine, @ad) %>
```
Можно также использовать `url_for` с набором объектов, и Rails автоматически определит, какой маршрут вам нужен:
```
<%= link_to 'Ad details', url_for([@magazine, @ad]) %>
```
В этом случае Rails увидит, что `@magazine` это `Magazine` и `@ad` это `Ad`, и поэтому использует хелпер `magazine_ad_path`. В хелперах, таких как `link_to`, можно определить лишь объект вместо полного вызова `url_for`:
```
<%= link_to 'Ad details', [@magazine, @ad] %>
```
Если хотите ссылку только на `magazine`:
```
<%= link_to 'Magazine details', @magazine %>
```
Для других экшнов следует всего лишь вставить имя экшна как первый элемент массива:
```
<%= link_to 'Edit Ad', [:edit, @magazine, @ad] %>
```
Это позволит рассматривать экземпляры модели как URL, что является ключевым преимуществом ресурсного стиля.

#### Определение дополнительных экшнов RESTful
Вы не ограничены семью маршрутами, которые создает роутинг RESTful по умолчанию. Если хотите, можете добавить дополнительные маршруты, применяющиеся к коллекции или отдельным элементам коллекции.

##### Добавление маршрутов к элементам
Для добавления маршрута к элементу, добавьте блок `member` в блок ресурса:
```
resources :photos do
  member do
    get 'preview'
  end
end
```
Это распознает `/photos/1/preview` с GET и направит в экшн preview контроллера `PhotosController` со значением `id` ресурса, переданного в `params[:id]`. Это также создаст хелперы `preview_photo_url` и `preview_photo_path`.

В блоке маршрутов элемента каждое имя маршрута определяет метод HTTP, с которым он будет связан. Тут можно использовать `get`, `patch`, `put`, `post` или `delete`. Если у вас нет нескольких маршрутов к `member`, также можно передать `:on` к маршруту, избавившись от блока:
```
resources :photos do
  get 'preview', on: :member
end
```
**Можно опустить опцию `:on`**, это создаст такой же маршрут для элемента, за исключением того, что значение `id` ресурса будет доступно в `params[:photo_id]` вместо `params[:id]`. Хелперы маршрутов также будут переименованы из `preview_photo_url` и `preview_photo_path` в `photo_preview_url` и `photo_preview_path`.


 ##### Добавление маршрутов к коллекции
Чтобы добавить маршрут к коллекции:
```
resources :photos do
  collection do
    get 'search'
  end
end
```
Это позволит Rails распознавать пути, такие как `/photos/search` с GET и направить в экшн `search` контроллера `PhotosController`. Это также создаст маршрутные хелперы `search_photos_url` и `search_photos_path`.

Как и с маршрутами к элементу, можно передать `:on` к маршруту:
```
resources :photos do
  get 'search', on: :collection
end
```
Если определяете дополнительные ресурсные маршруты с символом в качестве первого аргумента, помните, что это не эквивалент использования строки. Символы означают экшны контроллера, а строки означают пути.

##### Добавление маршрутов для дополнительных экшнов `new`
Чтобы добавить альтернативный экшн `new`, используйте сокращенный вариант `:on`:
```
resources :comments do
  get 'preview', on: :new
end
```
Это позволит Rails распознавать пути, такие как `/comments/new/preview` с GET, и направлять их в экшн `preview` в `CommentsController`. Он также создаст маршрутные хелперы `preview_new_comment_url` и `preview_new_comment_path`.

> Если вдруг вы захотели добавить много дополнительных экшнов в ресурсный маршрут, нужно остановиться и спросить себя, может быть, от вас утаилось присутствие другого ресурса.

### Нересурсные маршруты <a name="4.2.3"></a>
В дополнению к ресурсному роутингу, Rails поддерживает роутинг произвольных URL к экшнам. Тут не будет групп маршрутов, генерируемых автоматически ресурсным роутингом. Вместо этого вы должны настроить каждый маршрут отдельно в вашем приложении.

Хотя обычно следует пользоваться ресурсным роутингом, все еще есть много мест, где более подходит простой роутинг. Нет необходимости пытаться заворачивать каждый кусочек своего приложения в ресурсные рамки, если это менее удобно.

В частности, простой роутинг облегчает привязку унаследованных URL к новым экшнам Rails.

#### Необязательные параметры
При настройке обычного маршрута вы предоставляете ряд символов, которые Rails связывает с частями входящего запроса HTTP. Например, рассмотрим следующий маршрут:
```
get 'photos(/:id)', to: 'photos#display'
```
Если входящий запрос `/photos/1` обрабатывается этим маршрутом (так как он не соответствует любому предыдущему маршруту до этого), то результатом будет вызов экшна `display` в `PhotosController`, и результирующий параметр "1" будет доступен как `params[:id]`. **Этот маршрут также свяжет входящий запрос `/photos` с `PhotosController#display`**, поскольку `:id` — опциональный параметр, обозначенный скобками.

#### Динамические сегменты
Можете настроить сколько угодно динамических сегментов в обычном маршруте. Любой сегмент будет доступен для соответствующего экшна как часть хэша params. Таким образом, если настроите такой маршрут:
```
get 'photos/:id/:user_id', to: 'photos#show'
```
Входящий путь `/photos/1/2` будет направлен на экшн `show` в `PhotosController`. `params[:id]` будет установлен как "1", и `params[:user_id]` будет установлен как "2".

> По умолчанию динамические сегменты не принимают точки - потому что точка используется как разделитель для формата маршрутов. Если в динамическом сегменте необходимо использовать точку, добавьте ограничение, переопределяющее это – к примеру, `id: /[^\/]+/` позволяет все, кроме слэша.

#### Статичные сегменты
Можете определить статичные сегменты при создании маршрута, не начинающиеся с двоеточия в фрагменте:
```
get 'photos/:id/with_user/:user_id', to: 'photos#show'
```
Этот маршрут соответствует путям, таким как `/photos/1/with_user/2`. В этом случае params будет `{ controller: 'photos', action: 'show', id: '1', user_id: '2' }`.

#### Параметры строки запроса
`params` также включает любые параметры из строки запроса. Например, с таким маршрутом:
```
get 'photos/:id', to: 'photos#show'
```
Входящий путь `/photos/1?user_id=2` будет направлен на экшн `show` контроллера `Photos`. `params` будет `{ controller: 'photos', action: 'show', id: '1', user_id: '2' }`.

#### Определение значений по умолчанию
Можно определить значения по умолчанию в маршруте, предоставив хэш для опции `:defaults`. Это также относится к параметрам, которые не определены как динамические сегменты. Например:
```
get 'photos/:id', to: 'photos#show', defaults: { format: 'jpg' }
```
Rails направит `photos/12` в экшн `show` `PhotosController`, и установит `params[:format]` как "jpg".

Вы также можете использовать `defaults` в формате блока, чтобы определить значения по умолчанию для нескольких элементов:
```
defaults format: :json do
  resources :photos
end
```
> Невозможно переопределить значения по умолчанию с помощью параметров строки запроса - по причине безопасности. Единственные значения по умолчанию, которые могут быть переопределены - это динамические сегменты, с помощью подстановки в путь URL.

#### Именование маршрутов
Можно определить имя для любого маршрута, используя опцию `:as`:
```
get 'exit', to: 'sessions#destroy', as: :logout
```
Это создаст `logout_path` и `logout_url` как именованные хелперы маршрута в вашем приложении. Вызов `logout_path` вернет `/exit`

Также это можно использовать для переопределения маршрутных методов, определенных ресурсами, следующим образом:
```
get ':username', to: 'users#show', as: :user
```
Что определит метод `user_path`, который будет доступен в контроллерах, хелперах и вьюхах, и будет вести на маршрут, такой как `/bob`. В экшне `show` из `UsersController`, `params[:username]` будет содержать имя пользователя. Измените `:username` в определении маршрута, если не хотите, чтобы имя параметра было `:username`.

```
The :as option forms a named route.

Usually it's used in a non-root route. For example:

match '/search' => 'search#search', :as => 'search' # SearchController#search

You could then do something like:

<%= link_to search_path, 'Click Here to Search!' %>

search_path and search_url are defined because of the :as

For a root route, you don't really need :as because the the URL helpers root_path and root_url are defined for you by Rails.
```
#### Ограничения метода HTTP
В основном следует использовать методы `get`, `post`, `put`, `patch` и `delete` для ограничения маршрута определенным методом. Можно использовать метод `match` с опцией `:via` для соответствия нескольким методам сразу:
```
match 'photos', to: 'photos#show', via: [:get, :post]
```
Также можно установить соответствие всем методам для определенного маршрута, используя `:via: :all`:
```
match 'photos', to: 'photos#show', via: :all
```
> Роутинг запросов GET и POST одновременно в один экшн небезопасен. В основном, следует избегать роутинг всех методов в экшн, если нет веской причины делать так.

> GET в Rails не проверяет токен CSRF. Никогда не пишите в базу данных из GET запросов, подробнее о контрмерах CSRF смотрите в руководстве Безопасность приложений на Rails.

#### Ограничения сегмента
Можно использовать опцию `:constraints` для соблюдения формата динамического сегмента:
```
get 'photos/:id', to: 'photos#show', constraints: { id: /[A-Z]\d{5}/ }
```
Этот маршрут соответствует путям, таким как `/photos/A12345`, но не `/photos/893`. Можно выразить тот же маршрут более кратко:
```
get 'photos/:id', to: 'photos#show', id: /[A-Z]\d{5}/
```
`:constraints` принимает регулярное выражение c тем ограничением, что якоря `regexp` не могут использоваться. Например, следующий маршрут не работает:
```
get '/:id', to: 'articles#show', constraints: {id: /^\d/}
```
Однако отметьте, что нет необходимости использовать якоря, поскольку все маршруты заякорены изначально.

Например, следующие маршруты приведут к `articles` со значениями `to_param` наподобие 1-hello-world, которые всегда начинаются с цифры, и к `users` со значениями `to_param` наподобие david, которые никогда не начинаются с цифры, чтобы можно было использовать общее корневое пространство имен:
```
get '/:id', to: 'articles#show', constraints: { id: /\d.+/ }
get '/:username', to: 'users#show'
```

#### Ограничения, основанные на запросе
Также можно ограничить маршрут, основываясь на любом методе в объекте `Request`, который возвращает `String`.

Ограничение, основанное на запросе, определяется так же, как и сегментное ограничение:
```
get 'photos', to: 'photos#index', constraints: { subdomain: 'admin' }
```
Также можно определить ограничения в форме блока:
```
namespace :admin do
  constraints subdomain: 'admin' do
    resources :photos
  end
end
```
> Ограничения запроса работают, вызывая метод на объекте Request с тем же именем, что и ключ хэша, а затем сравнивают возвращенное значение со значением хэша. Следовательно, значения ограничений должны соответствовать возвращаемому типу соответствующего метода объекта Request. Например: `constraints: { subdomain: 'api' }` будет соответствовать поддомену api, как и ожидалось, однако, использование символа `constraints: { subdomain: :api }` не будет, так как request.subdomain возвращает 'api' как строку.

> Имеется исключения для ограничения `format:` так как это метод на объекте Request, это также неявный опциональный параметр для каждого пути. Ограничения сегмента имеют приоритет, и ограничение `format` применяется как есть, даже когда передано в хэше. Например, get 'foo', `constraints: { format: 'json' }` будет соответствовать GET /foo, так как формат опциональный по умолчанию. Однако, используя lambda, как в `get 'foo'`, `constraints: lambda { |req| req.format == :json }`, маршрут будет соответствовать только явным запросам JSON.

#### Продвинутые ограничения
Если имеется более продвинутое ограничение, можете предоставить объект, отвечающий на `matches?`, который будет использовать Rails. Скажем, вы хотите направить всех пользователей через список ограничений в `RestrictedListController`. Можно сделать так:
```
class RestrictedListController
  def initialize
    @ips = RestrictedList.retrieve_ips
  end

  def matches?(request)
    @ips.include?(request.remote_ip)
  end
end

Rails.application.routes.draw do
  get '*path', to: 'restricted_list#index',
    constraints: RestrictedListConstraint.new
end
```
Ограничения также можно определить как лямбду:
```
Rails.application.routes.draw do
  get '*path', to: 'restricted_list#index',
    constraints: lambda { |request| RestrictedList.retrieve_ips.include?(request.remote_ip) }
end
```
И метод `matches?`, и лямбда получают объект `request` в качестве аргумента.

#### Подстановка маршрутов и подстановочные сегменты
Подстановка маршрутов - это способ указать, что определенные параметры должны соответствовать остальным частям маршрута. Например:
```
get 'photos/*other', to: 'photos#unknown'
```
Этот маршрут будет соответствовать photos/12 или /photos/long/path/to/12, установив `params[:other]` как "12", или "long/path/to/12". Фрагменты, начинающиеся со звездочки, называются "подстановочные сегменты" ("wildcard segments").

Подстановочные сегменты могут быть где угодно в маршруте. Например:
```
get 'books/*section/:title', to: 'books#show'
```
будет соответствовать books/some/section/last-words-a-memoir с `params[:section]` равным 'some/section', и `params[:title]` равным 'last-words-a-memoir'.

На самом деле технически маршрут может иметь более одного динамического сегмента, matcher назначает параметры интуитивным образом. Для примера:
```
get '*a/foo/*b', to: 'test#index'
```
будет соответствовать zoo/woo/foo/bar/baz с `params[:a]` равным 'zoo/woo', и `params[:b]` равным 'bar/baz'.

Запросив '/foo/bar.json', ваш `params[:pages]` будет равен 'foo/bar' с форматом запроса JSON. Если вам нужно вернуть старое поведение 3.0.x, можете предоставить `format: false` вот так:
```
get '*pages', to: 'pages#show', format: false
```
Если хотите сделать сегмент формата обязательным, чтобы его нельзя было опустить, укажите `format: true` подобным образом:
```
get '*pages', to: 'pages#show', format: true
```

#### Перенаправление
Можно перенаправить любой путь на другой путь, используя хелпер `redirect` в вашем роутере:
```
get '/stories', to: redirect('/articles')
```
Также можно повторно использовать динамические сегменты для соответствия пути, на который перенаправляем:
```
get '/stories/:name', to: redirect('/articles/%{name}')
```
Также можно предоставить блок для перенаправления, который получает символизированные параметры пути и объект `request`:
```
get '/stories/:name', to: redirect { |path_params, req| "/articles/#{path_params[:name].pluralize}" }
get '/stories', to: redirect { |path_params, req| "/articles/#{req.subdomain}" }
```
Пожалуйста, отметьте, что перенаправлением по умолчанию является 301 "Moved Permanently". Учтите, что некоторые браузеры или прокси серверы закэшируют этот тип перенаправления, сделав старые страницы недоступными. Чтобы изменить статус отклика, можно использовать опцию `:status`:
```
get '/stories/:name', to: redirect('/articles/%{name}', status: 302)
```
Во всех этих случаях, если не предоставить предшествующий хост (http://www.example.com), Rails возьмет эти детали из текущего запроса.

#### Роутинг к приложениям Rack
Вместо строки, подобной `'articles#index'`, соответствующей экшну `index` в `ArticlesController`, можно определить любое приложение Rack как конечную точку совпадения.
```
match '/application.js', to: MyRackApp, via: :all
```
Пока `MyRackApp` отвечает на `call` и возвращает [status, headers, body], роутер не будет различать приложение Rack и экшн. Здесь подходит использование `via: :all`, если вы хотите позволить своему приложению Rack обрабатывать все методы так, как оно посчитает нужным.

Для любопытства, `'articles#index'` фактически расширяется до `ArticlesController.action(:index)`, который возвращает валидное приложение Rack.

Если вы указываете приложение Rack как конечную точку совпадения, помните что маршрут будет неизменным в принимающем приложении. Со следующим маршрутом ваше приложение Rack будет ожидать маршрут `/admin`:
```
match '/admin', to: AdminApp, via: :all
```
Если вы предпочитаете, чтобы ваше приложение Rack получало запросы на корневой путь, используйте вместо этого `mount`:
```
mount AdminApp, at: '/admin'
```

#### Использование `root`
Можно определить, с чем Rails должен связать '/' с помощью метода `root`:
```
root to: 'pages#main'
root 'pages#main' # то же самое в краткой форме
```
Следует поместить маршрут root в начало файла, поскольку это наиболее популярный маршрут и должен быть проверен первым.

Маршрут root связывает с экшном только запросы GET.

`root` также можно использовать внутри пространств имен и областей видимости. Например:
```
namespace :admin do
  root to: "admin#index"
end

root to: "home#index"
```

#### Маршруты с символами Unicode
Маршруты с символами `unicode` можно определять явно. Например:
```
get 'こんにちは', to: 'welcome#index'
```

#### Прямые маршруты
Можно создавать собственные хелперы URL напрямую. Например:
```
direct :homepage do
  "http://www.rubyonrails.org"
end

# >> homepage_url
# => "http://www.rubyonrails.org"
```
Возвращаемое значение блока должно быть валидным аргументом для метода `url_for`. Таким образом, можно передать валидный строковый URL, хэш, массив, экземпляр Active Model или класс Active Model.
```
direct :commentable do |model|
  [ model, anchor: model.dom_id ]
end

direct :main do
  { controller: 'pages', action: 'index', subdomain: 'www' }
end
```

#### Использование `resolve`
Метод `resolve` позволяет настраивать полиморфное сопоставление моделей. Например:
```
resource :basket

resolve("Basket") { [:basket] }

<%= form_with model: @basket do |form| %>
  <!-- basket form -->
<% end %>
```
Это сгенерирует URL в единственном числе `/basket` вместо обычного `/baskets/:id`.

### Настройка ресурсных маршрутов <a name="4.2.4"></a>
Хотя дефолтные маршруты и хелперы, сгенерированные `resources :articles`, как правило, нормально работают, возможно, может понадобиться некоторым образом их настроить. Rails позволяет настроить практически любую часть ресурсных хелперов.

#### Определение используемого контроллера
Опция `:controller` позволяет явно определить контроллер, используемый ресурсом. Например:
```
resources :photos, controller: 'images'
```
распознает входящие пути, начинающиеся с /photos, но смаршрутизирует к контроллеру `Images`:

| Метод HTTP | Путь |	Контроллер#Экшн | Именованный хелпер маршрута |
|------------|------|-----------------|-----------------------------|
| GET | /photos | images#index | photos_path |
| GET | /photos/new | images#new | new_photo_path |
| POST | /photos | images#create | photos_path |
| GET | /photos/:id | images#show | photo_path(:id) |
| GET | /photos/:id/edit | images#edit | edit_photo_path(:id) |
| PATCH/PUT | /photos/:id | images#update | photo_path(:id) |
| DELETE | /photos/:id | images#destroy | photo_path(:id) |

> Используйте `photos_path`, `new_photo_path` и т.д. для генерации путей для этого ресурса.

Для контроллеров в пространстве имен можно использовать нотацию директории. Например:
```
resources :user_permissions, controller: 'admin/user_permissions'
```
Это будет смаршрутизировано на контроллер `Admin::UserPermissions`.

> Поддерживается только нотация директории. Определение контроллера с помощью нотации константы Ruby (т.е. `controller: 'Admin::UserPermissions'`) может привести к маршрутным проблемам, и в итоге к предупреждению.

#### Определение ограничений
Можно использовать опцию `:constraints` для определения требуемого формата на неявном `id`. Например:
```
resources :photos, constraints: { id: /[A-Z][A-Z][0-9]+/ }
```
Это объявление ограничивает параметр `:id` соответствием предоставленному регулярному выражению. Итак, в этом случае роутер больше не будет сопоставлять `/photos/1` этому маршруту. Вместо этого он будет соответствовать `/photos/RR27`.

Можно определить одиночное ограничение, применив его к ряду маршрутов, используя блочную форму:
```
constraints(id: /[A-Z][A-Z][0-9]+/) do
  resources :photos
  resources :accounts
end
```
Конечно, можно использовать более продвинутые ограничения, доступные в нересурсных маршрутах, в этом контексте.

> По умолчанию параметр `:id` не принимает точки - так как точка используется как разделитель для отформатированного маршрута. Если необходимо использовать точку в `:id`, добавьте ограничение, которое переопределит это - к примеру, `id: /[^\/]+/` позволяет все, кроме слэша.

#### Переопределение именованных хелперов маршрута
Опция `:as` позволяет переопределить нормальное именование для именованных маршрутных хелперов. Например:
```
resources :photos, as: 'images'
```
распознает входящие пути, начинающиеся с `/photos` и смаршрутизирует запросы к `PhotosController`, но использует значение опции `:as` для наименования хелпера:
```
GET 	/photos 	photos#index 	images_path
```

#### Переопределение сегментов `new` и `edit`
Опция `:path_names` позволяет переопределить автоматически генерируемые сегменты `new` и `edit` в путях:
```
resources :photos, path_names: { new: 'make', edit: 'change' }
```
Это приведет к тому, что роутинг распознает пути, такие как:
```
/photos/make
/photos/1/change
```
Фактические имена экшнов не меняются этой опцией. Два показанных пути все еще ведут к экшнам `new` и `edit`.

Если вдруг захотите изменить эту опцию одинаково для всех маршрутов, можно использовать `scope`:
```
scope path_names: { new: 'make' } do
  # остальные ваши маршруты
end
```

#### Префикс именованных маршрутных хелперов
Можно использовать опцию `:as` для задания префикса именованных маршрутных хелперов, генерируемых Rails для маршрута. Используйте эту опцию для предотвращения коллизий имен между маршрутами, использующими область видимости пути. Например:
```
scope 'admin' do
  resources :photos, as: 'admin_photos'
end

resources :photos
```
Это предоставит маршрутные хелперы, такие как `admin_photos_path`, `new_admin_photo_path` и т.д.

Для задания префикса группы маршрутов, используйте `:as` со `scope`:
```
scope 'admin', as: 'admin' do
  resources :photos, :accounts
end

resources :photos, :accounts
```
Это сгенерирует маршруты такие как `admin_photos_path` и `admin_accounts_path`, ведущие соответственно к `/admin/photos` и `/admin/accounts`.

> Область видимости namespace автоматически добавляет `:as`, так же как и префиксы `:module` и `:path`.

Можно задать префикс маршрута именованным параметром также и так:
```
scope ':username' do
  resources :articles
end
```
Это предоставит URL, такие как `/bob/articles/1` и позволит обратиться к части пути username в контроллерах, хелперах и вьюхах как `params[:username]`.

####  Ограничение создаваемых маршрутов
По умолчанию Rails создает маршруты для всех семи дефолтных экшнов (`index`, `show`, `new`, `create`, `edit`, `update` и `destroy`) для каждого маршрута RESTful вашего приложения. Можно использовать опции `:only` и `:except` для точной настройки этого поведения. Опция `:only` говорит Rails создать только определенные маршруты:
```
resources :photos, only: [:index, :show]
```
Теперь запрос GET к /photos будет успешным, а запрос POST к /photos (который обычно соединяется с экшном `create`) провалится.

Опция `:except` определяет маршрут или перечень маршрутов, который Rails не должен создавать:
```
resources :photos, except: :destroy
```
В этом случае Rails создаст все нормальные маршруты за исключением маршрута для `destroy` (запрос DELETE к `/photos/:id`).

> Если в вашем приложении много маршрутов RESTful, использование `:only` и `:except` для генерации только тех маршрутов, которые Вам фактически нужны, позволит снизить использование памяти и ускорить процесс роутинга.

#### Переведенные пути
Используя scope, можно изменить имена путей, генерируемых с помощью `resources`:
```
scope(path_names: { new: 'neu', edit: 'bearbeiten' }) do
  resources :categories, path: 'kategorien'
end
```
Rails теперь создаст маршруты к `CategoriesController`:
```
GET 	/kategorien 	categories#index 	categories_path
```

#### Переопределение единственного числа
Если хотите определить единственное число ресурса, следует добавить дополнительные правила в `Inflector`:
```
ActiveSupport::Inflector.inflections do |inflect|
  inflect.irregular 'tooth', 'teeth'
end
```

#### Использование `:as` во вложенных ресурсах
Опция `:as` переопределяет автоматически генерируемое имя для ресурса в хелперах вложенного маршрута. Например:
```
resources :magazines do
  resources :ads, as: 'periodical_ads'
end
```
Это создаст маршрутные хелперы, такие как `magazine_periodical_ads_url` и `edit_magazine_periodical_ad_path`.

#### Переопределение параметров именованных маршрутов
Опция `:param` переопределяет дефолтный идентификатор ресурса `:id` (имя динамического сегмента, используемого для генерации маршрутов). К этому сегменту можно обратиться из контроллера с помощью `params[<:param>]`.
```
resources :videos, param: :identifier

    videos GET  /videos(.:format)                  videos#index
           POST /videos(.:format)                  videos#create
 new_video GET  /videos/new(.:format)              videos#new
edit_video GET  /videos/:identifier/edit(.:format) videos#edit

Video.find_by(identifier: params[:identifier])
```
Можно переопределить `ActiveRecord::Base#to_param` соответствующей модели, чтобы создать URL:
```
class Video < ApplicationRecord
  def to_param
    identifier
  end
end

video = Video.find_by(identifier: "Roman-Holiday")
edit_video_path(video) # => "/videos/Roman-Holiday/edit"
```
### Разделение очень большого маршрутного файл на несколько небольших: <a name="4.2.5"></a>
Если вы работаете в большом приложении с тысячами маршрутов, единственный файл `config/routes.rb` может стать громоздким и тяжелым для прочтения.

Rails предлагает способ разделения гигантского единого `routes.rb` на несколько небольших с помощью макроса `draw`.
```
# config/routes.rb

Rails.application.routes.draw do
  get 'foo', to: 'foo#bar'

  draw(:admin) # Загрузит другой маршрутный файл, расположенный в `config/routes/admin.rb`
end

# config/routes/admin.rb

namespace :admin do
  resources :comments
end
```
Вызов `draw(:admin)` в блоке `Rails.application.routes.draw` попытается загрузить маршрутный файл, по имени. заданному аргументом (в нашем случае `admin.rb`). Файл должен быть расположен в директории `config/routes` или любой поддиректории (например, `config/routes/admin.rb `, `config/routes/external/admin.rb`).

Внутри маршрутного файла `admin.rb` можно использовать любой маршрутный DSL, но не следует оборачивать его в блок `Rails.application.routes.draw`, как это сделано в основном файле `config/routes.rb`.

#### Когда использовать или не использовать эту особенность
Отрисовка маршрутов из внешних файлов может быть очень полезной для организации большого набора маршрутов на несколько организованных. Может быть маршрут `admin.rb`, содержащий все маршруты из области администрирования, другой файл `api.rb` для маршрутов к API ресурсов, и так далее...

Однако, не следует злоупотреблять этой особенностью, так как множество маршрутных файлов может делает сложными понятность и понимание. В зависимости от приложения, разработчикам может быть проще иметь один маршрутный файл, если у вас всего лишь несколько сотен маршрутов. Не следует пытаться создать новый маршрутный файл для каждой категории (admin, api ...) любой ценой; DSL маршрутизации Rails уже предлагает способ разделения маршрутов организованным способом с помощью `namespaces` и `scopes`.

### Осмотр и тестирование маршрутов <a name="4.2.6"></a>
#### Список существующих маршрутов
Чтобы получить полный список всех доступных маршрутов вашего приложения, посетите `http://localhost:3000/rails/info/routes` в браузере, в то время как ваш сервер запущен в режиме development. Команда `rails routes`, выполненная в терминале, выдаст тот же результат.

Оба метода напечатают все ваши маршруты, в том же порядке, что они появляются в `config/routes.rb`. Для каждого маршрута вы увидите:
* Имя маршрута (если имеется)
* Используемый метод HTTP (если маршрут реагирует не на все методы)
* Шаблон URL
* Параметры роутинга для этого маршрута 

Например, вот небольшая часть результата команды `rails routes` для маршрута RESTful:
```
    users GET    /users(.:format)          users#index
          POST   /users(.:format)          users#create
 new_user GET    /users/new(.:format)      users#new
edit_user GET    /users/:id/edit(.:format) users#edit
```
Также можно использовать опцию `--expanded` для включения режима расширенного табличного форматирования.
```
$ rails routes --expanded

--[ Route 1 ]----------------------------------------------------
Prefix            | users
Verb              | GET
URI               | /users(.:format)
Controller#Action | users#index
--[ Route 2 ]----------------------------------------------------
Prefix            |
Verb              | POST
URI               | /users(.:format)
Controller#Action | users#create
--[ Route 3 ]----------------------------------------------------
Prefix            | new_user
Verb              | GET
URI               | /users/new(.:format)
Controller#Action | users#new
--[ Route 4 ]----------------------------------------------------
Prefix            | edit_user
Verb              | GET
URI               | /users/:id/edit(.:format)
Controller#Action | users#edit
```
Можно искать маршруты с помощью опции `grep`: -g. Это выведет любые маршруты, которые частично соответствуют по имени метода хелпера URL, метода HTTP или пути URL.
```
$ rails routes -g new_comment
$ rails routes -g POST
$ rails routes -g admin
```
Если хотите просмотреть маршруты, ведущие на определенный контроллер, имеется опция -c.
```
$ rails routes -c users
$ rails routes -c admin/users
$ rails routes -c Comments
$ rails routes -c Articles::CommentsController
```
> Результат команды rails routes более читаемый, если у вас в окне терминала прокрутка, а не перенос строчек.

#### Тестирование маршрутов

Маршруты должны быть включены в вашу стратегию тестирования (так же, как и остальное в вашем приложении). Rails предлагает три встроенных оператора контроля, разработанных для того, чтобы сделать тестирование маршрутов проще:
* `assert_generates`
* `assert_recognizes`
* `assert_routing` 

##### Оператор контроля `assert_generates`
Используйте `assert_generates`, чтобы убедиться в том, что определенный набор опций генерирует конкретный путь и может использоваться с дефолтными маршрутами или своими маршрутами. Например:
```
assert_generates '/photos/1', { controller: 'photos', action: 'show', id: '1' }
assert_generates '/about', controller: 'pages', action: 'about'
```
##### Оператор контроля `assert_recognizes`
Оператор контроля `assert_recognizes` - это противоположность `assert_generates`. Он убеждается, что Rails распознает предложенный путь и маршрутизирует его в конкретную точку в вашем приложении. Например:
```
assert_recognizes({ controller: 'photos', action: 'show', id: '1' }, '/photos/1')
```
Можете задать аргумент `:method`, чтобы определить метод HTTP:
```
assert_recognizes({ controller: 'photos', action: 'create' }, { path: 'photos', method: :post })
```
##### Оператор контроля `assert_routing`
Оператор контроля `assert_routing` проверяет маршрут с двух сторон: он тестирует, что путь создает опции, и что опции создают путь. Таким образом, он комбинирует функции `assert_generates` и `assert_recognizes`:
```
assert_routing({ path: 'photos', method: :post }, { controller: 'photos', action: 'create' })
```


# Копаем глубже <a name="5"></a>
## Безопасность приложений Rails <a name="5.1"></a>
### Что такое сессии
Сессии позволяют приложению поддерживать пользовательское состояние, пока пользователи взаимодействуют с приложением. Например, сессии позволяют пользователю быть аутентифицированным единожды и оставаться таким во всех будущих запросах.
Если у пользователя уже есть активная сессия, Rails использует существующую сессию. В противном случае будет создана новая сессия.
### Угон сессии
Перехват куки в незащищенной сети. Беспроводная LAN может быть примером такой сети. В незашифрованной беспроводной LAN очень легко прослушивать трафик всех присоединенных клиентов. Для создателя веб-приложений это означает, что необходимо предоставить безопасное соединение через SSL. В Rails 3.1 и позже это может быть выполнено с помощью принуждения к соединению SSL в файле конфигурации приложения: 
`config.force_ssl = true`
### Хранение сессии 
Rails использует ActionDispatch::Session::CookieStore в качестве хранилища сессии по умолчанию.
`CookieStore` Rails сохраняет хэш сессии в куки на стороне клиента. Сервер получает хэш сессии из куки и устраняется необходимость в ID сессии.
`CookieStore` использует <a href="https://api.rubyonrails.org/classes/ActionDispatch/Cookies/ChainedCookieJars.html#method-i-encrypted">зашифрованные</a> куки, чтобы предоставить безопасное, зашифрованное место расположения для хранения данных сессии.
> Ключ шифрования, а также ключ верификации, используемый для подписанных куки, получены из конфигурационного значения secret_key_base.

Секретные ключи должны быть длинными и случайными. Используйте `rails secret` для получения новых уникальных секретных ключей.
Также важно использовать различные значения соли для зашифрованных и подписанных куки.

В test и development средах приложения получают `secret_key_base` из имени приложения. В других средах должен использоваться случайный ключ, присутствующий в `config/credentials.yml.enc`, показанный здесь в дешифрованном состоянии:
```
secret_key_base: 492f...
```
> Если секретные ключи вашего приложения могли быть скомпрометированы, настоятельно рекомендуется изменить секретный ключ. Изменение `secret_key_base` прекратит текущие активные сессии.
### Ротация зашифрованных и подписанных конфигураций куки
Ротация идеально подходит для изменения конфигураций куки и обеспечения того, что старые куки не сразу стали недействительны.

Например, чтобы изменить дайджест, используемый для подписанных куки с SHA1 на SHA256, необходимо сперва назначить новое конфигурационное значение:
```
Rails.application.config.action_dispatch.signed_cookie_digest = "SHA256"
```
Теперь добавьте ротацию для старого дайджеста SHA1, чтобы существующие куки были бесшовно апгрейднуты до нового дайджеста SHA256.
```
Rails.application.config.action_dispatch.cookies_rotations.tap do |cookies|
  cookies.rotate :signed, digest: "SHA1"
end
```
Для получения дополнительной информации о ротации ключа с зашифрованными и подписанными сообщениями, а также о различных опциях, которые принимает метод `rotate`, обратитесь, пожалуйста, к документации по <a href="https://api.rubyonrails.org/classes/ActiveSupport/MessageEncryptor.html">MessageEncryptor API</a> и <a href="https://api.rubyonrails.org/classes/ActiveSupport/MessageVerifier.html">MessageVerifier API</a>.
## Командная строка Rails <a name="5.11"></a>

# Расширяем Rails <a name="6"></a>
## Используем Rails для API приложений <a name="6.5"></a>
### Что такое API приложение
Вместо использования Rails для генерации HTML, взаимодействующего с сервером с помощью форм и ссылок, многие разработчики трактуют их веб-приложения как всего лишь клиент API, созданный из HTML с помощью JavaScript, обращающегося к JSON API.
### Зачем использовать Rails для JSON API?
Давайте посмотрим на некоторые вещи, которые Rails предоставляет из коробки и которые применимы к API-приложениям.

На уровне промежуточных программ:
* Перезагрузка: приложения Rails поддерживают прозрачную перезагрузку. Это работает, даже если ваше приложение становится большим и рестарт сервера для каждого запроса становится неприемлемым.
* Режим разработки: приложения Rails идут с разумными значениями по умолчанию для разработки, что делает разработку приятной без ущерба производительности для production.
* Тестовый режим: то же самое, что и для режима разработки.
* Логирование: приложения Rails логируют каждый запрос с уровнем детализации, приемлемым для текущего режима. Логи Rails в development включают информацию о среде запроса, запросах в базу данных и основную информацию о производительности.
* Безопасность: Rails обнаруживает и мешает исполнению IP-спуфинга, и безопасным способом обрабатывает криптографические сигнатуры в атаках по времени. Не знаете, что такое IP-спуфинг или атака по времени? Вот-вот!
* Парсинг параметров: Хотите устанавливать ваши параметры как JSON вместо URL-кодированной строки? Без проблем. Rails декодирует JSON и сделает его доступным в params. Хотите использовать вложенные URL-кодированные параметры? Это тоже работает.
* Условный GETs: Rails поддерживает условный GET (ETag и Last-Modified), обрабатывая заголовки запроса и возвращая правильный отклик и код статуса. Все, что нужно, это использовать проверку stale? в вашем контроллере, и Rails позаботится обо всех деталях HTTP.
* Запросы HEAD: Rails прозрачно конвертирует запросы HEAD в GET, и возвращает только заголовки тем же образом. Это позволяет HEAD надежно работать во всех API Rails.

Очевидно, что хотя вы и можете это создать сами в терминах существующих промежуточных программ Rack, этот список демонстрирует стек промежуточных программ Rails по умолчанию, представляющий большую ценность, даже если вы "просто генерируете JSON".

На уровне Action Pack:

* Ресурсный роутинг: Если вы создаете RESTful JSON API, вам захочется использовать роутер Rails. Чистое и общепринятое сопоставление от HTTP к контроллерам означает, что не нужно тратить время, думая, как смоделировать ваш API в терминах HTTP.
* Генерация URL: Обратной стороной роутинга является генерация URL. Хороший API, основанный на HTTP, включает URL (в качестве примера смотрите GitHub Gist API).
* Отклики с заголовками и редиректами: `head :no_content` и `redirect_to user_url(current_user)` очень удобны. Конечно, заголовки отклика можно добавить руками, но зачем?
* Кэширование: Rails предоставляет кэширование страниц, экшнов и фрагментов. Кэширование фрагментов особенно полезно при создании вложенных объектов JSON.
* __Базовая, дайджестная и токенная аутентификация__: Rails поставляется с поддержкой из коробки трех типов аутентификации HTTP.
* Инструментарий: в Rails имеется инструментальный API, запускающий зарегистрированные обработчики для множества событий, таких как обработка экшна, отсылка файла или данных, перенаправление и запросы к базе данных. Полезная нагрузка о каждом событии приходит с соответствующими параметрами (для события обработки экшна полезная нагрузка включает контроллер, экшн, параметры, формат запроса, метод запроса и полный путь запроса).
* Генераторы: Часто удобно сгенерировать ресурс и получить модель, контроллер, заготовки для тестов и роутов, созданные одной командой, для дальнейшей доработки. То же самое для миграций и остального.
* Плагины: Многие сторонние библиотеки поставляются с поддержкой Rails, что уменьшает или устраняет стоимость настройки и внедрения библиотеки во фреймворк. Это включает вещи, такие как переопределение генераторов по умолчанию, добавление задач Rake и принятие выбора в Rails (такого как логгер и кэширующий бэкенд). 
Конечно, процесс загрузки Rails также соединяет воедино все зарегистрированные компоненты. Например, процесс загрузки Rails это то, что использует файл `config/database.yml` при конфигурации Active Record.
> Краткая версия: можно не задумываться, какие части Rails все еще применимы, даже если вы уберете уровень представления, ответом будет - большая часть из них.
### Базовая конфигурация
#### Генерация приложения 
```
rails new my_api --api
```
Это сделает три основных вещи:
* Сконфигурирует приложение, чтобы оно запускало более ограниченный набор промежуточных программ, чем обычно. В частности, оно не включит по умолчанию какие-либо промежуточные программы, полезные для браузерных приложений (такие как поддержка куки).
* Унаследует ApplicationController от `ActionController::API` вместо `ActionController::Base`. Как и в случае с промежуточными программами, это выкинет все модули Action Controller, предоставляющие функциональность, в основном используемую браузерными приложениями.
* Сконфигурирует генераторы, чтобы они пропускали генерацию вьюх, хелперов и ассетов при генерации нового ресурса
#### Изменение существующего приложения
В `config/application.rb` добавьте следующую строчку в самый верх определения класса Application:
```
config.api_only = true
```
В `config/environments/development.rb` установите `config.debug_exception_response_format`, чтобы настроить формат, используемый в откликах, когда происходит ошибка в режиме development.

Чтобы отрендерить страницу HTML с отладочной информацией, используйте значение :default
```
config.debug_exception_response_format = :default
```
Чтобы отрендерить отладочную информацию, сохранив формат отклика, используйте значение :api
```
config.debug_exception_response_format = :api
```
По умолчанию `config.debug_exception_response_format` установлен :api, когда `config.api_only` установлен true.

Наконец, в `app/controllers/application_controller.rb` вместо:

```
class ApplicationController < ActionController::Base
end
```
сделайте:
```
class ApplicationController < ActionController::API
end
```
### Выбор промежуточных программ
API-приложение поставляется со следующими промежуточными программами по умолчанию:
* `Rack::Sendfile`
* `ActionDispatch::Static`
* `ActionDispatch::Executor`
* `ActiveSupport::Cache::Strategy::LocalCache::Middleware`
* `Rack::Runtime`
* `ActionDispatch::RequestId`
* `ActionDispatch::RemoteIp`
* `Rails::Rack::Logger`
* `ActionDispatch::ShowExceptions`
* `ActionDispatch::DebugExceptions`
* `ActionDispatch::Reloader`
* `ActionDispatch::Callbacks`
* `ActiveRecord::Migration::CheckPending`
* `Rack::Head`
* `Rack::ConditionalGet`
* `Rack::ETag`

Другие плагины, включая Active Record, могут добавлять дополнительные промежуточные программы. В основном, эти промежуточные программы безразличны к типу создаваемого приложения, и имеют смысл в API-приложении Rails.

Можно получить список всех промежуточных программ вашего приложения с помощью:
```
rails middleware
```
#### Использование кэширующей промежуточной программы

По умолчанию Rails добавит промежуточную программу, предоставляющую хранилище кэша, основанного на конфигурации вашего приложения (по умолчанию memcache). Это означает, что встроенный кэш HTTP будет полагаться на нее.

Например, используя метод `stale?`:
```
def show
  @post = Post.find(params[:id])

  if stale?(last_modified: @post.updated_at)
    render json: @post
  end
end
```
Вызов `stale?` сравнит заголовок `If-Modified-Since` в запросе с `@post.updated_at`. Если заголовок новее, чем время последнего модифицирования, этот экшн вернет отклик "304 Not Modified". В противном случае, он отрендерит отклик и включит в него заголовок `Last-Modified`.

Обычно этот механизм используется отдельно для каждого клиента. Кэширующая промежуточная программа позволяет распределять этот кэширующий механизм между клиентами. Можно включить межклиентское кэширование в вызове `stale?`:
```
def show
  @post = Post.find(params[:id])

  if stale?(last_modified: @post.updated_at, public: true)
    render json: @post
  end
end
```
Это означает, что кэширующая промежуточная программа сохранит значение `Last-Modified` для URL в кэше Rails, и добавит заголовок `If-Modified-Since` в любой последующий входящий запрос к этому URL.

Воспринимайте это как кэширование страниц в семантике HTTP.
#### Использование Rack::Sendfile
При использовании метода `send_file` в контроллере Rails, он устанавливает заголовок `X-Sendfile`. `Rack::Sendfile` ответственен за фактическую отсылку файла.

Если ваш фронтенд сервер поддерживает ускоренную отсылку файла, `Rack::Sendfile` переложит работу по фактической отсылке файла на фронтенд сервер.
Можно настроить имя заголовка, которое использует ваш фронтенд сервер для этой цели, с помощью `config.action_dispatch.x_sendfile_header` в соответствующем среде конфигурационном файле.
<a href="https://rubydoc.info/github/rack/rack/master/Rack/Sendfile">Подробнее о send_file</a>
Вот несколько значений этого заголовка для некоторых популярных серверов, которые, как только эти серверы будут настроены, добавят поддержку для ускоренной отсылки файла:
```
# Apache и lighttpd
config.action_dispatch.x_sendfile_header = "X-Sendfile"

# Nginx
config.action_dispatch.x_sendfile_header = "X-Accel-Redirect"
```
Убедитесь, что сконфигурировали на своем сервере поддержку этих опций в соответствии с инструкциями в документации `Rack::Sendfile`
#### Использование ActionDispatch::Request
`ActionDispatch::Request#params` примет параметры от клиента в формате JSON и сделает их доступными в контроллере внутри `params`.

Для его использования клиенту нужно сделать запрос с кодированными в JSON параметрами и указать `Content-Type` как `application/json`.

Вот пример на jQuery:
```
jQuery.ajax({
  type: 'POST',
  url: '/people',
  dataType: 'json',
  contentType: 'application/json',
  data: JSON.stringify({ person: { firstName: "Yehuda", lastName: "Katz" } }),
  success: function(json) { }
});
```
ActionDispatch::Request увидит Content-Type и вашими параметрами будут:
```
{ :person => { :firstName => "Yehuda", :lastName => "Katz" } }
```
####  Другие промежуточные программы
Rails поставляется с рядом других промежуточных программ, которые вы, возможно, захотите использовать в API-приложении, особенно если одним из клиентов вашего API является браузер:
* `Rack::MethodOverride`
* `ActionDispatch::Cookies`
* `ActionDispatch::Flash`
Для управления сессией:
* `ActionDispatch::Session::CacheStore`
* `ActionDispatch::Session::CookieStore`
* `ActionDispatch::Session::MemCacheStore`

Любые из этих промежуточных программ могут быть добавлены с помощью:
```
config.middleware.use Rack::MethodOverride
```
#### Удаление промежуточных программ
Если вы не хотите использовать промежуточную программу, которая включена по умолчанию в набор промежуточных программ для API, ее можно убрать с помощью:
```
config.middleware.delete ::Rack::Sendfile
```
Учтите, что удаление этих промежуточных программ удалит поддержку для определенных особенностей в Action Controller.
### Выбор модулей контроллера
API-приложение (использующее `ActionController::API`) по умолчанию поставляется со следующими модулями:
* `ActionController::UrlFor`: Делает доступными url_for и подобные хелперы.
* `ActionController::Redirecting`: Поддержка для redirect_to.
* `AbstractController::Rendering` и `ActionController::ApiRendering`: Базовая поддержка для рендеринга.
* `ActionController::Renderers::All`: Поддержка для `render :json` и сотоварищей.
* `ActionController::ConditionalGet`: Поддержка для `stale?`.
* `ActionController::BasicImplicitRender`: Убеждается, что возвращен пустой отклик, если нет явного.
* `ActionController::StrongParameters`: Поддержка для фильтрации параметров в сочетании с массовым назначением Active Model.
* `ActionController::DataStreaming`: Поддержка для `send_file` и `send_data`.
* `AbstractController::Callbacks`: Поддержка для `before_action` и подобных хелперов.
* `ActionController::Rescue: Поддержка для rescue_from.
* `ActionController::Instrumentation`: Поддержка для инструментальных хуков, определенных Action Controller (подробности относительно этого смотрите в руководстве Инструментарий Active Support).
* `ActionController::ParamsWrapper`: Оборачивает хэш параметров во вложенный хэш, таким образом, к примеру, не нужно указывать корневые элементы при посылка запросов POST.
* `ActionController::Head`: Поддержка возврата отклика без тела сообщения, только заголовки 
Другие плагины могут добавлять дополнительные модули. Список всех модулей, включенных в `ActionController::API` можно получить в консоли rails:
```
$ rails c
>> ActionController::API.ancestors - ActionController::Metal.ancestors
=> [ActionController::API,
    ActiveRecord::Railties::ControllerRuntime,
    ActionDispatch::Routing::RouteSet::MountedHelpers,
    ActionController::ParamsWrapper,
    ... ,
    AbstractController::Rendering,
    ActionView::ViewPaths]
```
#### Добавление других модулей
Все модули Action Controller знают о зависимых модулях, поэтому можно свободно включать любые модули в контроллеры, и будут включены и настроены все зависимости.

Некоторые распространенные модули, которые вы, возможно, захотите добавить:
* `AbstractController::Translation`: Поддержка для методов локализации l и перевода t.
* Поддержка для базовой, дайджестной или токенной аутентификации HTTP:
  1. `ActionController::HttpAuthentication::Basic::ControllerMethods` <a href="https://apidock.com/rails/v3.2.1/ActionController/HttpAuthentication/Basic">подробнее</a>,
  2. `ActionController::HttpAuthentication::Digest::ControllerMethods`,
  3. `ActionController::HttpAuthentication::Token::ControllerMethods` <a href="https://apidock.com/rails/v6.0.0/ActionController/HttpAuthentication/Token">Подробнее</a>
* `ActionView::Layouts`: Поддержка для макетов при рендеринге.
* `ActionController::MimeResponds`: Поддержка для respond_to.
* `ActionController::Cookies`: Поддержка для cookies, что включает поддержку для подписанных и зашифрованных куки. Он требует промежуточную программу для куки.
* `ActionController::Caching:` Поддержка кэширования вьюх для контроллера API. Отметьте, что нужно вручную указать хранилище кэша внутри контроллера подобно следующему: `ruby class ApplicationController < ActionController::API include ::ActionController::Caching self.cache_store = :mem_cache_store end` Rails не передает эту конфигурацию автоматически. 

Лучшим местом для добавления модулей является `ApplicationController`, но вы также можете добавить модули в отдельные контроллеры.

# Вносим вклад <a name="7"></a>

# Дополнительно <a name="8"></a>
## Все подряд
### task_desire_api
Модели:
```
rails g model User login:string:uniq password_digest name sign
rails g model Article head:string announcement:string content:text status:boolean user:references
```
Контроллеры:
```
rails g controller Articles create update destroy
```
### Задачи Rake
* `rake db:create` - Cоздать баду данных
* `rake db:drop` - Удалить базу данных
* `rake db:migrate` - Запустить миграцию базы
* `rake db:rollback` - Откатить миграцию данных к предыдущему состоянию
* `rake db:schema:dump` - Построение файла schema.rb на основе текущей структуры базы данных
* `rake db:schema:load` - Восстановление структуры базы данных из schema.rb
* `rake db:seed` - Запускает скрипт db/seed.rb который по идее должен заполнить базу первоначальными данными
* `rake db:setup` - Запустит поочереди create, schema:load, seed
* `rake db:structure:dump` - Сделает дамп структуры в db/structue.sql
* `rake db:structure:load` - Восстановит базу из db/structue.sql

