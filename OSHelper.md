### Границы зоны ответственности ОС
Задачи, покрываемые ОС:
* Управление пользовательскими задачами:
1. Запуска и останов процессов
2. Планирование времени центрального процессора
3. Распределение оперативной памяти
4. Разграничение полномочий
* Управление внешними устройствами
1. Абстрагирование от особенностей устройств разных моделей
2. Координация доступа нескольких задач к одному устройству

### О системе X Window
Запуск `X Window` - `X :1`. Чтобы запустить программу необходимо нажать Ctrl-Alt-F1, далее ctrl+z  и командой `bg` убрать работающую программу `X` в фоновый режим.
Запуск прикладной программы - `DISPLAY=:1.0 xterm`.
Вернутся к Х-серверу. Alt-F7, Alt-F8.

В системе X Window за стандартные элементы оконного интерфейса отвечают специальные программы, называемые оконными менеджерами.

### Каталоги
**Каталог** - особый тип файла, хранящий имена файлов, среди которых, возможно, тоже есть каталоги

Каждая запись в каталоге состоит из двух полей - **имя файла и номер индексного дескриптора**.

Хранимая на внешнем запоминающем устройстве (диске) структура данных, содержащая всю информацию о файле, включая его имя, называется **индексным дескриптором**.

Имя файла в ОС Unix не является ни в каком виде частью или принадлежностью самого файла.

Записи в каталогах ссылающиеся на тот же самый индексный дескриптор - **жесткие ссылки**.

В индексном дескрипторе содержится счетчик количества ссылок на данный дескриптор.

В ОС Unix не предусмотрено функций удаления файла, вместо этого имеется системный вызов, удаляющий ссылку, который называется `unlink`. 

Сам файл удаляется, только если удаленная ссылка была последней (счетчик обратился в нуль) и при этом файл не был ни одним из процессов открыт на запись или чтение.

Система запрещает создание жестких ссылок на каталоги, удаление каталогов происходит с помощью команды `rmdir`.

Для создания жесткой ссылки средствами командной строки можно воспользоваться командой - `ln`.

**Символическая ссылка** (symbolic link) представляет собой файл специального типа, содержащий имя другого файла. Операция открытия символической ссылки на чтение или запись приводит к открытию файла, на который она ссылается, а не её самой. Будучи файлом, символическая ссылка имеет свой номер индексного дескриптора. Создание и удаление символической ссылки никак не затрагивает ни файл, на который она ссылается, ни его индексный дескриптор. Более того файл, на который указывает ссылка, может вообще не существовать в момент её создания, а также может быть удален позднее, что никак не повлияет на ссылку. 

> Символическая ссылка, содержащая имя несуществующего файла, называется **висячей**. Символические ссылки не ограничены рамками одного диска, поскольку реализуются через хранение имен, а дерево имен, как мы знаем, в ОС Unix общее для всех имеющихся в системе дисковых устройств.

Для создания символической ссылки средствами командной строки следует использовать уже знакомую нам команду `ln`, указав её флаг `-s`:
```
ln -s /path/to/old/name new_name
```
### Права доступа к файлам
Скриптовый файл должен начинатся со строки `#!bin/sh`, означает что для исполнения этого файла нужно запустить программу `/bin/sh` (командный интерпретатор) и передать ему имя файла скрипта через аргумент командной строки. Подойдет любой интерпретатор, знающий что его будут вызывать (`Perl`, `Scheme`, `Prolog`). Нужно перед этим навесить на скриптовый файл бит исполнения.

> Биты `SetUid` и `SetGid` для скриптов не работают

`Sticky bit` в директории дает право удалять только свои собственные файлы.

> Обычно для создания общественной директории применяются права 01777 - всем разрешается все, но при этом взведенный `Sticky bit` не позволит удалять чужие файлы.

`SetGid bit` установленный на директорию, приводит к тому, что для файлов, создаваемых в такой директории, в качестве группы пользователей принудительно устанавливается та же группа, что и для самой директории.

`ls -l` - показать права доступа, системный вызов - `stat`

Измнение прав доступа - `chmod` - системный вызов - `chmod`

Смена владельца и группы для файла - `chown`, `chgrp`, системный вызов - `chown`

### Чтение и запись содержимого файлов
Основные системные вызовы для работы с потоками ввода-вывода:
* `int open(const char *name, int mode);`
* `int open(const char *name, int mode, int perms);`

Чтение из потока ввода и запись в поток вывода происходит с помощью сис. вызовов:
* `int read(int fd, void *mem, int len);`
* `int write(int fd, const void *data, int len)`

Закрытие файла - `int close(int fd)`, даже если произошла ошибка дескриптор никогда не остается открытым.

Изменение текущей позиции в файле - `int lseek(int fd, int offset, int whence);`. Возвращает новое значение текущей позиции, считая от начала, `lseek(fd, 0, SEEK_END)` вернет длину файла, а текущей позицией станет его конец.

В большинстве случаев операции записи выполняются системой в так называемом асинхронном режиме вывода.

В явном виде дожидается завершение операции записи при асинхронном режиме - `int fsync(int fd);`. Вызов сообщает ОС, что все данные, связанные с файлом, должны быть как можно скорее физически записаны на диск. Точнее должна быть как можно скорее выполнена физическая операция записи.

`fdatasync` - аналог `fsync` но гарантирующий запись на диск только той информации, которая необходима для последующего корректного прочтениях данных.

`sync` - сообщает системе, о необходимости немедленно физически записать всю информацию, которая пока что содержится только в памяти системы, но предназначена для записи на диск. Речь идет о всей информации для всех дисковых файлов для всех пользователей системы.

Гибкая настройка поведения дескрипторов. Доступ практически ко всем возможностям такой настройки предоставляет системный вызов `fcntl` - `int fcntl(int fd, int cmd, ...);`. Первый параметр - номер дескриптора, второй - код команды (определенная целочисленная константа)

Флаги команды `open`: 
1. Флаги режима доступа
* `O_RDONLY`
* `O_WRONLY`
* `O_RDWR`
2. Флаги создания файла:
* `O_CREAT`
* `O_EXCL`
* `O_TRUNC`
* `O_NOCTTY`
3. Флаги статуса (отличаются от всех, их можно менять после начала работы с файлом):
* `O_APPEND`
* `O_NONBLOCK`

Текущее значение флагов статуса для открытого потока можно узнать, выполнив `fcntl` с командой `F_GETFL`, например `flags = fcntl(fd, F_GETFL)`.

Установлен ли конкретный флаг, можно понять с помощью побитового "и":
```
if(flags & O_APPEND) { /* флаг O_APPEND установлен */
/*...*/
```
Изменение текущего статуса с командой `F_SETEL`:
```
flags = fcntl(fd, F_GETEL);
fcntl(fd, F_SETEL, flags | O_NONBLOCK);
```

### Управление объектами файловой системы
Создание жестких ссылок - `int link(const char *oldpath, const char *newpath);`

Удаление ссылки на файл из каталога - `int unlink(const char *name);`. Не позволяет удалять директории

`int rename(const char *oldpath, const char *newpath);` - переименование файла 

Создание и удаление директории:
```
int mkdir(const char *name, int perms);
int rmdir(const char *name);
```

Символические ссылки - `int symlink(const char *oldpath, const char *newpath);`

Удаление символической ссылки - `unlink`

Изменение прав доступа - `int chmod(const char *path, int perms);`. Параметр `umask` на работу `chmod` не влияет.

Изменение владельца файла:
```
int chown(const char *path, int owner, int group);
int lchown(const char *path, int owner, int group);
```
Различие в том, что если их применить к символической ссылке, то `chown` будет работать с файлом, на который эта ссылка ссылается, а `lchown` - с самой ссылкой, хотя в большинстве случаев это бессмысленно. Если в `group` указать -1, то сохранится без изменений.

Подробная информация о файле:
```
int stat(const char *path, struct stat *buf);
int lstat(const char *path, struct stat *buf);
int fstat(int fd, struct stat *buf);
```
Различие заключается в символической ссылке.

Поля структуры хранения информации о файле:
* `st_dev` - идентификатор устройства, на котором находится файл
* `st_ino` - номер индексного дескриптора
* `st_mode` - тип файла и права доступа к файлу. Чтобы вытащить права доступа, необходимо произвести побитовую конъюнкцию значения этого поля с маской 07777 (0x0fff), тем самым выделив из него 12 младших бит.
* `st_nlink` - количество ссылок на файл
* `st_uid` - идентификатор пользователя владельца
* `st_gid` - идентификатор группы пользователей
* `st_rdev` - идентификатор устройства
* `st_size` - размер файла в байтах
* `st_blksize` - размер блока ввода-вывода на даной файловой системе
* `st_blocks` - количество блоков по 512 байт, занятых данным файлом
* `st_atime` -  дата и время последнего доступа к файлу
* `st_mtime` - дата и время последней модификации содержимого файла
* `st_ctime` - дата и время последнего изменения свойств файла

Укорочение файла путем удаления содержимого начиная с указанной позиции - `int trucate(const char *path, int length);`. Второй параметр - новая длинна.

Если файл открыт то то же самое можно сделать этой функцией - `int ftruncate(int fd, int length);`

### Файлы устройств и классификация устройств
В ОС Unix достаточно открыть на чтение специальный файл, соответствующий нужному диску, с помощью вызова `lseek` позиционироваться на нужный сектор и выдать обычный `write`. Именно так происходит форматирование диска, т.е. создание файловой системы.

Устройства, имеющие представление в виде файла, делятся на два типа:
* символьные (или потоковые, они же байт-ориентированные) (терминал, звуковая карта, принтер...). Существует ряд символьных псевдоустройств, не имеющих физического воплощения. Например в устройство `/dev/null` можно записать любую информацию, которая попросту игнорируется. Попытка читать из этого файла приведет к ситуации конец файла. **Не поддерживают** операцию позиционирования.
* блочные (блок-ориентированные) (диски и другие). Поддерживают позиционирование `lseek`

Функция для совершения дополнительных операций, специфических для конкретного устройства - `int ioctl(int fd, int request, ...);`. Второй параметр - код нужной операции. Например:
```
int fd = open("/dev/cdrom", O_RDONLY|O_NONBLOCK);
ioctl(fd, CDROMEJECT);
ioctl(fd, CDROMCLOSETRAY);
```
открывает и закрывает лоток привода CD-ROM. Параметр `O_NONBLOCK` задается, чтобы избежать поиска диска в устройстве и ошибки в случае, если диск в устройство не вставлен. Если же вставить в то же устройство музыкальный диск (audio CD), код:
```
struct cdrom_ti cti;
cti.cdti_trk0 = 2;
cti.cdti_ind0 = 0;
cdi.cdti_trk1 = 2;
cti.cdti_ink1 = 0;
ioctl(fd, CDROMPLAYTRAKIND, &cti);
```
заставит устройство воспроизвести вторую дорожку диска.

### Работа с содержимым каталогов
Система позволяет открывать каталоги на чтение с помощью вызова `open`.

Библиотека Си предусматирвает для анализа содержимого каталогов функции - `opendir`, `readdir`, `closedir`:
```
DIR *opendir(const char *name);
struct dirent *readdir(DIR *dirp);
int closedir(DIR *dirp);
```

### Отображение файлов в память
Отображение содержимого некоторого файла в виртуальное адресное пространство процесса - `mmap`:
```
void *mmap(void *start, int length, int protection, int flags, int fd, int offset);
```
Перед обращением файл должен быть открыт с помощью `open`. Параметры `mmap`:
* Параметры  `offset` и `length` задают позицию начала отображаемого участка в файле и его длинну. 
* `protection` задает режим доступа к памяти (`PROT_READ`, `PROT_WRITE`, `PROT_EXEC`, `PROT_NONE`). 
* Параметр `flags` указвают либо `MAP_SHARED`, либо `MAP_PRIVATE`  (изменения в виртуальном файле не отразятся) и дополнительный флаг через `|` - `MAP_ANONYMOUS` - позволяет обойтись без файла.
* `start` - в каком месте адресного пространства хотелось бы видеть новую область памяти. Если передать `NULL`, система выберет свободную память виртуального пространства.

`mmap` возвращает указатель на созданную область виртуальной памяти. В случае ошибки возвращает -1 (`MAP_FAILED`).

Память, выделяемая с помощью `mmap` с одновременным указанием `MAP_ANONYMOUS` и `MAP_SHARED` отличается от обычной тем, что при создании нового процесса она становится доступна из обоих процессов, то есть изменения, сделанные в такой памяти порожденным процессом, будут доступны родительскому и наоборот. Это называется **разделяемой памятью**. Она используется для взаимодействия между процессами.

Длина и позиция `mmap` должны быть кратны некоторому предопределенному числу, называемому размером страницы.

Размер страницы - `int getpagesize();`

Пример `mmap`:
```
int fd, pgs;
char *p;
int size = 4096;
pgs = getpagesize();
size = ((size - 1) / pgs + 1) * pgs;
/* Минимальное целое число, большее либо равное
  исходному и при этом кратное размеру страницы */
fd = open("file.dat", O_RDWR);
if(fd == -1) {
  /* Обработка ошибки */
}
p = mmap(NULL, size, PROT_HEAD|PROT_WRITE, MAP_SHARED, fd, 0);  
if(p == MAP_FAILED) {
  /* обработка ошибки */
}
```
После выполнения выражение `p[25]` будет равно значению 26-го байта в файле "file.dat", причем операция присваивания `p[25] = 'a'`, занесет в этот байт символ `'a'`.

Отмена отображения `mmap` - `int munmap(void *start, int length);`

> Вызов `mmap`, изначально предназначавшийся для работы с содержимым дисковых файлов, в наше время воспринимается как универсальный интерфейс для создания областей виртуальной памяти. Например:
```
p = mmap(NULL, size, PROT_HEAD|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);
```
указатель `p` содержит адрес новой области виртуальной памяти, полученной от ОС.

### Процессы
Процесс - некая сущность, создаваемая ОС для выполнения пользовательской программы.

Процесс - это программа, которую запустили на выполенение под управлением ОС.

Процесс - это структура данных, создаваемая в ядре ОС для поддержки выполнения пользовательской программы.

### Свойства процесса
* `pid` - уникальный идентификатор
* `ppid` - уникальный идентификатор родительского процесса. Если родительский процесс завершается раньше потомка, то `ppid` потомка становится 1.
* `pgid` - некая группа в рамках сеанса, которые обозначаются идентификатором группы процессов.
* `sid` - идентификатор сеанса.

Информация, определяющая полномочия процесса:
* `uid`
* `gid`
* `euid` - эффективный идентификатор пользователя
* `egid` - эффективный идентификатор группы

> В большинстве случаев эффективные идентификаторы совпадают с обычными, примером случая, когда это не так, служат `suid` программы, то есть программы, выполняемые с правами пользователя, владеющего исполняемым файлом данной программы, а не того пользователя, который программу запустил. Например `passwd`.

Узнать свои значения `uid`, `gid`, `euid`, `egid`, `pid`, `ppid`, `sid`, `pgid` процесс может узнать с помощью системных вызовов, которые так и называются `getpid`, `getuid` и т.д.

Память процесса:
* Секция кода
* Секция данных
* Секция стека
* Другие секции

Важная характеристика процесса - **состояние регистров центрального процессора**, включая счетчик команд (указатель инструкций), регистр флагов, указатель стека и все регистры общего назначения. Когда процесс по тем или иным причинам находится вне состояния выполнения (то есть он заблокирован, либо готов к выполнению, но процессор занят чем-то другим), содержимое регистров ЦП для этого процесса хранится в специальной структуре данных в ядре. Когда процесс снова становится на выполнение, данные из этой структуры копируются обратно в регистры.

За обеспечение иллюзии одновременного исполнения процессов отвечает подсистема ядра, которая называется **планировщиком времени центрального процессора**. С точки зрения планировщика процесс обладает:
* Логическим значением готовности
* Приоритетом (статическим, динамическим). Статический приоритет может быть изменен с помощью системных вызовов `nice`, `setpriority`.

**Командная строка процесса** - является его свойством, к примеру командная строка каждого процесса показывается в выдаче команды `ps`, печатающей список процессов в системе.

> Увидеть все процессы в системе - `ps ax` или `ps axu`.

**Окружение процесса** - является его свойством. Наследование окружения обусловлено не свойством ОС, а библиотечными функциями, через которые обычно осуществляется запуск новых программ. С точки зрения ядра окружение для каждой запускаемой программы задается свое.

Окружение доступно в программах на Си через глобальную переменную:
```
extern char **environ;
```
Поскольку окружение располагается в памяти процесса, системные вызовы для работы с окружением не нужны. Для манипулияции переменными окружения служат библиотечные функции `getenv`, `setenv`, `unsetenv`:
```
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite);
void unsetenv(const char *name);
```

К свойствам процесса также относятся **текущий каталог** и **кореновой каталог**. Процесс может в любой момент сменить свой текущий каталог. Если процесс запускать с указанием корневого каталога как `/foo`, то процесс будет видеть путь `/` как `/foo`, а `/bar` как `/foo/bar`.

Смена текущего каталога с помощью системного вызова - `int chdir(const char* path);`

Смена корневого каталога - `int chroot(const char* path);`

> Текущий и коренвой каталоги нельзя изменить для другого процесса, только для самого себя.

Еще одно важное свойство процесса, связано с открытыми потоками ввода-вывода - это **таблица файловых дескрипторов**. Каждый поток ввода-вывода на самом деле представляет собой сложную структуру данных в памяти ядра, причем конкретный вид этой структуры существенно зависит от природы потока. Таблица файловых дескрипторов процесса задает соответствие собсвтенно файловых дескрипторов объектов внутря ядра ОС, содержащим все необходимое для функционирования этих потоков.

Параметр `umask` также является свойством процесса - `int umask(int mask)`;

**Диспозиция сигналов** - набор указаний ОС, что следует делать, когда данному процессу приходит тот или иной сигнал, тоже является свойством процесса.

**Счетчики потребленных ресурсов** (процессорного времени, памяти и т.п.) являются свойством процессора. 

Есть еще и другие свойства...

### Порождение процесса
Единственный способ порождения процесса в Unix - создание копии существующего процесса. Для этого используется системный вызов `fork` - `int fork(void)`.
В результате создается новый процесс, являющийся точной копией родительского за исключаением следующих различий:
* порожденный процесс имеет свой идентификатор (`pid`), который отличется от родительского
* параметр `ppid` порожденного процесса равен `pid` родительского
* счетчики потребленных ресурсов порожденного процесса сразу после `fork` равны нулю
* выполнение обоих процессов (родительского и порожденного) продолжается с первой инструкции, следующей сразу за вызовом `fork`(чаще всего это присваивание возвращаемого ею значения какой либо переменной), причем в родительском процессе `fork` возвращает `pid` порожденного процесса, а в порожденном возвращает число 0.

Например:
```
#include <stdio.h>
#include <unistd.h>
int main()
{
  fork();
  fork();
  fork();
  printf("Hello\n");
  return 0;
}
```
напечатает восемь строк `"Hello"`. В самом деле, после первого вызова `fork` процессов станет два, каждый из них продолжит выполнение со следующей после вызов операции, в данном случае - со второго вызова `fork`, то есть каждый из двух процессов снова породит свою копию. Имеющиеся четыре процесса продолжат выполнение с третьего `fork`, так что их станет восемь, и каждый из них выполнит `printf`.

На практике требуется, чтобы порожденный процесс делал не то же самое, что его родитель, а что-то другое. Для этого используется обычный `if`, проверяющий возвращенное вызовом `fork` значение:
```
p = fork();
if(p == 0) {
  .... действия порожденного процесса
 } else {
 .... действия родительского процесса 
}

или так
p = fork();
if(p == 0) {
  действия порожденного процесса
  exit(0);
}
действия родительского процесса
```

После обращения к `fork` оба процесса работают параллельно.

Ситуация, в которых результат зависит от конкретной последовательности независимых событий (обычно событий из работающих параллельно процессов) называется **ситуация гонок**.

После вызова `fork` оба процесса используют один и тот же сегмент кода, это возможно т.к. сегмент кода не может быть модифицирован. Остальная память процесса копируется за исключением некоторых особых случаев, копируется. В порожденном процессе существуют все переменные родительского процесса, имеют одни и те же значения на момент создания. Копированию подвергаются открытые дескрипторы файлов, установленные обработчики сигналов и т.п. 
 
### Замена выполняемой программы
Запустить на выполнение программу в ОС Unix можно путем замены выполняемой программы в рамках одного процесса. Работающую программу можно заменить на другую программу, которая начнет свое выполнение с её начала  (например с функции `main` для программ, написанны на С). Процесс остается тот же. В системах Unix это единственный способ запуска программ, другого нет.

Замена программы производится системным вызовом:
```
int execve(const char *name, char* const *argv. char* const *envir);
```
Для удобства программирования существуют еще несколько функций семейства `exec`, реализованных в библиотеке через вызов `execve`.

* Функция `execv`:
```
int execv(const char *name, char* const *argv);
```
* Функция `execvp`:
```
int execvp(const char *name, char* const *argv);
```
Эта функция умеет отыскивать запускаемую программу (`name`) по ее имени в системных директориях. Поиск производится если в строке переданной параметром `name`, нет ни одного символа `/`, так если значение переменной `PATH` содержит директорию `/bin`, то вызывать программу `/bin/ls` можно по имени `ls`, не указывая полный путь.

Часто бывает, когда нам известно точное количество параметров командной строки для программы, которую мы собираемся запустить с помощью `exec`. В таком случае нам нет необходимости самим формировать массив указателей на элементы командной строки. Вместо этого используются `execl` или `execlp`, который формируют массив за нас:
```
int execl(const char *name, const char *argv0, ...);
// execlp использует поиск по переменной PATH (системные директории)
int execlp(const char *name, const char *argv0, ...);
```
Чтобы функция знала где остановится , после последнего слова командной строки нужно добавить еще один параметр со значение `NULL`.

> Командная строка включает нулевой элемент, под которым подразумевается имя самой программы.

Допустим требуется выполнить команду `ls -l -a /var`. Это можно сделать так:
```
char *cmdline[] = { "ls", "-l", "-a", "/var", NULL };
execvp("ls", cmdline);

// или так
execlp("ls, "ls", "-l", "-a", "/var", NULL);
```

> Все функции семейства `exec` заменяют в памяти процесса выполнявшуюся ( и вызвавашую `exec`) программу на другую, указанную в параметрах вызова. Поэтому в случае успеха эти функции управление уже не возвращают, сам факт возврата свидетельсвтует об ошибкие.

Если после вызова функции семейства `exec` в тексте программы мы видим что-то отличное от связки `perror/exit`, в большинстве случаев здесь что-то не так.

> Если вызвать `fork`, когда некоторые из высокоуровневых потоков вывода содержат неотправленные данные, эти данные окажутся скопированы вместе со всеми данными родительского процесса, а функция `exit`, вызванная из порожденного процесса, произведет их вытеснение. Родительский процесс об этом знать не будет, и рано или поздно, вытеснит свой экземпляр скопированных данных. Результат можнет получиться довольно своеобразный. В общем нужно делать правильную последовательность вызовов:
```
execlp("ls", "ls", "-l", NULL);
perror("ls");
fflush(stderr);
_exit(1);
```

Открытые файловые дескрипторы при выполнении `exec` остаются открытыми, что позволяет перед запуском внешней программы произвести манипуляцию с дескрипторами. Это свойство `exec` используется для реализации хорошо знакомых нам перенаправлений ввода-вывода. Из этого правила есть исключение. На файловом дескрипторе может быть установлен флаг `FD_CLOEXEC(close-on-exec)`, и в этом случае файл - точнее, один отдельно взятый дескриптор - будет закрыт при успешно отработавшей замене программы.

> Вызов `fcntl` предусматривает отдельные команды - `F_SETFD` и `F_GETFD`. Изначально предполагалось, что эти команды будут работать с флагами, относящимися к дескриптору (в отличие от поток), но в итоге был введен один флаг - `FD_CLOEXEC`. Установить можно так:
```
fcntl(fd, F_SETED, FD_CLOEXEC);
```
> Узнать установлен флаг или нет, можно с помощью `fcntl(fd, F_GETED)` (такой вызов вернет значение `FD_CLOEXEC`, если флаг установлен и 0 если нет), но это почти никогда не нужно.

### Завершение процесса
Возврат значения из главного экземпляра `main` и прямой вызов `exit` есть в сущности одно и то же.

Профиль обертки `_exit` - `void _exit(int code);`. Параметр `code` задает код завершения процесса. Значение 0 означает успешное завершение, остальные 1, 2, 3 и т.д. что произошла ошибка или неудача.

> При использовании библиотечного интерфейса ввода-вывода, т.е. функций, вводимых заголовочным файлом `stdio.h`, функция `exit`, прежде чем завершить программу, вытеснит всю информацию из буферов вывода, тогда как `_exit`, будучи системным вызовом, этого не сделает. Эту разницу легко обнаружить на примере следующей программы ( перевод строки в `printf` отсутствует ):
```
int main()
{
  printf("Hello, world");
  _exit(0);
```
Если эту программу запустить, она ничего не напечатает. `printf` поместит строку в промежуточный буфер вывода и на этом успокоится. Поскольку в строке нет символа перевода строки, вытеснение буфер не произойдет. Далее `_exit` завершит программу немедленно, не оставив в библиотеке шанса вытеснить буфер.

Если заменить `_exit` на обычный `exit` (то есть вызвать библиотечную функцию вместе прямого обращения к системному вызову), фраза `"Hello, world"` будет благополучно напечатана, и то же самое произойдет, если завершить `main` традиционным `return 0`.

> Если к печатаемому сообщению добавить перевод строки и для завершения использовать `_exit` фраза будет напечата в терминал, а если запустить перенаправление в файл, то нет. Причина в том, что вытеснение буфера по символу перевода строки производится только на терминал.

`_exit` и `exit` и возврат управления из `main` - это случаи, когда процесс завершается самостоятельно, указав значение кода завершения. Но возможен другой случай, когда процессу приходит **сигнал**.
* О коде завершения при завершении по сигналу речи идти не может, поскольку процесс не дошел до своего вызова `_exit` и, как следствие, никакого кода завершения не указал, с другой стороны, имеется информация о номере сигнала, который стал причиной досрочного завершения процесса. Обычно номер сигнала - целое число от 1 до 31.
* Все варианты аварийного завершения программы вследствие её собственных некорректных действий, таких как нарушение защиты памяти, деление на ноль и тому подобное, представляют собой частный случай завершения по сигналу. 

> Когда процесс, работающий под управлением OS Unix становится причиной возникновения внутреннего прерывания (исключения) и ядро видит, что к этому привели некорректные действия самого процесса, оно отправляет процессу один из сигналов, предусмотренных специально для этих случаев. О том, что же произошло, мы можем узнать по номеру сигнала.

В OC Unix процесс при его завершении не исчезает, а переходит в так называемое состояние **зомби-процесса**.

### Ожидание завершения, процессы зомби
Информация о обстоятельствах завершения процесса запрашивается родительским процессом, если его нет, то функции родительского процесса берет на себя `init` (процесс номер 1), при этом даже `ppid` для "осиротевшего" процесса становится равным 1. Никто эту информацию больше получить не может.

> Завершенный процесс продолжает существовать в системе в виде процесса-зомби, то есть занимает место в таблице процессов до тех пор, пока находящаяся в нем информация об обстоятельствах завершения не будет затребована родительским процессом.

Убрать зомби процесс из системы позволяют системные вызовы семейства `wait`, например:
```
int wait(int *status);
```
Если у процесса нет ни одного непосредственного потомка, вызов возвращает код ошибки (-1). Когда порожденные процессы есть, но ни один из них еще не завершился, вызов ждем завершения любого из порожденных процессов. `wait` изымает из процесса-зомби хранящуюся в нем информацию об обстоятельствах завершения процесса, а сам зомби окончательно отправляет в небытие, освобождая слот таблицы процессов. Вызов возвращает `pid` завершившегося процесса. Если параметр представлял собой ненулевой указатель, то в целочисленную переменную, на которую он указывал, записывается информация о коде завершения процесса или о номере сигнала, по которому процесс будет снят. 

Для анализа информации, занесенной в такую переменную, используются макросы `WIFEXITED`, `WIFSIGNALED` (был ли процесс завершен обычным способом или по сигналу), `WEXITSTATUS` (если завершен обычным образом, то каков код завершения), `WTERMSIG` (если по сигналу, то каков номер сигнала). Например:
```
int status, wr;
wr = wait(&status);
if(wr == -1) {
  printf("There are no child processes at all\n");
} else {
  printf("Process with pid=%d finished.\n", wr);
  if(WIFEXITED(status)) {
    printf("It has exited with code=%d.\n", WEXITSTATUS(status));
  } else {
    printf("It was killed by signal %d.\n", WTERMSIG(status));
  }
}
```

Более гибкие возможности предоставляет системный вызов `wait4` - `int wait4(int pid, int *status, int opt, struct rusage *usage);`. 
* В качестве первого параметра вызова можно указать идентификатор конкретного процесса, либо -1, если требуется дождаться любого из порожденных процессов. Нулевое значение параметра `pid` соответствует ожиданию любого из непосредственных потомков, оставшихся в одной группе с родительским процессом, тогда как значение меньшее -1, означает ожидание завершения процесса из группы с заданным номером (например -2732 означает группу 2732). 
* Параметр `status` используется как передатчик адреса переменной типа `int`, в которую вызов записывает основную информацию об обстоятельствах завершения процесса. 
* В качестве значения параметра `opt` можно указать число 0 или константу `WHOHANG`, в этом случае вызов не ждет завершения процессов (если зомби нет, то возвращает 0). 
* В `usage` если он не нулевой, записывается значения счетчиков ресурсов завершившегося процесса. `wait4` возвращается -1 в случае ошибки, 0 в случае, если использовалась опция `WHOHANG` и завершившихся процессов не было, и `pid` завершившегося процесса, если вызов успешно получил информацию от зомби.

> При наличии нескольких потомков ждать какого-то одного из них рискованно - остальные могут завершится раньше, перейти в статус зомби, но убирать их будет некому.

В OS Unix предусмотрены системные вызовы `waitpid` и `wait3`:
```
int wait3(int *status, int opt, struct rusage *usage);
int waitpid(int pid, int *status, int opt);
```

Убрать зомби из системы может только тот процесс, который его породил. Или можно убрать родителя, тогда уберется дочерний процесс.

### Пример запуска внешней программы
Программа сначала запустит на выполнение команду `ls` с параметрами `-l -a /var`, а затем, дождавшись её завершения, выдаст сообщение `Ok`:
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
  int pid;
  pid = fork();
  if(pid == -1) { // ошибка порождения процесса
    perror("fork");
    exit(1);
  }
  if (pid == 0) {   // порожденный процесс
    execlp("ls", "ls", "-l", "-a", "/var", NULL);
    perror("ls"); // exec вернул управление -> ошибка
    exit(1); // завершаем процесс с кодом неуспеха
  }
  // родительский процесс
  wait(NULL); // дожидаемся завершения порожденного процесса, заодно убираем зомби
  printf("Ok\n");
  return 0;
}
```

### Выполнение процессов и время
Ядро операционной системы хранит текущее время и поддерживает **системные часы**. Узнать текущее системное время можно с помощью системного вызова `time`:
```
time_t time(time_t *t);
```
Возвращает текущее время в виде количества секунд, прошедших с начала 1 января 1970 года, по Гринвичу. То же число вызов записывает в переменную типа `time_t`. В большинстве случаев его оставляют нулевым и используют значение, возвращаемое `time` как функцией. `time_t` это в большинстве случаев обыкновенный `long`. Если описывать переменную, чтобы её адрес передать парамтром вызову `time`, лучше описать её как имеющую тип `time_t`.

Разложение на составляющие - год, месяц, часы, минуты, секунды:
```
struct tm *gmtime(const time_t *timep);
struct tm *gmtime(const time_t *timep, struct tm *result);
struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
```
Результат представляется в виде стркутры `struct tm`, имеющей следующие поля:
* `tm_year`
* `tm_mon`
* `tm_mday`
* `tm_hour`
* `tm_min`
* `tm_sec`
* `tm_wday`
* `tm_yday`
* `tm_isdst`.

Функции `gmtime` / `gmtime_r` возвращают результат для Гринвича, `localtime`/`localtime_r` - для часового пояса, установленного в настройках системы.

Функции, создающие текстовое представление заданной даты и времени:
```
char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);
char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);
```

> Функии с суффикосм `_r` используют для сохранения результата области памяти, тогда как функции без суффикса возвращают указатель на принадлежащую им структуру данных.

Если требуется представление, отличное от функций `gmtime`/`localtime`, о воспользоваться можно `strftime`:
```
int strftime(char *s, int max, const char *format, const struct tm *tm);
```

Узнать текущее время с большей точностью позволяет системный вызов `gettimeofday` - `int gettimeofday(struct timeval *tv, struct timezone *tz);`. Структура `timeval` состоит из двух полей: `tv_sec` для целого числа секунд и `tv_usec` для микросекунд. Чтобы узнать текущее время, мы должны в программе описать переменную типа `struct timeval` и передать её адрес первым аргументом в вызов `gettimeofday`. 

> Про второй аргумент в документации прямо сказано, что его использование нежелательно и будет лучше, если там указать `NULL`.

Функция (не системный вызов), отправляющая спать процесс - `int sleep(unsigned int seconds);`. Если процесс благополучно "проспал", функция вернет 0, но в некоторых случах (при доставке процессу обрабатываемого сигнала) функция `sleep` может завершиться досрочно, при этом она вернет положительное целое число, равное количеству секунд, которые её оставалось проспать, когда её прервали.

Функция `usleep` принимает в качестве параметра число микросекунд:
```
int usleep(long usec);
```

Наиболее универсальная функция сна - `int nanosleep(const struct timespec *req, struct timespec *rem);`. Первый параметр - нужный отрезок времени, второй параметр - адрес структуры того же типа, в который `nanosleep` запишет, сколько времени осталось до изначально заданного момента пробуждения, если ей не дали проспать сколько было указано. Структура `timespec` состоит из полей:
* `tv_sec`
* `tv_nsec`

> В современных системах как раз происходит прерывание таймера 1000 раз в секунду.

Ядро `Linux` использует в качестве приоритета число от -20(наивысший приоритет) до 19(самый низкий приоритет). По умолчанию все процессы в системе выполняются с приоритетом 0.

Процесс может понизить свой собственный приоритет с помощью системного вызова `nice` - `int nice(int inc);`. Параметром передается небольшое целое число, которое прибавляется к текущему значению статического приоритета, тем самым понижаю приоритет процесса.

Вызов `nice()` возвращает новое значение приортета, так что, например, процесс может узнать свой текущий приоритет, выполнив `nice(0)`.

Процессы, имеющие полномочия системного администратора могут, указывать отрицательно значение параметра при вызове `nice`, тем самым увеличивая свой приортет в системе.

> В случае ошибки `nice` возвращает, как и другие системные вызовы, значение -1, но то же самое значение вызов может вернуть, если новый приоритет стал равен -1. В документации говорится, чтобы отличить эту ситуацию от ошибочной, необходимо заранее присвоить значение 0 переменной `errno`, а после вызова проверить, поменялось ли оно. Впрочем, единственная ошибка, возвращаемая вызовом `nice` - это `EPERM`, происходит она в одном случае, если указано отрицательное значение параметра, а процесс не имеет полномочий суперпользователя.

Значение приоритета наследуется при создании нового процесса вызовом `fork` и не меняется при вызове `execve`.

Вызовы `getpriority` и `setpriority` позволяют манипулировать приоритетом конкретного процесса, группы процессов, либо всех процессов, принадлежащих пользователю:
```
int getpriority(int which, int who); // возвращает текущее значение приоритета заданных процессов 
// если много процессов, то возвращается с самым высоки приоритетом
int setpriority(int which, int who, int prio); // устанавливает заданное значение приоритета параметром `prio`
```

Параметр `which` задает способ, которым идентифицируются нужные процессы:
* `PROP_PROCESS` означает что будет задан номер (`pid`) конкретного процесса
* `PRIO_USER` предполагает, что речь пойдет о всех процессах, принадлежащих пользователю
* `PRIO_PGRP` позволяет задать группу процессов.
Значение `who` зависит от того, какой из вариантов мы избрали в первом параметре, и равняется соответственно `pid` нужного процесса, `uid` пользователя или идентификатору `pgidy` группы процессов.


### Перенаправление потоков ввода-вывода
Библиотечные функции считают потоки 0, 1 и 2 стандартными, что бы ни было под этими номерами открыто.

Для манипуляций с таблицей файловых дескрипторов используют специально предназначенные для этого системные вызовы `dup` и `dup2`:
* `int dup(int fd);` - создает новый файловый дескриптор, связанный с тем же самым потоком ввода-вывода, что и `fd`. Нового потока ввода-вывода не создается, оба дескриптора оказываются связаны с одним и тем же объектом ядра, реализующим поток ввода-вывода.
* `int dup2(int fd, int new_fd);` - новый дескриптор создается под заданным номером. Если на момент выполнения вызова у процесса был поток ввода-вывода, связанный с дескриптором `new_fd`, то есть этот дескриптор был открыт, он закрывается.

Пример программы вывода в файл:
```
int save1, fd;
fflush(stdout); // очищаем буфер стандартного вывода
save1 = dup(1); // сохраняем стандартный вывод
int fd = open("file.dat", O_CREAT|O_WRONLY|O_TRUNC, 0666); // открываем файл
if(fd == -1) // обработка ошибки
  dup2(fd, 1);  // сделали открытый файл стандартным потоком вывода

close(fd) // закрыли лишний дескриптор
// производим действия с нашей библитекой, все вызовы работающие со стандартным выводом, будут выводить информацию в наш файл  
dup2(save1, 1);  // восстановили старый стандартный поток вывода, файл при этом закрылся автоматически
close(save1); // лишняя копия не нужна
```

Допустим у нас возникла потребность в программе на Си смоделировать функционирование команды:
```
ls -l -a -R / > flist
```
т.е. сгенерировать возможности программы `ls`, сгенерировать файл `flist`, содержащий список всех файлов в системе с расширенной  информацией по каждому из них:
```
int pid, status;
pid = fork();
if(pid == 0) {
  int fd = open("flist", O_CREAT|O_WRONLY|O_TRUNC, 0666);
  if(fd == -1) {
    perror("flist");
    exit(1);
  }
  dup2(fd, 1);
  close(fd);
  execlp("ls", "ls", "-l", "-a", "-R", "/", NULL);
  perror("ls");
  exit(1);
}
// родительский процесс
wait(&status)
if(!WIFEXITED(status) || WEXITSTATIS(status)!=0) {
  // обработка ошибки
}
```
Пример с `open` в родительском процессе:
```
int pid, status, fd;
int fd = open("flist", O_CREAT|O_WRONLY|O_TRUNC, 0666);
if(fd == -1) {
  perror("flist");
  exit(1);
}
pid = fork();
if(pid == -1)  { // обработка ошибки } 
if(pid == 0) { // порожденный процесс
  dup2(fd, 1);
  close(fd);
  execlp("ls", "ls", "-l", "-a", "-R", "/", NULL);
  perror("ls");
  exit(1);
}
// родительский процесс
close(fd); // про это важно не забыть
wait(&status);
```

> Сдублировать дескриптор можно с помощью `fcntl`, используя команду `F_DUPFD`. В этом случае третий параметр `long`, задающий наименьший желаемый номер дублирующего дескриптора. Так, два следующие вызова эквивалентны:
```
nfd = dup(fd);
nfd = fcntl(fd, F_DUPFD, 0);
```

### Полномочия процесса
Процессу в системе приписываются:
* настоящие `uid`, `gid`, соответствующие идентификаторам пользователя, запустившего процесс.
* эффективные или действующие `euid`, `egid`, которые используются для проверки полномочий процесса
* сохраненные идентификаторы (saved set-user-Id, saved set-group-ID)
* массив дополнительных идентификаторов групп (supplementary groupd Ids)

> Во многих системах этим дело не ограничивается, так в ОС Linux процесс имеет отдельные файловые идентификаторы `fsuid`, `fsgid`, в большинстве случаев равные эффективным, но допускающие отдельную установку. Кроме того ядро Linux поддерживает механизм `capabilities`, позволяющий разрешать или запрещать процессам определенные привилегированные действия независимо от наличия или отсутствия у них суперпользовательских полномочий.

При старте системы ядро запускает процесс с номер 1 (обычно это программа `/bin/init`). Все шесть идентификаторов для этого процесса равны нулю.

> Процесс может менять свой `euid` туда-сюда между настоящим и сохранненым значениями, то есть (для случая выполняющейся SUID программы) при необходимости часть работы выполнять с правами владельца программы, а часть с правами пользователя, запустившего программу.

Например пользователь Вася с входным именем `vasya` `uid 1003` создал в системе исполняемый файл `vasyaprog` и поставил на него атрибут `SetUid`, а пользователь Петя с входным именем `petya` и `uid 1012` этот файл запустил. В этом случае программа `vasyaprog` сразу после запуска обнаружит, что её настоящий `uid` равен `1012` (это отражает тот факт, что запустил её Петя), тогда как эффективный и сохраненный `uid` оба равны `1003` - это результат действия атрибута `SetUid`.

Процесс может узнать свои настоящие и эффективные идентификаторы с помощью системных вызовов:
```
int getuid();
int geteuid();
int getgid();
int getegid();
```

> На самом деле тип возвращаемого значения этих системных вызовов - не `int`, `uid_t` и `gid_t`, в современных версиях того же Linux эти типы определены как `unsigned int`.

Вызовы, позволяющие запросить у ядра сразу все три идентификатора пользователя или группы:
```
getresuid;
getresgid;
getgroups;
```
Узнать свои идентификаторы дополнительных групп - `int getgroups(int size, gid_t *arr);`. Первым параметром можно передать ноль, в этому случае второй параметр игнорируется, а вызов возвращает количество дополнительных групп. Если места в массиве не хватает, вызов завершается ошибкой, но этого можно избежать, заранее узнав, какой длины должен быть массив. Вы можете применить примерно такой подход:
```
int n;
gid_t *p;
n = getgroups(0, NULL);
p = malloc(n * sizeof(gid_t));
getgroups(n, p);
```
После этого в переменной `n` будет находится общее количество дополнительных групп, а в массиве по адресу `p` - сами идентификаторы этих групп. Спецификация вызова `getgroups` не указывает, будет ли в число групп включена основная группа, т.е. значение вашего `euid`.

Информацию о группах пользователей, права которых даны процессу, можно узнать с помощью комбинации вызовов `getgroups`, `geteuid`.

Для манипуляции полномочиями процесса предусмотрены системные вызовы:
```
int setuid(int uid);
int setgid(int gid);
int seteuid(int euid);
int setegid(int egid);
int setgroups(int size, const gid_t *list);
```

Вызовы `setuid` и `setgid` вопреки своим названиям, тоже меняют прежде всего именно эффективные идентификаторы пользователя и группы, а вовсе не настоящие и меняют их по совершенно тем же правилам, что и `seteuid/setgid`.

### Количественные ограничения
Чтобы получить представление о действующих лимитах, можно воспользоваться командой `ulimit` в командной строке. В частности `ulimit -a` выдаст список всех возможных в данной системе количественных ограничений и их текущие значения.

Установк количественных ограничений - `int setrlimit(int resource, const struct rlimit *rlim);`.
* Структура `rlimit` имеет два поля - `rlim_cur` (мягкий уровень) и `rlim_max` (жесткий уровень). Оба поля имеют целочисленный тип. Для обозначения ситуации отсутствия ограничения используется константа `RLIM_INFINITY`.
* Первый параметр `resource` указывает, какое именно ограничение следует установить:
1. `RLIMIT_AS` - максимальное количество виртуальной памяти для отдельно взятого процесса (в байтах)
2. `RLIMIT_CORE` - максимальный возможный размер core-файла, создаваемого при авариях (в байтах). Если установить нулевой лимит, core файлы создаваться не будут.
3. `RLIMIT_CPU` - максимальное количество процессорного времени, которое может использовать процесс (в секундах). При достижении мягкого лимита, система отправит сигнал `SIGXCPU`, который по умолчанию убивает процесс, но если процесс перехватит или проигнорирует этот сигнал, то система продолжит продолжит посылать процессу сигнал `SIGXCPU` каждую секунд, пока не будет достигнут жесткий лимит, после чего уничтожит процесс сигналом `SIGKILL`, который нельзя ни перехватить, ни проигнорировать. 
4. `RLIMIT_FSIZE` - максимальный размер создаваемых дисковых файлов (в блоках по 512 байт). Если при записи в какой либо файл этот размер окажется превышен, процесс получит сигнал `SIGXFSZ`, если же этот сигнал не убьет процесс, то соответствующий системный вызов (например, `write`) вернет -1, а `errno` получит значение `EFBIG`.
5. `RLIMIT_NOFILE` - предельное количество одновременно открытых потоков ввода-вывода для одного процесса. Процесс не может создавать файловых дескриптор с номером, равным или превосходящим установленный лимит, даже если открытых потоков на этот момент гораздно меньше.
6. `RLIMIT_NPROC` - предельное количество процессов, разрешенных для создания от имени конкретного пользователя

Полный список лимитов - `man 2 setrlimit`.

> `Core` файл - файл с именем `core` или `prog.core`, создаваемый ОС в текущем каталоге при аварийном завершении процесса. В этот файл записывается содержимое сегментов данных и стека на момент аварии. Используется для отладчика.

Узнать текущие значения ограничений - `int getrlimit(int resource, struct rlimit *rlim);`

> Помимо количетсвенных ограничений, также существуют ограничения на использование дискового пространства (квотирование). Интерфейс механизма системный вызов - `quotactl`.

### Базовые средства взаимодейтсвия процессов
1. Локальные 
1.1 Сигналы
1.2 Каналы
1.2.1 Именованные
1.2.2 Неименованные
1.3 `mmap`
1.4 Трассировка
1.5 Виртуальный терминал
1.6 `System V IPC`
1.6.1 Очереди сообщений
1.6.2 Разделяемая память
1.6.3 Семафоры

2. Сетевые
2.1 Сокеты
2.2 ...

> Семейства Unix поддерживают специальный вид сокетов, который можно использовать внутри одной системы, даже если поддержка компьютерных сетей в системе отсутствует.

### Сигналы
* `SIGTERM` - 15 завершение процесса
* `SIGKILL` - 9 уничтожение процесса

> При перезагрузке системы сначала рассылвается `SIGTERM`, а через 5 секунд `SIGKILL`.

* Сигналы `SIGILL`, `SIGSEGV`, `SIGFPE`, `SIGBUS`, отправляют процессам, чьи действия привели к возникновению исключения. По умолчанию любой из этих сигналов учитожает файл и создает `core` файл.

* Сигналы `SIGSTOP` и `SIGCONT` позволяют остановить и продолжить выполнение процесса.

* Сигналы `SIGINT` и `SIGQUIT` отправляются текущей группе процессов данного терминала при нажатии на клавиатуре комбинаций `Ctrl + C` и `Ctrl + \` соответственно. По умолчанию приводят к завершению процесса, причем `SIGQUIT` создает `core` файл.

* Сигнал `SIGCHLD` система присылает родительскому процессу при завершении его непосредственного потомка.

* `SIGALARM` - присылается по истечении заданного интервала времени после вызова `alarm`. Т.о. процесс может взвести для себя напоминание. По умолчанию приводит к завершению процесса.

* `SIGUSR1`, `SIGUSR2` предназначены для использования программистом для своих целей. По умолчанию завершают процесс.

> Все названия сигналов, такие как `SIGKILL` или `SIGCHLD` представляют собой целочисленные константы, описанные в библиотечных заголовочных файлах и соответствующие номерам сигналов, например `SIGKILL` вводится так:
```
#define SIGKILL 9
```
> В своих программах такого писать не нужно.

Для отправки сигнала служит системный вызов `kill` - `int kill(int target_pid, int sig_no);`. 
* Параметр `sig_no` задает номер сигнала, который следует отправить. Для лучше ясности программы вместо целого числа пишутся целочисленные константы (`SIGKILL`, `SIGUSR1`).
* Параметр `target_pid` задает процесс(ы), которому(которым) следует отправить сигнал. Если использовать -1, то сигнал будет послан всем процессам, кроме самого вызвавшего `kill`, а также процесса №1 (`init`). Отрицательное число, большее единицы по модулю, означает передачу сигнала группе процессов с соответствующим номером. Ноль - означает передачу сигнала всем процессам своей группы.

> Процессы с администраторскими полномочиями, могут отправлять сигналы любым процессам. Все прочие процессы имеют право отправлять сигналы только процессам, принадлежащим тому же пользователю. Как следствие, непривилегированного процесса вызов `kill(-1, SIGTERM)` означает отправку сигнала `SIGTERM` всем процессам того же пользователя, кроме себя самого.

Процесс может для любого сигнала, кроме `SIGKILL` и `SIGSTOP`, установить свой режим обработки: вызов функции-обработчика, игнорирование или обработка по умолчанию. Говорят, что процесс может установить **диспозицию сигнала**.

Функция обработчик должна принимать один целочисленный параметр и иметь тип возвращаемого значения `void`, т.е. это должна быть функция вида:
```
void handler(int s)
{
  /*...*/
}
```

Для изменения диспозиции сигнала в том числе для установки обработчика, можно использовать системный вызов `signal`:
```
typedef void (*sighandler_t)(int);
sighandler_t signal(int signo, sighandler_t hdl);
```
* Параметр `signo` - задает номер сигнала
* Параметр `hdl` - новую диспозицию для этого сигнала, это может быть адрес функции обработчика, которая должна быть вызвана при получении соответствующего, также можно использовать специальные значения диспозиции `SIG_IGN` (игнорировать сигнал) и `SIG_DFL` (вернуть диспозицию по умолчанию). 
* Вызов `signal` возвращает значение, соответствующее предыдущей диспозиции данного сигнала, либо специальное значение `SIG_ERR` в случае ошибки. 

> `SIG_ERR` представляет собой число -1, преобразованное к типу `sighandler_t`. 

> Установка функции обработчика сигнала не приводит к вызову этой функции.

Когда процесс получает сигнал, для которого в качестве диспозиции назначена функция обработчик, эта функция вызывается асинхроноо по отношению к выполнению остального процесса, то есть, попросту говоря, в самый неожиданный момент. 

> Дальнейшее поведение процесса после получения первого экземпляра обрабатываемого сигнала зависит от версии ОС (а иногда, от версии системных библиотек).

Обращение к ядру производится через системный вызов - `sigaction` (аналог `signal`)

> Чтобы написанная программа вела себя более менее одинаково при любом из двух вариантов семантики вызова `signal`, следует переустанавливать режим обработки каждый раз в начале функции-обработчика, либо, наоборот, сбрасывать режим обработки в `SIG_DFL`, если требуется перехватить только один сигнал.

Функция обработчик не вызывается из основной программы и не возвращает ей управление. В определенном смысле можно сказать, что её вызывает ядро ОС. Не имея возможности передать информацию обработчику через параметры и получить информацию от неё через возвращаемое значение, основная программа вынуждена взаимодействовать с функцией-обработчиком через глобальные переменные, ведь других способов связи с ней не остается.

> Язык Си предусматривает ключевое слово `volatile` для пометки переменных, значение которых может "неожиданно" изменится.

Современные спецификации системы сигналов предлагают программисту воспользоваться специальным типом `sig_atomic_t` (обычно это синоним `int`, введенный с помощью `typedef`), гарантируя, что обращение к такой переменной проходит атомарно, то есть за одно неделимое действие - одну машинную команду. Кроме того, переменную, которую будет менять обработчик сигнала, предлагается обязательно помечать словом `volatile`.

> Если процесс выполнил системный вызов, который перевел его в состояние блокировки, то при получении процессом обрабатываемого сигнала такой системный вызов немедленно вернет управление (-1). Отличить эту ситуацию от настоящих ошибок можно по значению переменной `errno` - она будет равна константе `EINTR`

Если процесс находился в состоянии выполнения в ядре, то вернутся обратно в ядро он может по своей инициативе.

> Если в своей программе вы обрабатываете сигналы, для каждого блокирующего системного вызова будьте готовы к тому, что он завершится с ошибкой `EINTR`, но при этом не полагайтесь на то, что так обязательно произойдет.

Пример программы, которая при нажатии `Ctrl+C` сначала выдает сообщение и лишь на 25 раз завершается:
```
#include <stdio.h>
#include <signal.h>
int n = 0;
void handler(int s)
{
  n++;
  printf("Press it again, I like it\n");
}
int main()
{
  signal(SIGINT, handler);
  while(n < 25)
    ;
  return 0;
}

// правильный вариант
/* pressagain.c */
#include <signal.h>
#include <unistd.h>
#include <errno.h>
volatile statis sig_atomic_t n = 0;
const char message[] = "Press it again, I like it\n";
void handler(int s)
{
  int save_errno = errno;
  signal(SIGINT, handler);
  n++;
  write(1, message, sizeof(message)-1);
  errno = save_errno;
}
int main()
{
  signal(SIGINT, handler);
  while(n < 25)
    // при получении процессом обрабатываемого сигнала `sleep` всегда возвращает управление, так что, сразу после обработки сигнала произойдет очередная проверка условия `while`.
    sleep(1); // или pause()
  return 0;
}
```

* Системный вызов `pause` блокирует процесс до тех пор, пока не будет получен обрабатываемый сигнал. Единственно возможное возвращаемое значение = -1, при этом в `errno` заносится значение `EINTR`.

* С помощью вызова `alarm` можно затребовать от ядра отправки вызвавшему процессу сигнала `SIGALRM` через определенное количество секунд времени:
```
int alarm(usigned int seconds);
```
Возвращаемое значение зависит есть ли уже активный заказ на отправку `SIGALRM`. Если нет, вызов возвращает ноль. Если есть, то возвращает количество секунд (не менее 1), оставшееся до момента его исполнения.

> Система может помнить только об одном заказанном сигнале `SIGALRM` для каждого процесса, иначе говоря, текущее значение "заказа" представляет собой свойство процесса. Если по результатам предыдущего вызова сигнал процессу еще не прислали, новый вызов отменит старый заказ и установит новый. Нулево значение параметра `seconds` отменит активный заказ, не установив новый.

По умолчанию сигнал `SIGALRM` убивает процесс, так что в большинстве случаев нужно сначала изменить диспозицию `SIGALRM`, установив функцию-обработчик, и лишь после этого обращаться к вызову `alarm`.

> При использовании сигналов часто возникают ситуации гонок, сами сигналы ненадежны, при отправке двух одинаковых сигналов прийти может только один и т.д.

### Каналы
Канал - это объект ядра ОС, представляющий собой средство однонаправленной передачи данных от одного процесса другому.

Для работы с именованными каналами в файловой системе создаются файлы специального типа, открытие которых с помощью вызова `open` приводит к подключению к каналу. Сам канал как объект ядра создается в тот момент, когда какой-то из процессов пытается открыть на запись или чтение файл именованного канала, который пока не открыт ни в каком другом процессе.

В противоположность этому, неименованные каналы сразу создаются открытыми с обоих концов. При этом ни с какими файлами они не связаны, так что подключиться к уже созданному неименованному каналу невозможно.

Неименованный канал создается системным вызовом `pipe` - `int pipe(int fd[2]);`. На вход подается адрес массива из двух элементов типа `int`, в этот массив вызов `pipe` записывает дескрипторы, связанные с созданным каналом: `fd[0]` - для чтения, `fd[1]` - для записи.

> Неименованный канал для взаимодействия между собой могут использовать только родственные процессы, (потомки).

Пример программы, первый потомок может передавать второму данные через канал. Соответствующий код на языке Си будет выглядеть так:
```
int fd[2];
int p1, p2;
pipe(fd);
p1 = fork();
if(p1 == 0) { /* child #1 */
  close(fd[0]);
  /*...*/
  write(fd[1], /*...*/);
  /*...*/
  exit(0);
}
p2 = fork();
if(p2 == 0) { /* child #2 */
  close(fd[1]);
  /*...*/
  rc = read(fd[0], /*...*/);
  /*...*/
  exit(0);
}
/* parent */
close(fd[0]);
close(fd[1]);
/*...*/
```
> Если оказались закрыты все дескрипторы, через которые можно было записать данные в канал, операции чтения (`read`) сначала опустошат внутренний буфер канала, а затем будут возвращать 0, сигнализируя о наступлении ситуации "конец файла".

> Если, наоборот, оказались закрыты все дескрипторы, через которые можно было из канала читать, то первая же попытка записи в канал приведет к тому, что попытавшийся осуществить запись процесс получит сигнал `SIGPIPE`. По умолчанию этот сигнал завершает процесс. Вызов `write` при этом возвращает -1, что может быть обнаружено только если процесс перехватывает или игнорирует сигнал `SIGPIPE`.

Наиболее активно неименованные каналы используются для реализации **конвейеров** - групп программ, которые запускаются на одновременное выполнение, причем информация, выдаваемая первой программой на стандартный вывод, поступает второй программе на стандартный ввод, вывод второй программы - ввод третьей и т.д.

Пример программы конвеера `ls -lR | grep '^d'` на Си:
```
int main()
  int fd[2];
  pipe(fd);     // создаем канал для связи
  if(fork()==0) { // процесс для выполнения ls -lR
    close(fd[0]); // читать из канала не нужно 
    dup2(fd[1], 1); // стандартный вывод в канал
    close(fd[1]);  // fd[1] больше не нужен
    execlp("ls", "ls", "-lR", NULL); // запускаем ls -lR
    perror("ls"); // не получилось, сообщаем об ошибке
    exit(1);
  } 
  if(fork()==0) { // процесс для выполения grep
    close(fd[1]);  // писать в канал не нужно
    dup2(fd[0], 0); // стандартный ввод - из канала
    close(fd[0]); // fd[0] больше не нужен
    execlp("grep", "grep", "^d", NULL); // запускаем grep
    perror("grep"); // не получилось сообщаем об ошибке
    exit(1);
  }
  // в родительском процессе закрываем оба конца канала
  close(fd[0]);
  close(fd[1]);
  wait(NULL); // дожидаемся завершения потомков
  wait(NULL);
  return 0;
```

> Именованные каналы подобны неименованным, с той разницей, что именованному каналу соовтествтует резмещаемый в файловой системе файл специального типа, этот тип так и называется `FIFO`.

Для создания файла типа `FIFO` используется функция `mkfifo` - `int mkfifo(const char *name, int permissions);`. При создании файла `FIFO` система не создает сам объект канала в ядре. Это происходит только тогда, когда какой нибудь процесс открывает файл `FIFO` с помощью вызова `open` на чтение или запись. От того, в каком режиме (`O_RDONLY` или `O_WRONLY`) процесс попытается открыть файл типа `FIFO`, зависит, к какому концу канала будет присоединен полученный файловый дескриптор.

> Уничтожение канала не означает уничтожение файла `FIFO`, после закрытия всех дескрипторов файл останется на месте и может быть снова открыт каким нибудь процессом, после чего в ядре системы снова появится объект канала.

Вызов `open`, примененный к одному концу канала, не возвращает управление до тех пор, пока кто то не откроет второй конец. Это можно изменить добавив второй параметр в `open` флаг `O_NONBLOCK`. Но попытка неблокирующего открытия на запись может привести к неудаче, если канал никем не открыт на чтение, то вызов `open`, выполенный с флагами `O_WRONLY|O_NONBLOCK` вернет -1, а в переменную `errno` будет записан флаг `ENXIO`.

### Краткие сведения о трассировке

  
    
