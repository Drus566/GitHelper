### Границы зоны ответственности ОС
Задачи, покрываемые ОС:
* Управление пользовательскими задачами:
1. Запуска и останов процессов
2. Планирование времени центрального процессора
3. Распределение оперативной памяти
4. Разграничение полномочий
* Управление внешними устройствами
1. Абстрагирование от особенностей устройств разных моделей
2. Координация доступа нескольких задач к одному устройству

### О системе X Window
Запуск `X Window` - `X :1`. Чтобы запустить программу необходимо нажать Ctrl-Alt-F1, далее ctrl+z  и командой `bg` убрать работающую программу `X` в фоновый режим.
Запуск прикладной программы - `DISPLAY=:1.0 xterm`.
Вернутся к Х-серверу. Alt-F7, Alt-F8.

В системе X Window за стандартные элементы оконного интерфейса отвечают специальные программы, называемые оконными менеджерами.

### Каталоги
**Каталог** - особый тип файла, хранящий имена файлов, среди которых, возможно, тоже есть каталоги

Каждая запись в каталоге состоит из двух полей - **имя файла и номер индексного дескриптора**.

Хранимая на внешнем запоминающем устройстве (диске) структура данных, содержащая всю информацию о файле, включая его имя, называется **индексным дескриптором**.

Имя файла в ОС Unix не является ни в каком виде частью или принадлежностью самого файла.

Записи в каталогах ссылающиеся на тот же самый индексный дескриптор - **жесткие ссылки**.

В индексном дескрипторе содержится счетчик количества ссылок на данный дескриптор.

В ОС Unix не предусмотрено функций удаления файла, вместо этого имеется системный вызов, удаляющий ссылку, который называется `unlink`. 

Сам файл удаляется, только если удаленная ссылка была последней (счетчик обратился в нуль) и при этом файл не был ни одним из процессов открыт на запись или чтение.

Система запрещает создание жестких ссылок на каталоги, удаление каталогов происходит с помощью команды `rmdir`.

Для создания жесткой ссылки средствами командной строки можно воспользоваться командой - `ln`.

**Символическая ссылка** (symbolic link) представляет собой файл специального типа, содержащий имя другого файла. Операция открытия символической ссылки на чтение или запись приводит к открытию файла, на который она ссылается, а не её самой. Будучи файлом, символическая ссылка имеет свой номер индексного дескриптора. Создание и удаление символической ссылки никак не затрагивает ни файл, на который она ссылается, ни его индексный дескриптор. Более того файл, на который указывает ссылка, может вообще не существовать в момент её создания, а также может быть удален позднее, что никак не повлияет на ссылку. 

> Символическая ссылка, содержащая имя несуществующего файла, называется **висячей**. Символические ссылки не ограничены рамками одного диска, поскольку реализуются через хранение имен, а дерево имен, как мы знаем, в ОС Unix общее для всех имеющихся в системе дисковых устройств.

Для создания символической ссылки средствами командной строки следует использовать уже знакомую нам команду `ln`, указав её флаг `-s`:
```
ln -s /path/to/old/name new_name
```
### Права доступа к файлам
Скриптовый файл должен начинатся со строки `#!bin/sh`, означает что для исполнения этого файла нужно запустить программу `/bin/sh` (командный интерпретатор) и передать ему имя файла скрипта через аргумент командной строки. Подойдет любой интерпретатор, знающий что его будут вызывать (`Perl`, `Scheme`, `Prolog`). Нужно перед этим навесить на скриптовый файл бит исполнения.

> Биты `SetUid` и `SetGid` для скриптов не работают

`Sticky bit` в директории дает право удалять только свои собственные файлы.

> Обычно для создания общественной директории применяются права 01777 - всем разрешается все, но при этом взведенный `Sticky bit` не позволит удалять чужие файлы.

`SetGid bit` установленный на директорию, приводит к тому, что для файлов, создаваемых в такой директории, в качестве группы пользователей принудительно устанавливается та же группа, что и для самой директории.

`ls -l` - показать права доступа, системный вызов - `stat`

Измнение прав доступа - `chmod` - системный вызов - `chmod`

Смена владельца и группы для файла - `chown`, `chgrp`, системный вызов - `chown`

### Чтение и запись содержимого файлов
Основные системные вызовы для работы с потоками ввода-вывода:
* `int open(const char *name, int mode);`
* `int open(const char *name, int mode, int perms);`

Чтение из потока ввода и запись в поток вывода происходит с помощью сис. вызовов:
* `int read(int fd, void *mem, int len);`
* `int write(int fd, const void *data, int len)`

Закрытие файла - `int close(int fd)`, даже если произошла ошибка дескриптор никогда не остается открытым.

Изменение текущей позиции в файле - `int lseek(int fd, int offset, int whence);`. Возвращает новое значение текущей позиции, считая от начала, `lseek(fd, 0, SEEK_END)` вернет длину файла, а текущей позицией станет его конец.

В большинстве случаев операции записи выполняются системой в так называемом асинхронном режиме вывода.

В явном виде дожидается завершение операции записи при асинхронном режиме - `int fsync(int fd);`. Вызов сообщает ОС, что все данные, связанные с файлом, должны быть как можно скорее физически записаны на диск. Точнее должна быть как можно скорее выполнена физическая операция записи.

`fdatasync` - аналог `fsync` но гарантирующий запись на диск только той информации, которая необходима для последующего корректного прочтениях данных.

`sync` - сообщает системе, о необходимости немедленно физически записать всю информацию, которая пока что содержится только в памяти системы, но предназначена для записи на диск. Речь идет о всей информации для всех дисковых файлов для всех пользователей системы.

Гибкая настройка поведения дескрипторов. Доступ практически ко всем возможностям такой настройки предоставляет системный вызов `fcntl` - `int fcntl(int fd, int cmd, ...);`. Первый параметр - номер дескриптора, второй - код команды (определенная целочисленная константа)

Флаги команды `open`: 
1. Флаги режима доступа
* `O_RDONLY`
* `O_WRONLY`
* `O_RDWR`
2. Флаги создания файла:
* `O_CREAT`
* `O_EXCL`
* `O_TRUNC`
* `O_NOCTTY`
3. Флаги статуса (отличаются от всех, их можно менять после начала работы с файлом):
* `O_APPEND`
* `O_NONBLOCK`

Текущее значение флагов статуса для открытого потока можно узнать, выполнив `fcntl` с командой `F_GETFL`, например `flags = fcntl(fd, F_GETFL)`.

Установлен ли конкретный флаг, можно понять с помощью побитового "и":
```
if(flags & O_APPEND) { /* флаг O_APPEND установлен */
/*...*/
```
Изменение текущего статуса с командой `F_SETEL`:
```
flags = fcntl(fd, F_GETEL);
fcntl(fd, F_SETEL, flags | O_NONBLOCK);
```

### Управление объектами файловой системы
Создание жестких ссылок - `int link(const char *oldpath, const char *newpath);`

Удаление ссылки на файл из каталога - `int unlink(const char *name);`. Не позволяет удалять директории

`int rename(const char *oldpath, const char *newpath);` - переименование файла 

Создание и удаление директории:
```
int mkdir(const char *name, int perms);
int rmdir(const char *name);
```

Символические ссылки - `int symlink(const char *oldpath, const char *newpath);`

Удаление символической ссылки - `unlink`

Изменение прав доступа - `int chmod(const char *path, int perms);`. Параметр `umask` на работу `chmod` не влияет.

Изменение владельца файла:
```
int chown(const char *path, int owner, int group);
int lchown(const char *path, int owner, int group);
```
Различие в том, что если их применить к символической ссылке, то `chown` будет работать с файлом, на который эта ссылка ссылается, а `lchown` - с самой ссылкой, хотя в большинстве случаев это бессмысленно. Если в `group` указать -1, то сохранится без изменений.

Подробная информация о файле:
```
int stat(const char *path, struct stat *buf);
int lstat(const char *path, struct stat *buf);
int fstat(int fd, struct stat *buf);
```
Различие заключается в символической ссылке.

Поля структуры хранения информации о файле:
* `st_dev` - идентификатор устройства, на котором находится файл
* `st_ino` - номер индексного дескриптора
* `st_mode` - тип файла и права доступа к файлу. Чтобы вытащить права доступа, необходимо произвести побитовую конъюнкцию значения этого поля с маской 07777 (0x0fff), тем самым выделив из него 12 младших бит.
* `st_nlink` - количество ссылок на файл
* `st_uid` - идентификатор пользователя владельца
* `st_gid` - идентификатор группы пользователей
* `st_rdev` - идентификатор устройства
* `st_size` - размер файла в байтах
* `st_blksize` - размер блока ввода-вывода на даной файловой системе
* `st_blocks` - количество блоков по 512 байт, занятых данным файлом
* `st_atime` -  дата и время последнего доступа к файлу
* `st_mtime` - дата и время последней модификации содержимого файла
* `st_ctime` - дата и время последнего изменения свойств файла

Укорочение файла путем удаления содержимого начиная с указанной позиции - `int trucate(const char *path, int length);`. Второй параметр - новая длинна.

Если файл открыт то то же самое можно сделать этой функцией - `int ftruncate(int fd, int length);`

### Файлы устройств и классификация устройств
В ОС Unix достаточно открыть на чтение специальный файл, соответствующий нужному диску, с помощью вызова `lseek` позиционироваться на нужный сектор и выдать обычный `write`. Именно так происходит форматирование диска, т.е. создание файловой системы.

Устройства, имеющие представление в виде файла, делятся на два типа:
* символьные (или потоковые, они же байт-ориентированные) (терминал, звуковая карта, принтер...). Существует ряд символьных псевдоустройств, не имеющих физического воплощения. Например в устройство `/dev/null` можно записать любую информацию, которая попросту игнорируется. Попытка читать из этого файла приведет к ситуации конец файла. **Не поддерживают** операцию позиционирования.
* блочные (блок-ориентированные) (диски и другие). Поддерживают позиционирование `lseek`

Функция для совершения дополнительных операций, специфических для конкретного устройства - `int ioctl(int fd, int request, ...);`. Второй параметр - код нужной операции. Например:
```
int fd = open("/dev/cdrom", O_RDONLY|O_NONBLOCK);
ioctl(fd, CDROMEJECT);
ioctl(fd, CDROMCLOSETRAY);
```
открывает и закрывает лоток привода CD-ROM. Параметр `O_NONBLOCK` задается, чтобы избежать поиска диска в устройстве и ошибки в случае, если диск в устройство не вставлен. Если же вставить в то же устройство музыкальный диск (audio CD), код:
```
struct cdrom_ti cti;
cti.cdti_trk0 = 2;
cti.cdti_ind0 = 0;
cdi.cdti_trk1 = 2;
cti.cdti_ink1 = 0;
ioctl(fd, CDROMPLAYTRAKIND, &cti);
```
заставит устройство воспроизвести вторую дорожку диска.

### Работа с содержимым каталогов
Система позволяет открывать каталоги на чтение с помощью вызова `open`.

Библиотека Си предусматирвает для анализа содержимого каталогов функции - `opendir`, `readdir`, `closedir`:
```
DIR *opendir(const char *name);
struct dirent *readdir(DIR *dirp);
int closedir(DIR *dirp);
```

### Отображение файлов в память
Отображение содержимого некоторого файла в виртуальное адресное пространство процесса - `mmap`:
```
void *mmap(void *start, int length, int protection, int flags, int fd, int offset);
```
Перед обращением файл должен быть открыт с помощью `open`. Параметры `mmap`:
* Параметры  `offset` и `length` задают позицию начала отображаемого участка в файле и его длинну. 
* `protection` задает режим доступа к памяти (`PROT_READ`, `PROT_WRITE`, `PROT_EXEC`, `PROT_NONE`). 
* Параметр `flags` указвают либо `MAP_SHARED`, либо `MAP_PRIVATE`  (изменения в виртуальном файле не отразятся) и дополнительный флаг через `|` - `MAP_ANONYMOUS` - позволяет обойтись без файла.
* `start` - в каком месте адресного пространства хотелось бы видеть новую область памяти. Если передать `NULL`, система выберет свободную память виртуального пространства.

`mmap` возвращает указатель на созданную область виртуальной памяти. В случае ошибки возвращает -1 (`MAP_FAILED`).

Память, выделяемая с помощью `mmap` с одновременным указанием `MAP_ANONYMOUS` и `MAP_SHARED` отличается от обычной тем, что при создании нового процесса она становится доступна из обоих процессов, то есть изменения, сделанные в такой памяти порожденным процессом, будут доступны родительскому и наоборот. Это называется **разделяемой памятью**. Она используется для взаимодействия между процессами.

Длина и позиция `mmap` должны быть кратны некоторому предопределенному числу, называемому размером страницы.

Размер страницы - `int getpagesize();`

Пример `mmap`:
```
int fd, pgs;
char *p;
int size = 4096;
pgs = getpagesize();
size = ((size - 1) / pgs + 1) * pgs;
/* Минимальное целое число, большее либо равное
  исходному и при этом кратное размеру страницы */
fd = open("file.dat", O_RDWR);
if(fd == -1) {
  /* Обработка ошибки */
}
p = mmap(NULL, size, PROT_HEAD|PROT_WRITE, MAP_SHARED, fd, 0);  
if(p == MAP_FAILED) {
  /* обработка ошибки */
}
```
После выполнения выражение `p[25]` будет равно значению 26-го байта в файле "file.dat", причем операция присваивания `p[25] = 'a'`, занесет в этот байт символ `'a'`.

Отмена отображения `mmap` - `int munmap(void *start, int length);`

> Вызов `mmap`, изначально предназначавшийся для работы с содержимым дисковых файлов, в наше время воспринимается как универсальный интерфейс для создания областей виртуальной памяти. Например:
```
p = mmap(NULL, size, PROT_HEAD|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);
```
указатель `p` содержит адрес новой области виртуальной памяти, полученной от ОС.

### Процессы
Процесс - некая сущность, создаваемая ОС для выполнения пользовательской программы.
