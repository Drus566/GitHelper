### Границы зоны ответственности ОС
Задачи, покрываемые ОС:
* Управление пользовательскими задачами:
1. Запуска и останов процессов
2. Планирование времени центрального процессора
3. Распределение оперативной памяти
4. Разграничение полномочий
* Управление внешними устройствами
1. Абстрагирование от особенностей устройств разных моделей
2. Координация доступа нескольких задач к одному устройству

### О системе X Window
Запуск `X Window` - `X :1`. Чтобы запустить программу необходимо нажать Ctrl-Alt-F1, далее ctrl+z  и командой `bg` убрать работающую программу `X` в фоновый режим.
Запуск прикладной программы - `DISPLAY=:1.0 xterm`.
Вернутся к Х-серверу. Alt-F7, Alt-F8.

В системе X Window за стандартные элементы оконного интерфейса отвечают специальные программы, называемые оконными менеджерами.

### Каталоги
**Каталог** - особый тип файла, хранящий имена файлов, среди которых, возможно, тоже есть каталоги

Каждая запись в каталоге состоит из двух полей - **имя файла и номер индексного дескриптора**.

Хранимая на внешнем запоминающем устройстве (диске) структура данных, содержащая всю информацию о файле, включая его имя, называется **индексным дескриптором**.

Имя файла в ОС Unix не является ни в каком виде частью или принадлежностью самого файла.

Записи в каталогах ссылающиеся на тот же самый индексный дескриптор - **жесткие ссылки**.

В индексном дескрипторе содержится счетчик количества ссылок на данный дескриптор.

В ОС Unix не предусмотрено функций удаления файла, вместо этого имеется системный вызов, удаляющий ссылку, который называется `unlink`. 

Сам файл удаляется, только если удаленная ссылка была последней (счетчик обратился в нуль) и при этом файл не был ни одним из процессов открыт на запись или чтение.



Система запрещает создание жестких ссылок на каталоги, удаление каталогов происходит с помощью команды `rmdir`.

Для создания жесткой ссылки средствами командной строки можно воспользоваться командой - `ln`.

**Символическая ссылка** (symbolic link) представляет собой файл специального типа, содержащий имя другого файла. Операция открытия символической ссылки на чтение или запись приводит к открытию файла, на который она ссылается, а не её самой. Будучи файлом, символическая ссылка имеет свой номер индексного дескриптора. Создание и удаление символической ссылки никак не затрагивает ни файл, на который она ссылается, ни его индексный дескриптор. Более того файл, на который указывает ссылка, может вообще не существовать в момент её создания, а также может быть удален позднее, что никак не повлияет на ссылку. 

> Символическая ссылка, содержащая имя несуществующего файла, называется **висячей**. Символические ссылки не ограничены рамками одного диска, поскольку реализуются через хранение имен, а дерево имен, как мы знаем, в ОС Unix общее для всех имеющихся в системе дисковых устройств.

Для создания символической ссылки средствами командной строки следует использовать уже знакомую нам команду `ln`, указав её флаг `-s`:
```
ln -s /path/to/old/name new_name
```
### Права доступа к файлам
Скриптовый файл должен начинатся со строки `#!bin/sh`, означает что для исполнения этого файла нужно запустить программу `/bin/sh` (командный интерпретатор) и передать ему имя файла скрипта через аргумент командной строки. Подойдет любой интерпретатор, знающий что его будут вызывать (`Perl`, `Scheme`, `Prolog`). Нужно перед этим навесить на скриптовый файл бит исполнения.

> Биты `SetUid` и `SetGid` для скриптов не работают

`Sticky bit` в директории дает право удалять только свои собственные файлы.

> Обычно для создания общественной директории применяются права 01777 - всем разрешается все, но при этом взведенный `Sticky bit` не позволит удалять чужие файлы.

`SetGid bit` установленный на директорию, приводит к тому, что для файлов, создаваемых в такой директории, в качестве группы пользователей принудительно устанавливается та же группа, что и для самой директории.

`ls -l` - показать права доступа, системный вызов - `stat`

Измнение прав доступа - `chmod` - системный вызов - `chmod`

Смена владельца и группы для файла - `chown`, `chgrp`, системный вызов - `chown`

### Чтение и запись содержимого файлов
Основные системные вызовы для работы с потоками ввода-вывода:
* `int open(const char *name, int mode);`
* `int open(const char *name, int mode, int perms);`

Чтение из потока ввода и запись в поток вывода происходит с помощью сис. вызовов:
* `int read(int fd, void *mem, int len);`
* `int write(int fd, const void *data, int len)`

Закрытие файла - `int close(int fd)`, даже если произошла ошибка дескриптор никогда не остается открытым.

Изменение текущей позиции в файле - `int lseek(int fd, int offset, int whence);`. Возвращает новое значение текущей позиции, считая от начала, `lseek(fd, 0, SEEK_END)` вернет длину файла, а текущей позицией станет его конец.

В большинстве случаев операции записи выполняются системой в так называемом асинхронном режиме вывода.

В явном виде дожидается завершение операции записи при асинхронном режиме - `int fsync(int fd);`. Вызов сообщает ОС, что все данные, связанные с файлом, должны быть как можно скорее физически записаны на диск. Точнее должна быть как можно скорее выполнена физическая операция записи.

`fdatasync` - аналог `fsync` но гарантирующий запись на диск только той информации, которая необходима для последующего корректного прочтениях данных.

`sync` - сообщает системе, о необходимости немедленно физически записать всю информацию, которая пока что содержится только в памяти системы, но предназначена для записи на диск. Речь идет о всей информации для всех дисковых файлов для всех пользователей системы.

Гибкая настройка поведения дескрипторов. Доступ практически ко всем возможностям такой настройки предоставляет системный вызов `fcntl` - `int fcntl(int fd, int cmd, ...);`. Первый параметр - номер дескриптора, второй - код команды (определенная целочисленная константа)

Флаги команды `open`: 
1. Флаги режима доступа
* `O_RDONLY`
* `O_WRONLY`
* `O_RDWR`
2. Флаги создания файла:
* `O_CREAT`
* `O_EXCL`
* `O_TRUNC`
* `O_NOCTTY`
3. Флаги статуса (отличаются от всех, их можно менять после начала работы с файлом):
* `O_APPEND`
* `O_NONBLOCK`

Текущее значение флагов статуса для открытого потока можно узнать, выполнив `fcntl` с командой `F_GETFL`, например `flags = fcntl(fd, F_GETFL)`.

Установлен ли конкретный флаг, можно понять с помощью побитового "и":
```
if(flags & O_APPEND) { /* флаг O_APPEND установлен */
/*...*/
```
Изменение текущего статуса с командой `F_SETEL`:
```
flags = fcntl(fd, F_GETEL);
fcntl(fd, F_SETEL, flags | O_NONBLOCK);
```

### Управление объектами файловой системы
Создание жестких ссылок - `int link(const char *oldpath, const char *newpath);`

Удаление ссылки на файл из каталога - `int unlink(const char *name);`. Не позволяет удалять директории

`int rename(const char *oldpath, const char *newpath);` - переименование файла 

Создание и удаление директории:
```
int mkdir(const char *name, int perms);
int rmdir(const char *name);
```

Символические ссылки - `int symlink(const char *oldpath, const char *newpath);`

Удаление символической ссылки - `unlink`

Изменение прав доступа - `int chmod(const char *path, int perms);`. Параметр `umask` на работу `chmod` не влияет.

Изменение владельца файла:
```
int chown(const char *path, int owner, int group);
int lchown(const char *path, int owner, int group);
```
Различие в том, что если их применить к символической ссылке, то `chown` будет работать с файлом, на который эта ссылка ссылается, а `lchown` - с самой ссылкой, хотя в большинстве случаев это бессмысленно. Если в `group` указать -1, то сохранится без изменений.

Подробная информация о файле:
```
int stat(const char *path, struct stat *buf);
int lstat(const char *path, struct stat *buf);
int fstat(int fd, struct stat *buf);
```
Различие заключается в символической ссылке.

Поля структуры хранения информации о файле:
* `st_dev` - идентификатор устройства, на котором находится файл
* `st_ino` - номер индексного дескриптора
* `st_mode` - тип файла и права доступа к файлу. Чтобы вытащить права доступа, необходимо произвести побитовую конъюнкцию значения этого поля с маской 07777 (0x0fff), тем самым выделив из него 12 младших бит.
* `st_nlink` - количество ссылок на файл
* `st_uid` - идентификатор пользователя владельца
* `st_gid` - идентификатор группы пользователей
* `st_rdev` - идентификатор устройства
* `st_size` - размер файла в байтах
* `st_blksize` - размер блока ввода-вывода на даной файловой системе
* `st_blocks` - количество блоков по 512 байт, занятых данным файлом
* `st_atime` -  дата и время последнего доступа к файлу
* `st_mtime` - дата и время последней модификации содержимого файла
* `st_ctime` - дата и время последнего изменения свойств файла

Укорочение файла путем удаления содержимого начиная с указанной позиции - `int trucate(const char *path, int length);`. Второй параметр - новая длинна.

Если файл открыт то то же самое можно сделать этой функцией - `int ftruncate(int fd, int length);`

### Файлы устройств и классификация устройств
В ОС Unix достаточно открыть на чтение специальный файл, соответствующий нужному диску, с помощью вызова `lseek` позиционироваться на нужный сектор и выдать обычный `write`. Именно так происходит форматирование диска, т.е. создание файловой системы.

Устройства, имеющие представление в виде файла, делятся на два типа:
* символьные (или потоковые, они же байт-ориентированные) (терминал, звуковая карта, принтер...). Существует ряд символьных псевдоустройств, не имеющих физического воплощения. Например в устройство `/dev/null` можно записать любую информацию, которая попросту игнорируется. Попытка читать из этого файла приведет к ситуации конец файла. **Не поддерживают** операцию позиционирования.
* блочные (блок-ориентированные) (диски и другие). Поддерживают позиционирование `lseek`

Функция для совершения дополнительных операций, специфических для конкретного устройства - `int ioctl(int fd, int request, ...);`. Второй параметр - код нужной операции. Например:
```
int fd = open("/dev/cdrom", O_RDONLY|O_NONBLOCK);
ioctl(fd, CDROMEJECT);
ioctl(fd, CDROMCLOSETRAY);
```
открывает и закрывает лоток привода CD-ROM. Параметр `O_NONBLOCK` задается, чтобы избежать поиска диска в устройстве и ошибки в случае, если диск в устройство не вставлен. Если же вставить в то же устройство музыкальный диск (audio CD), код:
```
struct cdrom_ti cti;
cti.cdti_trk0 = 2;
cti.cdti_ind0 = 0;
cdi.cdti_trk1 = 2;
cti.cdti_ink1 = 0;
ioctl(fd, CDROMPLAYTRAKIND, &cti);
```
заставит устройство воспроизвести вторую дорожку диска.

### Работа с содержимым каталогов
Система позволяет открывать каталоги на чтение с помощью вызова `open`.

Библиотека Си предусматирвает для анализа содержимого каталогов функции - `opendir`, `readdir`, `closedir`:
```
DIR *opendir(const char *name);
struct dirent *readdir(DIR *dirp);
int closedir(DIR *dirp);
```

### Отображение файлов в память
Отображение содержимого некоторого файла в виртуальное адресное пространство процесса - `mmap`:
```
void *mmap(void *start, int length, int protection, int flags, int fd, int offset);
```
Перед обращением файл должен быть открыт с помощью `open`. Параметры `mmap`:
* Параметры  `offset` и `length` задают позицию начала отображаемого участка в файле и его длинну. 
* `protection` задает режим доступа к памяти (`PROT_READ`, `PROT_WRITE`, `PROT_EXEC`, `PROT_NONE`). 
* Параметр `flags` указвают либо `MAP_SHARED`, либо `MAP_PRIVATE`  (изменения в виртуальном файле не отразятся) и дополнительный флаг через `|` - `MAP_ANONYMOUS` - позволяет обойтись без файла.
* `start` - в каком месте адресного пространства хотелось бы видеть новую область памяти. Если передать `NULL`, система выберет свободную память виртуального пространства.

`mmap` возвращает указатель на созданную область виртуальной памяти. В случае ошибки возвращает -1 (`MAP_FAILED`).

Память, выделяемая с помощью `mmap` с одновременным указанием `MAP_ANONYMOUS` и `MAP_SHARED` отличается от обычной тем, что при создании нового процесса она становится доступна из обоих процессов, то есть изменения, сделанные в такой памяти порожденным процессом, будут доступны родительскому и наоборот. Это называется **разделяемой памятью**. Она используется для взаимодействия между процессами.

Длина и позиция `mmap` должны быть кратны некоторому предопределенному числу, называемому размером страницы.

Размер страницы - `int getpagesize();`

Пример `mmap`:
```
int fd, pgs;
char *p;
int size = 4096;
pgs = getpagesize();
size = ((size - 1) / pgs + 1) * pgs;
/* Минимальное целое число, большее либо равное
  исходному и при этом кратное размеру страницы */
fd = open("file.dat", O_RDWR);
if(fd == -1) {
  /* Обработка ошибки */
}
p = mmap(NULL, size, PROT_HEAD|PROT_WRITE, MAP_SHARED, fd, 0);  
if(p == MAP_FAILED) {
  /* обработка ошибки */
}
```
После выполнения выражение `p[25]` будет равно значению 26-го байта в файле "file.dat", причем операция присваивания `p[25] = 'a'`, занесет в этот байт символ `'a'`.

Отмена отображения `mmap` - `int munmap(void *start, int length);`

> Вызов `mmap`, изначально предназначавшийся для работы с содержимым дисковых файлов, в наше время воспринимается как универсальный интерфейс для создания областей виртуальной памяти. Например:
```
p = mmap(NULL, size, PROT_HEAD|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, 0, 0);
```
указатель `p` содержит адрес новой области виртуальной памяти, полученной от ОС.

### Процессы
Процесс - некая сущность, создаваемая ОС для выполнения пользовательской программы.

Процесс - это программа, которую запустили на выполенение под управлением ОС.

Процесс - это структура данных, создаваемая в ядре ОС для поддержки выполнения пользовательской программы.

### Свойства процесса
* `pid` - уникальный идентификатор
* `ppid` - уникальный идентификатор родительского процесса. Если родительский процесс завершается раньше потомка, то `ppid` потомка становится 1.
* `pgid` - некая группа в рамках сеанса, которые обозначаются идентификатором группы процессов.
* `sid` - идентификатор сеанса.

Информация, определяющая полномочия процесса:
* `uid`
* `gid`
* `euid` - эффективный идентификатор пользователя
* `egid` - эффективный идентификатор группы

> В большинстве случаев эффективные идентификаторы совпадают с обычными, примером случая, когда это не так, служат `suid` программы, то есть программы, выполняемые с правами пользователя, владеющего исполняемым файлом данной программы, а не того пользователя, который программу запустил. Например `passwd`.

Узнать свои значения `uid`, `gid`, `euid`, `egid`, `pid`, `ppid`, `sid`, `pgid` процесс может узнать с помощью системных вызовов, которые так и называются `getpid`, `getuid` и т.д.

Память процесса:
* Секция кода
* Секция данных
* Секция стека
* Другие секции

Важная характеристика процесса - **состояние регистров центрального процессора**, включая счетчик команд (указатель инструкций), регистр флагов, указатель стека и все регистры общего назначения. Когда процесс по тем или иным причинам находится вне состояния выполнения (то есть он заблокирован, либо готов к выполнению, но процессор занят чем-то другим), содержимое регистров ЦП для этого процесса хранится в специальной структуре данных в ядре. Когда процесс снова становится на выполнение, данные из этой структуры копируются обратно в регистры.

За обеспечение иллюзии одновременного исполнения процессов отвечает подсистема ядра, которая называется **планировщиком времени центрального процессора**. С точки зрения планировщика процесс обладает:
* Логическим значением готовности
* Приоритетом (статическим, динамическим). Статический приоритет может быть изменен с помощью системных вызовов `nice`, `setpriority`.

**Командная строка процесса** - является его свойством, к примеру командная строка каждого процесса показывается в выдаче команды `ps`, печатающей список процессов в системе.

> Увидеть все процессы в системе - `ps ax` или `ps axu`.

**Окружение процесса** - является его свойством. Наследование окружения обусловлено не свойством ОС, а библиотечными функциями, через которые обычно осуществляется запуск новых программ. С точки зрения ядра окружение для каждой запускаемой программы задается свое.

Окружение доступно в программах на Си через глобальную переменную:
```
extern char **environ;
```
Поскольку окружение располагается в памяти процесса, системные вызовы для работы с окружением не нужны. Для манипулияции переменными окружения служат библиотечные функции `getenv`, `setenv`, `unsetenv`:
```
char *getenv(const char *name);
int setenv(const char *name, const char *value, int overwrite);
void unsetenv(const char *name);
```

К свойствам процесса также относятся **текущий каталог** и **кореновой каталог**. Процесс может в любой момент сменить свой текущий каталог. Если процесс запускать с указанием корневого каталога как `/foo`, то процесс будет видеть путь `/` как `/foo`, а `/bar` как `/foo/bar`.

Смена текущего каталога с помощью системного вызова - `int chdir(const char* path);`

Смена корневого каталога - `int chroot(const char* path);`

> Текущий и коренвой каталоги нельзя изменить для другого процесса, только для самого себя.

Еще одно важное свойство процесса, связано с открытыми потоками ввода-вывода - это **таблица файловых дескрипторов**. Каждый поток ввода-вывода на самом деле представляет собой сложную структуру данных в памяти ядра, причем конкретный вид этой структуры существенно зависит от природы потока. Таблица файловых дескрипторов процесса задает соответствие собсвтенно файловых дескрипторов объектов внутря ядра ОС, содержащим все необходимое для функционирования этих потоков.

Параметр `umask` также является свойством процесса - `int umask(int mask)`;

**Диспозиция сигналов** - набор указаний ОС, что следует делать, когда данному процессу приходит тот или иной сигнал, тоже является свойством процесса.

**Счетчики потребленных ресурсов** (процессорного времени, памяти и т.п.) являются свойством процессора. 

Есть еще и другие свойства...

### Порождение процесса
Единственный способ порождения процесса в Unix - создание копии существующего процесса. Для этого используется системный вызов `fork` - `int fork(void)`.
В результате создается новый процесс, являющийся точной копией родительского за исключаением следующих различий:
* порожденный процесс имеет свой идентификатор (`pid`), который отличется от родительского
* параметр `ppid` порожденного процесса равен `pid` родительского
* счетчики потребленных ресурсов порожденного процесса сразу после `fork` равны нулю
* выполнение обоих процессов (родительского и порожденного) продолжается с первой инструкции, следующей сразу за вызовом `fork`(чаще всего это присваивание возвращаемого ею значения какой либо переменной), причем в родительском процессе `fork` возвращает `pid` порожденного процесса, а в порожденном возвращает число 0.

Например:
```
#include <stdio.h>
#include <unistd.h>
int main()
{
  fork();
  fork();
  fork();
  printf("Hello\n");
  return 0;
}
```
напечатает восемь строк `"Hello"`. В самом деле, после первого вызова `fork` процессов станет два, каждый из них продолжит выполнение со следующей после вызов операции, в данном случае - со второго вызова `fork`, то есть каждый из двух процессов снова породит свою копию. Имеющиеся четыре процесса продолжат выполнение с третьего `fork`, так что их станет восемь, и каждый из них выполнит `printf`.

На практике требуется, чтобы порожденный процесс делал не то же самое, что его родитель, а что-то другое. Для этого используется обычный `if`, проверяющий возвращенное вызовом `fork` значение:
```
p = fork();
if(p == 0) {
  .... действия порожденного процесса
 } else {
 .... действия родительского процесса 
}

или так
p = fork();
if(p == 0) {
  действия порожденного процесса
  exit(0);
}
действия родительского процесса
```

После обращения к `fork` оба процесса работают параллельно.

Ситуация, в которых результат зависит от конкретной последовательности независимых событий (обычно событий из работающих параллельно процессов) называется **ситуация гонок**.

После вызова `fork` оба процесса используют один и тот же сегмент кода, это возможно т.к. сегмент кода не может быть модифицирован. Остальная память процесса копируется за исключением некоторых особых случаев, копируется. В порожденном процессе существуют все переменные родительского процесса, имеют одни и те же значения на момент создания. Копированию подвергаются открытые дескрипторы файлов, установленные обработчики сигналов и т.п. 
 
### Замена выполняемой программы
Запустить на выполнение программу в ОС Unix можно путем замены выполняемой программы в рамках одного процесса. Работающую программу можно заменить на другую программу, которая начнет свое выполнение с её начала  (например с функции `main` для программ, написанны на С). Процесс остается тот же. В системах Unix это единственный способ запуска программ, другого нет.

Замена программы производится системным вызовом:
```
int execve(const char *name, char* const *argv. char* const *envir);
```
Для удобства программирования существуют еще несколько функций семейства `exec`, реализованных в библиотеке через вызов `execve`.

* Функция `execv`:
```
int execv(const char *name, char* const *argv);
```
* Функция `execvp`:
```
int execvp(const char *name, char* const *argv);
```
Эта функция умеет отыскивать запускаемую программу (`name`) по ее имени в системных директориях. Поиск производится если в строке переданной параметром `name`, нет ни одного символа `/`, так если значение переменной `PATH` содержит директорию `/bin`, то вызывать программу `/bin/ls` можно по имени `ls`, не указывая полный путь.

Часто бывает, когда нам известно точное количество параметров командной строки для программы, которую мы собираемся запустить с помощью `exec`. В таком случае нам нет необходимости самим формировать массив указателей на элементы командной строки. Вместо этого используются `execl` или `execlp`, который формируют массив за нас:
```
int execl(const char *name, const char *argv0, ...);
// execlp использует поиск по переменной PATH (системные директории)
int execlp(const char *name, const char *argv0, ...);
```
Чтобы функция знала где остановится , после последнего слова командной строки нужно добавить еще один параметр со значение `NULL`.

> Командная строка включает нулевой элемент, под которым подразумевается имя самой программы.

Допустим требуется выполнить команду `ls -l -a /var`. Это можно сделать так:
```
char *cmdline[] = { "ls", "-l", "-a", "/var", NULL };
execvp("ls", cmdline);

// или так
execlp("ls, "ls", "-l", "-a", "/var", NULL);
```

> Все функции семейства `exec` заменяют в памяти процесса выполнявшуюся ( и вызвавашую `exec`) программу на другую, указанную в параметрах вызова. Поэтому в случае успеха эти функции управление уже не возвращают, сам факт возврата свидетельсвтует об ошибкие.

Если после вызова функции семейства `exec` в тексте программы мы видим что-то отличное от связки `perror/exit`, в большинстве случаев здесь что-то не так.

> Если вызвать `fork`, когда некоторые из высокоуровневых потоков вывода содержат неотправленные данные, эти данные окажутся скопированы вместе со всеми данными родительского процесса, а функция `exit`, вызванная из порожденного процесса, произведет их вытеснение. Родительский процесс об этом знать не будет, и рано или поздно, вытеснит свой экземпляр скопированных данных. Результат можнет получиться довольно своеобразный. В общем нужно делать правильную последовательность вызовов:
```
execlp("ls", "ls", "-l", NULL);
perror("ls");
fflush(stderr);
_exit(1);
```

Открытые файловые дескрипторы при выполнении `exec` остаются открытыми, что позволяет перед запуском внешней программы произвести манипуляцию с дескрипторами. Это свойство `exec` используется для реализации хорошо знакомых нам перенаправлений ввода-вывода. Из этого правила есть исключение. На файловом дескрипторе может быть установлен флаг `FD_CLOEXEC(close-on-exec)`, и в этом случае файл - точнее, один отдельно взятый дескриптор - будет закрыт при успешно отработавшей замене программы.

> Вызов `fcntl` предусматривает отдельные команды - `F_SETFD` и `F_GETFD`. Изначально предполагалось, что эти команды будут работать с флагами, относящимися к дескриптору (в отличие от поток), но в итоге был введен один флаг - `FD_CLOEXEC`. Установить можно так:
```
fcntl(fd, F_SETED, FD_CLOEXEC);
```
> Узнать установлен флаг или нет, можно с помощью `fcntl(fd, F_GETED)` (такой вызов вернет значение `FD_CLOEXEC`, если флаг установлен и 0 если нет), но это почти никогда не нужно.

### Завершение процесса
Возврат значения из главного экземпляра `main` и прямой вызов `exit` есть в сущности одно и то же.

Профиль обертки `_exit` - `void _exit(int code);`. Параметр `code` задает код завершения процесса. Значение 0 означает успешное завершение, остальные 1, 2, 3 и т.д. что произошла ошибка или неудача.

> При использовании библиотечного интерфейса ввода-вывода, т.е. функций, вводимых заголовочным файлом `stdio.h`, функция `exit`, прежде чем завершить программу, вытеснит всю информацию из буферов вывода, тогда как `_exit`, будучи системным вызовом, этого не сделает. Эту разницу легко обнаружить на примере следующей программы ( перевод строки в `printf` отсутствует ):
```
int main()
{
  printf("Hello, world");
  _exit(0);
```
Если эту программу запустить, она ничего не напечатает. `printf` поместит строку в промежуточный буфер вывода и на этом успокоится. Поскольку в строке нет символа перевода строки, вытеснение буфер не произойдет. Далее `_exit` завершит программу немедленно, не оставив в библиотеке шанса вытеснить буфер.

Если заменить `_exit` на обычный `exit` (то есть вызвать библиотечную функцию вместе прямого обращения к системному вызову), фраза `"Hello, world"` будет благополучно напечатана, и то же самое произойдет, если завершить `main` традиционным `return 0`.

> Если к печатаемому сообщению добавить перевод строки и для завершения использовать `_exit` фраза будет напечата в терминал, а если запустить перенаправление в файл, то нет. Причина в том, что вытеснение буфера по символу перевода строки производится только на терминал.

`_exit` и `exit` и возврат управления из `main` - это случаи, когда процесс завершается самостоятельно, указав значение кода завершения. Но возможен другой случай, когда процессу приходит **сигнал**.
* О коде завершения при завершении по сигналу речи идти не может, поскольку процесс не дошел до своего вызова `_exit` и, как следствие, никакого кода завершения не указал, с другой стороны, имеется информация о номере сигнала, который стал причиной досрочного завершения процесса. Обычно номер сигнала - целое число от 1 до 31.
* Все варианты аварийного завершения программы вследствие её собственных некорректных действий, таких как нарушение защиты памяти, деление на ноль и тому подобное, представляют собой частный случай завершения по сигналу. 

> Когда процесс, работающий под управлением OS Unix становится причиной возникновения внутреннего прерывания (исключения) и ядро видит, что к этому привели некорректные действия самого процесса, оно отправляет процессу один из сигналов, предусмотренных специально для этих случаев. О том, что же произошло, мы можем узнать по номеру сигнала.

В OC Unix процесс при его завершении не исчезает, а переходит в так называемое состояние **зомби-процесса**.

### Ожидание завершения, процессы зомби
Информация о обстоятельствах завершения процесса запрашивается родительским процессом, если его нет, то функции родительского процесса берет на себя `init` (процесс номер 1), при этом даже `ppid` для "осиротевшего" процесса становится равным 1. Никто эту информацию больше получить не может.

> Завершенный процесс продолжает существовать в системе в виде процесса-зомби, то есть занимает место в таблице процессов до тех пор, пока находящаяся в нем информация об обстоятельствах завершения не будет затребована родительским процессом.

Убрать зомби процесс из системы позволяют системные вызовы семейства `wait`, например:
```
int wait(int *status);
```
Если у процесса нет ни одного непосредственного потомка, вызов возвращает код ошибки (-1). Когда порожденные процессы есть, но ни один из них еще не завершился, вызов ждем завершения любого из порожденных процессов. `wait` изымает из процесса-зомби хранящуюся в нем информацию об обстоятельствах завершения процесса, а сам зомби окончательно отправляет в небытие, освобождая слот таблицы процессов. Вызов возвращает `pid` завершившегося процесса. Если параметр представлял собой ненулевой указатель, то в целочисленную переменную, на которую он указывал, записывается информация о коде завершения процесса или о номере сигнала, по которому процесс будет снят. 

Для анализа информации, занесенной в такую переменную, используются макросы `WIFEXITED`, `WIFSIGNALED` (был ли процесс завершен обычным способом или по сигналу), `WEXITSTATUS` (если завершен обычным образом, то каков код завершения), `WTERMSIG` (если по сигналу, то каков номер сигнала). Например:
```
int status, wr;
wr = wait(&status);
if(wr == -1) {
  printf("There are no child processes at all\n");
} else {
  printf("Process with pid=%d finished.\n", wr);
  if(WIFEXITED(status)) {
    printf("It has exited with code=%d.\n", WEXITSTATUS(status));
  } else {
    printf("It was killed by signal %d.\n", WTERMSIG(status));
  }
}
```

Более гибкие возможности предоставляет системный вызов `wait4` - `int wait4(int pid, int *status, int opt, struct rusage *usage);`. 
* В качестве первого параметра вызова можно указать идентификатор конкретного процесса, либо -1, если требуется дождаться любого из порожденных процессов. Нулевое значение параметра `pid` соответствует ожиданию любого из непосредственных потомков, оставшихся в одной группе с родительским процессом, тогда как значение меньшее -1, означает ожидание завершения процесса из группы с заданным номером (например -2732 означает группу 2732). 
* Параметр `status` используется как передатчик адреса переменной типа `int`, в которую вызов записывает основную информацию об обстоятельствах завершения процесса. 
* В качестве значения параметра `opt` можно указать число 0 или константу `WHOHANG`, в этом случае вызов не ждет завершения процессов (если зомби нет, то возвращает 0). 
* В `usage` если он не нулевой, записывается значения счетчиков ресурсов завершившегося процесса. `wait4` возвращается -1 в случае ошибки, 0 в случае, если использовалась опция `WHOHANG` и завершившихся процессов не было, и `pid` завершившегося процесса, если вызов успешно получил информацию от зомби.

> При наличии нескольких потомков ждать какого-то одного из них рискованно - остальные могут завершится раньше, перейти в статус зомби, но убирать их будет некому.

В OS Unix предусмотрены системные вызовы `waitpid` и `wait3`:
```
int wait3(int *status, int opt, struct rusage *usage);
int waitpid(int pid, int *status, int opt);
```

Убрать зомби из системы может только тот процесс, который его породил. Или можно убрать родителя, тогда уберется дочерний процесс.

### Пример запуска внешней программы
Программа сначала запустит на выполнение команду `ls` с параметрами `-l -a /var`, а затем, дождавшись её завершения, выдаст сообщение `Ok`:
```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main()
{
  int pid;
  pid = fork();
  if(pid == -1) { // ошибка порождения процесса
    perror("fork");
    exit(1);
  }
  if (pid == 0) {   // порожденный процесс
    execlp("ls", "ls", "-l", "-a", "/var", NULL);
    perror("ls"); // exec вернул управление -> ошибка
    exit(1); // завершаем процесс с кодом неуспеха
  }
  // родительский процесс
  wait(NULL); // дожидаемся завершения порожденного процесса, заодно убираем зомби
  printf("Ok\n");
  return 0;
}
```

### Выполнение процессов и время
Ядро операционной системы хранит текущее время и поддерживает **системные часы**. Узнать текущее системное время можно с помощью системного вызова `time`:
```
time_t time(time_t *t);
```
Возвращает текущее время в виде количества секунд, прошедших с начала 1 января 1970 года, по Гринвичу. То же число вызов записывает в переменную типа `time_t`. В большинстве случаев его оставляют нулевым и используют значение, возвращаемое `time` как функцией. `time_t` это в большинстве случаев обыкновенный `long`. Если описывать переменную, чтобы её адрес передать парамтром вызову `time`, лучше описать её как имеющую тип `time_t`.

Разложение на составляющие - год, месяц, часы, минуты, секунды:
```
struct tm *gmtime(const time_t *timep);
struct tm *gmtime(const time_t *timep, struct tm *result);
struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
```
Результат представляется в виде стркутры `struct tm`, имеющей следующие поля:
* `tm_year`
* `tm_mon`
* `tm_mday`
* `tm_hour`
* `tm_min`
* `tm_sec`
* `tm_wday`
* `tm_yday`
* `tm_isdst`.

Функции `gmtime` / `gmtime_r` возвращают результат для Гринвича, `localtime`/`localtime_r` - для часового пояса, установленного в настройках системы.

Функции, создающие текстовое представление заданной даты и времени:
```
char *asctime(const struct tm *tm);
char *asctime_r(const struct tm *tm, char *buf);
char *ctime(const time_t *timep);
char *ctime_r(const time_t *timep, char *buf);
```

> Функии с суффикосм `_r` используют для сохранения результата области памяти, тогда как функции без суффикса возвращают указатель на принадлежащую им структуру данных.

Если требуется представление, отличное от функций `gmtime`/`localtime`, о воспользоваться можно `strftime`:
```
int strftime(char *s, int max, const char *format, const struct tm *tm);
```

Узнать текущее время с большей точностью позволяет системный вызов `gettimeofday` - `int gettimeofday(struct timeval *tv, struct timezone *tz);`. Структура `timeval` состоит из двух полей: `tv_sec` для целого числа секунд и `tv_usec` для микросекунд. Чтобы узнать текущее время, мы должны в программе описать переменную типа `struct timeval` и передать её адрес первым аргументом в вызов `gettimeofday`. 

> Про второй аргумент в документации прямо сказано, что его использование нежелательно и будет лучше, если там указать `NULL`.

Функция (не системный вызов), отправляющая спать процесс - `int sleep(unsigned int seconds);`. Если процесс благополучно "проспал", функция вернет 0, но в некоторых случах (при доставке процессу обрабатываемого сигнала) функция `sleep` может завершиться досрочно, при этом она вернет положительное целое число, равное количеству секунд, которые её оставалось проспать, когда её прервали.

Функция `usleep` принимает в качестве параметра число микросекунд:
```
int usleep(long usec);
```

Наиболее универсальная функция сна - `int nanosleep(const struct timespec *req, struct timespec *rem);`. Первый параметр - нужный отрезок времени, второй параметр - адрес структуры того же типа, в который `nanosleep` запишет, сколько времени осталось до изначально заданного момента пробуждения, если ей не дали проспать сколько было указано. Структура `timespec` состоит из полей:
* `tv_sec`
* `tv_nsec`

> В современных системах как раз происходит прерывание таймера 1000 раз в секунду.

Ядро `Linux` использует в качестве приоритета число от -20(наивысший приоритет) до 19(самый низкий приоритет). По умолчанию все процессы в системе выполняются с приоритетом 0.

Процесс может понизить свой собственный приоритет с помощью системного вызова `nice` - `int nice(int inc);`. Параметром передается небольшое целое число, которое прибавляется к текущему значению статического приоритета, тем самым понижаю приоритет процесса.

Вызов `nice()` возвращает новое значение приортета, так что, например, процесс может узнать свой текущий приоритет, выполнив `nice(0)`.

Процессы, имеющие полномочия системного администратора могут, указывать отрицательно значение параметра при вызове `nice`, тем самым увеличивая свой приортет в системе.

> В случае ошибки `nice` возвращает, как и другие системные вызовы, значение -1, но то же самое значение вызов может вернуть, если новый приоритет стал равен -1. В документации говорится, чтобы отличить эту ситуацию от ошибочной, необходимо заранее присвоить значение 0 переменной `errno`, а после вызова проверить, поменялось ли оно. Впрочем, единственная ошибка, возвращаемая вызовом `nice` - это `EPERM`, происходит она в одном случае, если указано отрицательное значение параметра, а процесс не имеет полномочий суперпользователя.

Значение приоритета наследуется при создании нового процесса вызовом `fork` и не меняется при вызове `execve`.

Вызовы `getpriority` и `setpriority` позволяют манипулировать приоритетом конкретного процесса, группы процессов, либо всех процессов, принадлежащих пользователю:
```
int getpriority(int which, int who); // возвращает текущее значение приоритета заданных процессов 
// если много процессов, то возвращается с самым высоки приоритетом
int setpriority(int which, int who, int prio); // устанавливает заданное значение приоритета параметром `prio`
```

Параметр `which` задает способ, которым идентифицируются нужные процессы:
* `PROP_PROCESS` означает что будет задан номер (`pid`) конкретного процесса
* `PRIO_USER` предполагает, что речь пойдет о всех процессах, принадлежащих пользователю
* `PRIO_PGRP` позволяет задать группу процессов.
Значение `who` зависит от того, какой из вариантов мы избрали в первом параметре, и равняется соответственно `pid` нужного процесса, `uid` пользователя или идентификатору `pgidy` группы процессов.


### Перенаправление потоков ввода-вывода
Библиотечные функции считают потоки 0, 1 и 2 стандартными, что бы ни было под этими номерами открыто.

Для манипуляций с таблицей файловых дескрипторов используют специально предназначенные для этого системные вызовы `dup` и `dup2`:
* `int dup(int fd);` - создает новый файловый дескриптор, связанный с тем же самым потоком ввода-вывода, что и `fd`. Нового потока ввода-вывода не создается, оба дескриптора оказываются связаны с одним и тем же объектом ядра, реализующим поток ввода-вывода.
* `int dup2(int fd, int new_fd);` - новый дескриптор создается под заданным номером. Если на момент выполнения вызова у процесса был поток ввода-вывода, связанный с дескриптором `new_fd`, то есть этот дескриптор был открыт, он закрывается.

Пример программы вывода в файл:
```
int save1, fd;
fflush(stdout); // очищаем буфер стандартного вывода
save1 = dup(1); // сохраняем стандартный вывод
int fd = open("file.dat", O_CREAT|O_WRONLY|O_TRUNC, 0666); // открываем файл
if(fd == -1) // обработка ошибки
  dup2(fd, 1);  // сделали открытый файл стандартным потоком вывода

close(fd) // закрыли лишний дескриптор
// производим действия с нашей библитекой, все вызовы работающие со стандартным выводом, будут выводить информацию в наш файл  
dup2(save1, 1);  // восстановили старый стандартный поток вывода, файл при этом закрылся автоматически
close(save1); // лишняя копия не нужна
```

Допустим у нас возникла потребность в программе на Си смоделировать функционирование команды:
```
ls -l -a -R / > flist
```
т.е. сгенерировать возможности программы `ls`, сгенерировать файл `flist`, содержащий список всех файлов в системе с расширенной  информацией по каждому из них:
```
int pid, status;
pid = fork();
if(pid == 0) {
  int fd = open("flist", O_CREAT|O_WRONLY|O_TRUNC, 0666);
  if(fd == -1) {
    perror("flist");
    exit(1);
  }
  dup2(fd, 1);
  close(fd);
  execlp("ls", "ls", "-l", "-a", "-R", "/", NULL);
  perror("ls");
  exit(1);
}
// родительский процесс
wait(&status)
if(!WIFEXITED(status) || WEXITSTATIS(status)!=0) {
  // обработка ошибки
}
```
Пример с `open` в родительском процессе:
```
int pid, status, fd;
int fd = open("flist", O_CREAT|O_WRONLY|O_TRUNC, 0666);
if(fd == -1) {
  perror("flist");
  exit(1);
}
pid = fork();
if(pid == -1)  { // обработка ошибки } 
if(pid == 0) { // порожденный процесс
  dup2(fd, 1);
  close(fd);
  execlp("ls", "ls", "-l", "-a", "-R", "/", NULL);
  perror("ls");
  exit(1);
}
// родительский процесс
close(fd); // про это важно не забыть
wait(&status);
```

> Сдублировать дескриптор можно с помощью `fcntl`, используя команду `F_DUPFD`. В этом случае третий параметр `long`, задающий наименьший желаемый номер дублирующего дескриптора. Так, два следующие вызова эквивалентны:
```
nfd = dup(fd);
nfd = fcntl(fd, F_DUPFD, 0);
```

### Полномочия процесса
Процессу в системе приписываются:
* настоящие `uid`, `gid`, соответствующие идентификаторам пользователя, запустившего процесс.
* эффективные или действующие `euid`, `egid`, которые используются для проверки полномочий процесса
* сохраненные идентификаторы (saved set-user-Id, saved set-group-ID)
* массив дополнительных идентификаторов групп (supplementary groupd Ids)

> Во многих системах этим дело не ограничивается, так в ОС Linux процесс имеет отдельные файловые идентификаторы `fsuid`, `fsgid`, в большинстве случаев равные эффективным, но допускающие отдельную установку. Кроме того ядро Linux поддерживает механизм `capabilities`, позволяющий разрешать или запрещать процессам определенные привилегированные действия независимо от наличия или отсутствия у них суперпользовательских полномочий.

При старте системы ядро запускает процесс с номер 1 (обычно это программа `/bin/init`). Все шесть идентификаторов для этого процесса равны нулю.

> Процесс может менять свой `euid` туда-сюда между настоящим и сохранненым значениями, то есть (для случая выполняющейся SUID программы) при необходимости часть работы выполнять с правами владельца программы, а часть с правами пользователя, запустившего программу.

Например пользователь Вася с входным именем `vasya` `uid 1003` создал в системе исполняемый файл `vasyaprog` и поставил на него атрибут `SetUid`, а пользователь Петя с входным именем `petya` и `uid 1012` этот файл запустил. В этом случае программа `vasyaprog` сразу после запуска обнаружит, что её настоящий `uid` равен `1012` (это отражает тот факт, что запустил её Петя), тогда как эффективный и сохраненный `uid` оба равны `1003` - это результат действия атрибута `SetUid`.

Процесс может узнать свои настоящие и эффективные идентификаторы с помощью системных вызовов:
```
int getuid();
int geteuid();
int getgid();
int getegid();
```

> На самом деле тип возвращаемого значения этих системных вызовов - не `int`, `uid_t` и `gid_t`, в современных версиях того же Linux эти типы определены как `unsigned int`.

Вызовы, позволяющие запросить у ядра сразу все три идентификатора пользователя или группы:
```
getresuid;
getresgid;
getgroups;
```
Узнать свои идентификаторы дополнительных групп - `int getgroups(int size, gid_t *arr);`. Первым параметром можно передать ноль, в этому случае второй параметр игнорируется, а вызов возвращает количество дополнительных групп. Если места в массиве не хватает, вызов завершается ошибкой, но этого можно избежать, заранее узнав, какой длины должен быть массив. Вы можете применить примерно такой подход:
```
int n;
gid_t *p;
n = getgroups(0, NULL);
p = malloc(n * sizeof(gid_t));
getgroups(n, p);
```
После этого в переменной `n` будет находится общее количество дополнительных групп, а в массиве по адресу `p` - сами идентификаторы этих групп. Спецификация вызова `getgroups` не указывает, будет ли в число групп включена основная группа, т.е. значение вашего `euid`.

Информацию о группах пользователей, права которых даны процессу, можно узнать с помощью комбинации вызовов `getgroups`, `geteuid`.

Для манипуляции полномочиями процесса предусмотрены системные вызовы:
```
int setuid(int uid);
int setgid(int gid);
int seteuid(int euid);
int setegid(int egid);
int setgroups(int size, const gid_t *list);
```

Вызовы `setuid` и `setgid` вопреки своим названиям, тоже меняют прежде всего именно эффективные идентификаторы пользователя и группы, а вовсе не настоящие и меняют их по совершенно тем же правилам, что и `seteuid/setgid`.

### Количественные ограничения
Чтобы получить представление о действующих лимитах, можно воспользоваться командой `ulimit` в командной строке. В частности `ulimit -a` выдаст список всех возможных в данной системе количественных ограничений и их текущие значения.

Установк количественных ограничений - `int setrlimit(int resource, const struct rlimit *rlim);`.
* Структура `rlimit` имеет два поля - `rlim_cur` (мягкий уровень) и `rlim_max` (жесткий уровень). Оба поля имеют целочисленный тип. Для обозначения ситуации отсутствия ограничения используется константа `RLIM_INFINITY`.
* Первый параметр `resource` указывает, какое именно ограничение следует установить:
1. `RLIMIT_AS` - максимальное количество виртуальной памяти для отдельно взятого процесса (в байтах)
2. `RLIMIT_CORE` - максимальный возможный размер core-файла, создаваемого при авариях (в байтах). Если установить нулевой лимит, core файлы создаваться не будут.
3. `RLIMIT_CPU` - максимальное количество процессорного времени, которое может использовать процесс (в секундах). При достижении мягкого лимита, система отправит сигнал `SIGXCPU`, который по умолчанию убивает процесс, но если процесс перехватит или проигнорирует этот сигнал, то система продолжит продолжит посылать процессу сигнал `SIGXCPU` каждую секунд, пока не будет достигнут жесткий лимит, после чего уничтожит процесс сигналом `SIGKILL`, который нельзя ни перехватить, ни проигнорировать. 
4. `RLIMIT_FSIZE` - максимальный размер создаваемых дисковых файлов (в блоках по 512 байт). Если при записи в какой либо файл этот размер окажется превышен, процесс получит сигнал `SIGXFSZ`, если же этот сигнал не убьет процесс, то соответствующий системный вызов (например, `write`) вернет -1, а `errno` получит значение `EFBIG`.
5. `RLIMIT_NOFILE` - предельное количество одновременно открытых потоков ввода-вывода для одного процесса. Процесс не может создавать файловых дескриптор с номером, равным или превосходящим установленный лимит, даже если открытых потоков на этот момент гораздно меньше.
6. `RLIMIT_NPROC` - предельное количество процессов, разрешенных для создания от имени конкретного пользователя

Полный список лимитов - `man 2 setrlimit`.

> `Core` файл - файл с именем `core` или `prog.core`, создаваемый ОС в текущем каталоге при аварийном завершении процесса. В этот файл записывается содержимое сегментов данных и стека на момент аварии. Используется для отладчика.

Узнать текущие значения ограничений - `int getrlimit(int resource, struct rlimit *rlim);`

> Помимо количетсвенных ограничений, также существуют ограничения на использование дискового пространства (квотирование). Интерфейс механизма системный вызов - `quotactl`.

### Базовые средства взаимодейтсвия процессов
1. Локальные

1.1 Сигналы

1.2 Каналы

1.2.1 Именованные

1.2.2 Неименованные

1.3 `mmap`

1.4 Трассировка

1.5 Виртуальный терминал

1.6 `System V IPC`

1.6.1 Очереди сообщений

1.6.2 Разделяемая память

1.6.3 Семафоры

2. Сетевые

2.1 Сокеты

2.2 ...

> Семейства Unix поддерживают специальный вид сокетов, который можно использовать внутри одной системы, даже если поддержка компьютерных сетей в системе отсутствует.

### Сигналы
* `SIGTERM` - 15 завершение процесса
* `SIGKILL` - 9 уничтожение процесса

> При перезагрузке системы сначала рассылвается `SIGTERM`, а через 5 секунд `SIGKILL`.

* Сигналы `SIGILL`, `SIGSEGV`, `SIGFPE`, `SIGBUS`, отправляют процессам, чьи действия привели к возникновению исключения. По умолчанию любой из этих сигналов учитожает файл и создает `core` файл.

* Сигналы `SIGSTOP` и `SIGCONT` позволяют остановить и продолжить выполнение процесса.

* Сигналы `SIGINT` и `SIGQUIT` отправляются текущей группе процессов данного терминала при нажатии на клавиатуре комбинаций `Ctrl + C` и `Ctrl + \` соответственно. По умолчанию приводят к завершению процесса, причем `SIGQUIT` создает `core` файл.

* Сигнал `SIGCHLD` система присылает родительскому процессу при завершении его непосредственного потомка.

* `SIGALARM` - присылается по истечении заданного интервала времени после вызова `alarm`. Т.о. процесс может взвести для себя напоминание. По умолчанию приводит к завершению процесса.

* `SIGUSR1`, `SIGUSR2` предназначены для использования программистом для своих целей. По умолчанию завершают процесс.

> Все названия сигналов, такие как `SIGKILL` или `SIGCHLD` представляют собой целочисленные константы, описанные в библиотечных заголовочных файлах и соответствующие номерам сигналов, например `SIGKILL` вводится так:
```
#define SIGKILL 9
```
> В своих программах такого писать не нужно.

Для отправки сигнала служит системный вызов `kill` - `int kill(int target_pid, int sig_no);`. 
* Параметр `sig_no` задает номер сигнала, который следует отправить. Для лучше ясности программы вместо целого числа пишутся целочисленные константы (`SIGKILL`, `SIGUSR1`).
* Параметр `target_pid` задает процесс(ы), которому(которым) следует отправить сигнал. Если использовать -1, то сигнал будет послан всем процессам, кроме самого вызвавшего `kill`, а также процесса №1 (`init`). Отрицательное число, большее единицы по модулю, означает передачу сигнала группе процессов с соответствующим номером. Ноль - означает передачу сигнала всем процессам своей группы.

> Процессы с администраторскими полномочиями, могут отправлять сигналы любым процессам. Все прочие процессы имеют право отправлять сигналы только процессам, принадлежащим тому же пользователю. Как следствие, непривилегированного процесса вызов `kill(-1, SIGTERM)` означает отправку сигнала `SIGTERM` всем процессам того же пользователя, кроме себя самого.

Процесс может для любого сигнала, кроме `SIGKILL` и `SIGSTOP`, установить свой режим обработки: вызов функции-обработчика, игнорирование или обработка по умолчанию. Говорят, что процесс может установить **диспозицию сигнала**.

Функция обработчик должна принимать один целочисленный параметр и иметь тип возвращаемого значения `void`, т.е. это должна быть функция вида:
```
void handler(int s)
{
  /*...*/
}
```

Для изменения диспозиции сигнала в том числе для установки обработчика, можно использовать системный вызов `signal`:
```
typedef void (*sighandler_t)(int);
sighandler_t signal(int signo, sighandler_t hdl);
```
* Параметр `signo` - задает номер сигнала
* Параметр `hdl` - новую диспозицию для этого сигнала, это может быть адрес функции обработчика, которая должна быть вызвана при получении соответствующего, также можно использовать специальные значения диспозиции `SIG_IGN` (игнорировать сигнал) и `SIG_DFL` (вернуть диспозицию по умолчанию). 
* Вызов `signal` возвращает значение, соответствующее предыдущей диспозиции данного сигнала, либо специальное значение `SIG_ERR` в случае ошибки. 

> `SIG_ERR` представляет собой число -1, преобразованное к типу `sighandler_t`. 

> Установка функции обработчика сигнала не приводит к вызову этой функции.

Когда процесс получает сигнал, для которого в качестве диспозиции назначена функция обработчик, эта функция вызывается асинхроноо по отношению к выполнению остального процесса, то есть, попросту говоря, в самый неожиданный момент. 

> Дальнейшее поведение процесса после получения первого экземпляра обрабатываемого сигнала зависит от версии ОС (а иногда, от версии системных библиотек).

Обращение к ядру производится через системный вызов - `sigaction` (аналог `signal`)

> Чтобы написанная программа вела себя более менее одинаково при любом из двух вариантов семантики вызова `signal`, следует переустанавливать режим обработки каждый раз в начале функции-обработчика, либо, наоборот, сбрасывать режим обработки в `SIG_DFL`, если требуется перехватить только один сигнал.

Функция обработчик не вызывается из основной программы и не возвращает ей управление. В определенном смысле можно сказать, что её вызывает ядро ОС. Не имея возможности передать информацию обработчику через параметры и получить информацию от неё через возвращаемое значение, основная программа вынуждена взаимодействовать с функцией-обработчиком через глобальные переменные, ведь других способов связи с ней не остается.

> Язык Си предусматривает ключевое слово `volatile` для пометки переменных, значение которых может "неожиданно" изменится.

Современные спецификации системы сигналов предлагают программисту воспользоваться специальным типом `sig_atomic_t` (обычно это синоним `int`, введенный с помощью `typedef`), гарантируя, что обращение к такой переменной проходит атомарно, то есть за одно неделимое действие - одну машинную команду. Кроме того, переменную, которую будет менять обработчик сигнала, предлагается обязательно помечать словом `volatile`.

> Если процесс выполнил системный вызов, который перевел его в состояние блокировки, то при получении процессом обрабатываемого сигнала такой системный вызов немедленно вернет управление (-1). Отличить эту ситуацию от настоящих ошибок можно по значению переменной `errno` - она будет равна константе `EINTR`

Если процесс находился в состоянии выполнения в ядре, то вернутся обратно в ядро он может по своей инициативе.

> Если в своей программе вы обрабатываете сигналы, для каждого блокирующего системного вызова будьте готовы к тому, что он завершится с ошибкой `EINTR`, но при этом не полагайтесь на то, что так обязательно произойдет.

Пример программы, которая при нажатии `Ctrl+C` сначала выдает сообщение и лишь на 25 раз завершается:
```
#include <stdio.h>
#include <signal.h>
int n = 0;
void handler(int s)
{
  n++;
  printf("Press it again, I like it\n");
}
int main()
{
  signal(SIGINT, handler);
  while(n < 25)
    ;
  return 0;
}

// правильный вариант
/* pressagain.c */
#include <signal.h>
#include <unistd.h>
#include <errno.h>
volatile statis sig_atomic_t n = 0;
const char message[] = "Press it again, I like it\n";
void handler(int s)
{
  int save_errno = errno;
  signal(SIGINT, handler);
  n++;
  write(1, message, sizeof(message)-1);
  errno = save_errno;
}
int main()
{
  signal(SIGINT, handler);
  while(n < 25)
    // при получении процессом обрабатываемого сигнала `sleep` всегда возвращает управление, так что, сразу после обработки сигнала произойдет очередная проверка условия `while`.
    sleep(1); // или pause()
  return 0;
}
```

* Системный вызов `pause` блокирует процесс до тех пор, пока не будет получен обрабатываемый сигнал. Единственно возможное возвращаемое значение = -1, при этом в `errno` заносится значение `EINTR`.

* С помощью вызова `alarm` можно затребовать от ядра отправки вызвавшему процессу сигнала `SIGALRM` через определенное количество секунд времени:
```
int alarm(usigned int seconds);
```
Возвращаемое значение зависит есть ли уже активный заказ на отправку `SIGALRM`. Если нет, вызов возвращает ноль. Если есть, то возвращает количество секунд (не менее 1), оставшееся до момента его исполнения.

> Система может помнить только об одном заказанном сигнале `SIGALRM` для каждого процесса, иначе говоря, текущее значение "заказа" представляет собой свойство процесса. Если по результатам предыдущего вызова сигнал процессу еще не прислали, новый вызов отменит старый заказ и установит новый. Нулево значение параметра `seconds` отменит активный заказ, не установив новый.

По умолчанию сигнал `SIGALRM` убивает процесс, так что в большинстве случаев нужно сначала изменить диспозицию `SIGALRM`, установив функцию-обработчик, и лишь после этого обращаться к вызову `alarm`.

> При использовании сигналов часто возникают ситуации гонок, сами сигналы ненадежны, при отправке двух одинаковых сигналов прийти может только один и т.д.

### Каналы
Канал - это объект ядра ОС, представляющий собой средство однонаправленной передачи данных от одного процесса другому.

Для работы с именованными каналами в файловой системе создаются файлы специального типа, открытие которых с помощью вызова `open` приводит к подключению к каналу. Сам канал как объект ядра создается в тот момент, когда какой-то из процессов пытается открыть на запись или чтение файл именованного канала, который пока не открыт ни в каком другом процессе.

В противоположность этому, неименованные каналы сразу создаются открытыми с обоих концов. При этом ни с какими файлами они не связаны, так что подключиться к уже созданному неименованному каналу невозможно.

Неименованный канал создается системным вызовом `pipe` - `int pipe(int fd[2]);`. На вход подается адрес массива из двух элементов типа `int`, в этот массив вызов `pipe` записывает дескрипторы, связанные с созданным каналом: `fd[0]` - для чтения, `fd[1]` - для записи.

> Неименованный канал для взаимодействия между собой могут использовать только родственные процессы, (потомки).

Пример программы, первый потомок может передавать второму данные через канал. Соответствующий код на языке Си будет выглядеть так:
```
int fd[2];
int p1, p2;
pipe(fd);
p1 = fork();
if(p1 == 0) { /* child #1 */
  close(fd[0]);
  /*...*/
  write(fd[1], /*...*/);
  /*...*/
  exit(0);
}
p2 = fork();
if(p2 == 0) { /* child #2 */
  close(fd[1]);
  /*...*/
  rc = read(fd[0], /*...*/);
  /*...*/
  exit(0);
}
/* parent */
close(fd[0]);
close(fd[1]);
/*...*/
```
> Если оказались закрыты все дескрипторы, через которые можно было записать данные в канал, операции чтения (`read`) сначала опустошат внутренний буфер канала, а затем будут возвращать 0, сигнализируя о наступлении ситуации "конец файла".

> Если, наоборот, оказались закрыты все дескрипторы, через которые можно было из канала читать, то первая же попытка записи в канал приведет к тому, что попытавшийся осуществить запись процесс получит сигнал `SIGPIPE`. По умолчанию этот сигнал завершает процесс. Вызов `write` при этом возвращает -1, что может быть обнаружено только если процесс перехватывает или игнорирует сигнал `SIGPIPE`.

Наиболее активно неименованные каналы используются для реализации **конвейеров** - групп программ, которые запускаются на одновременное выполнение, причем информация, выдаваемая первой программой на стандартный вывод, поступает второй программе на стандартный ввод, вывод второй программы - ввод третьей и т.д.

Пример программы конвеера `ls -lR | grep '^d'` на Си:
```
int main()
  int fd[2];
  pipe(fd);     // создаем канал для связи
  if(fork()==0) { // процесс для выполнения ls -lR
    close(fd[0]); // читать из канала не нужно 
    dup2(fd[1], 1); // стандартный вывод в канал
    close(fd[1]);  // fd[1] больше не нужен
    execlp("ls", "ls", "-lR", NULL); // запускаем ls -lR
    perror("ls"); // не получилось, сообщаем об ошибке
    exit(1);
  } 
  if(fork()==0) { // процесс для выполения grep
    close(fd[1]);  // писать в канал не нужно
    dup2(fd[0], 0); // стандартный ввод - из канала
    close(fd[0]); // fd[0] больше не нужен
    execlp("grep", "grep", "^d", NULL); // запускаем grep
    perror("grep"); // не получилось сообщаем об ошибке
    exit(1);
  }
  // в родительском процессе закрываем оба конца канала
  close(fd[0]);
  close(fd[1]);
  wait(NULL); // дожидаемся завершения потомков
  wait(NULL);
  return 0;
```

> Именованные каналы подобны неименованным, с той разницей, что именованному каналу соовтествтует резмещаемый в файловой системе файл специального типа, этот тип так и называется `FIFO`.

Для создания файла типа `FIFO` используется функция `mkfifo` - `int mkfifo(const char *name, int permissions);`. При создании файла `FIFO` система не создает сам объект канала в ядре. Это происходит только тогда, когда какой нибудь процесс открывает файл `FIFO` с помощью вызова `open` на чтение или запись. От того, в каком режиме (`O_RDONLY` или `O_WRONLY`) процесс попытается открыть файл типа `FIFO`, зависит, к какому концу канала будет присоединен полученный файловый дескриптор.

> Уничтожение канала не означает уничтожение файла `FIFO`, после закрытия всех дескрипторов файл останется на месте и может быть снова открыт каким нибудь процессом, после чего в ядре системы снова появится объект канала.

Вызов `open`, примененный к одному концу канала, не возвращает управление до тех пор, пока кто то не откроет второй конец. Это можно изменить добавив второй параметр в `open` флаг `O_NONBLOCK`. Но попытка неблокирующего открытия на запись может привести к неудаче, если канал никем не открыт на чтение, то вызов `open`, выполенный с флагами `O_WRONLY|O_NONBLOCK` вернет -1, а в переменную `errno` будет записан флаг `ENXIO`.

### Краткие сведения о трассировке
В режиме трассировки один процесс(отладчик) контролиурет выполнение другого процесса(отлаживаемой программы), может остановить его, посмотреть и изменить содержимое его памяти, выполнить в пошаговом режиме, установить точки останова, продолжить выполнение до точки останова или до системного вызова и т.п.
  
В ОС Unix трассировка поддерживается системным вызовом `ptrace` - `int ptrace(int request, int pid, void *addr, void *data);`.
* Первый параметр `request` получает одну из возможных команд (какие именно действия, связанные с трассировкой, требуются)

Для присоединения к существующему процессу используется вызов `ptrace` с командой `PTRACE_ATTACH`.

### Драйвер терминала и дисциплина линии
Узнать, связан ли данный конкретный поток ввода-вывода с терминалом, позволяет функция `isatty` - `int isatty(int fd);`. Параметр функции - файловый дескриптор, если он связан с терминалом, возвращает 1, иначе 0. Это библиотечная функция, нужную информацию она получает через уже знакомый нам системный вызов `fstat`.

> Ядра Linux и FreeBSD эмулируют набор виртуальных терминалов, используя видоекарту и клавиатуру компьютера, на котором запущена система. Это те самые консоли, доступные до запуска графической подсистемы. Между ними можно переключаться нажатием комбинаций `Alt-F1`, `Alt-F2` и т.д., если не требуется графика, возможности консоли может хватить для работы с компьютером.

После запуска `X-Window` виртуальные консоли никуда не деваются, перейти на них можно `Ctrl-Alt-F1`, `Ctrl-Alt-F2` и т.д., а вернутся в графику нажатием `Alt-F7`, `Alt-F8` (конкретная конфигурация зависит от конфигурации системы), но вместо них становится удобнее использовать специальные оконные приложения, эмулирующие терминал, такие как `xterm`, `rxvt`, `konsole` и т.п.

> В отличие от виртуальных консолей, где за эмуляцию терминала отвечает ядро системы, здесь функциональность терминала эмулирует обычная программа, выполняющаяся в виде процесса.

При предоставлении удаленного доступа к машине также используется программная эмуляция терминала, в роли эмулятора выступает серверная программа (так называемый **демон**), предоставляющая доступ - **sshd**, **telnetd** или их аналог.

> Какова бы ни была природа терминального устройства, будь это физический терминал или эмулируемый (любым из имеющихся способов), между ним и программами, выполняющими операции ввода-вывода, находится специфический слой программного управления, называемой **дисциплиной линии**.

### Сеансы и группы процессов
Для объединения процессов, запущенных пользователем в ходе работы с одного терминала, в unix системах введено понятие сеанса.

Реализуется эта сущность просто - у каждого процесса есть **идентификатор сеанса** (`sid`). Сеансу может принадлежать управляющий терминал.

В рамках одного сеанса процессы могут быть разбиты на отдельные **группы**.

В каждом сеансе, имеющем управляющий терминал, одна группа процессов называется **текущей группой**, а остальные группы того же сеанса - **фоновыми группами**.

> Текущая группа, это свойство терминала, а не сеанса.

Группа процессов имеет свой идентификатор **pgid**.

Узнать для процессора параметры `sid`, `pgid` пожно с помощьд `getsid` и `getpgid`:
```
int getsid(int pid);
int getpgid(int pid);
```

Создание нового сеанса - `int setsid();`

Чтобы гарантировать успешное создание сеанса, следует вызвать `fork` и завершить родительский процесс, сменив свой `pid`:
```
if(fork() > 0)  
  exit(0);
setsid();
```
При успешном выполнении `setsid` будут созданы одновременно новый сеанс и новая группа, идентификаторы которых будут совпадать с `pid` процесса, выполнившего `setsid`, причем вызвавший процесс окажется единственным членом и того и другого.

Смена группы - `int setgpid(int pid, int pgid);`. Первый `pid` задает номер процесса, который нужно перевести в другую группу. `pgid` - номер этой группы.

Если у сеанса есть управляющий терминал, можно указать драйверу терминала, какую группу процессов считать текущей, с помощью:
```
int tcsetpgrp(int fd, int pgrp);
```
* `fd` - должен быть связан с управляющем терминалом

### Управление драйвером терминала 
Для управления линией связи с терминалом - используется системный вызов `ioctl`. 

> В Си включеная целая группа функций под общим названием `termios`, предназначенных для управления терминалом.

При управлении терминалом следует помнить, что основных режимов работы терминала существует два: **канонический** и **неканонический**. Основное различие между ними в том, будет ли драйвер терминала накапливать вводимую строку символов, чтобы отдать её активной программе сразу всю, или же каждый введенный символ окажется доступен активной программе немедленно.

> Все настройки дисциплины линии собраны в одну структуру `struct termios`.

Получить текущие настройки терминала поможет функция `tcgetattr` и установить новые с помощью `tcsetattr`:
```
int tcgetattr(int fd, struct termios *tp);
int tcsetattr(int fd, int options, const struct termios *tp);
```
* При установке нового режима работы терминала с помощью `tcsetattr` нужно её вторым параметром (`options`) указать, в какой момент драйверу следует действительно перейти на новый режим работы, три варианта:
1. `TCSANOW` (применить немедленно)
2. `TCSADRAIN` (дождаться, пока все данные, записанные в поток вывода, связанные с `fd`, не будут физически переданы в линию связи)
3. `TCSAFLUSH` (дождаться, пока все записанные данные уйдут в линию, сбросить все данные, пришедшие из линии, но пока не прочитанные, и после этого применить новые настройки). 
В большинстве годится `TCSANOW`

Структура `termios` содержит как минимум следующие поля:
* `int c_iflag;` - отвечает за поток входящей информации. Единственный флаг, эффект от которого понятен и полезен - `IXON`, если он установлен то вывод на терминал можно в любой момент приостановить нажатием комбинации `Ctrl-S`, а затем продолжить `Ctrl-Q`. Полезно, если какая то программа слишком быстро выдает текст, а нам надо остановить и посмотреть.
* `int c_oflag;` - управляет обработкой потока, выдаваемого на терминал. Например `ONLRET` запрещает вывод символа возврата каретки, то есть драйвер скушает все символы с кодом 13, выдаваемые активными программами.
* `int c_cflag;`
* `int c_lflag;` - флаг `ICANON` - пока он возведен, терминал работает в каноническом режиме, то есть дожидается ввода строки целиком, прежде чем отдать её активной программе, обрабатывает специальные символы, предназначенные для удаления последнего символа и очистки всей строки `Backspace` и `Ctrl-U`. Если добавить флаг `IEXTEN` терминал будет обрабатывать также спецсимволы для удаления последнего введенног слова (`Ctrl+W`) и др. `IEXTEN` без `ICANON` не работает. 
* `char c_cc[NCCS];`

`ECHO` в `int c_lflag;` определяет, следует ли выдавать на экран вводимые символы по мере их ввода (так называемый режим `local echo`). Иногда требуется вводить вслепую например пароль. Ввод секретного текста, а затем обратно в обычный режим, пример программы:
```
#include <stdio.h>
#include <unistd.h>
#include <termios.h>
#include <string.h>
enum { bufsize = 128 };
int main()
{
  struct termios ts1, ts2;
  char buf[bufsize];
  if(!isatty(0))  {
    fprintf(stderr, "Not a terminal, sorry\n");
    return 1;
  }
  tcgetattr(0, &ts1); // получаем текущие настройки 
  memcpy(&ts2, &ts1, sizeof(ts1)); // создаем копию
  ts1.c_lflag &= ~ECHO; // сбрасываем флаг `ECHO`
  tcsetattr(0, TCSANOW, &ts1); // выключаем local echo
  printf("Please blind type the code: ");
  if(!fgets(buf, sizeof(buf), stdin)) {
    fprintf(stderr, "Unexpected and of file\n");
    return 1;
  }
  printf("\nThe code you entered is [%s]\n", buf);
  tcsetattr(0, TCSANOW, &ts2); // восстанавливаем настройки
  return 0;
}
```
> Чтобы установить несколько флагов в поле `c_lflag` можно примерно так:
```
ts1.c_lflag |= (ICANON | IEXTEN | ISIG | ECHO);
```
> Принудительный сбро флага:
```
ts1.c_lflag &= ~(ICANON | IEXTEN | ISIG | ECHO);
```
> Все эти операции изменяют только поля структуры, но никак не влияют на рабочие настройки терминала, которые меняются только когда будет вызвана функция `tcsetattr`.

Справочная информация - `man 3 termios`.

### По ту сторону псевдотерминала
Для эмуляции терминала пользовательскими программами предусмотрен механизм **псевдотерминалов** - специальных объектов ядра, имитирующих линию связи с терминалом.

Псевдотерминал как объект ядра имеет два двусторонних канала связи, один - для программы, эмулирующей функционирование терминала(например `xterm`), второй для программ, выполняющихся под управлением терминала. Программа, эмулирующая терминал, называется главвной (`master`). а работающие под управлением терминала - подчиненными `slaves`.

Создание псевдотерминала - `int getpt();`

В переносимых программах следует использовать `int posix_openpt(int flags);`

> Вызов `posix_openpt(O_RDWR|O_NOCTTY)` эквивалентен вызову `getpt` без параметров. И в обоих случаях на самом деле происходит системный вызов `open`, примененный к специальному файлу виртуального устройства `/dev/ptmx`.

При этом, ядро создает пару связанных между собой устройств, которые называются **главное устройство псевдотерминала** и **подчиненное устройство псевдотерминала**. Первое из них ядро открывает в виде потока ввода-вывода и возвращает файловый дескриптор этого потока. Одновременно в файловой системе появляется файл подчиненного устройства, открытие которого позволит присоединиться к тому же псевдотерминалу уже со стороны программ, для которых он будет управляющим.

Чтобы сделать подчиненное устройство доступным для открытия, нужно применить к дескриптору главного устройства (то есть тому дескриптору, который нам вернула функция `getpt`, `posix_openpt` или просто `open`, примененный к `/dev/ptms`) последовательно функции `grantpt` и `unlockpt`:
```
int grantpt(int fd); // изменяет принадлежность файла устройства подчиненного псевдотерминала так, что он становится доступен владельцу текущего процесса
int unlockpt(int fd); // разрешает открыть файл псевдотерминала с помощью вызова `open`.
```

Узнать имя файла устройства подчиненного псевдотерминала  можно с помощью функции - `char *ptsname(int master_id);`. Где `master_id` - дескриптор, полученный от `getpt` или `posix_openpt`. 

Всю работу, связанную с созданием описанной связки главный-подчиненный, можно выполнить и проще, с помощью одной функции `openptry`:
```
int openpty(int *master, int *slave, char *name, struct termios *termp, struct winsize *winp);`
```
Параметры `master` и `slave` задают адреса переменных, в которые следует записать дескрипторы, связанные соответственно с главным и подчиненными каналами связи с псевдотерминалом. Параметр `name` указывает на буфер, куда следует записать имя подчиненного псевдотерминала, параметры `termp` и `winp` задают режим работы псевдотерминала. В качестве любого из последних трех параметров можно передать нулевой указатель.
  
> Функция `openpty` считается особенностью систем семейства BSD, в литературе можно встретить рекомендации воздержаться от её использования.

### Процессы-демоны
Под **демонами** понимаются процессы, не предназначенные для непосредственного взаимодействия с пользователями системы (серверные программы, обслуживающие WWW или электронную почту).

Старт процесса-демона:
```
close(0);
close(1);
close(2);
open("/dev/null", O_RDONLY); /* stdin */
open("/dev/null", O_WRONLY); /* stdout */
open("/dev/null", O_WRONLY); /* stderr */
chdir("/");
if (forK() > 0)
  exit(0);
setsid();
if (fork() > 0)
  exit(0);
```
> Первая явязка `fork-exit` выполняется перед вызовом `setsid` чтобы ничто не мешало процессу создавать новый сеанс. Если этого не сделать, имеется риск, что `setsid` не пройдет: например, процесс уже был лидером сеанса или хотя бы группы. Вторая такая же связка выполняется уже после `setsid`, чтобы процесс, породив сеанс, перестал быть его лидером.

Передача сообщений от демона к администратору происходит посредством **системы журнализации**. Для этого используются библиотечные функции:
```
void openlog(const char *ident, int option, int facility);
void syslog(int priority, const char *format, ...);
void closelog(void);
```
Пример вызова `syslog` - `syslog(LOG_INFO, "Daemon started, pid == %d", getpid());`


### Протокол IP
* ICMP (internet control message protocol) - протокол обмена штатными нештатными ситуациями (обрыв соединения, отсутствие подходящего маршрута и др.)

* Сетевой адрес (ip адрес), состоящий из четырех восьмибитных байтов. Например 192.168.215.17 - 1100 0000 1010 1000. Старший бит всегда записывается первым.

* Адреса можно объединять в подсети. Размер подсети (т.е. количество адресов в ней) всегда представляет собой степень двойки, при этом в неё входят только те адреса, для которых совпадают сколько-то первых битов. Например если нам нужна подсеть на восемь адресов, то варьироваться в такой подсети будут три последних бита(8=2^3). 

> Поскольку всего в ip-адресе 32 бита, остальные 29 фиксируются и образуют адрес подсети, также называемый ip-префиксом.

Адрес подсети записывают как обычный ip адрес, четырьмя десятичными числами через точку, варьируемые биты при этом равны нулю.

> Иначе говоря адрес подсети записывается также как наименьший из входящих в эту подсеть ip адресов.

Подсеть обычно обозначают в виде её адреса подсети, после которого через дробную черту записывают длину префикса. Например
```
203.0.113.32/28
```
28 - длинна перфикса. На варьируемую часть адреса остается 4 бита, следовательно эта подсеть содержит 2^4 = 16 адресов. Т.е. это адреса с 203.0.113.32 по 203.0.113.47. В двоичном виде все адреса этой подсети имеют вид 11001011 00000000 01110001 0010хххх, где xxxx варьируемые биты.

> Часто можно увидеть обозначение вроде 203.0.113.41/32. Один адрес в эту подсеть все же входит - в нашем примере это адрес 203.0.113.41. Иначе говоря длина префикса 32 бита используется для обозначения *одного отдельно взятого ip-адреса*.

Адреса, начинающиеся с байтов 224-239, формально говоря, используются - они были выделены для протоколов группового вещания ("multicast"). Общая идея группового вещания состоит в том, что для одного источника передаваемой информации имеется неопределенное число её получателей, примерно так, как это происходит при передаче теле и радиопрограмм. Отдельный ip адрес из подсети 224.0.0.0/4 представляет собой некий аналог канала.

> Адреса 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16 - предназначены для использования в частных сетях. Кто угодно, выстраивая свою компьютерную сеть, может использовать в ней любые из этих адресов по своему усмотрению, но при этом не должен выпускать пакеты с такими адресами за пределы своей сети, то есть компьютеры, имеющие адреса из этих трех блоков, не видны из Интернета, хотя благодаря хитрым преобразованиям адресов сами могут осуществлять доступ к серверам через Интернет.

**NAT** - (network address translation) трансляция сетевых адресов. Маршрутизатор, видя пакет, подменяет в нем обратный адрес на свой собственный и в таком виде отправляет в Интернет - как будто от своего имени. При получении ответного пакета маршрутизатор производит обратную замену и отправляет полученный ответ в локальную сеть.

> Если ip адрес подходит под несколько разных правил маршрутизации, то маршрутизатор всегда использует то правило, в котором указана подсеть наименьшего размера.

### Дейтаграммы и потоки
UDP предусматривает что участники сетевого взаимодействия, работающие на одном компьютере, будут для идентификации использовать двухбайтные беззнаковые числа, называемые номерами портов или портами.

> К данным, которые нужно передать через сеть, проткол UDP предписывает добавить заголовок 8 байт, содержащий номер отправителя, номер порта получателя, длину дейтаграммы(данные вместе с заголовком) и контрольную сумму. Полученная структура(Дейтаграмма) заворачивается в пакет в соответствии с соглашениями протокола IP. Сетевые адреса отправителя и получателя указываются уже в заголовке этого пакета.

Протокол TCP как и UDP использует номера портов для идентификации участников взаимодействия, работающих на одном компьютере. Заголовок пакета TCP имеет переменную длину и может занимать от 16 до 56 байт. 

> Всю реализацию соглашений протокола TCP берет на себя ОС.

### Протоколы прикладного слоя
Многие протоколы прикладного уровня основываются на обмене текстовыми репликами через двунаправленное потокове соединение - SMTP (simple mail transfer protocol, протокол передачи электронной почты) и HTTP(hypertext transfer protocol, протокол по которому браузер соединяется с вебсайтами).

### Доменные имена
Система доменных имен представляет собой глобальную распределенную базу данных, в которой иерархия доменных имен, записываемых через точку, используется в качестве ключа, используется в качестве ключа для поиска. Информация, связанная с конкретным доменным именем, совершенно не обязана ограничиваться ip адресом, структура базы данных позволяет хранить записи различных типов, в том числе простые текстовые сообщения.

> В системе доменных имен собственно доменное имя - это последовательность разделенных точками токенов, каждый из которых представляет собой непустую последовательность латинских букв, цифр и символа дефиса, причем начинаться и заканчиваться дефисом токен не может. Например доменное имя `www.stolyarov.info` состоит из трех токенов `www`, `stolyarov`, `info`. 

Количество токенов в доменном имени называется уровнем этого имени - так, `www.stolyarov.info` - имя третьего уровня, `stolyarov.info` - второго, а `info` - первого.

С каждым доменным именем DNS позволяет связать произвольное количество записей, каждая из которых имеет служебный параметр `time to live` (количество секунд, в течение которого с момента получения запись можно продолжать считать актуальной), а также класс, тип и содержимое.
* Класс записей в DNS реально используется всего один - `IN` (от слова `Internet`), хотя в спецификациях упоминается по меньшей мере ещё два других класса  и два служебных значения, которые классами не являются, но якобы должны использовать вместо класса.
* Типы записей:

1. `A` (от слова `address`) - содержит адрес протокола IPv4, который должен быть поставлен в соответствие данному доменному имени.

2. `AAAA` - для IPv6

3. `MX` (`mail exchanger`) - для указания серверов электронной почты. Позволяет создавать доменные имена, используемые только для почты.

4. `SRV` - указание местонахождения серверов некоторых других протоколов

5. `TXT` - указание обычных текстовых данных. А также есть другие типы...



> Руссокязычные домены `зона.рф` на самом деле тоже представляют собой последовательности латинских букв, цифр и дефиса, получаемые из русских слов по хитрым правилам.

Суффиксами доменного имени называют доменные имена, полученные из исходного отбрасыванием нуля или более токенов слева. Так, доменное имя `www.stolyarov.info` имеет три суффикса: `www.stolyarov.info`, `stolyarov.info`, `info`.

> Доменные имена, имеющие общий заданный суффикс, как раз и образуют домен. Иначе говоря домен - это бесконечное множество доменных имен, имеющих один общий суффикс.

Домены вкладываются друг в друга.

Корневой домен обозначается точкой `"."` и объединяет все существующие домены и доменные имена.

Домен за вычетом поддоменов, делегированных на другие сервера, называется **доменной зоной**.

> Запись `CNAME` предписывает рассматривать имя как синоним другого имени.

Вместо младшего токена в доменном имени можно указать звездочку `*`, это будет означать, что указанную запись следует отдавать в ответ на запросы, в которых вместо звездочки может стоять что угодно. Например 
```
*.camp  IN  A   198.51.100.72
```

Для делегирования поддомена достаточно занести в зону исходного домена соответствующие записи. Например делегировать домен третьего уровня `example.stolyarov.info` серверам `ns1.example.com` и `ns2.example.com`, достаточно в доменную зону `stolyarov.info` внести строки:
```
example IN  NS  ns1.example.com
example IN  NS  ns2.example.com
```

### Семейства адресации и типы взаимодействия 
Сокет - объект ядра ОС, через который происходит сетевое взаимодействие.

В ОС Unix с сокетом связывается файловый дескриптор, в частности работа с сокетом может быть завершена обычным вызовом `close`. 

Для идентификации сокетов в сетях используются **адреса**.

*Сетевой порт* позволяет идентифицировать участников взаимодействия внутри одной системы, тогда как сама система идентифицируется ip адресом. Эта пара (айпи + порт) как раз и составляет сетевой адрес для сокета при использовании протоколов семейства IP. Кроме того, отдельный специальный вид сокетов предназначен для связи процессов в рамках одной машины, в качестве адресов такие сокеты используют имена специальных файлов в файловой системе.

При создании сокета указывается, к какому **семейству адресации** новый сокет будет принадлежать.

При создании сокета нужно указать **тип взаимодействия**. Два основных типа взаимодействия - дейтаграммный и потоковый.

Сокет в ОС Unix создается с помощью системного вызова, который называется `socket`:
```
int socket(int family, int type, int protocol);
```
* параметр `family` задает используемое семейство адресации. Например `AF_INET` для взаимодействия по сети посредством протоколов TCP/IP, `AF_UNIX` для взаимодействия в рамках одной машины.
* параметр `type` задает тип взаимодействия. Константа `SOCK_STREAM` соответствует потоковому взаимодействию, `SOCK_DGRAM` - дейтаграммному.
* параметр `protocol` задает конкретный используемый протокол
* возвращает -1 в случае ошибки, в случае успеха возвращается номер файлового дескриптора.


> Для рассматриваемых нами двух семейств адресации и двух типов взаимодействия протокол однозначно определяется значениями первых двух параметров, так что в качестве этого параметра всегда можно указать число 0. Можно впрочем указать и значение конкретного протокола: `IPPROTO_TCP` для `TCP` и `IPPROTO_UDP` для `UDP`.


### Сокет и его сетевой адрес
Снабдить сокет адресом можно с помощью системного вызова `bind`:
```
int bind(int sockfd, struct sockaddr *addr, int addrlen);
```
* `sockfd` - дескриптор сокета, полученный в результате выполнения `socket`
* `addr` - указатель на структуру, содержащую адрес 
* `addrlen` - размер структуры адреса в байтах
* возвращает 0 в случае успеха, -1 в случае ошибки.

> `bind` может не пройти, например ошибка произойдет при попытке использования привилегированного порта (от 1 до 1023) или порта, который на данный машине уже кем-то занят.

Реально в качестве параметра `addr` используется не структура типа `sockaddr`, а структура другого типа, который зависит от используемого семейства адресации. В семействе `AF_INET` используется структура `struct sockaddr_in`, умеющая хранить ip + порт. Эта структура имеет следующие поля:
* `sin_family` - обозначает семейство адресации. Это единственное общее поле для всех существующих структур, используемых для задания адреса сокета. В это поле заносится идентификатор используемого семейства адресации (в данном случае `AF_INET`)
* `sin_port` - задает номер порта в сетевом порядке байтов
* `sin_addr` - задает ip адрес, поле `sin_addr` само является структурой, имеющей лишь одно поле с именем `s_addr`, которое хранит ip адрес в виде беззнакового четырехбайтного целого, в сетевом порядке байтов.

Чтобы обесепечить переносимость программ на уровне исходного кода, в ОС семейства Unix введены стандартные библиотечные функции для преобразования целых чисел из формата данной машины (host byte order) в сетевой формат (network byte order):
```
unsigned long int htonl(unsigned long int hostlong);
unsigned short int htons(unsigned short int hostshort);
unsigned long int ntohl(unsigned long int netlong);
unsigned short int ntohs(unsigned short int netshort);
```
* h - host
* n - network
* l - long
* s - short


Номер порта представляет собой двухбайтовое целое - такое целое, которое большинство компиляторов Си называют "коротким целым" (`short int` или просто `short`). Для заполнения поля `sin_port` нам потребуется функция `htons`. Например если мы решили запустить сервер, использующий порт 7654, то выглядеть это будет так:
```
struct sockaddr_in addr;
/*...*/
addr.sin_port = htons(7654);
```

> Для протокола UDP и TCP номера портов от 1 до 1023 включительно считаются привилегированными, такой порт может забрать себе процесс, который имеет права администратора (`euid == 0`). Если обычный процесс попытается задать сокету адрес с привилегированным номером порта, вызов `bind` вернет -1, `errno` получит значение `EACCES`.

Что касается ip адреса, то, имея его текстовое представление (например 192.168.1.1), можно воспользоваться функцией `inet_aton` для формирования структуры типа `struct in_addr` (поле `sin_addr` структуры  `sockaddr_in` имеет именно этот тип):
```
int inet_aton(const char *cp, struct in_addr *inp);
```
* строка `cp`, содержащая текстовое представление ip адреса
* `inp` указывает на структуру, подлежащую заполнению.
* возвращает ненулевое значение, если заданная строка является допустимой текстовой записью ip адреса, и 0 в противном случае.

Допустим, нужный нам ip адрес содержится в строке `char *serv_ip`, а порт - в переменной `port` в виде целого числа. Тогда заполнение структуры `sockaddr_in` может выглядеть так:
```
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(port);
if(!inet_aton(serv_ip, &(addr.sin_addr))) {
  /* Ошибка - невалидный ip-адрес */
}
```

Можно также воспользоваться функцией `inet addr`, которая принимает один аргумент - строковое представление адреса, а возвращает четырехбайтное целое число, которое может занести в поле `sin_addr.s_addr`:
```
unsigned int inet_addr(const char *cp);
```
* Возвращает адрес уже в сетевом порядке байтов.


> В большинстве случаев задавать созданному нами сокету конкретный ip адрес не обязательно. В системах семейства Unix нет простого и переносимого способа узнать, какие ip адреса имеются в системе. Поэтому, когда нам нужен серверный сокет, гораздо проще проинструктировать систему принимать соединения (или дейтаграммы) *на заданный порт на любом из имеющихся в системе ip адресов*, а при отправке исходящих дейтаграмм или запросов на установление соединения использовать ip адрес того сетевого интерфейса, через который происходит работа. Для этого поле `sin_addr` следует заполнить специальным значением `INADDR_ANY`:
```
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(port);
addr.sin_addr.s_addr = htonl(INADDR_ANY);
```
* `INADDR_ANY` - это арифметический ноль или ip 0.0.0.0.

> При подготовке к вызову `bind` в большинстве случаев ip адрес, т.е. значение поля `sin_addr`, как раз и заполняют с помощью константы `INADDR_ANY`. Функции `inet_addr` и `inet_aton` чаще используют при формировании адреса получателя дейтаграммы или запроса.

> Структура `sockaddr_in` описана в заголовочном файле `netinet/in.h`.

Поскольку тип структуры `struct sockaddr_in` формально отличается от типа второго параметра вызова `bind`, при обращении к этому вызову приходится прибегать к явному приведению типа, например:
```
if (-1 == bind(sd, struct sockaddr*)&addr, sizeof(addr))) {
  /* обработка ошибок */
}
```

В семействе `AF_UNIX` используется структура `struct sockaddr_un`, в которой можно хранить имя файла. Эта структура состоит из полей:
* `sun_family` - обозначает семейство адресации (в данном случае значение этого поля должно быть установлено в `AF_UNIX`);
* `sun_path` - массив на 108, в которой непосредственно записывается строка имени файла.

> Структура выше, описана в заголовочном файле `sys/un.h`. 

> Файл, имя которого используется в качестве адреса сокета, должен иметь специальный тип "сокет". Это отдельный тип файла наряду с:
* Обычными файлами
* Директориями
* Символическими ссылками
* Символьными устройствами
* Блоычными устройствами
* Именованными каналаами

Файл сокета сам по себе не исчезает при завершении работы с сокетом. Его нужно удалить явным образом с помощью системного вызова `unlink`.

> Для других семейств адресации системные заголовочные файлы предоставляют свои структуры, имена которых тоже имеют вид `sockaddr_XX`.

### Прием и передача дейтаграмм
Сокет создается вызовом `socket` с указанием константы `SOCK_DGRAM` в качестве второго параметра. Желательно связать сокет с конкретным адресом с помощью `bind`, при этом ip адрес можно заменить константой `INADDR_ANY`, но порт все же задать. Если этого не сделать, то при отправке первой дейтаграммы система сама выберет один из своих адресов и портов в качестве адреса отправителя.

> Это не проблема, если мы собираемся сначала отправить кому-то дейтаграмму (например в качестве запроса), а потом уже пытаться получить дейтаграмму, которая будет послана нам в качестве ответа. 

> Но если мы предполагаем, что кто-то другой может послать нам дейтаграмму по своей инициативе, а не в ответ на наш запрос, то, очевидно, наш сокет должен быть связан с конкретныи адресом, и этот адрес должен быть известен нашим партнерам.

Для передачи и приема данных предназначены системные вызовы `sendto`, `recvfrom`:
```
int sendto(int s, const void *buf, int len, int flags, const struct sockaddr *to, socklen_t tolen);
int recvfrom(int s, void *buf, int len, int flags, struct sockaddr *from, socklen_t *fromlen);
```
* `s` - дескриптор сокета
* `buf` - буфер, содержащий данные для передачи либо предназначенный для размещения принятых данных
* `len` - устанавливает размер этого буфера (количество данных подлежащих приему или передаче)
* `flags` - указание дополнительных опций (для нормальной работы достаточно указать значение 0)

В `sendto` параметр:
* `to` - указывает на структуру, содержащую адрес сокета, на который нужно отправить данные (адрес получателя сообщения). Используется при этом структура типа, соответствующего избранному семейству адресации: `sockaddr_in` для `AF_INET` и `sockaddr_un` для `AF_UNIX` и т.д. 
* `tolen` - должен быть равен размеру этой структуры. Тип `socklen_t` обычно описан в системных заголовочных файлах как синоним типа `int`.

В `recvfrom` 
* `from` - указывает на структуру, в которую вызову следует записать адрес отправителя полученного пакета (позволяет узнать откуда пришел пакет).
* `fromlen` - указатель на переменную типа `socklen_t`, причем перед вызовом `recvfrom` в эту переменную следует занести размер адресной структуры, на которую указывает предыдущий параметр.
* После возврата из `recvfrom` переменная будет содержать количество байтов, которые вызов в итоге в эту структуру записал.

> При использовании протокола UDP передан может быть только пакет ограниченного размера.

Установка тайм аута для `recvfrom`:
```
struct timeval tv;
tv.tv_sec = 3; /* полные секунды */
tv.tv_usec = 500000; /* микросекунды */
setsockopt(sd, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
```
Здесь мы установили для сокета `sd` тайм-аут на чтение (получение дейтаграммы) в 3.5 секунды. Подробности об этом способе можно найти, например, дав команду `man 7 socket`.

### Потоковые сокеты. Клиент-серверная модель
При установлении соединения ядро ОС, которая обслуживает программу-сервер, создает еще один сокет, который и будет использоваться для передачи данных по только что установленному соединению.

На стороне сервера сокет нужно создать вызовом `socket` с соответствующими параметрами и связать его вызовом `bind` с конкретным адресом, на котором будут приниматься соединения. Затем сокет следует перевести в слушающий режим с помощью `listen`:
```
int listen(int sd, int qlen);
```
* `sd` - связанный с сокетом файловый дескриптор
* `qlen` - размер очереди непринятых запросов на соединение. (В Linux максимум 128)

Принятие соединения - `int accept(int sd, struct sockaddr *addr, socklen_t *addrlen);`
* `sd` - дескриптор слушающего сокета
* `addr` - структура для записи адреса сокета, с которым установлено соединение
* `addrlen` - перед вызовом `accept` в эту переменную следует занести размер адресной структуры, на которую указывает предыдущий параметр. Будет содержать количество байт, которые вызов в итоге в эту структуру записал.
* Возвращает файловый дескриптор нового сокета, созданного специально для обслуживания вновь установленного соединения (или -1 в случае ошибки).

> Если на момент выполнения `accept` запросов на соединение еще не поступило, вызов блокирует вызвавший процесс и ожидает поступления запроса на соединение, возвращая управление только после того, как такой запрос поступит и соединение будет установлено.

Клиентская программа должна, как и сервер, создать сокет вызовом `socket`. Связывать сокет с конкретным адресом в этом случае не обязательно, хотя и возможно. Если этого не сделать, система выберет адрес автоматически. 

Запрос на соединение формируется вызовом `connect` - `int connect(int sd, struct sockaddr *addr, int addrlen);`
* `sd` - связанный с сокетом файловый дескриптор
* `addr` - указывает на структуру, содержащую адрес сервера. При этом используется структура типа, соответствующая избранному семейству адресации: `sockaddr_in` для `AF_INET`, `sockaddr_un` для `AF_UNIX`.
* `addrlen` - должен быть равен размеру этой структуры.
* Возвращает 0 в случае успеха, -1 в случае ошибки.

После установления соединения для передачи по нему данных можно использовать вызовы `read`, `write`, а также `recv`, `send` у которых есть дополнительный параметр `flags`.


> Вызов `connect` можно применять также к дейтаграммным сокетам. Поведение сокета меняется. Сокет намертво привязывается к единственному (указанному в вызове `connect`) адресу партнера по коммуникации. При чтении из сокета теперь получаем дейтаграммы, обратным адресом в которых указан партнер по соединению, а все остальные сбрасывает. Для передачи и приема дейтаграммы используются `read`, `write` или `send/recv`, а не `sendto/recvfrom`.

Завершить работу с дескриптором сокета - `close`

> Закрытие дескриптора не означает закрытие соединения и вообще прекращения использования сокета, ведь с одним и тем же сокетом связано больше одного дескриптора.

> В разных процессах дескрипторы, связанные с одним и тем же потоком ввода/вывода (объектом ядра), появляются при создании нового процесса с помощью `fork`, а в одном процессе в результате `dup`, `dup2`.

Если мы закроем все дескрипторы, связанные с сокетом, системе придется закрыть соединение и уничтожить объект сокета. Точнее говоря, вызов `close` вернет управление  сразу же, но сокет может исчезнуть не сразу: система сначала передаст "на тот конец" соединения все данные, которые еще не переданы, а затем, отправив партнеру извещение о закрытии соединения, окончательно ликвидирует сокет как объект ядра.

> Когда наш партнер по соединению закрыл свой сокет, очередной вызов чтения (`read` или `recv`) вернет нам значение 0, соответствтующее ситуации "конец файла".

Несколько иной подход к завершению обмена информацией через установленное соединение реализует системный вызов `shutdown`:
```
int shutdown(ind sd, int how);
```
* `sd` - дескриптор сокета
* `how`:

1. `SHUT_RD` - прекращает прием данных через сокет

2. `SHUT_WR` - прекращает передачу данных

3. `SHUT_RDWR` - закрывает обмен данными в обеих направлениях

> В отличие от `close` вызов `shutdown` относится  к сокету как к объекту ядра, а не как к отдельному дескриптору.

Вызов `shutdown` не уничтожает ни объект сокета, ни связанные с ним дескрипторы. Т.е. не отменяет последующей необходимости вызова `close`.


### О залипании TCP порта
Система сокетов позволяет изменить поведение ядра в отношении адресов, находящихся в состоянии `TIME_WAIT`. Для этого нужно перед вызовом `bind` выставить на будущем слушающем сокете опцию `SO_REUSEADDR`. Это делается с помощью системного вызова `setsockopt`:
```
int setsockopt(int sd, int level, int optname, const void *optval, int optlen);
```
* `sd` - дескриптор сокета
* `level` - слой стека протоколов (в данном случае это уровень сокетов - `SOL_SOCKET`)
* `optname` - имя устанавливаемой опции, в данном случае - `SO_REUSEADDR`.
* Поскольку информация, связанная с нужной опцией, может иметь произвольную сложность, вызов принимает нетипизированный указатель на значение опции и длину опции (параметры `optval` и `optlen` соответственно). 

Значением опции в данном случае будет целое число 1, так что следует завести переменную типа `int`, присвоить её значение 1 и передать в качестве `optval` адрес этой переменной, а в качестве `optlen` - выражение `sizeof(int)`. В итоге наш вызов будет выглядеть так:
```
int opt = 1;
setsockopt(ls, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
```

### Сокеты для связи родственных процессов
Создает сразу два сокета, между которыми уже установлено соединение:
```
int socketpair(int af, int type, int protocol, int sv[2]);
```
* `af` - семейство адресации
* `type` - тип создаваемых сокетов
* `protocol` - протокол создаваемых сокетов.
> Например `AF_UNIX, SOCK_STREAM, 0`
* `sv[2]` - указывает на массив из двух элементов типа `int`, в которые вызов занесет файловые дескрипторы двух созданных сокетов.
* Возвращает 0 если успех, -1 если провал.

> Сокеты создаются уже связанные друг с другом, причем оба конца открыты как на чтение так и на запись

> В отличие от `pipe`, результат работы `socketpair` отличается тем, что создаваемое соединение оказывается двухсторонним, в остальном принципы работы с ним совершенно такие же. Предполагается, что после создания такой пары сокетов процесс породит одного или более потомков, а передача информации через созданное соединение будет производиться либо между потомком и предком, либо между потомками одного предка(процесса, обратившегося к `socketpair`).

### Проблема очередности действий и её решение
Можно с помощью вызова `fcntl` перевести все сокеты в неблокирующий режим:
```
flags = fcntl(sd, F_GETFL);
fcntl(sd, F_SETEL, flags | O_NONBLOCK);
```
Для сокетов в неблокирующем режиме вызовы `read` и `accept` всегда возвращают управление немедленно, ничего не ожидая. Если не было данных или входящего соединения, возвращается ошибка. Вызов `write` на неблокирующем сокете также возвращает управление немедленно, если ему не удалось записать ни одного байта, он завершается с ошибкой (возвращает -1), если хотя бы один байт был записан, вызов  считается успешным, и возвращает количество записанных байтов.

> Когда все сокеты настроены как неблокирующие, можно их опрашивать по очереди в бесконечном цикле. Это называется **активным ожиданием**. *Но такой вариант неприемлим в многозадачных системах*.

Мы можем **создать отдельный процесс** для обслуживания каждого пришедшего клиента.

Аналогичный вариант в программировании называется **мультиплексированием ввод-вывода**.

### Решение на основе обслуживающих процессов
Главный процесс находится большую часть времени в вызове `accept`. Приняв очередное соединение, он порождает процесс для обслуживания этого соединения. После этого родительский процесс закрывает сокет клиентского соединения, а порожденный процесс закрывает слушающий сокет. Все обязанности по обслуживанию пришедшего клиента возлагаются на порожденный процесс. После завершения сеанса связи с клиентом этот процесс завершается. Все это время родительский процесс продолжает исполнять обязанности, вызывая `accept`. Код:
```
int ls;
struct sockaddr_in addr;
ls = socket(AF_INET, SOCK_STREAM, 0);
if(ls == -1) {
  /* ... ошибка */
}
addr.sin_family = AF_INET;
addr.sin_port = htons(port);
addr.sin_addr.s_addr = htonl(INADDR_ANY);
if(-1 == bind(ls, &addr, sizeof(addr)) {
  /* ... ошибка .. */
}
for(;;) {
  socklen_t slen = sizeof(addr);
  int cls = accept(ls, &addr, &slen);
  if(fork() == 0) { /* облсуживающий процесс */
    close(ls);
    /* ...
      работаем с клиентом через сокет cls
      Клиент пришел с адреса, хранящегося
      теперь в структуре addr
      ...
    */
    exit(0);
  }
  /* родительский процесс */
  close(cls);
  /* проверить, не завершились ли какие либо
    процессы потомки(убрать зомби) */
  while(wait4(-1, NULL, WHOHANG, NULL)>0)
    {}  /* тело цикла пустое */
}
```
### Событийно-управляемое программирование 
Способ построения программ, при котором программа имеет главный цикл, одна итерация которого соответствует наступлению некоторого события из определенного множества, а все действия программы построены как реакция на событие, называется событийно-управляемым программированием.

### Выборка событий в OS Unix
Когда в роли событий рассматривается готовность нескольких потоков ввода-вывода к очередным операциям, а сами операции ввода-вывода становятся реакцией на эти событтия, говорят о мультиплексировании ввода-вывода.

В Unix выборку событий можно организовать с помощью системных вызовов `select` и `poll`.

`select` позволяет обрабатывать события 3 типов:
* изменение состояния файлового дескприптора
* истечение заданного количества времени с момента входа в вызов
* получение процессом неигнорируемого сигнала

```
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exfds, struct timeval *timeout)
```
### Сеанс работы как конечный автомат
При реализации конечных автоматов в программах состоянием соответствует значения переменных.
Пример:
```
enum fsm_states {
  fsm_states,
  fsm_name = fsm_start,
  fsm_age,
  fsm_town,
  fsm_band
};
```
Конечный автомат не может управлять поступлением событий.

Пример программы, ведущей диалог с пользователем:
```
#define INBUFSIZE 1024

struct session {
  int fd;
  char buf[INBUFSIZE];
  int buf_used;
  enum fsm_states state;
  char *name, *town, *band;
  int age;
};
```
### Неблокирующее установление соединения
`connect` в неблокирующем режиме, если вернет -1 и `errno` равен ERRORPROGRESS то норм

Далее вызов `int getsockopt(int sockfd, int level, int optname, void *optval, socklen_t *optlen);`

Итоговое обращение:
```
int opt;
socklen_opt = sizeof(opt);

getsockopt(sd, SOL_SOCKET, SO_ERROR, &opt, &optlen);
```

### Сигналы в роли событий
`int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);`
`int pselect(int n, fd_set *readfds, fd_set *writefds, fd_set *exfds, const struct timeval *timeout, const sigset_t *sigmask);`

### Многопоточное программирование
Конкретный результат зависит от последовательности событий в независимых процессах (ситуация гонок, состязаний).

Под критической секцией понимается такая часть программы, в которой производятся логически связанные манипуляции с разделяемыми данными.

Мьютекс - объект имеющий 2 состояния (открыт/заперт), имеющий 2 операции `lock`, `unlock`. Они атомарны.
```
while(!lock(s)) {} /* Ждем, пока не получим мьютекс */
section(); /* критическая секция */
unlock(s); /* разрешаем другим процессам доступ */
```
Блокирующий тип реализации `lock`
```
lock(s); /* получаем мьютекс */
section(); /* критическая секция */
unlock(s); /* разрешаем другим процессам доступ */
```

Подавляющее большинство операций блокировки и разблокировки мьютексов не требует обращения к ядру.

