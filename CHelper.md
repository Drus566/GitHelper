### Секции `man` 
* 1 - описывает программы и команды, которые установлены в системе
* 2 - содержит описания системных вызовов
* 3 - функции стандартной библиотеки си
* 5 - описания форматов файлов
* 8 - описания команд, предназначенных для системного администратора
Пример вызова для стандратной библиотеки Си:
```
man 3 printf
```
### Компиляция
`gcc -Wall -g <название файла который компилируем> -o <название файла в который все компилируется>`
* `-Wall` включает все разумные предупреждения
* `-g` включает всю отладочную информацию

Пример: `gcc -Wall -g hello.c -o hello`
### Подключение библиотеки при компиляции
`gcc -Wall -g -lm -Calc.c -o calc`
* `-lm` - подключение библиотеки (математической в этом случае)

### Функция вывода 
```
printf("%d times %d is %d\n", x, x, x * x);
```
* `%d` - параметр как целое число
* `%x` - параметр как шестнадцетиричное число
* `%f` - параметр как число с точкой, а `%.5f` - сколько знаков после запятой
* `%c` - печать символа

### Функция ввода
`scanf` - возвращает число, успешно обслуженных введенных данных ("процентов"). Например:
```
n = scanf("%lf %lf %lf", &p, &q, &r);
if(n != 3){
  printf("Error: wrong input.\n");
  return 1;
}
```

* `%f` - число с точкой
* `%lf` - длинное число с точкой
### Операция взятия адреса 
`&t` - взятие адреса с переменной `t`

### Инициализация
`var t = 25`
> Если в описании переменной нет инициализатора, то её исходное значение зависит от того, локальная она или глобальная. **Глобальные переменные**, для которых начальное значение не задано, заполняются нулями. **Локальные переменные** в отсутствии инициализаторов никаких начальных значений не получают, то есть в локальной переменной может оказаться абсолютно произвольный мусор. (**Уточнение страница 217 Столяров том 2**)
### Типы данных
#### Логические значения (их нет)
* 0 - ложь
* Все остальное - истина
Пример для проверки значения:
```
a = <целое число>
if(a != 0)
// одно и то же что и
if(a)
```
> Также можно использовать адресное выражение. **Нулевой указатель** - ложь, а любой другой указатель - истину.

#### Символьные значения
Символ и его код это одно и то же
Например символ обозначается как `'a'`, но это для компилятора то же самое что и `'97'` (Код `a` в ASCII таблице)

#### Разрядность
* `char` - 1 байт (или минимальный адресуемый размер памяти)
* `unsigned char` - беззнаковый (от 0 до 255)
* `signed char` - знаковый (от -128 до 127)
* `short` - 2 байт (или не может быть меньше `char`)
* `unsigned short` (иногда пишут `unsigned short int x`)
* `int` - 4 байт
* `unsigned int`
* `long` - 6 байт
* `unsigned long`
* `long long` - 6 байт
* `unsigned long long`
* `float`
* `double`
* `long double` - от 12 до 16 байт
> Математические функции (`sqrt`, синусы, косинусы и т.д.) по умолчанию работают с типом `double`. Также для любых вычислений  и простой передачи параметров значений типа `float` все преобразуется к типу `double`, следовательно использовать тип `float` бессмысленно, его используют только в случае если таких чисел много, а памяти не хватает.
> `sizeof(<тип>)` - выражение данного вида, компилятор заменяет на число, равное размеру данного типа (единицей измерения является `char`).

### Литералы(константы) разных типов
Простейший пример - целое число как оно есть.
* Восьмеричное - 035 (впереди ноль)
* Шестнадцатиричное - 0x1d (впереди 0x)

* Литералов типа `char` нет, символы имеют тип `int`
* Литералы типа `short`, `unsigned short` не предусмотрены

> Можно явно указать тип литерала `L(long)`,`LL(long long)`, `U(unsigned)`, `F(float)`, например `15ULL` - тип `unsigned long long`.

> **Числа с плавающей точкой** записываются в виде литералов в десятичной системе счисления, например:
```
1500.0 1500. 15E2 15.E2 15E+2 0.15e4 .15e4 15000e-4
```
#### Escape последовательности
* Символ перевода строки - `\n` или 10
* Возврат каретки - `\r` или 13
* Табуляция - `\t` или 9
* Звонок - `\a` или 7
* Забой - `\b` или 8
* Перевод страницы - `\f` или 12
* Вертикальная табуляция - `\v` или 11

#### Представление символов
* Обратный слеш - `'\\'`
* Апостроф - `'\''`
* Кавычки - `'\"'` или `'"'`
> Строки и символы - разные сущности, например `'z'` представляется кодом символа, а `"z"` представляется двумя символами - кодом символа, и кодом окончания строки (0).

> Строковые литералы записанные через пробел скеливаются - `"This " "is" " a string"` = `This is a string`.

### Операции и выражения
* операция взятия адреса - `&`, например `&a`
* операция разыменования - `*`, если `p` это адрес, то `*p`- то, что расположено по этому адресу.
* операция выборки поля из структуры или объединения обозначается точкой, например `item1.next`
* операция выборки поля из структуры или объединения по имеющемуся адресу обозначается стрелкой `->`, например `a->b` - то же самое, что и `(*a).b`.
* взятие остатка от деления - `%`
> операции сравнения всегда возвращают целочисленное число, 1 - истина, 0 - ложь.

### Операторы
* `x = 17` - оператор вычисления выражения ради побочного эффекта, само выражение построено на основе бинарной арифметической операции - присваивания 
* `printf("Hello, world\n")` - оператор вычисления выражения. В качестве выражения здесь выступает бинарная версия вызова функции(первый аргумент `printf`, второй аргумент литерал `"Hello, world\n"`. Мы даже знаем, что у этого выражения есть значение - функция `printf` в результате такого вызова вернет число 13, но оно нам не нужно, о чем мы и сообщаем компилятору, поставив точку с запятой.
* `{}` - составно оператор блок
* `if (<условие>) <оператор1> [else <оператор2>]` - оператор ветвления
* `while (<условие>) <оператор>` - цикл c предусловием (выполняется пока условие не станет ложным)
* `do <оператор> while (<условие>)` - цикл с пост условием, сначала выполняется оператор, затем условие, и если оно истинно, выполнение продолжается сначала. Пример:
```
do {
  get_event(&event);
  res = handle_event(&event);
} while (res != EV_QUIT_NOW);
```
* `for ([ <инциализация]> ; [ <условие> ] ; [ <итерация> ]) <оператор>` - цикл `for`
> Первое из выражений (инициализация) вычисляется перед началом работы цикла. Записывается присваивание начального значения переменной цикла, но можно написать здесь что угодно. Итерация вычисляется после выполнения тела цикла, то есть непосредственно **перед** вычислением условия (но не первоочередного).


* Цикл `for` с применением операции запятая `,`. Пример:
```
for (i = 0, j = arr_len - 1; i < j; i++, j++ {
  int t;
  t = arr[i];
  arr[i] = arr[j];
  arr[j] = t;
}
```
* `break;` - оператор выхода из цикла
* `continue` - досрочно завершает выполнение цикла, цикл продолжается со следующей итерации (т.е. игнорирует остаток тела цикла).
* `return <выражение>` - возврат функции. В случае функции тип возвращаемого значения которой `void`, пишется просто `return;` если не обходимо выйти досрочно, а если нет, то не пишется ничего.
* `goto <метка>;` - оператор безусловного перехода
> Оператор `goto` использовать не стоит, но есть два случая когда он полезен. 1 выход из нескольких вложенных друг в друга конструкций. 2 освобождение локально захваченных ресурсов перед досрочным завершением подпрограммы.

* `switch (<выражение>) {<метки и операторы>}` - оператор выбора
> операторы в теле `switch` представляют собой единую секцию операторов, которая выполняется от метки, соответствующей, вычисленному значению выражения, и до конца тела `switch`, если только выполнение не будет прервано с помощью выполнения какого нибудь оператора, например `break;`. Пример:
```
switch(t) {
case 1:
  printf("First\n");
case 2:
  printf("Second\n");
case 3:
  printf("Third\n");
case 4: 
  printf("Fourt\n");
case 5: 
  printf("Fifth\n");
default:
  printf("Mode\n");
}
// при t = 4, вывод следующий:
Fourth
Fifth
More
```
### Локальные статические переменные
* Глобальные переменные описываются вне блока кода, и живут до конца исполнения программы.
* Локальные переменные описываются в блоках и живут во время исполнения блока кода.
* Локальные статические переменные, описываются в блоках и живут до конца исполнения программы. Она сохраняет свое значение между вызовами функции. Пример описания - `static int zz = 25`. Например:
```
void print_next_number()
{
  static int n = 0;
  printf("%d\n", n);
  n++;
}
// при вызове функции будет итерировать значение n, первый вызов возвращает 1, второй 2 и т.д.
```
### Указатели и операции над ними
* `int *p` - адрес `int` в переменной `p`. Пример:
```
char *s1, *s2, *s3;
// указатели
```
* Операция взятия адреса - `&`
* Операция разыменования - `*` 
Пример:
```
int x;
int *p
// заносим адрес x в указатель p
p = &x
// заносим значение 27 в область памяти int, расположенную по адресу p, то есть в переменную x
*p = 27
```
* `NULL` - нулевой адрес, является ложью в логических выражениях

### Массивы
В языке Си массивов нет.
```
int m[20];
```
Выше `m` обозначает не сам массив, а адрес его первого элемента.
Если мы создадим указатель и просвоим ему имя массива `m`, то этот указатель также будет указывать на первый элемент массива, пример:
```
int *p;
p = m;
p[0] == m[0] // true
// или
*p == *m // true 
```
> В языке Си к типизированному адресному выражению можно прибавить целое число, при этом адрес меняется на размер типа, например `char*` на 1 байт, а `int*` на 4 байта. Т.е. добавление единицы к адресу элемента, даст адрес следующего элемента. Т.о. `m` - адрес первого элемента, `m + 1` - адрес второго элемента и т.д. Получается можем обращаться к элементам массива через разыменования: `*m`, `*(m + 1)`, `*(m + 2)`, будет то же самое что и `m[0]`, `m[1]`, `m[2]` и т.д.

> Выражние `a[b]` означает то же самое что и `*(a + b)`, поэтому вместо `m[17]` можем написать `17[m]`, и компилятор выдаст одно и то же значение.

> Единственная осмысленная ситуация в которой имя массива соответствует всему массиву как единому объекту - это применение к имени массива псевдофункции `sizeof` - в этом случае выдается размер всего массива целиком (в байтах).

> Индексирование это операция над адресом, а не над массивом.

#### Инициализатор массивов
Все элементы инициализатора обязаны быть константами времени компиляции, т.е. не может быть переменных, вызовов функций, выражений, которые не смогут вычислятся во время компиляции.
```
int m[2] = { 1, 2 };
int m[] = { 1, 2, 3 };
```
> Узнать количество элементов массива можно поделив размер массива (в байтах) на размер его элемента (в байтах): `sizeof(m)/sizeof(m[0])` или `sizeof(m)/sizeof(*m)`. Например пример кода с печатью элементов массива:
```
for(i = 0; i < sizeof(m)/sizeof(*m); i++)
  printf("[%d] = %d\n", i, m[i]);
```
> **Инициализация и присваивание не одно и то же**. Массиву нельзя таким образом ничего присвоить, как в инициализации, конструкция из фигурных скобок и списка значений не является в Си выражением и не может встречаться в других выражениях.

> Инициализировать можно также в блоке, но данные будут копироваться в область памяти в стековом фрейме каждый раз в начале выполнения такой функции.

### Динамическая память
В самом языке Си нет средств работы с динамической память, они вынесены в библиотеку.
* `void *malloc(int size);` - выделение памяти. Принимает размер необходимой области памяти. Возвращает адрес начала выделенной памяти. Возвращает нетипизированный адрес. Например:
```
double *k;
k = malloc(360*sizeof(double));
// k указывает после присваивания на свежевыделенную область памяти, где могут поместится 360 элементов double
for (i = 0; i < 360; i++)
  k[i] = sin((2*M_PI/360.0) * (double)i);
// заполнили памятить синусами с интервалом в один градус.
```
* `void free(void *p);` - освобождение памяти. Принимает адрес, ранее возвращенный функцией `malloc`. Например освободить массив выше, можно так:
```
free(k);
```
> Размер области памяти, библиотека хранит где-то у себя, так что указывать его не требуется.

> Эти функции расположены в `stdlib.h`

### Модификатор `const`
Используется чтобы запретить изменение некоторой области памяти. 
* Константная переменная `int`, пример:
```
const int iteration_count = 78;
```
* Указатель на константную область памяти, пример:
```
const int *p;
// или
int * const q;
```
> `const` находит применение в описаниях формальных параметров функций, например:
```
// такая функция что-то сделает с переданной ей областью памяти
void suspicious_func(int *a);
// а эта функция не собирается ничего делать
void trustworthy_func(const int *a);
```

> Но слово `const` ничего не гарантирует, т.к. можно изменить тип адресного выражения на любой другой, в том числе не предполагающий константности. Слово `const` можно воспринимать как обещание не менять соответствующую область памяти.

### Строки
Строка - массив элементов типа `char` с нулем в конце, который означает конец строки.
* `strlen(s);` - подсчет длины строки, находится в библиотеке `string.h`. 
Пример написания своей функции вычисляющей длину строки:
```
// тип возвращаемого значения int - длина строки, тип параметра указатель на строку (первая ячейка памяти типа char), при этом const дает понять что менять строку по адресу мы не собираемся.
int string_length(const char *str)
{
  int i;
  i = 0;
  while(str[i] != '\0')
    i++;
  return i;
}
// или логичнее будет использовать цикл for
int string_length(const char *str)
{
  int i;
  for (i = 0; str[i]; i++)
    {}
  return i;
}
// а также можно написать так
int string_length(const char *str)
{
  const char *p;
  for(p = str; *p; p++)
    {}
  return p - str;
}
```
* `strcopy` - функция копирования строки в `string.h`.
Пример функции копирования строки:
```
void string_copy(char *dest, const char *src)
{
  int i;
  for(i = 0; src[i]; i++)
    dest[i] = src[i];
  dest[i] = 0;
}
// или так
void string_copy(char *dest, const char *src)
{
  for(; *src; dest++, src++)
    *dest = *src;
  *dest = 0;
}
// или даже так
void string_copy(char *dest, const char *src)
{
  while((*dest++ = *src++));
}
```
### Строковые литералы
Строковый литерал может применяться в качестве инициализатора массива элементов типа `char`, `signed char`, `unsigned char`, и при этом, компилятор не станет размещать его в неизменяемой памяти (даже если массив будет объявлен со словом `const`). Например:
```
// создаст массив из шести элементов
char str[6] = "Hello";
// и это тоже
char str[6] = { 'H', 'e', 'l', 'l', 'o', 0 };
// число обозначающее размерность массива можно опустить
char str[] = "Hello";
// но это НЕ то же самое что и 
char *ptr = "Hello";
// т.е. описывается указатель, который инициализируется адресом строкого литерала, тогда как сам литерал при этом воспринимается компилятором согласно 
// общим правилам, и всё сказанное про неизменяемые области памяти снова обретают силу.
str[4] = 0 // превратит слово в Hell
ptr[4] = 0 // это попытка в запись строкового литерала, что приведет к ошибке.
```
### Обработка аргументов командной строки
ОС отводит в адресном пространстве специальную область памяти, в которой располагает строки, составляющие командную строку. Получить доступ к этой области памяти можно, описав функцию `main` как имеющую параметры, причем первый из этих параметров должен иметь тип `int`, он задает количество элементов командной строки. Второй параметр представляет собой адрес начала массива из указателей на сами строки (слова), составляющие командную строку.
Например:
```
int main(int argc, char **argv);
```
Пример программы печати аргументов:
```
#include <stdio.h>
int main(int argc, char **argv)
{
  int i;
  for(i = 1; i < argc; i++)
    printf("[%s]\n", argv[i]);
  return 0;
}
// %s означает печать строки, расположенной в памяти по адресу, который берется из очередного аргумента.
// или 
#include <stdio.h>
int main(int argc, char **argv)
{
  while(*++argv)
    printf("[%s]\n", *argv);
  return 0;
}
```
### Посимвольный ввод-вывод
* `int getchar()` - ввод данных
> Если `getchar()` успешно прочитала один байта, то она его вернет, интерпретируя в беззнаковое целое число от 0 до 255

* `ctrl + D` - ситуация конца файла, или `-1` или `EOF`
> Значение, возвращенное функцией `getchar`, нельзя сразу присваивать переменной типа `char`, это приведет к потере информации. Такое присваивание можно сделать лишь когда мы убедились что возвращено значение, отличное от `EOF`.
Пример программы:
```
#include <stdio.h>
int main()
{
  int c, n;
  n = 0;
  while ((c = getchar()) != EOF) {
    if (c == '\n') {
      printf("%d\m", n);
      n = 0;
    else {
      n++;
    }
  }
  return 0;
}
```

* `int putchar(int c)` - операция вывода символа в стандартный поток.
> параметр задает код выводимого символа, формально он имеет тип `int`, но на самом деле числа за пределами диапазона значений `unsigned char` (в реально жизни это всегда диапазон `0..255`) будут превращены в числа этого диапазона путем отбрасывания "лишних" битов, так что давать их этой функциини к чему. Функция возвращает код выведенного символа, если все в порядке, а если произошла ошибка, то уже знакомую нам константу `EOF`. 
Пример программы:
```
#include <stdio.h>
int main() 
{
  int c, pr;
  pr = 1;
  while((c = getchar()) != EOF) {
    switch(c) {
    case '\n':
      putchar('\n');
      pr = 1;
      break;
    case ' ':
      pr = 0;
      break;
    default:
      if(pr)
        putchar(c);
    }
  }
  return 0;
}
```
### Форматированный ввод-вывод
* `int printf(const char *format, ...);` - формальный прототип `printf`, многоточие означает, что в этом месте может быть еще сколько угодно параметров, такие функции обычно называются **вариодическими**.
> Работа функции `printf` управляется форматной строкой, можно сказать, что функция представляет собой интерпретатор форматной строки. Формально говоря, форматная строка состоит из **форматных директив**, которые делятся на *обычные символы* (любые байты, кроме нулевого и символа `'%'`) и *директивы преобразования*, которые начинаются с символа `'%'` и заканчиваются *спецификатором преобраования*, в роли которого могут выступать символы `diouxXeEfFgGcsp%`. Например:
```
printf("[%5d]", 12) 
// выведет
[   12]

printf("%3d", 1234)
// выведет
1234
```

*Спецификатор преобразования* указывает какого типа значение следует извлечь из списка фактических параметров функции(т.е. из очередной позиции стека) и в каком виде представить это значение на печати.

*Внутри директивы преобразования*, то есть между символом `%` и символом спецификации формата, могут быть указаны дополнительные параметры форматирования:
* Флаги - набор из символов `'-'`, `'+'`, `'0'`, `'#'` и пробел. Например:
```
printf("[%-5d]", 12) 
// выведет
[12   ]

printf("[%05d]", 12)
// выведет
[00012]

printf("%+d,%+d", 12, -3)
// выведет
+12, -3

// пробел, означает что для знака нужно оставить место, но печатать его только для отрицательных чисел, а положительные предварять пробелом.
printf("[% d], [% d]", 12, -3)
// выведет
[ 12], [-3]
```
* Целое число, задающее ширину поля (кол-во знакомест, отведенное для данного параметра)
* Десятичная точка и целое число, задающее так называемую точность представления. Например:
```
printf("[%7.5s]", "abrakadabra")
// выведет
[  abrak] // т.е от строки взято 5 символов в соответствии с заданной точностью

printf("[%-7.5s]", "abrakadabra") 
// выведет
[abrak  ]

printf("[%6.4d]", 12)
// выведет
[  0012]
```

* Модификатор разрядности - `h` (`short`, `unsigned short`), `l` (`long`, `unsigned long`), `ll` (`long long`, `unsigned long long`), `L` (`long double`)
> Различать `float` и `double` не требуется, поскольку `float` преобразуется к `double`

Пример модификатора разрядности:
```
// Пример директивы в которой существуют все возможные части, 2 флага (пробел и #), ширина 7, точность 4, модификатор разрядности L, символ спецификатор преобразования g.
% #4.7Lg 
```

> Отметим особенность `printf("%*.*d", w, p, n)` напечатает число `n` с использованием ширины взятой из `w` и точности `p`.

* Форматированный ввод из стандартного потока - `int scanf(const char *format, ...);`. Доп информация в Строляров том2 стр 279. Возвращает количество успешно преобразованных и помещенных в память значений, либо -1, если достигнут конец файла или произошла ошибка при чтении. Например `scanf("%d %d %d", &a, &b, &c)` может вернуть `-1`, если не успев прочитать ни одного числа, она уперлась в конец файла, она вернет `0`, если при попытке проанализировать первое же число она встретила ошибочный ввод (буквы, знаки или другой элемент, который не может быть истолкован как число), значение `1` будет возвращено, если первое число было успешно прочитано, а белиберда встретилась при чтении второго, и т.д., в случае полного успеха возвращается значение `3`.

> В общем `scanf` сложная штука, не стоит использовать её в своих программах

> Указание ширины поля при чтении строк абсолютно обязательно, учитывая что массив должен быть на один элемент больше, для конечного нуля.

### Работа с текстовыми файлами
* `FILE* fopen(const char *name, const char *mode);` - операция открытия файла для высокоуровневого ввода-вывода. Возвращает адрес типа `FILE*`. Если вернул `NULL`, значит произошла ошибка. Первый параметр - имя файла, если оно начинается со слеша `/` то путь относительно коренвой директории, если слеша нет, то путь относительно текущей директории. Второй параметр режим открытия файла, их бывает несколько:
1. `r` - только для чтения
2. `r+` - на чтение и запись, работа начнется с начала файла
3. `w` - открытие файла на запись, если файла не было, он создается, если существовал, старое содержимое удаляется
4. `w+` - файл открывается на чтение и запись, например записав что-то в файл, можно принудительно спозиционироваться и прочитать записанные данные.
5. `a` - открывает файл на добавление информации в конец, если файла не существовало, он создается
6. `a+` - файл открывается на чтение и запись, чтение начинается с начала файла, а запись с конца.
> Реализация функции `fopen` в системах Unix допускает букву `b`, которая по идее должна означать, что открываемый файл следует рассматривать как двоичный, а не текстовый.

Пример открытия файла:
```
FILE *f;
f = fopen("file.txt", "r");
if(!f) {
  perror("file.txt");
  exit(1);
}
```
* Операция закрытия файла - `int fclose(FILE *f);`
* Ввод-вывод отдельных символов:
```
int fgetc(FILE *stream);
int fputc(int c, FILE *stream);
```
* Возвращает только что прочитанный символ обратно в поток - `int ungetc(int c, FILE *stream);`

Пример чтения и записи файла:
```
#include <stdio.h>

int main(int argc, char **argv)
{
	FILE *from, *to;
	int c, lnum;
	lnum = 1;
	if (argc < 3) {
		fprintf(stderr, "Too few arguments\n");
		return 1;
	}
	from = fopen(argv[1], "r");
	if (!from) {
		perror(argv[1]);
		return 2;
	}
	to = fopen(argv[2], "w");
	if (!to) {
		perror(argv[2]);
		return 3;
	}
	lnum = 1;
	while (lnum <= 10 && (c = fgetc(from)) != EOF) {
		fputc(c, to);
		if (c == '\n')
			lnum++;
	}
	return 0;
}
```
Пример форматированного ввод-вывода:
```
#include <stdio.h>
#include <math.h>

int main()
{
	FILE *f;
	int grad;
	f = fopen("sincos.txt", "w");
	if(!f) {
		perror("sincos.txt");
		return 1;
	}
	for (grad = 0; grad < 360; grad++) {
		double rads = (double)grad * M_PI / 180.0;
		double s = sin(rads);
		double c = cos(rads);
		fprintf(f, "%03d % 7.5f % 7.5f\n", grad, s, c);
	}
	fclose(f);
	return 0;
}
```
Пример программы, получает на вход открытый поток ввода, рассматривая его как последовательность представлений целых чисел, подсчитывает, во-первых, сумму этих чисел, и, во-вторых, их количество. Чтение выполняется до тех пор, пока попытка чтения очередного числа по тем или иным причинам не оканчиывается неудачно. Поскольку вернуть нужно два числа, возврат производится через параметры:
```
void intfilesum(FILE *f, int *sum, int *count)
{
  int n;
  *count = 0;
  *sum = 0;
  while(fscanf(f, "%d", &n) == 1) {
    *sum += n;
    *count++;
  }
}
```
> Любую функцию (как библиотечную, так и собственную), которая рассчитана на работу с потоком типа `FILE *`, можно применить к одному из стандартных потоков ввода-вывода. Для этого в стандартной библиотеке описаны, а в заголовочном файле объявлены три глобальные переменные типа `FILE*`:
* `stdin` - поток стандартного ввода
* `stdout` - поток стандартного вывода
* `stderr` - поток ошибок(диагностический поток)

### Ввод-вывод отдельных строк
* Выдает заданную строку в заданный поток вывода - `int fputs(const char *s, FILE *stream);`
* Читает строку из заданного потока ввода и размещает прочитанное в памяти - `char *fgets(char *s, int size, FILE *stream);`, первый параметр - область памяти, в которую хотим поместить прочитанную строку, второй параметр - сколько элементов массиве, адрес которого является первый параметр.
> Получив свои параметры, `fgets` читает из заданного потока ввода не более `size-1` символов. Чтение прекращается, если символ оказался символом перевода строки (`\n` код `10`) то он заносится в массив как обыкновенный символ (при этом функция возвращает тот же адрес, который она получила через первый параметр), либо если символ не удалось прочитать (ошибка(в этом случае возвращается `NULL`) или конец файла), либо если прочитано максимальное количество символов.

Пример чтение из потока `f1` и записи в поток `f2`:
```
void string50(FILE *f1, FILE *f2)
{
	char buf[51];
	while(fgets(buf, sizeof(buf), f1)) {
		int i;
		int nlpos = -1;
		for (i = 0; i < sizeof(buf) && buf[i]; i++)
			if(buf[i] == '\n') {
				nlpos = i;
				break;
			}
		}
		if (nlpos == -1) {
			int c;
			fputc('\n', f2);
			while((c = fgetc(f1)) != EOF && c != '\n')
			{}
		else {
			buf[nlpos] = '\0';
			fprintf(f2, "[%s]\n", buf);
		}
	}
}
```
Аналоги двух верхних функций:
* `int puts(const char *s);` - выдает также символ перевода строки в конце
* `getc` - её нельзя использовать, так как она не проверяет длинну строки, и подвержена атакам **buffer overflow exploit**.

### О буферизации ввода-вывода
Например `getchar` прочитает все, что пользователь набрал, при этом отдаст нам один байт, а при следующем вызове не станет обращаться к ОС, а отдаст следующий байт. То же самое происходит при записи в поток вывода.

* `int fflush(FILE *stream);` - вытеснения буфера в явном виде. Очищает буфер вывода, связанный с потоком, данные будут отправлены по назначению.
> Очистка всех буферов происходит при корректном завершении программы

* Проверка, находится ли по ту сторону терминал - `isatty`
> Если вывод происходит на терминал, буфер вывода вытесняется при выводе символа перевода строки и при выполнении операции ввода, причем тоже на терминале. Для потоков не связанных с терминалом, этого не происходит.

### Вывод в строку и ввод из строки
Следующие функции анализируют форматную строку, по мере необходимости извлекая значения из списка своих параметров (то есть из стека), но результат преобразования в текстовое представление никуда не выводится, а вместо этого складывается в предоставленный строковый буфер.
* `int sprintf(char *buf, const char *format, ...);` - возвращает количество, выведенных символов (длину строки), сформированных в буфере (*нулевой байт не учитывается*). Часто используют для перевод числа в текстовое представление, например:
```
char str[32];
int n;
/*...*/
sprintf(str, "%d", n);
```

> Обеспечить буфер нужного размера - обязанность вызывающего.

> В более новых стандартах `C99` есть функция `snprintf` она принимает размер буфера.

> Также `sprintf` используют для формирования данных в массиве `char`, перед передачей в ОС для ввода-вывода низкого уровня.

* `int sscanf(const char *buf, const char *format, ...);` - проделывает противоположную операцию, то есть анализирует строку в соответствии с заданным форматом, раскладывает полученные результаты по адресам из списка параметров.

> Правила интерпретации форматной строки совпадают с таковыми для `scanf`, роль ситуации конца файла играет преждевременное окончание строки `buf`, то есть если строка кончилась раньше, чем функция успешно проанализировала хотя бы одну директорию преобразования, возвращается `-1`.

### Блочный ввод-вывод
Чтение и запись бинарных файлов:
* `int fread(void *ptr, int size, int n, FILE *stream);`
* `int fwrite(const void *ptr, int size, int n, FILE *stream);`
`*stream` задает файл, с которым нужно работать, `n` количество элементов которые нужно прочитать или записать, `size` размер каждого элемента, `ptr` - область куда запишется или откуда будет взята информация для записи - эта область памяти обязана иметь размер `size*n` байт. Функции возвращают количество успешно записанных элементов (не байтов). Если произошла ошибка возвращают ноль.

Отличить ошибочную ситуацию от ситуации конца файла, можно с помощью:
* `int feof(FILE *stream);`
* `int ferror(FILE *stream);`
Возвращают не нулевое значение (истину) если возникла ситуация конец файла или ошибка, в противном случае возвращается ноль (ложь).
* `int fseek(FILE *stream, long offset, int whence);` - изменяет текущую позицию в файле. Возвращает новое значение текущей позиции, считая от начала файла.

> Удобнее работать с функциями `fread` и `fwrite` при размере элемента (`size`) в 1 байт.

### Ввод-вывод низкого уровня
Системные вызовы (Unix):
* `int open(const char *name, int mode);`
* `int open(const char *name, int mode, int perms);` - возвращает -1, если ошибка, если файл открылся возвращается небольшое цело неотрицательно число - номер файлового дескриптора.
* `int read(int fd, void *mem, int len);` - 1 параметр - файловый дескриптор, 2 - область памяти, куда размещаются прочитанные данные, 3 - размер этой области памяти. Возвращает -1 в случае ошибки. Если успешно возвращается целое число - количество прочитанных байтов. Возвращает 0 в ситуации конца файла.
* `int write(int fd, const void *data, int len);` - 1 параметр - файловый дескриптор, 2 - область памяти, содержащий данные которые нужно записать в файл, 3 - количество данных. -1 в случае ошибки, количество записанных байтов в случае успеха.
* `int lseek(int fd, int offset, int whence);` 1 параметр - файловый дескриптор, 2 - смещение, 3 - с какого места следует отсчитывать байты:
1. `SEEK_SET` - от начала файла
2. `SEEK_CUR` - от текущей позиции
3. `SEEK_END` - от конца файла.
Пример программы - чтение последних 100 байт:
```
int rc;
char buf[100];
/*...*/
lseek(fd, -100, SEEK_END);
rc = read(fd, buf, 100);
```
> Можно создать "дырку" между последними данными перед старым концом файла и первыми данными, записанными с новой позиции. Т.о. можно создать на мегабайтной дискете файл размером в гигабайт. В Unix такие дырки не заполняются реальными данными и не занимают места на диске, пока кто нибудь не произведет операцию записи.

* `int close(int fd)` - закрытие файла. 0 в случае успеха, -1 в случае ошибки.

> При завершении процесса, все открытые файлы закрываются автоматически.

Режимы открытия файла:
* `O_RDONLY` - только чтение
* `O_WRONLY` - только запись
* `O_RDWR` - чтение и запись

Модифицирующие константы:
* `O_APPEND` - запись в конец
* `O_CREAT` - разрешить создание файла, если его нет
* `O_TRUNC` - уничтожить старое содержимое файла
* `O_EXCL` - создание нового файла, если файл уже есть, то выдает ошибку

Значения `umask`:
* `022` - запись у автора, остальные чтение и выполнение
* `027` - запрет доступа к новосоздаваемым файлам, не входящих в группу пользователей
* `077` - сбрасывание всех прав доступ для всех, кроме владельца

Значения `perms`:
* `0666` - права на чтение и запись (но не исполнение) для владельца, группы и всех остальных.
* `0600` - запрещает любой доступ к создаваемому файлу для кого-либо кроме владельца.

> Функции низкоуровневого ввода вывода различают файл по *файловым дескрипторам*. Это небольшие неотрицательные числа (0, 1, 2, ...)

### Ханойские башни
```
#include <stdio.h>
#include <stdlib.h>

static void solve(int source, int target, int interm, int n)
{
	if(n == 0)
		return;
	solve(source, interm, target, n-1);
	printf("%d: %d -> %d\n", n, source, target);
	solve(interm, target, source, n-1);
}

int main(int argc, char **argv)
{
	int n;
	if(argc < 2) {
		fprintf(stderr, "No parameter given\n");
		return 1;
	}
	n = atoi(argv[1]);
	if (n < 1) {
		fprintf(stderr, "Incorrect token count\n");
		return 2;
	}
	solve(1, 3, 2, n);
	return 0;
}
```

### Перечислимый тип
Пример - `enum colors { red, orange, yellow, green, blue, violet };`. `colors` - имя перечисления, но не имя типа. Имя типа здесь `enum colors`. Можем описать переменную нового типа так: `enum colors one_color;`.
> Идентификаторы в перечислимом типе, являются целочисленными константами, тоесть имеют тип `int`. Т.е. `red` = 0, `orange` = 1 и т.д.

Некторые предпочитают не вводить переменные и функции типа `enum`, обходясь обычными `int`, описания перечислимых типов используют для создания констант, например:
```
enum { alpha, beta, gamma }
```
> Значения констант, можно указать явно:

```
enum colors {
	red = 0xff0000
}
```

> Две константы из одного и того же перечисления могут иметь одинаковые значения.

В одном описании можно смешивать константы с указанием значения и без такового:
```
enum numbers { one = 1, two, three, first = 1, second, third };
```
> Идентификаторы `two` и `second` будут иметь значение 2, а `three` и `third` значение 3.

При указании значения , можно использовать любую константу времени компиляции:
```
enum example_enum {
	example_first = 1000,
	example_second = example_first * 20
};
```
> Точкой с запятой в СИ должно заканчиваться любое объявление или описание, за исключением описания функции, в котором вместо точки с запятой фигурирует тело функции.

В Си не различаются конструкции описания типа и описания переменной, например можно описать типа, а за ним переменные:
```
// также помимо типа, описываются переменные типа enum state: news_state, last_state.
enum states {
	running, blocked, ready
} new_state, last_state;
```
### Перечислимый тип как средство описания констант
`enum { max_buffer_size = 1024 };` - перечислимые типа используются для описания констант. Но есть минус, что так описываются только целочисленные константы.

### Перечислимый тип и оператор выбора
Компилятор предполагает, что если выражение, по которому проводится выбор в операторе `switch`, имеет перечислимый тип, то в теле `switch` должны присутствовать все `case` метки для всех различных значений, или метка `default`.

### Структуры
Переменные, состоящие из элементов составного типа, называются **полями**.
* `struct [<имя>] {<список_полей>} [<список_переменных>];` - структура. Пример описания структуры:
```
enum { max_name_len = 64, max_group_len = 8 };
/*...*/
struct student {
	char name[max_name_len];
	char sex;
	int year_of_birth;
	int major_code;
	int year;
	char group[max_group_len];
	float average;
};
```
Введенный тип имеет имя, состоящее из двух слов `struct student`, например описать переменную типа можно так `struct student st1;`. Доступ к полям осуществляется через точку:
```
st1.sex = 'm';
st1.year_of_birth = 1995;
st1.major_code = 51311;
```
**Переменные** структурного типа можно инициализировать при описании:
```
struct student st1 = {
	"Otlichnikov Vasya Sergeich",
	'm', 1995, 51311, 3, "312", 4.729
};
// подобные конструкции допустимы при инициализации, но не при присваивании.
```
> Присваивать структурные элементы друг другу в отличие от массива можно. Также структуры можно передавать в функции в качестве параметров, а также возвращать из функций. Но передавать в функцию лучше все таки адерс структуры.

> Что касается возврата из функции, то обычно делают иначе, в функцию передают адрес структурной переменной, и функция заполняет её поля нужно информацией.

Выделение памяти под динамическую структуру:
```
struct student *ptr;
ptr = malloc(sizeof(struct student));
// или так 
struct student *ptr;
ptr = malloc(sizeof(*ptr));
```
Обращение к полю структуры через указатель:
```
struct student *p;
(*p).year;
// или
struct student *p;
p->year
```
### Односвязные списки
Простейшая из всех связных динамических структур данных - односвязный список.
Список целых чисел можно построить из такой структуры:
```
struct item {
	int data;
	struct item *next;
};
```
Пример функции построения списка из массива целых чисел:
```
struct item *int_array_to_list(int *arr, int len)
{
	struct item *first = NULL, *last = NULL, *tmp;
	int i;
	for (i = 0; i < len; i++) {
		// выделяем память, заполняем поля (заполнять поля нужно сразу после создания структуры)
		tmp = malloc(sizeof(struct item));
		tmp->data = arr[i],
		tmp->next = NULL;
		if(last) {
			last->next = tmp;
			last = last->next;
		} else {
			first = last = tmp;
		}
	}
	return first;
}

// или можно сделать так
struct item *int_array_to_list(int *arr, int len)
{
	struct item *first = NULL, *tmp;
	int i;
	// берем числа с конца массива и создаем односвязный список с конца.
	for(i = len-1; i >= 0; i--) {
		tmp = malloc(sizeof(struct item));
		tmp->data = arr[i];
		tmp->next = first;
		// равняем адрес first = tmp
		first = tmp;
	}
	// возвращаем 1 элемент списка
	return first;
}
```
Создание списка с помощью рекурсии:
```
struct item *int_array_to_list(int *arr, int len)
{
	struct item *tmp;
	if(!len)	
		return NULL;
	tmp = malloc(sizeof(struct item));
	tmp->data = *arr;
	tmp->next = int_array_to_list(arr + 1, len - 1);
	return tmp;
}
```
Пример суммы всех элементов списка:
```
int int_list_sum(const struct item *1st)
{
	int sum = 0;
	const struct item *tmp = 1st;
	while(tmp) {
		sum += tmp->data;
		tmp = tmp->next;
	}
	return sum;
}

// или например так
int int_list_sum(const struct item *1st)
{
	int sum = 0;
	const struct item *tmp;
	for(tmp = 1st; tmp; tmp = tmp->next)
		sum += tmp->data;
	return sum;
}

// или даже так
int int_list_sum(const struct item *1st)
{
	int sum = 0;
	for(; 1st; 1st = 1st->next)
		sum += 1st->data;
	return sum;
}
```

Суммирование элементов списка через рекурсию:
```
int int_list_sum(const struct item *1st)
{
	if(1st)
		return 1st->data + int_list_sum(1st->next);
	else
		return 0;
}

// или так
int int_list_sum(const struct item *1st)
{
	return 1st ? 1st->data + int_list_sum(1st->next) : 0;
}
```
Удаление элементов списка
```
void delete_int_list(struct item *1st)
{
	while(1st) {
		struct item *tmp = 1st;
		1st = 1st->next;
		free(tmp);
	}
}

// или так
void delete_int_list(struct item *1st)
{
	while(1st) {
		struct item *tmp = 1st->next;
		free(1st);
		1st = tmp;
	}
}
```
Удаление элементов списка с помощью рекурсии:
```
void delete_int_list(struct item *1st)
{
	if(!1st)
		return;
	delete_int_list(1st->next);
	free(1st);
}

// или так
void delete_int_list(struct item *1st)
{
	if(1st) {
		delete_int_list(1st->next);
		free(1st);
	}
}
```
Пример удаления всех отрицательных чисел из списка:
```
// Указатель на текущий элемент(по сути это указатель на указатель)
struct item **pcur;

void delete_negatives_from_int_list(struct item **pcur)
{
	while(*pcur) { // пока то, на что он указывает, не равно NULL
		if ((*pcur)->data < 0) { // если элемент надо удалить
			struct item *tmp = *pcur;  // запоминаем его АДРЕС
			*pcur = (*pcur)->next; // исключаем из списка
			free(tmp); // удаляем
			// при этом адрес уже стал текущим
		} else {
			pcur = &(*pcur)->next;
		}
	}
}
delete_negatives_from_int_list(&first) // вызов функции
```
Удаление всех отрицательных чисел с помощью рекурсии
```
void delete_negatives_from_int_list(struct item **pcur)
{
	if(!*pcur)
		return;
	delete_negatives_from_int_list(&(*pcur)->next);
	if((*pcur)->data < 0) {
		struct item *tmp = *pcur;
		*pcur = (*pcur)->next;
		free(tmp);
	}
}
```
### Двусвязные списки
Пример:
```
struct dbl_item {
	double data;
	struct dbl_item *prev, *next;
};
```
Пример внесения элемента в начало:
```
struct dbl_item *first = NULL, *last = NULL;
struct dbl_item *current = NULL, *tmp;

tmp = malloc(sizeof(struct dbl_item));
tmp->data = x;
tmp->prev = NULL;
tmp->next = first;
if(first)
	first->prev = tmp;
else	
	last = tmp;
first = tmp;
```
Внесение в конец:
```
tmp = malloc(sizeof(struct dbl_item));
tmp->data = x;
tmp->prev = last;
tmp->next = NULL;
if(last)
	last->next = tmp;
else
	first = tmp;
last = tmp;
```
Изъятие первого элемента двусвязного списка:
```
if(first) {
	tmp = first;
	first = first->next;
	if(first)
		first->prev = NULL;
	else 
		last = NULL;
	free(tmp);
}
```
Изъятие последнего элемента:
```
if(last) {
	tmp = last;
	last = last->prev;
	if(last)
		last->next = NULL;
	else	
		first = NULL;
	free(tmp);
}
```
Удаление всех элементов списка:
```
if(first) {
	first = first->next;
	while(first){
		free(first->last);
		first = first->next;
	}
	free(last);
	last = NULL;
}
```
Вставка элемента перед текущим:
```
tmp = malloc(sizeof(struct_dbl_item));
tmp->data = x;
tmp->next = current;
tmp->prev = current->prev;
current->prev = tmp;
if(tmp->prev)
	tmp->prev->next = tmp;
else
	first = tmp;
```
Вставка после текущего:
```
tmp = malloc(sizeof(struct dbl_item));
tmp->data = x;
tmp->prev = current;
tmp->next = current->next;
current->next = tmp;
if(tmp->next)
	tmp->next->prev = tmp;
else
	last = tmp;
```
Удаление текущего элемента:
```
if (current->prev)
	current->prev->next = current->next;
else
	first = current->next;
if (current->next)
	current->next->prev = current->prev;
else
	last = current->prev;
free(current);
current = NULL;
```

### Простое бинарное дерево поиска
Бинарное дерево поиска состоит из узлов, в каждом из которых присутствуют указатели на левое и правое поддеревья, а также полезная информация. Например:
```
struct node {
	int val;
	struct node *left, *right;
};
```
Пример прохода по дереву и печать его значений с помощью рекурсий:
```
void int_bin_tree_print_rec(struct node *r) {
	if(!r)
		return;
	int_bin_tree_print_rec(r->left);
	printf("%d ", r->val);
	int_bin_tree_print_rec(r->right);
}
```
Добавление нового элемента в дерево:
```
void int_bin_tree_add(struct node **root, int n)
{
	if(!*root) {
		*root = malloc(sizeof(**root));
		(*root)->val = n;
		(*root)->left = NULL;
		(*root)->right = NULL;
		return;
	}
	if((*root)->val == n)
		return;
	if(n < (*root)->val)
		int_bin_tree_add(&(*root)->left, n);
	else 
		int_bin_tree_add(&(*root)->right, n);
}
```

### Объединение и вариантные структуры
Под *объединением* (union) в Си понимается такой типа данных, переменная которого может хранить значение одного из нескольких типов, но только одно в каждый момент. Отличие от структур в том, что поля объединенного адреса расположены в памяти начиная с одного и того же адреса, с которого начинается само объединение. Тоесть присваивание значения любому из полей объединения затирает остальные его поля.

Пример:
```
struct expression_item {
	char c;
	union un_data {
		int i;
		double d;
		char var[sizeof(double)];
	} data;
	struct expression_item *next;
};

enum expr_item_types
	{ eit_int = 0, eit_dbl = 1, eit_var = 2, eit_min_op = ' ' };
// если пишем калькулятор, то перечислением будет значением поля структуры c, и в зависимости от него, будет выбираться соответствующее поле объединения.
```
Структура с анонимным объединением:
```
struct expression_item {
	char c;
	union {
		int i;
		double d;
		char var[sizeof(double)];
	};
	struct expression_item *next;
};
// теперь для структуры типа struct expression_item доступны поля c, i, d, var, next, при этом из трех полей i, d, var можно использовать только какое то одно,
// поскольку они занимают одну и ту же память.
```
### Битовые поля


