### Секции `man` 
* 1 - описывает программы и команды, которые установлены в системе
* 2 - содержит описания системных вызовов
* 3 - функции стандартной библиотеки си
* 5 - описания форматов файлов
* 8 - описания команд, предназначенных для системного администратора
Пример вызова для стандратной библиотеки Си:
```
man 3 printf
```
### Компиляция
`gcc -Wall -g <название файла который компилируем> -o <название файла в который все компилируется>`
* `-Wall` включает все разумные предупреждения
* `-g` включает всю отладочную информацию

Пример: `gcc -Wall -g hello.c -o hello`
### Подключение библиотеки при компиляции
`gcc -Wall -g -lm -Calc.c -o calc`
* `-lm` - подключение библиотеки (математической в этом случае)

### Функция вывода 
```
printf("%d times %d is %d\n", x, x, x * x);
```
* `%d` - параметр как целое число
* `%x` - параметр как шестнадцетиричное число
* `%f` - параметр как число с точкой, а `%.5f` - сколько знаков после запятой
* `%c` - печать символа

### Функция ввода
`scanf` - возвращает число, успешно обслуженных введенных данных ("процентов"). Например:
```
n = scanf("%lf %lf %lf", &p, &q, &r);
if(n != 3){
  printf("Error: wrong input.\n");
  return 1;
}
```

* `%f` - число с точкой
* `%lf` - длинное число с точкой
### Операция взятия адреса 
`&t` - взятие адреса с переменной `t`

### Инициализация
`var t = 25`
> Если в описании переменной нет инициализатора, то её исходное значение зависит от того, локальная она или глобальная. **Глобальные переменные**, для которых начальное значение не задано, заполняются нулями. **Локальные переменные** в отсутствии инициализаторов никаких начальных значений не получают, то есть в локальной переменной может оказаться абсолютно произвольный мусор. (**Уточнение страница 217 Столяров том 2**)
### Типы данных
#### Логические значения (их нет)
* 0 - ложь
* Все остальное - истина
Пример для проверки значения:
```
a = <целое число>
if(a != 0)
// одно и то же что и
if(a)
```
> Также можно использовать адресное выражение. **Нулевой указатель** - ложь, а любой другой указатель - истину.

#### Символьные значения
Символ и его код это одно и то же
Например символ обозначается как `'a'`, но это для компилятора то же самое что и `'97'` (Код `a` в ASCII таблице)

#### Разрядность
* `char` - 1 байт (или минимальный адресуемый размер памяти)
* `unsigned char` - беззнаковый (от 0 до 255)
* `signed char` - знаковый (от -128 до 127)
* `short` - 2 байт (или не может быть меньше `char`)
* `unsigned short` (иногда пишут `unsigned short int x`)
* `int` - 4 байт
* `unsigned int`
* `long` - 6 байт
* `unsigned long`
* `long long` - 6 байт
* `unsigned long long`
* `float`
* `double`
* `long double` - от 12 до 16 байт
> Математические функции (`sqrt`, синусы, косинусы и т.д.) по умолчанию работают с типом `double`. Также для любых вычислений  и простой передачи параметров значений типа `float` все преобразуется к типу `double`, следовательно использовать тип `float` бессмысленно, его используют только в случае если таких чисел много, а памяти не хватает.
> `sizeof(<тип>)` - выражение данного вида, компилятор заменяет на число, равное размеру данного типа (единицей измерения является `char`).

### Литералы(константы) разных типов
Простейший пример - целое число как оно есть.
* Восьмеричное - 035 (впереди ноль)
* Шестнадцатиричное - 0x1d (впереди 0x)

* Литералов типа `char` нет, символы имеют тип `int`
* Литералы типа `short`, `unsigned short` не предусмотрены

> Можно явно указать тип литерала `L(long)`,`LL(long long)`, `U(unsigned)`, `F(float)`, например `15ULL` - тип `unsigned long long`.

> **Числа с плавающей точкой** записываются в виде литералов в десятичной системе счисления, например:
```
1500.0 1500. 15E2 15.E2 15E+2 0.15e4 .15e4 15000e-4
```
#### Escape последовательности
* Символ перевода строки - `\n` или 10
* Возврат каретки - `\r` или 13
* Табуляция - `\t` или 9
* Звонок - `\a` или 7
* Забой - `\b` или 8
* Перевод страницы - `\f` или 12
* Вертикальная табуляция - `\v` или 11

#### Представление символов
* Обратный слеш - `'\\'`
* Апостроф - `'\''`
* Кавычки - `'\"'` или `'"'`
> Строки и символы - разные сущности, например `'z'` представляется кодом символа, а `"z"` представляется двумя символами - кодом символа, и кодом окончания строки (0).

> Строковые литералы записанные через пробел скеливаются - `"This " "is" " a string"` = `This is a string`.

### Операции и выражения
* операция взятия адреса - `&`, например `&a`
* операция разыменования - `*`, если `p` это адрес, то `*p`- то, что расположено по этому адресу.
* операция выборки поля из структуры или объединения обозначается точкой, например `item1.next`
* операция выборки поля из структуры или объединения по имеющемуся адресу обозначается стрелкой `->`, например `a->b` - то же самое, что и `(*a).b`.
* взятие остатка от деления - `%`
> операции сравнения всегда возвращают целочисленное число, 1 - истина, 0 - ложь.

### Операторы
* `x = 17` - оператор вычисления выражения ради побочного эффекта, само выражение построено на основе бинарной арифметической операции - присваивания 
* `printf("Hello, world\n")` - оператор вычисления выражения. В качестве выражения здесь выступает бинарная версия вызова функции(первый аргумент `printf`, второй аргумент литерал `"Hello, world\n"`. Мы даже знаем, что у этого выражения есть значение - функция `printf` в результате такого вызова вернет число 13, но оно нам не нужно, о чем мы и сообщаем компилятору, поставив точку с запятой.
* `{}` - составно оператор блок
* `if (<условие>) <оператор1> [else <оператор2>]` - оператор ветвления
* `while (<условие>) <оператор>` - цикл c предусловием (выполняется пока условие не станет ложным)
* `do <оператор> while (<условие>)` - цикл с пост условием, сначала выполняется оператор, затем условие, и если оно истинно, выполнение продолжается сначала. Пример:
```
do {
  get_event(&event);
  res = handle_event(&event);
} while (res != EV_QUIT_NOW);
```
* `for ([ <инциализация]> ; [ <условие> ] ; [ <итерация> ]) <оператор>` - цикл `for`
> Первое из выражений (инициализация) вычисляется перед началом работы цикла. Записывается присваивание начального значения переменной цикла, но можно написать здесь что угодно. Итерация вычисляется после выполнения тела цикла, то есть непосредственно **перед** вычислением условия (но не первоочередного).


* Цикл `for` с применением операции запятая `,`. Пример:
```
for (i = 0, j = arr_len - 1; i < j; i++, j++ {
  int t;
  t = arr[i];
  arr[i] = arr[j];
  arr[j] = t;
}
```
* `break;` - оператор выхода из цикла
* `continue` - досрочно завершает выполнение цикла, цикл продолжается со следующей итерации (т.е. игнорирует остаток тела цикла).
* `return <выражение>` - возврат функции. В случае функции тип возвращаемого значения которой `void`, пишется просто `return;` если не обходимо выйти досрочно, а если нет, то не пишется ничего.
* `goto <метка>;` - оператор безусловного перехода
> Оператор `goto` использовать не стоит, но есть два случая когда он полезен. 1 выход из нескольких вложенных друг в друга конструкций. 2 освобождение локально захваченных ресурсов перед досрочным завершением подпрограммы.

* `switch (<выражение>) {<метки и операторы>}` - оператор выбора
> операторы в теле `switch` представляют собой единую секцию операторов, которая выполняется от метки, соответствующей, вычисленному значению выражения, и до конца тела `switch`, если только выполнение не будет прервано с помощью выполнения какого нибудь оператора, например `break;`. Пример:
```
switch(t) {
case 1:
  printf("First\n");
case 2:
  printf("Second\n");
case 3:
  printf("Third\n");
case 4: 
  printf("Fourt\n");
case 5: 
  printf("Fifth\n");
default:
  printf("Mode\n");
}
// при t = 4, вывод следующий:
Fourth
Fifth
More
```
### Локальные статические переменные
* Глобальные переменные описываются вне блока кода, и живут до конца исполнения программы.
* Локальные переменные описываются в блоках и живут во время исполнения блока кода.
* Локальные статические переменные, описываются в блоках и живут до конца исполнения программы. Она сохраняет свое значение между вызовами функции. Пример описания - `static int zz = 25`. Например:
```
void print_next_number()
{
  static int n = 0;
  printf("%d\n", n);
  n++;
}
// при вызове функции будет итерировать значение n, первый вызов возвращает 1, второй 2 и т.д.
```
### Указатели и операции над ними
* `int *p` - адрес `int` в переменной `p`. Пример:
```
char *s1, *s2, *s3;
// указатели
```
* Операция взятия адреса - `&`
* Операция разыменования - `*` 
Пример:
```
int x;
int *p
// заносим адрес x в указатель p
p = &x
// заносим значение 27 в область памяти int, расположенную по адресу p, то есть в переменную x
*p = 27
```
* `NULL` - нулевой адрес, является ложью в логических выражениях

### Массивы
В языке Си массивов нет.
```
int m[20];
```
Выше `m` обозначает не сам массив, а адрес его первого элемента.
Если мы создадим указатель и просвоим ему имя массива `m`, то этот указатель также будет указывать на первый элемент массива, пример:
```
int *p;
p = m;
p[0] == m[0] // true
// или
*p == *m // true 
```
> В языке Си к типизированному адресному выражению можно прибавить целое число, при этом адрес меняется на размер типа, например `char*` на 1 байт, а `int*` на 4 байта. Т.е. добавление единицы к адресу элемента, даст адрес следующего элемента. Т.о. `m` - адрес первого элемента, `m + 1` - адрес второго элемента и т.д. Получается можем обращаться к элементам массива через разыменования: `*m`, `*(m + 1)`, `*(m + 2)`, будет то же самое что и `m[0]`, `m[1]`, `m[2]` и т.д.

> Выражние `a[b]` означает то же самое что и `*(a + b)`, поэтому вместо `m[17]` можем написать `17[m]`, и компилятор выдаст одно и то же значение.

> Единственная осмысленная ситуация в которой имя массива соответствует всему массиву как единому объекту - это применение к имени массива псевдофункции `sizeof` - в этом случае выдается размер всего массива целиком (в байтах).

> Индексирование это операция над адресом, а не над массивом.

#### Инициализатор массивов
Все элементы инициализатора обязаны быть константами времени компиляции, т.е. не может быть переменных, вызовов функций, выражений, которые не смогут вычислятся во время компиляции.
```
int m[2] = { 1, 2 };
int m[] = { 1, 2, 3 };
```
> Узнать количество элементов массива можно поделив размер массива (в байтах) на размер его элемента (в байтах): `sizeof(m)/sizeof(m[0])` или `sizeof(m)/sizeof(*m)`. Например пример кода с печатью элементов массива:
```
for(i = 0; i < sizeof(m)/sizeof(*m); i++)
  printf("[%d] = %d\n", i, m[i]);
```
> **Инициализация и присваивание не одно и то же**. Массиву нельзя таким образом ничего присвоить, как в инициализации, конструкция из фигурных скобок и списка значений не является в Си выражением и не может встречаться в других выражениях.

> Инициализировать можно также в блоке, но данные будут копироваться в область памяти в стековом фрейме каждый раз в начале выполнения такой функции.

### Динамическая память
В самом языке Си нет средств работы с динамической память, они вынесены в библиотеку.
* `void *malloc(int size);` - выделение памяти. Принимает размер необходимой области памяти. Возвращает адрес начала выделенной памяти. Возвращает нетипизированный адрес. Например:
```
double *k;
k = malloc(360*sizeof(double));
// k указывает после присваивания на свежевыделенную область памяти, где могут поместится 360 элементов double
for (i = 0; i < 360; i++)
  k[i] = sin((2*M_PI/360.0) * (double)i);
// заполнили памятить синусами с интервалом в один градус.
```
* `void free(void *p);` - освобождение памяти. Принимает адрес, ранее возвращенный функцией `malloc`. Например освободить массив выше, можно так:
```
free(k);
```
> Размер области памяти, библиотека хранит где-то у себя, так что указывать его не требуется.

> Эти функции расположены в `stdlib.h`

### Модификатор `const`
Используется чтобы запретить изменение некоторой области памяти. 
* Константная переменная `int`, пример:
```
const int iteration_count = 78;
```
* Указатель на константную область памяти, пример:
```
const int *p;
// или
int * const q;
```
> `const` находит применение в описаниях формальных параметров функций, например:
```
// такая функция что-то сделает с переданной ей областью памяти
void suspicious_func(int *a);
// а эта функция не собирается ничего делать
void trustworthy_func(const int *a);
```

> Но слово `const` ничего не гарантирует, т.к. можно изменить тип адресного выражения на любой другой, в том числе не предполагающий константности. Слово `const` можно воспринимать как обещание не менять соответствующую область памяти.

### Строки
Строка - массив элементов типа `char` с нулем в конце, который означает конец строки.
* `strlen(s);` - подсчет длины строки, находится в библиотеке `string.h`. 
Пример написания своей функции вычисляющей длину строки:
```
// тип возвращаемого значения int - длина строки, тип параметра указатель на строку (первая ячейка памяти типа char), при этом const дает понять что менять строку по адресу мы не собираемся.
int string_length(const char *str)
{
  int i;
  i = 0;
  while(str[i] != '\0')
    i++;
  return i;
}
// или логичнее будет использовать цикл for
int string_length(const char *str)
{
  int i;
  for (i = 0; str[i]; i++)
    {}
  return i;
}
// а также можно написать так
int string_length(const char *str)
{
  const char *p;
  for(p = str; *p; p++)
    {}
  return p - str;
}
```
* `strcopy` - функция копирования строки в `string.h`.
Пример функции копирования строки:
```
void string_copy(char *dest, const char *src)
{
  int i;
  for(i = 0; src[i]; i++)
    dest[i] = src[i];
  dest[i] = 0;
}
// или так
void string_copy(char *dest, const char *src)
{
  for(; *src; dest++, src++)
    *dest = *src;
  *dest = 0;
}
// или даже так
void string_copy(char *dest, const char *src)
{
  while((*dest++ = *src++));
}
```
### Строковые литералы
Строковый литерал может применяться в качестве инициализатора массива элементов типа `char`, `signed char`, `unsigned char`, и при этом, компилятор не станет размещать его в неизменяемой памяти (даже если массив будет объявлен со словом `const`). Например:
```
// создаст массив из шести элементов
char str[6] = "Hello";
// и это тоже
char str[6] = { 'H', 'e', 'l', 'l', 'o', 0 };
// число обозначающее размерность массива можно опустить
char str[] = "Hello";
// но это НЕ то же самое что и 
char *ptr = "Hello";
// т.е. описывается указатель, который инициализируется адресом строкого литерала, тогда как сам литерал при этом воспринимается компилятором согласно 
// общим правилам, и всё сказанное про неизменяемые области памяти снова обретают силу.
str[4] = 0 // превратит слово в Hell
ptr[4] = 0 // это попытка в запись строкового литерала, что приведет к ошибке.
```
### Обработка аргументов командной строки
ОС отводит в адресном пространстве специальную область памяти, в которой располагает строки, составляющие командную строку. Получить доступ к этой области памяти можно, описав функцию `main` как имеющую параметры, причем первый из этих параметров должен иметь тип `int`, он задает количество элементов командной строки. Второй параметр представляет собой адрес начала массива из указателей на сами строки (слова), составляющие командную строку.
Например:
```
int main(int argc, char **argv);
```
Пример программы печати аргументов:
```
#include <stdio.h>
int main(int argc, char **argv)
{
  int i;
  for(i = 1; i < argc; i++)
    printf("[%s]\n", argv[i]);
  return 0;
}
// %s означает печать строки, расположенной в памяти по адресу, который берется из очередного аргумента.
// или 
#include <stdio.h>
int main(int argc, char **argv)
{
  while(*++argv)
    printf("[%s]\n", *argv);
  return 0;
}
```
### Посимвольный ввод-вывод
* `int getchar()` - ввод данных
> Если `getchar()` успешно прочитала один байта, то она его вернет, интерпретируя в беззнаковое целое число от 0 до 255

* `ctrl + D` - ситуация конца файла, или `-1` или `EOF`
> Значение, возвращенное функцией `getchar`, нельзя сразу присваивать переменной типа `char`, это приведет к потере информации. Такое присваивание можно сделать лишь когда мы убедились что возвращено значение, отличное от `EOF`.
Пример программы:
```
#include <stdio.h>
int main()
{
  int c, n;
  n = 0;
  while ((c = getchar()) != EOF) {
    if (c == '\n') {
      printf("%d\m", n);
      n = 0;
    else {
      n++;
    }
  }
  return 0;
}
```

* `int putchar(int c)` - операция вывода символа в стандартный поток.
> параметр задает код выводимого символа, формально он имеет тип `int`, но на самом деле числа за пределами диапазона значений `unsigned char` (в реально жизни это всегда диапазон `0..255`) будут превращены в числа этого диапазона путем отбрасывания "лишних" битов, так что давать их этой функциини к чему. Функция возвращает код выведенного символа, если все в порядке, а если произошла ошибка, то уже знакомую нам константу `EOF`. 
Пример программы:
```
#include <stdio.h>
int main() 
{
  int c, pr;
  pr = 1;
  while((c = getchar()) != EOF) {
    switch(c) {
    case '\n':
      putchar('\n');
      pr = 1;
      break;
    case ' ':
      pr = 0;
      break;
    default:
      if(pr)
        putchar(c);
    }
  }
  return 0;
}
```
### Форматированный ввод-вывод
* `int printf(const char *format, ...);` - формальный прототип `printf`, многоточие означает, что в этом месте может быть еще сколько угодно параметров, такие функции обычно называются **вариодическими**.
> Работа функции `printf` управляется форматной строкой, можно сказать, что функция представляет собой интерпретатор форматной строки. Формально говоря, форматная строка состоит из **форматных директив**, которые делятся на *обычные символы* (любые байты, кроме нулевого и символа `'%'`) и *директивы преобразования*, которые начинаются с символа `'%'` и заканчиваются *спецификатором преобраования*, в роли которого могут выступать символы `diouxXeEfFgGcsp%`. Например:
```
printf("[%5d]", 12) 
// выведет
[   12]

printf("%3d", 1234)
// выведет
1234
```

*Спецификатор преобразования* указывает какого типа значение следует извлечь из списка фактических параметров функции(т.е. из очередной позиции стека) и в каком виде представить это значение на печати.

*Внутри директивы преобразования*, то есть между символом `%` и символом спецификации формата, могут быть указаны дополнительные параметры форматирования:
* Флаги - набор из символов `'-'`, `'+'`, `'0'`, `'#'` и пробел. Например:
```
printf("[%-5d]", 12) 
// выведет
[12   ]

printf("[%05d]", 12)
// выведет
[00012]

printf("%+d,%+d", 12, -3)
// выведет
+12, -3

// пробел, означает что для знака нужно оставить место, но печатать его только для отрицательных чисел, а положительные предварять пробелом.
printf("[% d], [% d]", 12, -3)
// выведет
[ 12], [-3]
```
* Целое число, задающее ширину поля (кол-во знакомест, отведенное для данного параметра)
* Десятичная точка и целое число, задающее так называемую точность представления. Например:
```
printf("[%7.5s]", "abrakadabra")
// выведет
[  abrak] // т.е от строки взято 5 символов в соответствии с заданной точностью

printf("[%-7.5s]", "abrakadabra") 
// выведет
[abrak  ]

printf("[%6.4d]", 12)
// выведет
[  0012]
```

* Модификатор разрядности - `h` (`short`, `unsigned short`), `l` (`long`, `unsigned long`), `ll` (`long long`, `unsigned long long`), `L` (`long double`)
> Различать `float` и `double` не требуется, поскольку `float` преобразуется к `double`

Пример модификатора разрядности:
```
// Пример директивы в которой существуют все возможные части, 2 флага (пробел и #), ширина 7, точность 4, модификатор разрядности L, символ спецификатор преобразования g.
% #4.7Lg 
```

> Отметим особенность `printf("%*.*d", w, p, n)` напечатает число `n` с использованием ширины взятой из `w` и точности `p`.

* Форматированный ввод из стандартного потока - `int scanf(const char *format, ...);`. Доп информация в Строляров том2 стр 279. Возвращает количество успешно преобразованных и помещенных в память значений, либо -1, если достигнут конец файла или произошла ошибка при чтении. Например `scanf("%d %d %d", &a, &b, &c)` может вернуть `-1`, если не успев прочитать ни одного числа, она уперлась в конец файла, она вернет `0`, если при попытке проанализировать первое же число она встретила ошибочный ввод (буквы, знаки или другой элемент, который не может быть истолкован как число), значение `1` будет возвращено, если первое число было успешно прочитано, а белиберда встретилась при чтении второго, и т.д., в случае полного успеха возвращается значение `3`.

> В общем `scanf` сложная штука, не стоит использовать её в своих программах

> Указание ширины поля при чтении строк абсолютно обязательно, учитывая что массив должен быть на один элемент больше, для конечного нуля.

### Работа с текстовыми файлами
* `FILE* fopen(const char *name, const char *mode);` - операция открытия файла для высокоуровневого ввода-вывода. Возвращает адрес типа `FILE*`. Если вернул `NULL`, значит произошла ошибка. Первый параметр - имя файла, если оно начинается со слеша `/` то путь относительно коренвой директории, если слеша нет, то путь относительно текущей директории. Второй параметр режим открытия файла, их бывает несколько:
1. `r` - только для чтения
2. `r+` - на чтение и запись, работа начнется с начала файла
3. `w` - открытие файла на запись, если файла не было, он создается, если существовал, старое содержимое удаляется
4. `w+` - файл открывается на чтение и запись, например записав что-то в файл, можно принудительно спозиционироваться и прочитать записанные данные.
5. `a` - открывает файл на добавление информации в конец, если файла не существовало, он создается
6. `a+` - файл открывается на чтение и запись, чтение начинается с начала файла, а запись с конца.
> Реализация функции `fopen` в системах Unix допускает букву `b`, которая по идее должна означать, что открываемый файл следует рассматривать как двоичный, а не текстовый.

Пример открытия файла:
```
FILE *f;
f = fopen("file.txt", "r");
if(!f) {
  perror("file.txt");
  exit(1);
}
```
* Операция закрытия файла - `int fclose(FILE *f);`
* Ввод-вывод отдельных символов:
```
int fgetc(FILE *stream);
int fputc(int c, FILE *stream);
```
* Возвращает только что прочитанный символ обратно в поток - `int ungetc(int c, FILE *stream);`

Пример чтения и записи файла:
```
#include <stdio.h>

int main(int argc, char **argv)
{
	FILE *from, *to;
	int c, lnum;
	lnum = 1;
	if (argc < 3) {
		fprintf(stderr, "Too few arguments\n");
		return 1;
	}
	from = fopen(argv[1], "r");
	if (!from) {
		perror(argv[1]);
		return 2;
	}
	to = fopen(argv[2], "w");
	if (!to) {
		perror(argv[2]);
		return 3;
	}
	lnum = 1;
	while (lnum <= 10 && (c = fgetc(from)) != EOF) {
		fputc(c, to);
		if (c == '\n')
			lnum++;
	}
	return 0;
}
```
Пример форматированного ввод-вывода:
```
#include <stdio.h>
#include <math.h>

int main()
{
	FILE *f;
	int grad;
	f = fopen("sincos.txt", "w");
	if(!f) {
		perror("sincos.txt");
		return 1;
	}
	for (grad = 0; grad < 360; grad++) {
		double rads = (double)grad * M_PI / 180.0;
		double s = sin(rads);
		double c = cos(rads);
		fprintf(f, "%03d % 7.5f % 7.5f\n", grad, s, c);
	}
	fclose(f);
	return 0;
}
```
Пример программы, получает на вход открытый поток ввода, рассматривая его как последовательность представлений целых чисел, подсчитывает, во-первых, сумму этих чисел, и, во-вторых, их количество. Чтение выполняется до тех пор, пока попытка чтения очередного числа по тем или иным причинам не оканчиывается неудачно. Поскольку вернуть нужно два числа, возврат производится через параметры:
```
void intfilesum(FILE *f, int *sum, int *count)
{
  int n;
  *count = 0;
  *sum = 0;
  while(fscanf(f, "%d", &n) == 1) {
    *sum += n;
    *count++;
  }
}
```
> Любую функцию (как библиотечную, так и собственную), которая рассчитана на работу с потоком типа `FILE *`, можно применить к одному из стандартных потоков ввода-вывода. Для этого в стандартной библиотеке описаны, а в заголовочном файле объявлены три глобальные переменные типа `FILE*`:
* `stdin` - поток стандартного ввода
* `stdout` - поток стандартного вывода
* `stderr` - поток ошибок(диагностический поток)

### Ввод-вывод отдельных строк
* Выдает заданную строку в заданный поток вывода - `int fputs(const char *s, FILE *stream);`
* Читает строку из заданного потока ввода и размещает прочитанное в памяти - `char *fgets(char *s, int size, FILE *stream);`, первый параметр - область памяти, в которую хотим поместить прочитанную строку, второй параметр - сколько элементов массиве, адрес которого является первый параметр.
> Получив свои параметры, `fgets` читает из заданного потока ввода не более `size-1` символов. Чтение прекращается, если символ оказался символом перевода строки (`\n` код `10`) то он заносится в массив как обыкновенный символ (при этом функция возвращает тот же адрес, который она получила через первый параметр), либо если символ не удалось прочитать (ошибка(в этом случае возвращается `NULL`) или конец файла), либо если прочитано максимальное количество символов.

Пример чтение из потока `f1` и записи в поток `f2`:
```
void string50(FILE *f1, FILE *f2)
{
	char buf[51];
	while(fgets(buf, sizeof(buf), f1)) {
		int i;
		int nlpos = -1;
		for (i = 0; i < sizeof(buf) && buf[i]; i++)
			if(buf[i] == '\n') {
				nlpos = i;
				break;
			}
		}
		if (nlpos == -1) {
			int c;
			fputc('\n', f2);
			while((c = fgetc(f1)) != EOF && c != '\n')
			{}
		else {
			buf[nlpos] = '\0';
			fprintf(f2, "[%s]\n", buf);
		}
	}
}
```
Аналоги двух верхних функций:
* `int puts(const char *s);` - выдает также символ перевода строки в конце
* `getc` - её нельзя использовать, так как она не проверяет длинну строки, и подвержена атакам **buffer overflow exploit**.

### О буферизации ввода-вывода
Например `getchar` прочитает все, что пользователь набрал, при этом отдаст нам один байт, а при следующем вызове не станет обращаться к ОС, а отдаст следующий байт. То же самое происходит при записи в поток вывода.

* `int fflush(FILE *stream);` - вытеснения буфера в явном виде. Очищает буфер вывода, связанный с потоком, данные будут отправлены по назначению.
> Очистка всех буферов происходит при корректном завершении программы

* Проверка, находится ли по ту сторону терминал - `isatty`
> Если вывод происходит на терминал, буфер вывода вытесняется при выводе символа перевода строки и при выполнении операции ввода, причем тоже на терминале. Для потоков не связанных с терминалом, этого не происходит.

### Вывод в строку и ввод из строки
Следующие функции анализируют форматную строку, по мере необходимости извлекая значения из списка своих параметров (то есть из стека), но результат преобразования в текстовое представление никуда не выводится, а вместо этого складывается в предоставленный строковый буфер.
* `int sprintf(char *buf, const char *format, ...);` - возвращает количество, выведенных символов (длину строки), сформированных в буфере (*нулевой байт не учитывается*). Часто используют для перевод числа в текстовое представление, например:
```
char str[32];
int n;
/*...*/
sprintf(str, "%d", n);
```

> Обеспечить буфер нужного размера - обязанность вызывающего.

> В более новых стандартах `C99` есть функция `snprintf` она принимает размер буфера.

> Также `sprintf` используют для формирования данных в массиве `char`, перед передачей в ОС для ввода-вывода низкого уровня.

* `int sscanf(const char *buf, const char *format, ...);` - проделывает противоположную операцию, то есть анализирует строку в соответствии с заданным форматом, раскладывает полученные результаты по адресам из списка параметров.

> Правила интерпретации форматной строки совпадают с таковыми для `scanf`, роль ситуации конца файла играет преждевременное окончание строки `buf`, то есть если строка кончилась раньше, чем функция успешно проанализировала хотя бы одну директорию преобразования, возвращается `-1`.

### Блочный ввод-вывод
Чтение и запись бинарных файлов:
* `int fread(void *ptr, int size, int n, FILE *stream);`
* `int fwrite(const void *ptr, int size, int n, FILE *stream);`
`*stream` задает файл, с которым нужно работать, `n` количество элементов которые нужно прочитать или записать, `size` размер каждого элемента, `ptr` - область куда запишется или откуда будет взята информация для записи - эта область памяти обязана иметь размер `size*n` байт. Функции возвращают количество успешно записанных элементов (не байтов). Если произошла ошибка возвращают ноль.

Отличить ошибочную ситуацию от ситуации конца файла, можно с помощью:
* `int feof(FILE *stream);`
* `int ferror(FILE *stream);`
Возвращают не нулевое значение (истину) если возникла ситуация конец файла или ошибка, в противном случае возвращается ноль (ложь).
* `int fseek(FILE *stream, long offset, int whence);` - изменяет текущую позицию в файле. Возвращает новое значение текущей позиции, считая от начала файла.

> Удобнее работать с функциями `fread` и `fwrite` при размере элемента (`size`) в 1 байт.

### Ввод-вывод низкого уровня
Системные вызовы (Unix):
* `int open(const char *name, int mode);`
* `int open(const char *name, int mode, int perms);` - возвращает -1, если ошибка, если файл открылся возвращается небольшое цело неотрицательно число - номер файлового дескриптора.
* `int read(int fd, void *mem, int len);` - 1 параметр - файловый дескриптор, 2 - область памяти, куда размещаются прочитанные данные, 3 - размер этой области памяти. Возвращает -1 в случае ошибки. Если успешно возвращается целое число - количество прочитанных байтов. Возвращает 0 в ситуации конца файла.
* `int write(int fd, const void *data, int len);` - 1 параметр - файловый дескриптор, 2 - область памяти, содержащий данные которые нужно записать в файл, 3 - количество данных. -1 в случае ошибки, количество записанных байтов в случае успеха.
* `int lseek(int fd, int offset, int whence);` 1 параметр - файловый дескриптор, 2 - смещение, 3 - с какого места следует отсчитывать байты:
1. `SEEK_SET` - от начала файла
2. `SEEK_CUR` - от текущей позиции
3. `SEEK_END` - от конца файла.
Пример программы - чтение последних 100 байт:
```
int rc;
char buf[100];
/*...*/
lseek(fd, -100, SEEK_END);
rc = read(fd, buf, 100);
```
> Можно создать "дырку" между последними данными перед старым концом файла и первыми данными, записанными с новой позиции. Т.о. можно создать на мегабайтной дискете файл размером в гигабайт. В Unix такие дырки не заполняются реальными данными и не занимают места на диске, пока кто нибудь не произведет операцию записи.

* `int close(int fd)` - закрытие файла. 0 в случае успеха, -1 в случае ошибки.

> При завершении процесса, все открытые файлы закрываются автоматически.

Режимы открытия файла:
* `O_RDONLY` - только чтение
* `O_WRONLY` - только запись
* `O_RDWR` - чтение и запись

Модифицирующие константы:
* `O_APPEND` - запись в конец
* `O_CREAT` - разрешить создание файла, если его нет
* `O_TRUNC` - уничтожить старое содержимое файла
* `O_EXCL` - создание нового файла, если файл уже есть, то выдает ошибку

Значения `umask`:
* `022` - запись у автора, остальные чтение и выполнение
* `027` - запрет доступа к новосоздаваемым файлам, не входящих в группу пользователей
* `077` - сбрасывание всех прав доступ для всех, кроме владельца

Значения `perms`:
* `0666` - права на чтение и запись (но не исполнение) для владельца, группы и всех остальных.
* `0600` - запрещает любой доступ к создаваемому файлу для кого-либо кроме владельца.

> Функции низкоуровневого ввода вывода различают файл по *файловым дескрипторам*. Это небольшие неотрицательные числа (0, 1, 2, ...)

### Ханойские башни
```
#include <stdio.h>
#include <stdlib.h>

static void solve(int source, int target, int interm, int n)
{
	if(n == 0)
		return;
	solve(source, interm, target, n-1);
	printf("%d: %d -> %d\n", n, source, target);
	solve(interm, target, source, n-1);
}

int main(int argc, char **argv)
{
	int n;
	if(argc < 2) {
		fprintf(stderr, "No parameter given\n");
		return 1;
	}
	n = atoi(argv[1]);
	if (n < 1) {
		fprintf(stderr, "Incorrect token count\n");
		return 2;
	}
	solve(1, 3, 2, n);
	return 0;
}
```

### Перечислимый тип
Пример - `enum colors { red, orange, yellow, green, blue, violet };`. `colors` - имя перечисления, но не имя типа. Имя типа здесь `enum colors`. Можем описать переменную нового типа так: `enum colors one_color;`.
> Идентификаторы в перечислимом типе, являются целочисленными константами, тоесть имеют тип `int`. Т.е. `red` = 0, `orange` = 1 и т.д.

Некторые предпочитают не вводить переменные и функции типа `enum`, обходясь обычными `int`, описания перечислимых типов используют для создания констант, например:
```
enum { alpha, beta, gamma }
```
> Значения констант, можно указать явно:

```
enum colors {
	red = 0xff0000
}
```

> Две константы из одного и того же перечисления могут иметь одинаковые значения.

В одном описании можно смешивать константы с указанием значения и без такового:
```
enum numbers { one = 1, two, three, first = 1, second, third };
```
> Идентификаторы `two` и `second` будут иметь значение 2, а `three` и `third` значение 3.

При указании значения , можно использовать любую константу времени компиляции:
```
enum example_enum {
	example_first = 1000,
	example_second = example_first * 20
};
```
> Точкой с запятой в СИ должно заканчиваться любое объявление или описание, за исключением описания функции, в котором вместо точки с запятой фигурирует тело функции.

В Си не различаются конструкции описания типа и описания переменной, например можно описать типа, а за ним переменные:
```
// также помимо типа, описываются переменные типа enum state: news_state, last_state.
enum states {
	running, blocked, ready
} new_state, last_state;
```
### Перечислимый тип как средство описания констант
`enum { max_buffer_size = 1024 };` - перечислимые типа используются для описания констант. Но есть минус, что так описываются только целочисленные константы.

### Перечислимый тип и оператор выбора
Компилятор предполагает, что если выражение, по которому проводится выбор в операторе `switch`, имеет перечислимый тип, то в теле `switch` должны присутствовать все `case` метки для всех различных значений, или метка `default`.

### Структуры
Переменные, состоящие из элементов составного типа, называются **полями**.
* `struct [<имя>] {<список_полей>} [<список_переменных>];` - структура. Пример описания структуры:
```
enum { max_name_len = 64, max_group_len = 8 };
/*...*/
struct student {
	char name[max_name_len];
	char sex;
	int year_of_birth;
	int major_code;
	int year;
	char group[max_group_len];
	float average;
};
```
Введенный тип имеет имя, состоящее из двух слов `struct student`, например описать переменную типа можно так `struct student st1;`. Доступ к полям осуществляется через точку:
```
st1.sex = 'm';
st1.year_of_birth = 1995;
st1.major_code = 51311;
```
**Переменные** структурного типа можно инициализировать при описании:
```
struct student st1 = {
	"Otlichnikov Vasya Sergeich",
	'm', 1995, 51311, 3, "312", 4.729
};
// подобные конструкции допустимы при инициализации, но не при присваивании.
```
> Присваивать структурные элементы друг другу в отличие от массива можно. Также структуры можно передавать в функции в качестве параметров, а также возвращать из функций. Но передавать в функцию лучше все таки адерс структуры.

> Что касается возврата из функции, то обычно делают иначе, в функцию передают адрес структурной переменной, и функция заполняет её поля нужно информацией.

Выделение памяти под динамическую структуру:
```
struct student *ptr;
ptr = malloc(sizeof(struct student));
// или так 
struct student *ptr;
ptr = malloc(sizeof(*ptr));
```
Обращение к полю структуры через указатель:
```
struct student *p;
(*p).year;
// или
struct student *p;
p->year
```
### Односвязные списки
Простейшая из всех связных динамических структур данных - односвязный список.
Список целых чисел можно построить из такой структуры:
```
struct item {
	int data;
	struct item *next;
};
```
Пример функции построения списка из массива целых чисел:
```
struct item *int_array_to_list(int *arr, int len)
{
	struct item *first = NULL, *last = NULL, *tmp;
	int i;
	for (i = 0; i < len; i++) {
		// выделяем память, заполняем поля (заполнять поля нужно сразу после создания структуры)
		tmp = malloc(sizeof(struct item));
		tmp->data = arr[i],
		tmp->next = NULL;
		if(last) {
			last->next = tmp;
			last = last->next;
		} else {
			first = last = tmp;
		}
	}
	return first;
}

// или можно сделать так
struct item *int_array_to_list(int *arr, int len)
{
	struct item *first = NULL, *tmp;
	int i;
	// берем числа с конца массива и создаем односвязный список с конца.
	for(i = len-1; i >= 0; i--) {
		tmp = malloc(sizeof(struct item));
		tmp->data = arr[i];
		tmp->next = first;
		// равняем адрес first = tmp
		first = tmp;
	}
	// возвращаем 1 элемент списка
	return first;
}
```
Создание списка с помощью рекурсии:
```
struct item *int_array_to_list(int *arr, int len)
{
	struct item *tmp;
	if(!len)	
		return NULL;
	tmp = malloc(sizeof(struct item));
	tmp->data = *arr;
	tmp->next = int_array_to_list(arr + 1, len - 1);
	return tmp;
}
```
Пример суммы всех элементов списка:
```
int int_list_sum(const struct item *1st)
{
	int sum = 0;
	const struct item *tmp = 1st;
	while(tmp) {
		sum += tmp->data;
		tmp = tmp->next;
	}
	return sum;
}

// или например так
int int_list_sum(const struct item *1st)
{
	int sum = 0;
	const struct item *tmp;
	for(tmp = 1st; tmp; tmp = tmp->next)
		sum += tmp->data;
	return sum;
}

// или даже так
int int_list_sum(const struct item *1st)
{
	int sum = 0;
	for(; 1st; 1st = 1st->next)
		sum += 1st->data;
	return sum;
}
```

Суммирование элементов списка через рекурсию:
```
int int_list_sum(const struct item *1st)
{
	if(1st)
		return 1st->data + int_list_sum(1st->next);
	else
		return 0;
}

// или так
int int_list_sum(const struct item *1st)
{
	return 1st ? 1st->data + int_list_sum(1st->next) : 0;
}
```
Удаление элементов списка
```
void delete_int_list(struct item *1st)
{
	while(1st) {
		struct item *tmp = 1st;
		1st = 1st->next;
		free(tmp);
	}
}

// или так
void delete_int_list(struct item *1st)
{
	while(1st) {
		struct item *tmp = 1st->next;
		free(1st);
		1st = tmp;
	}
}
```
Удаление элементов списка с помощью рекурсии:
```
void delete_int_list(struct item *1st)
{
	if(!1st)
		return;
	delete_int_list(1st->next);
	free(1st);
}

// или так
void delete_int_list(struct item *1st)
{
	if(1st) {
		delete_int_list(1st->next);
		free(1st);
	}
}
```
Пример удаления всех отрицательных чисел из списка:
```
// Указатель на текущий элемент(по сути это указатель на указатель)
struct item **pcur;

void delete_negatives_from_int_list(struct item **pcur)
{
	while(*pcur) { // пока то, на что он указывает, не равно NULL
		if ((*pcur)->data < 0) { // если элемент надо удалить
			struct item *tmp = *pcur;  // запоминаем его АДРЕС
			*pcur = (*pcur)->next; // исключаем из списка
			free(tmp); // удаляем
			// при этом адрес уже стал текущим
		} else {
			pcur = &(*pcur)->next;
		}
	}
}
delete_negatives_from_int_list(&first) // вызов функции
```
Удаление всех отрицательных чисел с помощью рекурсии
```
void delete_negatives_from_int_list(struct item **pcur)
{
	if(!*pcur)
		return;
	delete_negatives_from_int_list(&(*pcur)->next);
	if((*pcur)->data < 0) {
		struct item *tmp = *pcur;
		*pcur = (*pcur)->next;
		free(tmp);
	}
}
```
### Двусвязные списки
Пример:
```
struct dbl_item {
	double data;
	struct dbl_item *prev, *next;
};
```
Пример внесения элемента в начало:
```
struct dbl_item *first = NULL, *last = NULL;
struct dbl_item *current = NULL, *tmp;

tmp = malloc(sizeof(struct dbl_item));
tmp->data = x;
tmp->prev = NULL;
tmp->next = first;
if(first)
	first->prev = tmp;
else	
	last = tmp;
first = tmp;
```
Внесение в конец:
```
tmp = malloc(sizeof(struct dbl_item));
tmp->data = x;
tmp->prev = last;
tmp->next = NULL;
if(last)
	last->next = tmp;
else
	first = tmp;
last = tmp;
```
Изъятие первого элемента двусвязного списка:
```
if(first) {
	tmp = first;
	first = first->next;
	if(first)
		first->prev = NULL;
	else 
		last = NULL;
	free(tmp);
}
```
Изъятие последнего элемента:
```
if(last) {
	tmp = last;
	last = last->prev;
	if(last)
		last->next = NULL;
	else	
		first = NULL;
	free(tmp);
}
```
Удаление всех элементов списка:
```
if(first) {
	first = first->next;
	while(first){
		free(first->last);
		first = first->next;
	}
	free(last);
	last = NULL;
}
```
Вставка элемента перед текущим:
```
tmp = malloc(sizeof(struct_dbl_item));
tmp->data = x;
tmp->next = current;
tmp->prev = current->prev;
current->prev = tmp;
if(tmp->prev)
	tmp->prev->next = tmp;
else
	first = tmp;
```
Вставка после текущего:
```
tmp = malloc(sizeof(struct dbl_item));
tmp->data = x;
tmp->prev = current;
tmp->next = current->next;
current->next = tmp;
if(tmp->next)
	tmp->next->prev = tmp;
else
	last = tmp;
```
Удаление текущего элемента:
```
if (current->prev)
	current->prev->next = current->next;
else
	first = current->next;
if (current->next)
	current->next->prev = current->prev;
else
	last = current->prev;
free(current);
current = NULL;
```

### Простое бинарное дерево поиска
Бинарное дерево поиска состоит из узлов, в каждом из которых присутствуют указатели на левое и правое поддеревья, а также полезная информация. Например:
```
struct node {
	int val;
	struct node *left, *right;
};
```
Пример прохода по дереву и печать его значений с помощью рекурсий:
```
void int_bin_tree_print_rec(struct node *r) {
	if(!r)
		return;
	int_bin_tree_print_rec(r->left);
	printf("%d ", r->val);
	int_bin_tree_print_rec(r->right);
}
```
Добавление нового элемента в дерево:
```
void int_bin_tree_add(struct node **root, int n)
{
	if(!*root) {
		*root = malloc(sizeof(**root));
		(*root)->val = n;
		(*root)->left = NULL;
		(*root)->right = NULL;
		return;
	}
	if((*root)->val == n)
		return;
	if(n < (*root)->val)
		int_bin_tree_add(&(*root)->left, n);
	else 
		int_bin_tree_add(&(*root)->right, n);
}
```

### Объединение и вариантные структуры
Под *объединением* (union) в Си понимается такой типа данных, переменная которого может хранить значение одного из нескольких типов, но только одно в каждый момент. Отличие от структур в том, что поля объединенного адреса расположены в памяти начиная с одного и того же адреса, с которого начинается само объединение. Тоесть присваивание значения любому из полей объединения затирает остальные его поля.

Пример:
```
struct expression_item {
	char c;
	union un_data {
		int i;
		double d;
		char var[sizeof(double)];
	} data;
	struct expression_item *next;
};

enum expr_item_types
	{ eit_int = 0, eit_dbl = 1, eit_var = 2, eit_min_op = ' ' };
// если пишем калькулятор, то перечислением будет значением поля структуры c, и в зависимости от него, будет выбираться соответствующее поле объединения.
```
Структура с анонимным объединением:
```
struct expression_item {
	char c;
	union {
		int i;
		double d;
		char var[sizeof(double)];
	};
	struct expression_item *next;
};
// теперь для структуры типа struct expression_item доступны поля c, i, d, var, next, при этом из трех полей i, d, var можно использовать только какое то одно,
// поскольку они занимают одну и ту же память.
```
### Битовые поля
Для целочисленных полей язык СИ позволяет в явном виде указать количество битов, которые данное поле будет занимать. Как правило такие поля описывают как беззнаковые, количество битов указывается сразу после имени поля через двоеточие:
```
struct myflags {
	unsigned char io_error:1;
	unsigned char seen_a_digit:1;
	unsigned char had_a_eol:1;
	unsigned char signaled:1;
	unsigned char count:4;
	// структура = 1 байту.
};
```
> Важно понимать, что подобное имеет смысл только если несколько битовых полей расположены в структуре подряд друг за другом, поскольку любое поле, не являющееся битовым, естественно, будет начинаться с границы ячейки памяти, возможно, даже не ближайший (компилятор на большинстве архитектур выравнивает многобайтовые поля в структурах на четные адреса, а в некоторых случаях - и на адреса, кратные четырем).

### Директива `typedef`
Пользовательское имя типа - идентификатор, обозначающий тот или иной тип значений и переменных. Например:
```
typedef int *intptr;
// вводит имя типа intptr
```
> На 32 битных архитектурах, используются синонимы типа `int` а на 64 битных `long`

Пример синонима структуры:
```
struct tag_myscript {
	int i;
	double d;
};
typedef struct tag_myscript mystruct;

// или
typedef struct tag_mystruct {
	int i;
	double d;
} my_struct;

// описание структуры
mystruct s1, s2, s3;
mystruct *ptr;
```
Описание полей списка:
```
typedef struct tag_item {
	int data;
	struct tag_item *next;
} item;

item *first = NULL;

// или с одинаковым именем типа и структуры
typedef struct item {
	int data;
	struct item next*;
} item;
```
> В си++ отсутствует понятие "идентификатора структуры", там имя структуры сразу же считается именем типа, и описание выше, вызовет конфликт имен, тоесть наш модуль нельзя будет использовать в с++ проектах.

### Макроопределения и макровызовы
Макроопределение представляет собой фрагмент исходного текста программы, в котором вводится новое имя(идентификатор), предназначенное к обработке микропроцессором. Пример:
```
#define BUFFERSIZE 1024
#define HELLOMSG "Hello, world\n"
#define MALLOCITEM malloc(sizeof(struct item))
```
`BUFFERSIZE`, `HELLOMSG`, `MALLOCITEM` - макроимена или просто макросы. Встретив любой из этих идентификаторов в дальнейшем тексте программы, компилятор заменит первый из на число 1024, второй на "Hello, world\n" и т.д. Соответственно в тексте можно делать так:
```
char buffer[BUFFERSIZE];
puts(HELLOMSG);
struct item *p = MALLOCITEM;
```
Также можно определить следующие макроимена:
```
#define IF if(
#define THEN ) {
#define ELSE } else {
#define FI }

IF a > b THEN
	printf("Ggwp");
	b = a;
ELSE	
	printf("Second");
	a = b;
FI
```
### Соглашения об именовании
Имя макросов пишут большими буквами, чтобы не было конфликта с переменными программы.

### Более сложные возможности макросов
Препроцессор языка си позволяет задавать макросы с параметрами:
```
#define MAX(A, B) ((A) > (B) ? (A) : (B))
#define square(x) x * x
#define BADMAX(A, B) A > B ? A : B

// вызовы
MAX(x, 15)
square(z + 1) 
BADMAX(100, 10) * 5

// сгенерируют
((x) > (15) ? (x) : (15))
z + 1 * z + 1
100 > 10 ? 100 : 10 * 5
```
> Чтобы избежать неясностей, необходимо в параметризированном макросе каждое вхождение макропараметра обязательно заключить в круглые скобки, а все тело макроса - еще в одни.

Склейка строк:
```
#define HELP_TEXT\
	"This is ea\n" \
	"To use it\n" \
	"as sa\n" \
	"  sdsdsd\n"

if (argc < 2) {
	fputs(HELP_TEXT, stderr);
	return 1;
}
```

Создание функции суммирования для разных типов с помощью макросов:
```
#define MAKE_ARRAY_SUM_FUNCTION(FUNNAME, TYPE) \ 
	TYPE FUNNAME(const TYPE *a, int n) { \
		TYPE s = 0; \
		while (n > 0) { \
			s += *a; \
			a++; \
			n--; \
		} \
		return s; \
	}

MAKE_ARRAY_SUM_FUNCTION(int_array_sum, int)
MAKE_ARRAY_SUM_FUNCTION(double_array_sum, double)
MAKE_ARRAY_SUM_FUNCTION(long_array_sum, long)
```
Склеивание токенов - `##`. В ходе макроподстановки препроцессор склеивает в одну лексему две разные лексемы, между которыми которыми обнаружилось `##`, в роли склеиваемых лексем обычно выступают идентификаторы. Например:
```
#define MAKE_ARRAY_SUM_FUNCTION(TYPE) \ 
	TYPE TYPE ## _array_sum(const TYPE *a, int n) { \
		TYPE s = 0; \
		/*...*/

// Вызов 
MAKE_ARRAY_SUM_FUNCTION(int)

// Сгенерирует
int int_array_sum(const int *a, int n) { 
	int s = 0;
	/*...*/
}
```
> Если случайно оставить после символа косой черты `\` пробел, текст перестанет компилироваться, при этом пробел, который стал причиной ошибки, не будет видно.

> Если допустить в тексте макроса ошибку, то компилятор выдаст ошибку в том месте, где макрос раскрывается, а не там, где он описан.

> Для удобства отладки можно добавить ключ `-E`, предписывающий прекратить компиляцию сразу после стадии макропроцессирования, а результат выдать на поток стандартного вывода.

Превращение токена в строковую константу - `#`, например:
```
#define VAR_PRINT(x) printf("%s = %d\n", #x, x)

// вызов
int abrakadabra = 13;
VAR_PRINT(abrakadabra);

// сгенерируется
printf("%s = %d\n", "abrakadabra", abrakadabra);

// того же эффекта можно достичь еще так
#define VAR_PRINT(x) printf(#x " = %d\n", x)
```
### Макросы и конструкция `do {} while(0)`
`#define MYMACRO(arg) do { f(arg); g(); } while(0)`

### Директивы условной компиляции
Все что написано между `#if 0` и `#endif` компилятор проигнорирует. Если потребуется снова включить код, то вместо `if 0`, необходимо писать `if 1`.
```
#if 0
void sort(int *a, int n)
{
	/*...*/
}
#endif
```
Пример выбора фрагмента кода с помощью ветвления `else`:
```
#if 1
void string_copy(char *dest, const char *src)
{
	int i;
	for(i = 0; src[i]; i++) 
		dest[i] = src[i];
	dest[i] = 0;
}
#else	
void string_copy(char *dest, const char *src)
{
	for(; *src; dest++, src++)
		*dest = *src;
	*dest = 0;
}
#endif
```
Директивы для управления ветвлением - `#if`, `#else`, `#endif`, `#elif`. Пример управления ветвлением с помощью директивы `#define`:
```
#define USE_INDEX_IN_STRING_COPY 1

#if USE_INDEX_IN_STRING_COPY
```

Указание директивы с помощью флага при компиляции:
```
gcc -Wall -g -D USE_INDEX_IN_STRING_COPY=1 prog.c -o prog
```

Для проверки определения директивы `#define` используются дирекитвы `#ifdef`, `#ifndef`. Это сокращенные версии для `#if defined()` и `if !defined()`.
Пример проверки определения дирекитвы `#define`:
```
#ifndef USE_INDEX
#define USE_INDEX 1
#endif
```

Операция определенности макросимвола `defined`. Пример:
```
#if defined(DEBUG_PRINT) && DEBUG_PRINT > 7
```

Ветвление с помощью `defined`:
```
#if defined(FOR_PETROV)
	/*...*/
#elif defined(FOR_SIDOROV)
	/*...*/
#else
	/*...*/
#endif

// или так
#ifdef FOR_PETROV
/*...*/
#elifdef FOR_SIDOROV
/*...*/
#else 
/*...*/
#endif
```
Определить символ можно не задавая ему никакого значения:
```
#define MYSYMBOL
// или так
gcc -Wall -g -D MYSYMBOL prog.c -o prog
```
### Еще несколько полезных директив
* Директива для забывания макросимвола - `#undef <макросимвол>`
* Прерывание компиляции и выдача ошибки - `#error <текст ошибки>`
* Когда текст Си это результат компиляции другой программы, используется - `#line`
* Макросимволы, определенные изначально компилятором, и не могут быть переопределены:
1. `__LINE__` - номер текущей строки
2. `__FILE__` - имя файла
3. `__DATE__` - текущая дата
4. `__TIME__` - текущее время
5. `__STDC__` - равен 1, позволяет проверить равен ли компилятор стандарту.

### Директива `#include`
* `#include <stdio.h>` - для библиотек.
* `#include "mymodule.h"` - предназначен для своих заголовочных файлов, которые написаны для той же программы, что и файл из которого происходит включение.

### Особенности оформления макродиректив
Отступы макродиректив оформляются так:
```
#ifdef FIXED_ARRAY
#	if ARRAY_SIZE > MAX_ARRAY_SIZE
		quick_sort(array);
#	else
		slow_sort(array);
#	endif
#else
	if(arr > MAX_ARRAY)
		quick_sort(array);
	else
		bubble(array);
#endif
```

### Общая схема раздельной трансляции в Си
Поддержки модулей в Си нет вообще, все что есть - средства, позволяющие делать те или иные символы (функции и глобальные переменные) видимыми или невидимыми для редактора связей, а также ссылаться на символы, осутствующие в текущей единице трансляции, которые редактор связей должен потом откуда-то добыть. Все остальное достигается использованием препроцессора и целой системы хаков.
* Компиляция файла для создания объектного файла - `gcc -Wall -g -c mod.c`

Если наша программа состоит из главного модуля `prog.c` и двух дополнительных модулей `mod1.c` и `mod2.c`, мы можем собрать её так:
```
gcc -Wall -g -c mod1.c
gcc -Wall -g -c mod2.c
gcc -Wall -g prog.c mod1.o mod2.o -o prog

// или так
gcc -Wall -g -c mod1.c
gcc -Wall -g -c mod2.c
gcc -Wall -g -c prog.c
gcc prog.o mod1.o mod2.o -o prog
```

### Видимость объектов из других модулей
* Слово для отметки объектов, чтобы они были невидимы для (других файлов) трансляции - `static`. Пример:
```
static int very_local_subroutine(int x, const char *n)
{
/*...*/
}
```
* Отметка глобальных переменных, для скрытия единиц трансляции:
```
int very_bad; // видно отовсюду
static int a_bit_better // только из текущего модуля
```
Для доступа к функциям и перменным, которые описаны в других модулях, в текущем модуле помещают их объявления. Объявление сообщает компилятору что соответствующий объект где-то существует и можно не пугаться его отсутствия, оставив решение проблемы редактору связей. Пример:
```
// объявлено в одном файле
int cube(int x)
{
	return x * x * x
}

// можно вызвать в другом файле
int cube(int x);
```
Если в другом модуле есть глобальная переменная, к которой надо получить доступ из текущего файла, надо дописать:
```
// можно использовать, как будто она описана в текущем модуле
extern int very_bad_global;
```
Константный массив, например можно использовать таблицу из одного файла в другом:
```
// объявлением в одном файле
const int prime_numbers[] = { 1, 2, 3, 4 ... }

// вызов в другом файле
extern const int prime_numbers[];
```

### Заголовочные файлы к модулям
Обычно отдельным заголовочным файлом снабжают каждый модуль, кроме главного, файлом с таким же именем, но с суффиксом `.h`. Например для модуля (`m1.c` создают `m1.h`). В такой заголовочный файл выносят объявления всех объектов, описанных в модуле, к которым предполагаются обращения из других модулей. Т.е. если в модуле имеется функция `func` и предположительно, что в других модулях к этой функции будут обращения, то её заголовок нужно вынести в заголовочный файл модуля. А если в модуле описана глобальная переменная и предположительна её доступность из других модулей, то в заголовочном файле следует поместить её объявление со словом `extern`.

Далее достаточно включить этот заголовочный файл `#include` и при трансляции всех этих модулей компилятор будет видеть объявления, но сами эти объявления будут в одном экземпляре - заголовочном файле.

В модуль обязательно указывать свой собственный заголовочный файл.

Все функции и глобальный переменные, которые вы решили не выносить в заголовочник, нужно обязательно пометить модификатором `static`, тем самым сделав их невидимыми для редактора связей.

### Описание типов и макросов в заголовочных файлах, защита от повторного включения
* Все, что занимает память в какой-либо из секций будущей исполняемой программы, описывается в файле реализации модуля и либо объявляется в заголовочном файле (или экспортируется), либо помечается словом `static` (если объект предназначен только для внутреннего использования в модуле). **Функции и глобальный переменные**.
* Все, что не занимает памяти, или, иначе говоря, все, что используется только во время компиляции и затем бесследно исчезает, описывается в заголовочном файле (либо, если предназначено только для внутреннего использования в модуле, описывается в файле реализации). **Типы и макросы**.

**Повторное включение** - включение в модуль директивы заголовочного файла дважды.

Техника, не позволяющая автоматически заголовочникам включаться в одну и ту же единицу трансляции больше одного раза `sentry macros`: 
```
// в начале файла пишутся директивы (чаще всего имя файла заглавными буквами)
#ifndef MYMODULE_H_SENTRY
#define MYMODULE_H_SENTRY
// последней строкой пишется
#endif

// т.е. директива следит за тем, чтобы код включался один раз
```
> Каждый заголовочный файл следует снабжать защитой от повторного включения сразу послего его создания.

> Нужно добавлять `#include` в модуль который включает собственный заголовочный файл.

Процедура создания в программе нового модуля:
* Создайте пустые файлы `newmod.c` и `newmod.h`;
* Вставьте в файл `newmod.c` директиву `#include "newmod.h";
* Вставьте в файл `newmod.h` директивы: 
```
#ifndef NEWMOD_H_SENTRY
#define NEWMOD_H_SENTRY
// содержимое 
#endif 
```
* Зарегистрируйте созданные файлы в системе контроля версий и системе сборки
* При необходимости отразите появление нового модуля в документации.

### Объявления типов, неполные типы
Структуры в Си можно объявлять не показывая сам тип. Например: `struct item;`. С этого момента компилятор будет знать что словосочетание `struct item` обозначает некий структурный тип, но больше ничего про этот типа знать не будет. Такой типа называется **неполным**. Точно так же можно описать неполный тип объединение, но это обычно не используется.

Неполный тип можно использовать для описания указателей, размер указателя обычно не зависит от того, на переменную какого типа он указывает.

Основное назначение таких объявлений в том, чтобы позволить двум структурам иметь в качестве полей указатели друг на друга. Например:
```
struct item {
	int data;
	struct item *next;
};
```
На тот момент, когда компилятор видит описание поля `next`, сам тип `struct item` ещё не описан, ведь его описание еще не закончилось. С другой стороны 	поскольку словосочетание `struct item` компилятор уже видел, этот тип считается объявленнным (хотя и неполным), и компилятор полагает, что для описания указателя этого достаточно.

Также неполные типы не показывают компилятору описание типа, если нужен только указатель на такой тип. **Это позволяет написать объявление структуры(неполной), вместо того чтобы включать с помощью `#include` тот файл, где находится её полное описание**. Так можно достичь изрядной экономии времени компиляции, выкинув лишние включения, в особенности если речь идет о включении одного заголовочного файла из другого.

> Иногда описание структуры вообще не выносят в заголовочный файл, несмотря на то, что в нем содержатся прототипы функций, работающие с указателями на эту структуру. Такой вариант применяется, если автор модуля предлагает пользователю хранить указатели на какую-то его структуру, например, для целей идентификации, но при этом предпочитает, чтобы пользователь не обращался к полям этой структуры напрямую. Примером такой ситуации является знакомый тип `FILE*`.
	
> Большинство компиляторов позволяют также объявить тип `enum`, но это в явном виде запрещено стандартами и к тому же совершенно бессмысленно, проще тогда использовать `int`.

### Оформление кода
```
float cube(float a)
{
	return a * a * a;
}
```

### Фирменные особенности Си
* Си чувствителен к регистру
* Слова в составе идентификаторов отделяют знаком подчеркивания - `_`
* Имена зарезервированы системой, если начинаются с нижнего подчеркивания.

### Интернациолизация
Перевести строки для вывода, можно с помощью библиотеки `gettext`, для этого надо все строковые заключить в макровызов `_()`. Те строки что будут переводиться, заключить в `_()`, а те что переводить не нужно в  `N_()`.
```
#include <stdio.h>
#define N_(STR) (STR)

int main()
{
	printf(_("Hello, world!\n"));
	printf(_("Good bye, world!\n"));
	retunr 0;
}
```
Когда потребуется превратить программу в международную, придется сделать несколько модификаций её исходного текста. Нужно будет добавить включение заголовочных файлов `locale.h` ради функции `setlocale` и `libint1.h`, в котором объявлены функция `gettext` и вспомогательные `bindtextdomain` и `textdomain`.

Библиотека `gettext` требует первичной настройки, вся цель которой, в том, чтобы сообщить , из какого файла брать переводы строк. Для этого требуется задать некую *базовую директорию*, гда хранятся данные, имеющие отношение к локалям,  и текстовый домен, который при ближайшем рассмотрении оказывается именем нашей программы.
> Если бы мы собирались инсталлировать нашу программу в системные директории, в этой роли выступала бы директория `/usr/share/locale` или `/usr/locale/share/locale` (в зависимости от того, каким способом производится установка). Но мы укажем базовую директорию `.` для нашего простого примера. В боевых проектах базовая директория читается из конфигурационных файлов или другим образом.

Имя базовой директории и текстового домена вынесем в макроконстанты в начале программы `hellobye.c`:
```
#include <stdio.h>
#include <locale.h>
#include <libint1.h>

#define LOCALEBASEDIR "."
#define TEXTDOMAIN "hellobye"

#define _(STR) gettext(STR)
#define N_(STR) (STR)

int main()
{
	// настройка локали и самой библиотеки
	setlocale(LC_CTYPE, "");
	setlocale(LC_MESSAGES, "");
	bindtextdomain(TEXTDOMAIN, LOCALEBASEDIR);
	textdomain(TEXTDOMAIN);
	
	printf(_("Hello, world!\n"));
	printf(_("Good bye, world!\n"));
	return 0;
}
```
Далее необходимо создать "переводы", то есть файлы, задающих для английских сообщений их переводы на другие языки. Для начала потребуется запустить программу `xgettext` которая автоматически извлечет из нашего программы все строки, заключенные в макровызов `_()`, и на их основе создаст файл перевода. Запускаем команду:
```
// суффикс pot означает portable object template - шаблон переносимого файла
xgettext --keyword="_" hellobye.c -o hellobye.pot
```
* `keyword` - задает имя макровызова в нашем случае `_`.
* `-o` - указывает имя файла для записи результата.

Копируем сгенерированный файл под именем `ru.po` (русский, переносимый объект) и отредактируем. `CHARSET` устанавливаем в `UTF-8`. Затем этот файл следует откомпилировать, получив бинарный файл, который `gettext` будет использовать в работе. От своего исходника результат такой компиляции отличается возможностью быстрого поиска нужного сообщения. Компиляцию произведет программа:
```
msgfmt ru.po -o ru.mo
```
Результатом станет `ru.mo`, `mo` - `machine object`. После файл `.mo` нужно разместить так, чтобы привередливая `gettext` их нашла во время работы нашей программы:
```
mkdir -p ru/LC_MESSAGES
cp ru.mo ru/LC_MESSAGES/hellobye.mo
```
Компилируем программу как обычно (в системах, отличных от Linuxm может потребоваться явное подключение библиотеки `intl`, но в Linux это не нужно):
```
gcc -Wall -g hellobye.c -o hellobye

./hellobye
Здравствуй, мир!
До свиданья, мир!
```
Язык на котором программа разговаривает, можно менять, задавая `LANGUAGE`.
```
LANGUAGE=en ./hellobye
```
В случае добавления нового кода предусмотрена программа `msgmerge`, которая позволяет строить новый `.po` файл по имеющемуся `.po` файлу и новому `.pot` файлу. Например вставляем новый код:
```
printf(_("We are speaking\n"));
```
Теперь строим обновленный файл `hellobye.pot` с помощью `xgettext`, после чего обновим имеющиеся у нас файлы перевода с помощью `msgmerge`:
```
msgmerge -U --backup=numbered ru.po hellobye.pot
```
При таких параметрах `msgmerge` запишет результаты сразу в файлы `ru.po`, а старые версии на всякий случай сохранит под `ru.po.~1~`. Далле форматируем новые файлы и запускаем `msgfmt` и копируем полученные файлы с суффиксом `.mo` куда следует.
> Пакеты `autoconf/autotools` ничего не решают а создают проблемы, поэтому `gettext` следует использовать без них.

### Указатель на массив
`int m[3][4];` - `m` есть массив из трех массивов из четырех элементов типа `int`. В памяти массив располагается построчно. Пример заполнения двумерного массива:
```
for(i = 0; i < 3; i++)
	for(j = 0; j < 4; j++)
		m[i][j] = i * j;
```
Пример инициализаторов:
```
int m[3][4] = {{ 0, 0, 0, 0 }, { 0, 1, 2, 3 }, { 0, 2, 4, 6 }};
const int level_change[3][3] = {
	{ 0, 0, 0 },
	{ 0, 1, 2 },
	{ 0, 2, 3 }
};
```

Адрес массива из четырех элементов типа `int`(указатель на массив):
```
int (*p)[4];
```
Теперь можно сделать `p = m` и работать с этим `p` так же, как мы работали с `m`.

Аналогичным образом для трехмерного массива:
```
int z[10][15][20];
```
потребуется указатель на двумерный массив:
```
int (*zptr)[15][20];
```

### Указатели на функции
Функции имеют одинаковый профиль,  если их количество и типы параметров, а также тип возвращаемого значения у них одинаковый.

Например если есть функции:
```
double dbl_sum(const double *a, int size)
{
/*...*/
}

double dbl_min(const double *a, int size)
{
/*...*/
}

double dbl_average(const double *a, int size)
{
/*...*/
}
```
то указатель способный хранить адрес любой из трех функций выглядит так:
```
double (*fptr)(const double *a, int);
```
присвоить адрес любой из трех функций можно так:
```
fptr = &dbl_min;
fptr = dbl_min;
```
вызов функции через указатель:
```
double arr[100];
double res;

res = (*fptr)(arr, sizeoff(arr)/sizeof(*arr));
res = fptr(arr, sizeof(arr)/sizeof(*arr));
```
Пример использования указателя на массив для критерия удаления из списка:
```
int is_negative(int x) { return x < 0; }
int is_even(int x) { return x % 2 == 0; }
int is_div7(int x) { return x % 7 == 0; }

void delete_from_int_list(struct item **pcur, int (*crit)(int))
{
	while(*pcur) {
		// вызов указателя на функцию с параметром очередного числа из массива
		if((*crit)((*pcur)->data)) {
			struct item *tmp = *pcur;
			*pcur = (*pcur)->next;
			free(tmp);
		} else {
			pcur = &(*pcur)->next;
		}
	}
}

// вызов
delete_from_int_list(&first, &is_negative);
delete_from_int_list(&first, &is_div7);
```

Пример с **`callback function`**.
Обход дерева и вывод значения элемента через колбек функцию:
```
// профиль функции
void callback_function(int num, void *userdata);

void int_bin_tree_traverse(struct node *r,
	  		   void (*callback)(int, void*),
			   void *userdata)
{
	if(!r)
		return;
	int_bin_tree_traverse(r->left);
	(*callback)(r->val, userdata);
	int_bin_tree_traverse(r->right);
}

// для вывода значения дерева
void int_callback_print(int data, void *userdata)
{
	printf("%d ", data);
}

// вызов, поскольку данные не используются, их значение NULL
int_bin_tree_traverse(root, int_callback_print, NULL);
```
тот же пример с суммированием элементов дерева:
```
void int_callback_sum(int data, void *userdata)
{
	int *sum = userdata;
	*sum += data;
}

// или можно записать так
void int_callback_sum(int data, void *userdata)
{
	*(int*)userdata += data;
}

// подсчет суммы
int sum;
sum = 0;
int_bin_tree_traverse(root, int_callback_sum, &sum);
```
пример с поиском минимального числа, максимального числа и общего количества чисел. 
```
// пользовательские данные 
struct minmaxcount {
	int count, min, max;
};

// callback
void int_callback_minmaxcount(int data, void *userdata)
{
	struct minmaxcount *mmc = userdata;
	if(mmc->count == 0) {
		mmc->min = mmc->max = data;
	} else {
		if(mmc->min > data)
			mmc->min = data;
		if(mmc->max < data)
			mmc->max = data;
	}
	mmc->count++;
}

// вызов
struct minmaxcount mmc;
mmc.count = 0;
int_bin_tree_traverse(root, int_callback_minmaxcount, &mmc);
```

### Сложные описания и общие правила их прочтения
Пример - `int (*(*replace_f_ptr)(int (*)(int, int)))(int, int);` расшифровывается как:
`replace_f_ptr` - **это** (справа мы уперлись в закрывающую круглую скобку, так что сначала надо посмотреть, что у нас слева) **указатель на** (содержимое скобок кончилось, выходим наружу, справа что-то есть, поэтому начинаем оттуда) **функцию, которая получает на вход** (читаем тип параметра, для чего находим "исполняющую обязанности идентификатора" конструкцию `"(*)"`) **указатель на функцию, принимающую на вход два целых числа и возвращающую значение типа `int`** (список формальных параметров заканчивается, завершаем фразу про функцию) **и возвращает** (справа опять закрывающаяся скобка, приходится смотреть налево) **указатель на**(опять кончилось содержимое круглых скобок, выходим наружу) **функцию, принимающую на вход два целых числа и возвращающую число типа `int`**.

Аналогичным образом описание:
```
int (*funvec[10])(int, int);
```
читается как: `funvec` - **это массив из десяти указателей на функции, принимающие на вход два целых числа и возвращающие значение типа `int`**.

### Дополнительные функции работы с динамической памятью
* Функция для выделения памяти помимо `malloc` и `free`, `calloc` - `void *calloc(int nmemb, int size);`. Эта функция предназначена для выделения памяти под массив, содержащий `nmemb` элементов, каждый из которых имеет размер `size`, но `calloc` в отличие от `malloc` забивает память нулями.
* Изменение размера уже выделенной области памяти - `void *realloc(void *ptr, int size);`. `ptr` указывает на имеющуеся область памяти для которой нужно поменять размер, а `size` задает этот новый размер.
> В большинстве случаев функция вынуждена создавать новую область динамической памяти, копировать туда все содержимое старой области, саму старую область освобождать, а возвращать адрес новой. После этого адрес, переданный через `ptr`, становится невалидным, и вместе него необходимо использовать адрес, который вернул `realloc`, поэтому чаще всего результат `realloc` присвивают той же переменной, значение которой передают его первым параметром, примерно так: `p = realloc(p, sz);`

Достоинством `realloc` является то, что когда сразу после данной области памяти достаточное количество памяти свободно, она может сэкономить процессорное время, не копируя информацию - то есть реально увеличив размер имеющейся области памяти. 

Недостатком `realloc` является то, что не зная как в вызывающей программе используется область памяти, если все же приходится копировать, функция вынуждена копировать все содержимое области памяти, что в действительно требуется не всегда.

> Два специальных случая `realloc`: если первым параметром передан нулевой адрес, то функция работает в точности как `malloc`, если же в качестве второго параметра передан ноль, она работает как `free`.

### Функции обработки строк
* Длинна строки - `int strlen(const char *str);`
* Копирование строки в заранее подготовленный массив - `char *strcpy(char *destination, const char *source);`
* Копирование строки в массив с длинной `size` - `char *strncpy(char *destination, const char *source, int size);`. У этой функции недостаток, если не хватило место для копирования, то нулевой байт она в конец массива не записывает, поэтому в массиве может оказаться не корректная строка. Если осталось свободное место, то заполняет его нулями. В случае если обрезанная строка не беспокоит, то добавляем ноль в конец.

> Функции `strcpy` и `strncpy` в качестве своего значения возвращают параметр `destination`. Их иногда вызывают ради побочного эффекта, игнорируя возвращаемое значение.

* Измеряет длинну строки, создает с помощью `malloc` область динамической памяти нужной длины, копирует туда заданную строку и вернет адрес начала созданной копии - `char *strdup(const char *a);`. Необходимо не забывать освободить память с помощью `free`.

> Многие не любят `strdup`, т.к. она затрудняет проверку правильности программы, ведь выделение памяти проиходит не там, где её освобождение, память выделяется где-то в недрах библиотечной функции, а освобождать её вынуждены в своей программе.

* Для сравнения строк применяются - `int strcmp(const char *s1, const char *s2);`, `int strncmp(const char *s1, const char *s2, int n);`. Обе функции посимвольно сравнивают строки, начиная с адресов `s1` и `s2`. Работа заканчивается, если строки различаются символом в очередной позиции, если одна из строк кончилась, а `strncmp` дополнительно заканчивает работу, если просмотрено уже `n` позиций.

> Если очередной символ в строках различается, та строка, в которой в очередной позиции оказался символ с меньшим кодом, считается меньше, чем другая. Если одна из строк кончилась, а вторая еще нет, кончившаяся считается меньше второй. Функции возвращают отрицательно число, если `s1` оказалась меньше, чем `s2`, положительное - если `s2` оказалась меньше, чем `s1`, и ноль, если различий обнаружено не было. Строки сравниваются в лексиграфическом (словарном) порядке.

Пример кода сравнения строк:
```
if(0 == strcmp(str1, str2)) {
	/*...*/
}
```

* Поиск в заданной строке заданный символ - `char *strchr(const char *s, int c);`, `char *strrchr(const char *s, int c);`. Обе функции отыскивают символ с кодом `c` в строке, начинающейся с адреса `s`. Различие между ними проявляется только в случае, если таких символов больше одного, функция `strchr` находит первый символ, а `strrchr` последний. Возвращают адрес того места, где в строке располагается искомый символ. Если символа нет, возвращает `NULL`.

* Позволяет найти вхождение подстроки в строку - `char *strstr(const char *haystack, const char *needle);`. Первый параметр - строка где нужно искать, второй - подстрока, которую нужно искать. Возвращает адрес места в строке, где найдена искомая подстрока, либо `NULL`, если ничего не нашлось. Например:
```
char ak[] = "abrakadabra";
/*...*/
// занесет в p адрес ak+4
p = strstr(ak, "kada");
```

* Позволяет заполнить область памяти заданного размера, начиная с заданного адреса, заданным значением байта - `void *memset(void *memory, int value, int size);`. Первый параметр адрес начала, второй значение, третий сколько ячеек надо заполнить. Функция возвращает свой первый параметр.

* Копируют содержимое заданного размера из одной области памяти в другую - `void *memcpy(void *dest, const void *src, int size);`, `void *memmove(void *dest, const void *src, int size);`. Первый параметр задает куда производится копирование, второй откуда, третий размер копируемой области. Различие в том, что `memcpy` предназначена для копирования информации между областями, которые не могут накладываться друг на друга, `memmove` делает соответствующие проверки, и если области `dest` и `src` перекрываются, производит копирование от начала к концу, когда `dest` находится левее `src`, и от конца к началу когда правее. 

> Эту функцию можно использовать, например, когда в имеющуюся строку нужно вставить несколько символов (в середину) или, наоборот, изъять из строки несколько символов, в обоих случах остаток строки приходится сдвигать - соответственно вправо и влево. Если по смыслу происходящего области памяти перекрываться не могут (например `dest` указывает на только что выделенную память, или они относятся к заведомо разным объектам, и т.д.), лучше использовать `memcpy`: она быстрее за счет отсутствия лишних проверок.

### Генерация псевдослучайных чисел
Получить настоящие случайные числа в OC Linux можно, открыв на чтение файл псевдоустройства /dev/random. Это делается вызовом `open`, само чтение выполняется вызовом `read`. Этим методом стоит пользовать когда нужны действительно случайные числа.

Методы генерации псевдослучайных чисел в библиотеки Си - `int rand(void);`, `void srand(unsigned int seed);`. `rand` возвращает значение от 0 до `RAND_MAX` включительно. Если `rand` использовать без `srand`, то получающася последовательность выдаваемых чисел будет одна и та же при каждом запуске программы. 

Чтобы последовательность чисел получалась каждый раз другая, нужно один раз в начале программы вызвать функцию `srand`, дав ей в качестве параметра какое-то число, которое будет каждый раз новым (например текущее время `time` в `time.h`, пример `srand(time(NULL));`.

> Эта функция инициализирует датчик псевдослучайных чисел, задав начальное число последовательности (само это число в последовательность не войдет).

> В большинстве случаев нужно не просто случайное число, а число из заданного диапазона. Проще всего это сделать с помощью взятия остатка от деления, например, случайное число `r` от 1 до 12 можно получить с помощью выражения `rand()%12+1`. Но так делать не рекомендуется поскольку распределение младших бит псевдослучайных чисел может быть неравномерным, а именно младшие биты при таком применении `rand` оказывают влияние на получаемые числа. 

> Одна из версий страницы справочника `man` по функции `read`, рекомендует применять в подобных ситуациях следующее выражение:
```
1 + (int)(12.0 * rand() / (RAND_MAX + 1.0))
```
Это позволяет использовать в равной степени все составляющие псевдослучайного числа, а в целом псевдослучайные числа имеют распределение, достаточно близкое к равномерному.

### Средство создания вариадических функций
Вариадическая функция - функция способная принимать переменное число аргументов. Например `printf`, `scanf`. Чтобы создавать вариадические функции необходимо подключить библиотеку: `stdarg.h`, в котором описан тип `va_list` и три макроса `va_start`, `va_end`, `va_arg`.

> Сама вариадическая функция должна иметь хотя бы один параметр, снабженный именем, имя последнего из именованных параметров используется макросом `va_start` для инициализации переменной типа `va_list`. Последующие параметры извлекаются из стека макросом `va_arg`, которому нужно указать, параметр какого типа требуется извлечь, в конце работы (обязательно в той же самой функции) мы должны поместить макровызов `va_end`, который приведет дела в порядок.

> Имеющиеся средства не позволяют понять, сколько параметров было фактически передано в функцию, это предмет соглашения между вызывающим и вызываемым. Например в функцию `printf` должно быть, помимо форматной строки, передано ровно столько параметров, сколько форматных директив имеется в форматной строке.

Пример вариадической функции. Следующая функция принимает произвольное( но не менее одного) количество параметров типа `int`, не равных нулю, и возвращает их сумму, последний параметр в списке параметров должен быть напротив, равен нулю - это позволяет функции понять, что список параметров кончился.
```
int sum(int c, ...)
{
	va_list vl;
	int s = c, k;
	
	va_start(vl, c);
	while((k = va_arg(vl, int)) != 0)
		s += k;
	va_end(vl);
	
	return s;
}
```
Пример функции, которая принимает на вход попеременно указатель на строку и целое число, и так сколько угодно раз, пока очередной указатель не окажется нулевым. Каждая строка печатается столько раз, сколько указано в следующем за ней параметре(числе):
```
; variadic.
void print_times(const char *str, ...)
{
	va_list vl;
	const char *p;
	va_start(vl, str);
	for(p = str; p; p = va_arg(vl, const char *)) {	
		int n, i;
		n = va_arg(vl, int);
		for(i = 0; i < n; i++) {
			printf("%s ", p);
		printf("\n");
	}
	va_end(vl);
}

// вызов функции
print_times("once", 1, twice, 2, "seven times", 7, NULL);
```
Функции:
```
int vprintf(const char *fmt, va_list ap);
int vfprintf(FILE *stream, const char *fmt, va_list ap);
int vsprintf(char *str, const char *fmt, va_list ap);
int vsnprintf(char *str, int size, const char *fmt, va_list ap);
int vscanf(const char *fmt, va_list ap);
int vsscanf(const char *str, const char *fmt, va_list ap);
int vfscanf(FILE *stream, const char *fmt, va_list ap);
```
Все они работают точно так же, как и их аналоги без буквы `v` в имени (то есть `printf`, `fprintf` и т.д.), за исключением того, что вместо списка аргументов переменной длины все эти функции принимают параметр типа `va_list`. Это позволяет создавать функции, аналогичные функциям семейства `printf/scanf`, то есть принимающие на вход форматную строку и параметры, но при этом производящие какие-то дополнительные действия, а затем вызывающие соответствующие библиотечные функции из привиденного списка для выполнения основной работы.

### Программы с использование `ncurses`
* Инициализация библиотеки происходит с помощью вызова функции `initscr` без параметров.
* Дальше нам потребуется узнать, сколько строк имеет наше окно терминала и сколько знакомест содержится в каждой строке. Для этого мы опишем две целочисленные переменные `row` и `col` и напишем такую строку:
```
getmaxyx(stdscr, row, col);
```
`stdscr` - означает окно на весь терминал.

> Библиотека `ncurses` позволяет объявлять отдельные окна в разных местах терминала и вывод в каждое такое окно выполнять независимо от других окон, очищать окно, производить в нем скроллинг текста. 

> При работе с экраннами позициями сначала всегда указывается координата по вертикали (номер строки), а координата по горизонтали (номер столбца) идет второй.

> `getmaxyx` - это не функция, а макрос, который разворачивается во фрагмент текста, содержащий обычные присваивания.

* Перемещение курсора в нужную позицию - `move(<номер строки (координата по вертикали)>, <номер столбца (координата по горизонтали)>)`

> Операции вывода не оказывают никакого влияния на реальное содержимое экрана до тех пор, пока мы не потребуем привести экран в актуальное состояние

* Вывод на экран строку в текущей позиции курсора - `addstr(<строка>)`
* Вывод одного символа в текущей позиции курсора - `addch(символ)`
* Убрать курсор с экрана - `curs_set(0)`
* Приведение экрана в соответствие с выводом - `refresh`
* Позволяет усыпить программу (**не является частью `ncurses`**) - `sleep`. Находится в `unistd.h`.
* Завершение работы `ncurses` - `endwin`

Пример программы:
```
#include <curses.h>
#include <unistd.h>

const char message[] = "Hello, world!";
enum { delay_duration = 5 };

int main()
{
	int row, col;
	initscr();
	getmaxyx(stdscr, row, col);
	move(row/2, (col-(sizeof(message)-1))/2);
	addstr(message);
	curs_set(0);
	refresh();
	sleep(delay_duration);
	endwin();
	return 0;
}
```
### Обработка клавиатурных и других событий
В обычных условиях терминал работает в каноническом режиме ввода, при котором программа получает введенные пользователем символы только после нажатия Enter (сразу всю строку).

* Если мы хотим чтобы комбинации `Ctrl-C`, `Ctrl-D` продолжали работать, то следует вызвать функицю `cbreak`, в противном случае `raw`.
* Если хотим вернуть терминал в канонический режим, то вызываем `nocbreak` или `noraw`.
* Выключить автоматическое отображение вводимых символов на экране - `noecho`, (отменить этот эффект - `echo`)
* Обработка `escape` последовательностей (типа стрелки и т.д.) - `keypad(stdscr, 1)`, если указать 0 вместо 1, режим обработки последовательностей будет выключен.
* После такой настройки, можно узнать о нажатиях клавиш на клавиатуре - `getch`, возвращает `int`. Если пользователь вводит специальные клавиши, то возвращает значения, находящиеся за пределами диапазона кодов символов. Библиотека `ncurses` предоставляет программисту символические имена для этих значений, такие как `KEY_UP`, `KEY_DOWN`, `KEY_LEFT`, `KEY_RIGHT` - для стрелочек, `KEY_F(1)`, `KEY_F(2)`, `KEY_F(10)` и т.д. для функциональных клавиш. Все эти имена в действительности обозначают целые числа.

> `getch` может сообщить нам не только о событиях нажатия клавиш, но и о других, например действия с мышью, изменение размера экрана.

* Каждый раз когда меняется размер окна, функция `getch` возвращает `KEY_RESIZE`. После этого можно воспользоваться макросом `getmaxyx`, чтобы перерисовать окно.

Еще один пример с изменением размеров окна:
```
#include <ncurses.h>

static const char message[] = "Hello, world!";
enum { key_escape = 27 };

static void show_message(int x, int y)
{
	move(y, x);
	addstr(message);
	refresh();
}

static void hide_message(int x, int y)
{
	int i;
	move(y, x);
	for(i = 0; i < sizeof(message)-1; i++)
	{
		addch(' ');
	refresh();
}

static void check(int *coord, int max)
{
	if(*coord < 0)
		*coord = 0;
	else
	if(*coord > max)
		*coord = max;
}

static void
move_message(int *x, int *y, int mx, int my, int dx, int dy)
{
	hide_message(*x, *y);
	*x += dx;
	check(x, mx);
	*y += dy;
	check(y, my);
	show_message(*x, *y);
}

static void handle_resize(int *x, int *y, int *mx, int *my)
{
	int row, col;
	getmaxyx(stdscr, row, col);
	*mx = col - sizeof(message) + 1;
	*my = row - 1;
	hide_message(*x, *y);
	check(x, *mx);
	check(y, *my);
	show_message(*x, *y);
}

int main()
{
	int row, col, x, y, max_x, max_y, key;
	initscr();
	cbreak();
	keypad(stdscr, 1);
	noecho();
	curs_set(0);
	getmaxyx(stdscr, row, col);
	x = (col-(sizeof(message)-1))/2;
	y = row/2;
	max_x = col - sizeof(message) + 1;
	max_y = row - 1;
	show_message(x, y);
	while((key = getch()) != key_escape) {
		switch(key) {
		case KEY_UP:
			move_message(&x, &y, max_x, max_y, 0, -1);
			break;
		case KEY_DOWN:
			move_message(&x, &y, max_x, max_y, 0, 1);
			break;
		case KEY_LEFT:
			move_message(&x, &y, max_x, max_y, -1, 0);
			break;
		case KEY_RIGHT:
			move_message(&x, &y, max_x, max_y, 1, 0);
			break;
		case KEY_RESIZE:
			handle_resize(&x, &y, &max_x, &max_y);
			break;
		}
	}
	endwin();
	return 0;
}
```

* Функция вывода - `printw`, принимает аргументы как `printf` и используется для форматированного вывода. Например:
```
move(0, 0);
printw("(%d,%d)    ", x, y);

// или в одну строку с помощью mvprintw
mvprintw(0, 0, "(%d,%d)    ", x, y);

// только не забываем что координаты для вывода указываются в последовательности `y, x`
```
### Управление аттрибутами и цветом символов
Аттрибуты для терминальных символов. Пример:
```
attron(A_BOLD);
addstr("Hello, ");
attron(A_UNDERLINE);
addstr("wonderful");
attroff(A_BOLD|A_UNDERLINE);
addstr(" world! ");

addch('*' | A_BOLD | A_BLINK); 
```

* Проверка, возможна ли работа с цветом в терминале - `has_colors`, если вернула 0, то недоступны.

Пример программы для работы с цветом, с учетом поддерживает терминал цвет или нет:
```
initscr();
work_bw = !has_colors();
if(!work_bw)
	start_color();
```
> Цвета символов `ncurses` всегда устанавливаются цветовыми парами (для символа и фона). Пример:
```
// параметры, номер пары, цвет символа, цвет фона.
init_pair(1, COLOR_WHITE, COLOR_BLUE);
attrset(COLOR_PAIR(1) | A_UNDERLINE);
addstr("White on blue");
refresh();
```

> Если изменить цвета для существующей цветовой пары, то на экране соответствующим образом изменятся цвета всех символов, выданных с использованием этого номера цветовой пары.

### Клавиатурный ввод с тайм аутами
По умолчанию, функция `getch` ждет наступления очередного события, если оно еще не произошло на момент её вызова. Но режим работы можно изменить так, чтобы `getch` всегда немедленно возвращала управление, причем если никаких событий не произошло, возвращаемое значение будет равно константе `ERR`. Болле того можно задать `getch` тайм аут(в миллисекундах). В этом случае функция будет ожидать наступления события, но не более чем в течение заданного тайм-аутом временного периода, после чего, если никакое событие так и не произойдет, благополучно вернет `ERR`.

> Управлять режимом тайм аута можно с помощью функции, которая так и называется `timeout`. Любое отрицательное значение аргумента `timeout`, установит обычный блокирующий режим, при котором `getch` ждет наступления события без ограничения по времени.

Программа вывода звездочки с управлением:
```
#include <ncurses.h>

enum { delay_duration = 100 };
enum { key_escape = 27 };

struct star {
	int cur_x, cur_y, dx, dy;
};

static void show_star(const struct star *s)
{
	move(s->cur_y, s->cur_x);
	addch('*');
	refresh();
}

static void hide_star(const struct start *s)
{
	move(s->cur_y, s->cur_x);
	addch(' ');
	refresh();
}

static void check(int *coord, int max)
{
	if(*coord < 0)
		*coord += max;
	else
	if(*coord > max)
		*coord -= max;
}

static void move_star(struct star *s, int max_x, int max_y)
{
	hide_star(s);
	s->cur_x += s->dx;
	check(&s->cur_x, max_x);
	s->cur_y += s-dy;
	check(&s->cur_y, max_y);
	show_star(s);
}

static void set_direction(struct star *s, int dx, int dy)
{
	s->dx = dx;
	s->dy = dy;
}

static void handle_resize(struct star *s, int *col, int *row)
{
	getmaxyx(strscr, *row, *col);
	if(s->cur_x > *col)
		s->cur_x = *col;
	if(s->cur_y > *row)
		s->cur_y = *row;
}

int main()
{
	int row, col, key;
	struct star s;
	initscr();
	cbreak();
	timeout(delay_duration);
	keypad(stdscr, 1);
	noecho();
	curs_set(0);
	getmaxyx(stdscr, row, col);
	s.cur_x = col/2;
	s.cur_y = row/2;
	set_direction(&s, 0, 0);
	while((key = getch()) != key_escape) {
		switch(key) {
		case ' ':
			set_direction(&s, 0, 0);
			break;
		case KEY_UP:
			set_direction(&s, 0, -1);
			break;
		case KEY_DOWN:
			set_direction(&s, 0, 1);
			break;
		case KEY_LEFT:
			set_direction(&s, -1, 0);
			break;
		case KEY_RIGHT:
			set_direction(&s, 1, 0);
			break;
		case ERR:
			move_star(&s, col-1, row-1);
			break;
		case KEY_RESIZE:
			handle_resize(&s, &col, &row);
			break;
		}
	}
	endwin();
	return 0;
}
```
### Программа на Си без стандартной библиотеки
Пример программы без стандартной библиотеки на Си, выводит на экран информацию. Модуль на assembler:
```
; calls.asm
global 		sys_read
global		sys_write
global		sys_errno

section		.text

generic_syscall_3:
		push	ebp
		mov	ebp, esp
		push	ebx
		mov	ebx, [ebp+8]
		mov	ecx, [ebp+12]
		mov	edx, [ebp+16]
		int 	80h
		mov	edx, eax
		and	edx, 0fffff000h
		cmp	edx, 0fffff000h
		jnz	.okay
		mov	[sys_errno], eax
		mov	eax, -1
.okay		pop	ebx
		mov	esp, ebp
		pop 	ebp
		ret
		
sys_read:	mov 	eax, 3
		jmp 	generic_syscall_3
sys_write: 	mov	eax, 4
		jmp	generic_syscall_3

section		.bss
sys_errno	resd	1
```
Модуль для загрузки `main` на ассмеблер:
```
; start.asm
global _start;
extern main
section		.text
_start:		mov	ecx, [esp]	; argc in ecx
		mov	eax, esp
		add	eax, 4		; argv in eax
		push	eax
		push	ecx
		call	main
		add	esp, 8		; clean the stack
		mov	ebx, eax	; now call _exit
		mov	eax, 1
		int 	80h
```

Модуль на Си, с расчетом на использование только что написанных оберток, вместо функции `write` из стандартной библиотеки:
```
/* greet3.c */
int sys_write(int fd, const void *buf, int size);

static const char dunno[] = "I don't know how to greet you\n";
static const char hello[] = "Hello, dear ";

static int string_length(const char *s)
{
	int i;
	for(i = 0; s[i]; i++)
		;
	return i;
}

int main(int argc, char **argv)
{
	if(argc < 2) {
		sys_write(1, dunno, sizeof(dunno)-1);
		return 1;
	}
	sys_write(1, hello, sizeof(hello)-1);
	sys_write(1, argv[1], string_length(argv[1]));
	sys_write(1, "\n", 1);
	return 0;
}
```

Сборка программы:
```
nasm -f elf start.asm
nasm -f elf calls.asm
gcc -Wall -c greet3.c
ld start.o calls.o greet3.o -o greet3
```

> Для финальной сборки вызвали редактор связей вручную, не использую возможностей `gcc`. Ведь мы отказались от использования библиотеки Си, так что знания компилятора относительно того, где брать эту библиотеку, не нужны. 

Размер исполняемого файла - 816 байт, что в семьсот с лишним раз меньше, чем со стандартной библиотекой.

Но гораздо важнее сам принцип. **Язык Си позовляет полностью отказаться от возможностей стандартной библиотеки**. Кроме Си, таким свойством - абсолютной независимостью от библиотечного кода, также иногда называемым `zero runtime` - обладают на сегодняшний день только языки ассемблеров, ни один язык выского уровня не представляет такой возможности.

Для того, чтобы обладать свойствами `zero runtime`, язык не должен включать никаких средств, реализация которых на уровне машинного кода столь сложна, чтобы имело смысл выносить её в подпрограмму. Иначе говоря, свойство `zero runtime` достигается благодаря отсутствию в языке определенных возможностей, а не благодаря их наличию.

> При использовании `gcc` наша программа могла бы не пройти финальную сборку, при этом компоновщик пожаловался бы на отсутствие каких-то неведомых функций, чьи имена начинаются с двух подчеркиваний. Это означало бы, что в нашей программе мы использовали некую возможность, которую компилятор реализует через вызов "своей собственной функции". Примером такой возможности служит умножение чисел типа `long long` на 32 битной системе. К счастью, в такой ситуации требуется подключать не обычную "стандартную библиотеку", а сравнительно небольшую библиотеку, содержащую как раз такие вот "хитрые" функции. Для `gcc` эта библиотека называется `libgcc` и подключается добавлением флага `-lgcc` при вызове линкера:
```
ld start.o calls.o greet3.o -lgcc -o greet3
```

### Компилятор `gcc`
Для `c++` и `c` используется один и тот же компилятор, оба имени являются обычно символическими ссылками на исполняемый файл, для `c` - `gcc`, для `c++` - `g++`. Поведение компилятора зависит от того, по какому имени его вызывали, прежде всего различие выражается в наборе стандартных библиотек, подключаемых по умолчанию при сборке исполняемого файла.

Некоторые ключи компилятора:
* `-o <filename>` - задает имя исполняемого файла, в который будет записан результат компиляции (если не указать, будет помещен в a.out);
* `-Wall` - приказывает выдавать все разумные предупреждения.
* `-ggdb` и `-g` - включение в результирующие файлы отладочной информации, т.е. информации, используемой отладчиком, включая имена переменных и функций и т.п. Флаг `-ggdb` снабжает файлы расширенной отладочной информацией, понятной только `gdb`. Если что-то не в порядке с отладчиком, пробуй использовать `-g`.
* `-c` - указывает что результатом должна быть не вся программа, а отдельный её модуль. В этом случае имя файла для объектного модуля можно не задавать, оно будет сгенерировано автоматически заменой расширения на `.o`;
* `-0n` - задает уровень оптимизации `n=0` означает отсутствие оптимизации(значение по умолчанию). Для получения более эффективного объектного кода рекомендуется использовать флаг `-02`. Оптимизация может затруднить работу с отладчиком.
* `-ansi` - приказывает компилятору работать в соответствии со стандартом `ANSI C`;
* `-pedantic` - запрещает все расширения языка, не входящие в выбранный стандарт.
* `-E` - Останавливает компилятор после проведения стадии макропроцессирования. Результат макропроцессирования выдается на стандартный вывод. Этот режим работы подойдет если ваши макроопределения повели себя не так, как вы ожидали, и хочется понять, что на самом деле происходит.
* `-S` - останавливает процесс компиляции после стадии генерации ассемблерного кода. Получившийся текст на языке ассемблера записывается в файл с суффиксом `.S`. К сожалению генерируемый ассемблерный код имеет синтаксис `AT&T`, который существенно отличается от изучавшегося синтаксиса `Intel`, но разобраться в нем вполне реально.
* `-D` - позволяет с командной строки (т.е. без изменения исходных файлов) определить в программе некий макросимвол. Например `-DDEBUG=2`, дает такой же эффект как `#define DEBUG 2` в начале исходного кода.
* `-include` включает в программу текстовый файл, как если бы он был подключен директивой `#include`.
* `-I` - добавляет к рассмотрению директорию, в которой следует искать файлы, подключаемые с помощью `#include`. Этот флаг оказывает влияние как на `#include "..."`, так и на `#include <...>;`.
* `-isystem` делает примерно то же самое, но добавленная директория рассматривается как "системная". Это сравнительно недавнее новшество в компиляторах семейства `gcc`, которое может оказаться важным при использовании флага `-MM`.
* `-l` - позволяет подключить к программе библиотеку функций. Например если в программе используются математические функции, необходимо задать ключ `-lmath`.
* `-L` - добавляет к рассмотрению директорию, в которой следует искать файлы библиотек, подключенных с помощью `-l`.
* `-MM` - анализирует заданные исходные файлы и строит информацию об их взаимозависимостях.
* `-s` - предписывает компилятору и линкеру выкинуть из генерируемого кода все, что оттуда возможно выкинуть. Например при финальной сборке многомодульной программы будет исключена отладочная информация - даже из тех модулей, которые были откомпилированны с флагом `-g`.

Например чтобы откомпилировать программу, состоящую из нескольких модулей `mod1.c`, `mod2.c`, `mod3.c` и главного файла `prog.c` следует откомпилировать все модули:
```
gcc -g -Wall -c mod1.c
gcc -g -Wall -c mod2.c
gcc -g -Wall -c mod3.c
```
После этого следует дать команду: `gcc -g -Wall mod1.o mod2.o mod3.o prog.c -o prog`.

### Отладчик `gdb`
Для нормальной работы отладчика нужно, чтобы все модули программы были откомпилированы с ключом `-ggdb` или `-g`.

> В некоторых случаях работе отладчика может помешать включенный режим оптимизации.

Запуск отладчика: `gdb ./prog`

Основные команды отладчика:
* `run` - осуществляет запуск программы в отладочном режиме. Перед запуском целесообразно задать точки останова.
* `start` - запускает программу в отладочном режиме, остановив её в начале функции `main()`;
* `list` -  показывает на экране несколько строк программы, предшествующих текущей и идущих непосредственно после текущей.
* `inspect` - позволяет просмотреть значение переменной (в том числе и заданной сложным выражением вроде `*(a[i+1].p))`.
* `backtrace` или `bt` - показывает текущее содержимое стека, что позволяет узнать последовательность вызовов функций, приведшую к текущему состоянию программы.
* `frame` - позволяет сделать текущим один из фреймов, показанных командой `backtrace`, что дает возможность исследовать значения  переменных в этом фрейме и т.п.
* `step` - позволяет выполнить одну строку программы. Если в строке содержится вызов функции, текущей строкой станет первая строка этой функции.
* `next` - подобна команде `step`, с тем отличием, что вход в тела вызываемых функций не производится.
* `until <номер строки>` - позволяет выполнять программу до тех пор, пока текущей не окажется строка с указанным номером.
* `call` - позволяет выполнить вызов произвольной функции
* `set var <присваивание>` - позволяет занести заданное значение в переменную, например `set var i=17`, занесет в переменную `i` значение 17.
* `break` - позволяет задать точку приостановки выполнения программы (`breakpoint`). Точка останова может быть задана именем функции, номером строки в текущем файле или выражением <имя файла>:<номер строки> например `file1.c:73`.
* `disable <номер точки останова>` - позволяет временно отменить точку остановка, отладчик продолжает помнить о ней, но программа в этом месте не останавливается.
* `enable <номер точки останова>` - снова активирует точку останова, ранее выключенную командой `disable`.
* `ignore <номер точки останова> <число>` - предписывает отладчику проигнорировать заданную точку останова указанное число раз, например `ignore 5 200` означает, что точка останова №5 должна быть 200 раз проигнорирована, а при попадании в эту точку 201й раз программу следует приостановить.
* `cond <номер точки останова> <условие>` - задает условие, при выполнении которого следует приостановить выполнение программы в данной точке останова. Например, `cond 5 i<100` означает, что в точке останова №5 следует остановится только в случае, если занести значение переменной `i` в программе будет меньше 100.
* `cont` - позволяет продолжить прерванное выполнение программы
* `help` - позволит узнать подробнее об этих и других командах отладчика
* `quit` - завершает работу отладчика (можно воспользоваться `Ctrl+D`).

Если отлаживаемой программе нужно задать аргументы командной строки, это можно сделать одним из двух способов. Во-первых, можно воспользоваться при запуске флагом `--args` так:
```
gdb --args ./prog bra sads sad
```
Или можно запустить отладчик без указания аргументов командной строки, а при запуске программы на пошаговое выполнение указать эти аргументы в команде `run`:
```
(gdb) run asd asd asd
```
Когда  ошибки в программе приводят к её аварийному завершению, ОС создает (если это не запрещено `ulimit -c` - узнать, `ulimit -c unlimited` - отменить запрет) `core` файл. При этом выдается сообщение `Segmentation fault (core dumped)`. Это означает что в текущей директории аварийно завершенного процесса создан файл с именем `core` (или `prog.core`, где `prog` - имя программы), в который система записала содержимое сегмента данных и стека программы на момент её аварийного завершения. Сегмент кода в `core` файл не записываются, поскольку его можно взять из исполняемого файла.

С помощью отладчика `gdb` можно проанализировать `core` файл, узнав, при выполнении какой строки программы произошла авария, откуда и с какими параметрами была вызвана функция, содержащая эту строку, каковы были значения переменных на момент аварии и т.д. Отладчик в режима анализа `core` файла запускается командой:
```
gdb ./prog prog.core
```
Сразу после запуска отладчика в режиме анализа `core` файла рекомендуется дать команду `backtrace` или просто `bt`. В большинстве случаев по её выдаче вы сможете понять что произошло и где. В остальных случаях помогут команды `frame`, `list`, `inspect`. Команды `step`, `next`, `cont`, `break` применять нельзя.

В случае если процесс завис, полезно провести его анализ, прежде чем убить его. Определите номер процесса с помощью `ps`, а затем вызвать отладчик можно так:
```
gdb ./prog 12345
```
При подключении отладчика выполнение программы будет приостановлено, однако можно при необходимости продолжить его командой `cont`. В случае повторного зацикливания можно приказать отладчику вновь приостановить выполнение нажатием комбинации `Ctrl-C`

### Программа `valgrind`
Утилита `valgrind` позволяет в автоматическом режиме обнаружить в поведении вашей программы такие особенности, которые свидетельствуют о допущенных ошибках и могут рано или поздно привести к тяжелым последствиям.

Утилита `valgrind` представляет собой интерпретатор машинного кода, то есть реализует возможности центрального процессора программно.

Запуск `valgrind`:
```
valgrind --tool=memcheck ./<имя проверяемого файла>
```

> Всю свою выдачу `valgrind` направляет в поток диагностики (`stderr`), так что можно например:
```
valgrind --tool=memcheck ./badcode 2> VG_LOG
```
В этом случае увидим на экране только строки, выдаваемые программой, а информацию от `valgrind` найдете в файле `VG_LOG`.

> Отличить строки, которые напечатал `valgrind` просто, они начинаются:
```
==NNNN==
--NNNN--
```
где `NNNN` номер процесса.

Запуск отладчика:
```
valgrind --tool=memcheck --db-attach=yes ./badcode
```

### Система автоматической сборки (утилита `make`)
Утилита позволяет автоматически строить одни файлы на основании других (например исполняемые файлы на основании исходных текстов программы) в соответствии с заданными правилами. При этом `make` отслеживает даты последней модификации файлов и производит перестроение только тех целевых файлов, для которых исходные файлы претерпели изменение.

Правила для утилиты `make` задаются в файле `Makefile`, который утилита ищет в директории.

Например чтобы собрать программу из файлов, можно сделать `makefile`:
```
mod1.o: mod1.c mod1.h
	gcc -g -Wall -c mod1.c -o mod1.o
	
mod2.o: mod2.c mod2.h
	gcc -g -Wall -c mod2.c -o mod2.o

prog: main.c mod1.o mod2.o
	gcc -g -Wall main.c mod1.o mod2.o -o prog
```
 
 > Строка команды всегда начинается с символа табуляции. `make` считает конца списка команд первую строку, начинающуюся с символа, отличного от табуляции.
 
 Имя в текущей директории `Makefile`, мы можем для сборки нашей программы дать команду `make prog`.
 
 Можно переписать `Makefile` с использованием переменных:
```
CC = gcc
CFLAGS = -g -Wall -ansi -pedantic
 
mod1.o: mod1.c mod1.h
 	$(CC) $(CFLAGS) -c mod1.c -o mod1.o
	
mod2.o: mod2.c mod2.h
	$(CC) $(CFLAGS) -c mod2.c -o mod2.o
	
prog: main.c mod1.o mod2.o
	$(CC) $(CFLAGS) main.c mod1.o mod2.o -o prog
```

Некоторые традиционные имена переменных:
* `CC` - команда вызова компилятора языка Си;
* `CFLAGS` - параметры для компилятора языка
* `CXX` - команда вызова компилятора языка
* `CXXFLAGS` - параметры для компилятора языка Си ++
* `CPPFLAGS` - параметры препроцессора (обычно сюда помещают предопределенные макропеременные)
* `LD` - команда вызова системного линкера (редактора связей)
* `MAKE` - команда вызова утилиты `make` со всеми параметрами

> По умолчанию переменные `CC`, `CXX`, `LD`, `MAKE` имеют соответствующие значения, справедливые для данной системы и в данной ситуации.

Псевдопеременные:
* `$@` - имя текущей цели
* `$<` - имя первой цели из списка зависимостей
* `$^` - весь список зависимостей

С использованием псевдопеременных можем переписать `Makefile`:
```
CFLAGS = -g -Wall

mod1.o: mod1.c mod1.h
	$(CC) $(CFLAGS) -c $< -o $@
	
mod2.o: mod2.c mod2.h
	$(CC) $(CFLAGS) -c $< -o $@

prog: main.c mod1.o mod2.o
	$(CC) $(CFLAGS) $^ -o $@
```

Можно задать одно обобщенное правило построения объектного файла для любого модуля, написанного на языке Си, исходный файл которого имеет имя с суффиксом `.c`, а заголовочный файл - имя с суффиксом `.h`:
```
%.o: %.c %.h
	$(CC) $(CFLAGS) -c $< -o $@
```

Перепишем `Makefile`:
```
OBJMODULES = mod1.o mod2.o
CFLAGS = -g -Wall -ansi -pedantic

%.o: %.c %.h
	$(CC) $(CFLAGS) -c $< -o $@

prog: main.c $(OBJMODULES)
	$(CC) $(CFLAGS) $^ -o $@
```
Если перечисление модулей через имена объектных файлов представляются неествественным, можно заменить первую строку `Makefile` следующими двумя строками:
```
SRCMODULES = mod1.c mod2.c
OBJMODULES = $(SRCMODULES:.c=.o)
// $(SRCMODULES:.c=.o) означает что нужно взять значение переменной `SRCMODULES` и в каждом входящем в это значение слове заменить суффикс .c на .o
```
Утилиту `make` можно использовать не только для построения файлов, но и для выполнения произвольных действий. Добавим к нашему файлу две дополнительные цели:
```
run: prog
	./prog

clean: 
	rm -f *.o prog
```
Теперь по команде `make run` произведет если нужно сборку программы и запустит её. С помощью команды `make clean` можем очистить рабочую директорию от объектных и исполняемых файлов. Такие цели называют **псевдоцелями**.

Утилита `make` позволяет наряду с обобщенным правилом указать список зависимостей для построения конкретных модулей:
```
%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@
	
mod1.o: mod1.c mod1.h mod2.h mod3.h
```
В этом случае для построения `mod1.o` будет использовано обобщенное правило (поскольку никаких команд в цели `mod1.o` мы не указали), но список зависимостей будет использован из цели `mod1.o`.
	
Списки зависимостей можно построить с помощью компилятора. Получить строку подобную последней строке вышеприведенного примера можно так:
```
gcc -MM mod1.c
```
Если результат выполнения такой команды перенаправить в файл, то этот файл можно будет включить в наш `Makefile` директивой `include`. Эта директива имеет специальную форму со знаком `-`, при использовании которой `make` не выдает ошибок, если файл не найден. Если использовать для файла зависимостей имя `deps.mk`, директива его включения будет выглядеть так:
```
-include deps.mk
```
Если предусмотреть цель для генерации файла, включаемого такой директивой, например:
```
deps.mk: $(SRCMODULES)	
	$(CC) -MM $^ > $@
```
утилита `make`, прежде чем начать построение любых других целей, будет пытаться построить включаемый файл.

> Такое поведение нежелательно для псевдоцели `clean`, поскольку для очистки рабочей директории от мусора построение файлов зависимостей не нужно и только отнимает время. Чтобы избежать этого, следует снабдить директиву `-include` условной конструкцией, исключающей эту строку из рассмотрения, если единственной целью, заданной в командной строке, является цель `clean`. Это делается с помощью директивы `ifneq` и встроенной переменной `MAKECMDGOALS`:
```
ifneq (clean, $(MAKECMDGOALS))
-include deps.mk
endif
```

Перепишем `Makefile`:
```
SRCMODULES = mod1.c mod2.c
OBJMODULES = $(SRCMODULES:.c=.o)
CFLAGS = -g -Wall -ansi -pedantic

%.o: %.c %.h
	$(CC) $(CFLAGS) -c $< -o $@
	
prog: main.c $(OBJMODULES)	
	$(CC) $(CFLAGS) $^ -o $@

ifneq (clean, $(MAKECMDGOALS))
-include deps.mk
endif

deps.mk: $(SRCMODULES)
	$(CC) -MM $^ > $@

clean: 
	rm -f *.o prog
```
> Примечания насчет `gcc -MM` на странице 456 Столяров том 2.

### Сравнение файлов и наложение изменений
Выявить различия между файлами помогает программа `diff`:
```
diff hello.c hello2.c
```
