### Секции `man` 
* 1 - описывает программы и команды, которые установлены в системе
* 2 - содержит описания системных вызовов
* 3 - функции стандартной библиотеки си
* 5 - описания форматов файлов
* 8 - описания команд, предназначенных для системного администратора
Пример вызова для стандратной библиотеки Си:
```
man 3 printf
```
### Компиляция
`gcc -Wall -g <название файла который компилируем> -o <название файла в который все компилируется>`
* `-Wall` включает все разумные предупреждения
* `-g` включает всю отладочную информацию

Пример: `gcc -Wall -g hello.c -o hello`
### Подключение библиотеки при компиляции
`gcc -Wall -g -lm -Calc.c -o calc`
* `-lm` - подключение библиотеки (математической в этом случае)

### Функция вывода 
```
printf("%d times %d is %d\n", x, x, x * x);
```
* `%d` - параметр как целое число
* `%x` - параметр как шестнадцетиричное число
* `%f` - параметр как число с точкой, а `%.5f` - сколько знаков после запятой
* `%c` - печать символа

### Функция ввода
`scanf` - возвращает число, успешно обслуженных введенных данных ("процентов"). Например:
```
n = scanf("%lf %lf %lf", &p, &q, &r);
if(n != 3){
  printf("Error: wrong input.\n");
  return 1;
}
```

* `%f` - число с точкой
* `%lf` - длинное число с точкой
### Операция взятия адреса 
`&t` - взятие адреса с переменной `t`

### Инициализация
`var t = 25`
> Если в описании переменной нет инициализатора, то её исходное значение зависит от того, локальная она или глобальная. **Глобальные переменные**, для которых начальное значение не задано, заполняются нулями. **Локальные переменные** в отсутствии инициализаторов никаких начальных значений не получают, то есть в локальной переменной может оказаться абсолютно произвольный мусор. (**Уточнение страница 217 Столяров том 2**)
### Типы данных
#### Логические значения (их нет)
* 0 - ложь
* Все остальное - истина
Пример для проверки значения:
```
a = <целое число>
if(a != 0)
// одно и то же что и
if(a)
```
> Также можно использовать адресное выражение. **Нулевой указатель** - ложь, а любой другой указатель - истину.

#### Символьные значения
Символ и его код это одно и то же
Например символ обозначается как `'a'`, но это для компилятора то же самое что и `'97'` (Код `a` в ASCII таблице)

#### Разрядность
* `char` - 1 байт (или минимальный адресуемый размер памяти)
* `unsigned char` - беззнаковый (от 0 до 255)
* `signed char` - знаковый (от -128 до 127)
* `short` - 2 байт (или не может быть меньше `char`)
* `unsigned short` (иногда пишут `unsigned short int x`)
* `int` - 4 байт
* `unsigned int`
* `long` - 6 байт
* `unsigned long`
* `long long` - 6 байт
* `unsigned long long`
* `float`
* `double`
* `long double` - от 12 до 16 байт
> Математические функции (`sqrt`, синусы, косинусы и т.д.) по умолчанию работают с типом `double`. Также для любых вычислений  и простой передачи параметров значений типа `float` все преобразуется к типу `double`, следовательно использовать тип `float` бессмысленно, его используют только в случае если таких чисел много, а памяти не хватает.
> `sizeof(<тип>)` - выражение данного вида, компилятор заменяет на число, равное размеру данного типа (единицей измерения является `char`).

### Литералы(константы) разных типов
Простейший пример - целое число как оно есть.
* Восьмеричное - 035 (впереди ноль)
* Шестнадцатиричное - 0x1d (впереди 0x)

* Литералов типа `char` нет, символы имеют тип `int`
* Литералы типа `short`, `unsigned short` не предусмотрены

> Можно явно указать тип литерала `L(long)`,`LL(long long)`, `U(unsigned)`, `F(float)`, например `15ULL` - тип `unsigned long long`.

> **Числа с плавающей точкой** записываются в виде литералов в десятичной системе счисления, например:
```
1500.0 1500. 15E2 15.E2 15E+2 0.15e4 .15e4 15000e-4
```
#### Escape последовательности
* Символ перевода строки - `\n` или 10
* Возврат каретки - `\r` или 13
* Табуляция - `\t` или 9
* Звонок - `\a` или 7
* Забой - `\b` или 8
* Перевод страницы - `\f` или 12
* Вертикальная табуляция - `\v` или 11

#### Представление символов
* Обратный слеш - `'\\'`
* Апостроф - `'\''`
* Кавычки - `'\"'` или `'"'`
> Строки и символы - разные сущности, например `'z'` представляется кодом символа, а `"z"` представляется двумя символами - кодом символа, и кодом окончания строки (0).

> Строковые литералы записанные через пробел скеливаются - `"This " "is" " a string"` = `This is a string`.

### Операции и выражения
* операция взятия адреса - `&`, например `&a`
* операция разыменования - `*`, если `p` это адрес, то `*p`- то, что расположено по этому адресу.
* операция выборки поля из структуры или объединения обозначается точкой, например `item1.next`
* операция выборки поля из структуры или объединения по имеющемуся адресу обозначается стрелкой `->`, например `a->b` - то же самое, что и `(*a).b`.
* взятие остатка от деления - `%`
> операции сравнения всегда возвращают целочисленное число, 1 - истина, 0 - ложь.

### Операторы
* `x = 17` - оператор вычисления выражения ради побочного эффекта, само выражение построено на основе бинарной арифметической операции - присваивания 
* `printf("Hello, world\n")` - оператор вычисления выражения. В качестве выражения здесь выступает бинарная версия вызова функции(первый аргумент `printf`, второй аргумент литерал `"Hello, world\n"`. Мы даже знаем, что у этого выражения есть значение - функция `printf` в результате такого вызова вернет число 13, но оно нам не нужно, о чем мы и сообщаем компилятору, поставив точку с запятой.
