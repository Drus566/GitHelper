# Содержание
1. [С чего начать](#1)
* 1.1 [Rails для начинающих](#1.1)
* * 1.1.1 [Что такое Rails](#1.1.1)
* * 1.1.2 [Создание Rails приложения](#1.1.2)
* * 1.1.3 [Hello Rails](#1.1.3)
* * 1.1.4 [Безопасность Rails](#1.1.4)
* * 1.1.5 [Что дальше](#1.1.5)
2. [Модели](#2)
* 2.1 [Основы Active Record](#2.1)
* * 2.1.1 [Что такое Active record](#2.1.1)
* * 2.1.2 [Соглашения над конфигурацией](#2.1.2)
* * 2.1.3 [Создание моделей Active record](#2.1.3)
* * 2.1.4 [Переопределение соглашений о конфигурации](#2.1.4)
* * 2.1.5 [CRUD операции](#2.1.5)
* * 2.1.6 [Валидации](#2.1.6)
* * 2.1.7 [Колбэки](#2.1.7)
* * 2.1.8 [Миграции](#2.1.8)
* 2.2 [Миграции Active Record](#2.2)
* * 2.2.1 [Обзор миграции](#2.2.1)
* * 2.2.2 [Создание миграции](#2.2.2)
* * 2.2.3 [Написание миграции](#2.2.3)
* * 2.2.4 [Запуск миграции](#2.2.4)
* * 2.2.5 [Изменение существующих миграций](#2.2.5)
* * 2.2.6 [Выгрузка схемы](#2.2.6)
* * 2.2.7 [Active Record и ссылочная целостность](#2.2.7)
* * 2.2.8 [Миграции и сиды](#2.2.8)
* * 2.2.9 [Старые миграции](#2.2.9)
* 2.3 [Валидации](#2.3)
* * 2.3.1 [Обзор валидаций](#2.3.1)
* * 2.3.2 [Валидационные хелперы](#2.3.2)
* * 2.3.3 [Общие опции валидаций](#2.3.3)
* * 2.3.4 [Строгие валидации](#2.3.4)
* * 2.3.5 [Условная валидация](#2.3.5)
* * 2.3.6 [Выполнение собственных валидаций](#2.3.6)
* * 2.3.7 [Работаем с ошибками валидации](#2.3.7)
* * 2.3.8 [Отображение ошибок валидации во вьюхах](#2.3.8)
* 2.4 [Колбэки](#2.4)
* * 2.4.1 [Жизненный цикл объекта](#2.4.1)
* * 2.4.2 [Обзор колбэков](#2.4.2)
* * 2.4.3 [Доступные колбэки](#2.4.3)
* * 2.4.4 [Запуск колбэков](#2.4.4)
* * 2.4.5 [Пропуск колбэков](#2.4.5)
* * 2.4.6 [Прерывание выполнения](#2.4.6)
* * 2.4.7 [Колбэки для отношений](#2.4.7)
* * 2.4.8 [Условные колбэки](#2.4.8)
* * 2.4.9 [Классы колбэков](#2.4.9)
* * 2.4.10 [Транзакционные колбэки](#2.4.10)
* 2.5 [Связи (ассоциации)](#2.5)
* * 2.5.1 [Зачем нужны связи?](#2.5.1)
* * 2.5.2 [Типы связей](#2.5.2)
* * 2.5.3 [Полезные советы и предупреждения](#2.5.3)
* * 2.5.4 [Подробная информация по связи belongs_to](#2.5.4)
* * 2.5.5 [Подробная информация по связи has_one](#2.5.5)
* * 2.5.6 [Подробная информация по связи has_many](#2.5.6)
* * 2.5.7 [Подробная информация по связи has_and_belongs_to_many](#2.5.7)
* * 2.5.8 [Подробная информация по колбэкам и расширениям связи](#2.5.8)
* * 2.5.9 [Наследование с единой таблицей (STI)](#2.5.9)
* 2.6 [Интерфейс запросов](#2.6)
* * 2.6.1 [Получение объектов из базы данных](#2.6.1)
* * 2.6.2 [Условия](#2.6.2)
* * 2.6.3 [Сортировка](#2.6.3)
* * 2.6.4 [Выбор определенных полей](#2.6.4)
* * 2.6.5 [Ограничение и смещение](#2.6.5)
* * 2.6.6 [Группировка](#2.6.6)
* * 2.6.7 [Having](#2.6.7)
* * 2.6.8 [Переопределяющие условия](#2.6.8)
* * 2.6.9 [Нулевой Relation](#2.6.9)
* * 2.6.10 [Объекты только для чтения](#2.6.10)
* * 2.6.11 [Блокировка записей для обновления](#2.6.11)
* * 2.6.12 [Соединительные таблицы](#2.6.12)
* * 2.6.13 [Нетерпеливая загрузка связей](#2.6.13)
* * 2.6.14 [Скоупы](#2.6.14)
* * 2.6.15 [Динамический поиск](#2.6.15)
* * 2.6.16 [Enum](#2.6.16)
* * 2.6.17 [Цепочки методов](#2.6.17)
* * 2.6.18 [Поиск или создание нового объекта](#2.6.18)
* * 2.6.19 [Поиск с помощью SQL](#2.6.19)
* * 2.6.20 [Существование объектов](#2.6.20)
* * 2.6.21 [Вычисления](#2.6.21)
* * 2.6.22 [Запуск EXPLAIN](#2.6.22)
* 2.7 [Active Record для PostgreSQL](#2.7)
* * 2.7.1 [Типы данных](#2.7.1)
* * 2.7.2 [Первичные ключи UUID](#2.7.2)
* * 2.7.3 [Полнотекстовый поиск](#2.7.3)
* * 2.7.4 [Представление базы данных](#2.7.4)
* 2.8 [Основы Active Model](#2.8)
* * 2.8.1 [Введение](#2.8.1)
3. [Вьюхи](#3)
* 3.1 [Обзор Action View](#3.1)
* * 3.1.1 [Что такое Action View?](#3.1.1)
* * 3.1.2 [Использование Action View с Rails](#3.1.2)
* * 3.1.3 [Шаблоны, партиалы и макеты](#3.1.3)
* * 3.1.4 [Макеты партиалов](#3.1.4)
* * 3.1.5 [Пути вьюх](#3.1.5)
* * 3.1.6 [Обзор хелперов, предоставленных Action View](#3.1.6)
* * 3.1.7 [Локализованные вьюхи](#3.1.7)
* 3.2 [Макеты и рендеринг в Rails](#3.2)
* * 3.2.1 [Обзор: как кусочки складываются вместе](#3.2.1)
* * 3.2.2 [Создание откликов](#3.2.2)
* * 3.2.3 [Структурирование макетов](#3.2.3)
* 3.3 [Макеты и рендеринг в Rails](#3.3)
* * 3.3.1 [Разбираемся с простыми формами](#3.3.1)
* * 3.3.2 [Работаем с объектами модели](#3.3.2)
* * 3.3.3 [Легкое создание списков выбора](#3.3.3)
* * 3.3.4 [Использование хелперов даты и времени](#3.3.4)
* * 3.3.5 [Загрузка файлов](#3.3.5)
* * 3.3.6 [Настройка Form Builder](#3.3.6)
* * 3.3.7 [Понимание соглашений по именованию параметров](#3.3.7)
* * 3.3.8 [Формы к внешним ресурсам](#3.3.8)
* * 3.3.9 [Создание сложных форм](#3.3.9)
* * 3.3.10 [Использование form_for и form_tag](#3.3.10)
4. [Контроллеры](#4)
* 4.1 [Обзор Action Controller](#4.1)
* * 4.1.1 [Что делает контроллер?](#4.1.1)
* * 4.1.2 [Соглашение по именованию контроллеров](#4.1.2)
* * 4.1.3 [Методы и экшны](#4.1.3)
* * 4.1.4 [Параметры](#4.1.4)
* * 4.1.5 [Сессия](#4.1.5)
* * 4.1.6 [Куки](#4.1.6)
* * 4.1.7 [Рендеринг данных XML и JSON](#4.1.7)
* * 4.1.8 [Фильтры](#4.1.8)
* * 4.1.9 [Защита от подделки запроса](#4.1.9)
* * 4.1.10 [Объекты Request и Response](#4.1.10)
* * 4.1.11 [Аутентификации HTTP](#4.1.11)
* * 4.1.12 [Потоки и загрузка файлов](#4.1.12)
* * 4.1.13 [Фильтрация лога](#4.1.13)
* * 4.1.14 [Обработка ошибок](#4.1.14)
* * 4.1.15 [Навязывание протокола HTTPS](#4.1.15)
* 4.2 [Роутинг в Rails](#4.2)
* * 4.2.1 [Цель роутера Rails](#4.2.1)
* * 4.2.2 [Ресурсный роутинг](#4.2.2)
* * 4.2.3 [Нересурсные маршруты](#4.2.3)
* * 4.2.4 [Настройка ресурсных маршрутов](#4.2.4)
* * 4.2.5 [Разделение очень большого маршрутного файл на несколько небольших:](#4.2.5)
* * 4.2.6 [Осмотр и тестирование маршрутов](#4.2.6)
5. [Копаем глубже](#5)
* 5.1 [Расширения ядра Active Support](#5.1)
* * 5.1.1 [Как загрузить расширения ядра](#5.1.1)
* * 5.1.2 [Расширения ко всем объектам](#5.1.2)
* * 5.1.3 [Расширения для `Module`](#5.1.3)
* * 5.1.4 [Расширения для `Class`](#5.1.4)
* * 5.1.5 [Расширения для `String`](#5.1.5)
* * 5.1.6 [Расширения для `Numeric`](#5.1.6)
* * 5.1.7 [Расширения для `Integer`](#5.1.7)
* * 5.1.8 [Расширения для `BigDecimal`](#5.1.8)
* * 5.1.9 [Расширения для `Enumerable`](#5.1.9)
* * 5.1.10 [Расширения для `Array`](#5.1.10)
* * 5.1.11 [Расширения для `Hash`](#5.1.11)
* * 5.1.12 [Расширения для `Regexp`](#5.1.12)
* * 5.1.13 [Расширения для `Range`](#5.1.13)
* * 5.1.14 [Расширения для `Date`](#5.1.14)
* * 5.1.15 [Расширения для `DateTime`](#5.1.15)
* * 5.1.16 [Расширения для `Time`](#5.1.16)
* * 5.1.17 [Расширения для `File`](#5.1.17)
* * 5.1.18 [Расширения для `Marshal`](#5.1.18)
* * 5.1.19 [Расширения для `NameError`](#5.1.19)
* * 5.1.20 [Расширения для `LoadError`](#5.1.20)
* 5.2 [Инструментарий Active Support](#5.2)
* * 5.2.1 [Введение в инструментарий](#5.2.1)
* * 5.2.2 [Хуки фреймворка Rails](#5.2.2)
* * 5.2.3 [Action Controller](#5.2.3)
* * 5.2.4 [Action View](#5.2.4)
* * 5.2.5 [Active Record](#5.2.5)
* * 5.2.6 [Action Mailer](#5.2.6)
* * 5.2.7 [Active Support](#5.2.7)
* * 5.2.8 [Active Job](#5.2.8)
* * 5.2.9 [Action Cable](#5.2.9)
* * 5.2.10 [Active Storage (Rails 5.2)](#5.2.10)
* * 5.2.11 [Railties](#5.2.11)
* * 5.2.12 [Rails](#5.2.12)
* * 5.2.13 [Подписка на события](#5.2.13)
* * 5.2.14 [Создание пользовательского события](#5.2.14)
* 5.3 [API интернационализации Rails (I18n)](#5.3)
* * 5.3.1 [Как работает I18n в Ruby on Rails](#5.3.1)
* * 5.3.2 [ Настройка приложения на Rails для интернационализации](#5.3.2)
* * 5.3.3 [Интернационализация и Локализация](#5.3.3)
* * 5.3.4 [Обзор особенностей I18n API](#5.3.4)
* * 5.3.5 [Как хранить свои переводы](#5.3.5)
* * 5.3.6 [Настройка I18n](#5.3.6)
* * 5.3.7 [Перевод контента модели](#5.3.7)
* * 5.3.8 [Заключение](#5.3.8)
* * 5.3.9 [Вклад в Rails I18n](#5.3.9)
* * 5.3.10 [Ресурсы](#5.3.10)
* * 5.3.11 [Авторы](#5.3.11)
* 5.4 [Основы Action Mailer](#5.4)
* * 5.4.1 [Отправка электронной почты](#5.4.1)
* * 5.4.2 [Колбэки Action Mailer](#5.4.2)
* * 5.4.3 [Использование хелперов Action Mailer](#5.4.3)
* * 5.4.4 [Настройка Action Mailer](#5.4.4)
* * 5.4.5 [Тестирование рассыльщика](#5.4.5)
* * 5.4.6 [Перехват и обзор писем](#5.4.6)

8. [Дополнительно](#8)

> В rus rails имеется множество ссылок, на ресурсы по связанным темам прямо в тексте, которые здесь не отображены.

# C чего начать <a name="1"></a>
## Rails для начинающих <a name="1.1"></a>
### Что такое Rails <a name="1.1.1"></a>
Если изучите "The Rails Way", то, возможно, откроете в себе значительное увеличение производительности. Если будете упорствовать и переносить старые привычки с других языков в разработку на Rails, и попытаетесь использовать шаблоны, изученные где-то еще, ваш опыт разработки будет менее счастливым.

Философия Rails включает два важных ведущих принципов:
* Don't Repeat Yourself: DRY — это принцип разработки ПО, который гласит, что "Каждый кусочек информации должен иметь единственное, неизбыточное, авторитетное представление в системе". Не пишите одну и ту же информацию снова и снова, код будет легче поддерживать, и он будет более расширяемым и менее ошибочным.
* Convention Over Configuration: у Rails есть мнения о наилучших способах делать множество вещей в веб-приложении, и по умолчанию выставлены эти соглашения, вместо того, чтобы заставлять вас по мелочам править многочисленные конфигурационные файлы. 
### Создание Rails приложения <a name="1.1.2"></a>
Для установки Rails используйте команду `gem install`, представленную RubyGems:
```
gem install rails
```
Создание приложения:
```
rails new blog
```
Это создаст приложение на Rails с именем Blog в директории blog и установит гемы, зависимости от которых упомянуты в Gemfile при использовании `bundle install`.
> При использовании Windows Subsystem for Linux, имеются некоторые ограничения на сообщения файловой системы, означающие, что следует отключить гемы spring и listen, что можно сделать, запустив `rails new blog --skip-spring --skip-listen`.

Можно посмотреть все возможные опции командной строки, которые принимает билдер приложения на Rails, запустив rails new -h.

Директория
| Файл/Папка | Назначение |
|------------|------------|
| app/ | Содержит контроллеры, модели, вьюхи, хелперы, рассыльщики, каналы, задания и ассеты вашего приложения. Мы рассмотрим эту папку подробнее далее. |
| bin/ | Содержит Rails скрипты которые стартуют ваше приложение, также директория может содержать другие скрипты которые вы используете для настройки, обновления, деплоя или запуска. |
| config/ | Конфигурации маршрутов, базы данных вашего приложения, и т.д. Более подробно это раскрыто в Конфигурирование приложений на Rails |
| config.ru | Конфигурация Rack для серверов, основанных на Rack, используемых для запуска приложения. Подробнее о Rack смотрите на сайте Rack. |
| db/ | Содержит текущую схему вашей базы данных, а также миграции базы данных. |
| Gemfile Gemfile.lock | Эти файлы позволяют указать, какие зависимости от гемов нужны для вашего приложения на Rails. Эти файлы используются гемом Bundler. Подробнее о Bundler смотрите на сайте Bundler. |
| lib/ | Внешние модули для вашего приложения. |
| log/ | Файлы логов приложения. |
| package.json | Этот файл позволяет указать, какие зависимости npm необходимы для приложения Rails. Этот файл используется Yarn. Подробнее о Yarn смотрите на сайте Yarn. |
| public/ | Единственная папка, которая доступна извне как есть. Содержит статичные файлы и скомпилированные ассеты. |
| Rakefile | Этот файл находит и загружает задачи, которые могут быть запущены в командной строке. Определенная задача доступна во всех компонентах Rails. Вместо изменения Rakefile, можно добавить свои собственные задачи, добавив файлы в директорию lib/tasks приложения. |
| README.md | Это вводный мануал для вашего приложения. Его следует отредактировать, чтобы рассказать остальным, что ваше приложение делает, как его настроить, и т.п. |
| storage/ | Файлы Active Storage для сервиса Disk. Это раскрывается в руководстве Обзор Active Storage. |
| test/ | Юнит-тесты, фикстуры и прочий аппарат тестирования. Это раскрывается в руководстве Тестирование приложений на Rails |
| tmp/ | Временные файлы (такие как файлы кэша и pid) |
| vendor/ | Место для кода сторонних разработчиков. В типичном приложении на Rails включает внешние гемы. |
| .gitignore | Этот файл сообщает git, какие файлы (явно или по шаблону) ему следует игнорировать. Подробнее об игнорировании файлов смотрите GitHub - Ignoring files. |
| .ruby-version | Этот файл содержит дефолтную версию Ruby |
### Hello rails <a name="1.1.3"></a>
Запуск `rails server`
> Если вы используете Windows, вы должны передавать скрипты из папки bin непосредственно в интерпретатор Ruby, то есть ruby bin\rails server.

Веб сервер по умолчанию - puma

> Сжатие ассетов JavaScript требует среды выполнения JavaScript в вашей системе, и его отсутствие приведет к ошибке execjs во время сжатия ассетов. Обычно macOS и Windows поставляются с установленной средой выполнения JavaScript. therubyrhino - рекомендованная среда выполнения для пользователей JRuby, она добавляется в Gemfile, если приложение генерируется под JRuby. Можно узнать все о поддерживаемых средах выполнения в ExecJS

`Ctrl + C` - остановка сервера
В режиме development, Rails в основном не требует остановки сервера; все изменения, которые Вы делаете в файлах, автоматически подхватываются сервером.

`rails routes` - выводит в терминал все пути 
Основной form builder для Rails представлен методом хелпера по имени `form_with`
```
<%= form_with scope: :article, url: articles_path, local: true do |form| %>
<%= form_with scope: :article, local: true do |form| %>
```
ПРИМЕЧАНИЕ: По умолчанию form_with отправляет формы с использованием Ajax, тем самым не осуществляя редирект всей страницы. Чтобы облегчить чтение данного руководства, мы отключили это с помощью `local: true`.
#### Создание статей
При отправке формы, ее поля будут посланы в Rails как параметры. К этим параметрам можно обратиться из экшнов контроллера, как правило, для выполнения определенных задач. Чтобы увидеть, на что похожи эти параметры, измените экшн create так:
```
def create
  render plain: params[:article].inspect
end
```
Метод params возвращает объект ActionController::Parameters, позволяющий получать доступ к ключам хэша с использованием или строк, или символов.
> Давайте рассмотрим в качестве примера URL: http://www.example.com/?username=dhh&email=dhh@email.com. В этом URL, params[:username] будет равен "dhh" и params[:email] будет равен "dhh@email.com".

Если еще раз отправить форму, вы увидите что-то вроде следующего:
`<ActionController::Parameters {"title"=>"First Article!", "text"=>"This is my first article."} permitted: false>`

#### Создание модели Article
`rails generate model Article title:string text:text`
создаст:
```
class CreateArticles < ActiveRecord::Migration[6.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :text

      t.timestamps
    end
  end
end
```
Миграция в бд `rails db:migrate`
Если хотите выполнить миграции в другой среде, например в production, следует явно передать ее при вызове команды: `rails db:migrate RAILS_ENV=production`

Rails имеет ряд защитных мер, помогающих писать безопасные приложения, и вы только что столкнулись с одной из них. Она называется strong parameters и требует, чтобы мы указали Rails, какие именно параметры разрешено передавать в экшны нашего контроллера.

Нам нужно определить разрешенные параметры нашего контроллера, чтобы предотвратить ошибочное массовое назначение. В этом случае, мы хотим и разрешить, и затребовать параметры title и text для правильного использования в create. Синтаксис для этого представлен методами `require` и `permit`. Изменение затрагивает одну строчку в экшне create:
```
private
  def article_params
    params.require(:article).permit(:title, :text)
  end
```
> Если вам нужна ссылка на экшн того же контроллера, не нужно определять опцию :controller, так как Rails по умолчанию использует текущий контроллер.

В режиме development (с которым вы работаете по умолчанию), Rails перегружает ваше приложение с каждым запросом браузера, так что не нужно останавливать и перезапускать веб-сервер при внесении изменений.
`pluralize` это хелпер rails, принимающий число и строку как аргументы. Если число больше одного, строка будет автоматически склонено во множественном числе.
Rails автоматически оборачивает поля, содержащие ошибку, в div с классом `field_with_errors`. Можно определить правило CSS, чтобы сделать их выделяющимися.
Передача объекта статьи в метод `form_with` автоматически установит URL для отправки формы отредактированной статьи. Эта опция сообщает Rails, что мы хотим, чтобы эта форма была отправлена с помощью PATCH, метода HTTP, от которого ожидается, что он используется для обновления ресурсов в соответствии с протоколом REST.
Также, передача объекта модели в `form_with`, наподобие `model: @article` во вьюхе редактирования выше, заставит хелпер формы заполнить поля формы соответствующими значениями объекта. Передача в пространство имен символа, такая как `scope: :article`, что было сделано во вьюхе new, только создаст пустые поля формы.
> Не обязательно передавать все атрибуты в update. К примеру, если был вызван `@article.update(title: 'A new title')`, Rails обновит только атрибут title, оставив все другие атрибуты нетронутыми.
Хелперы, в том числе `form with` https://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with-label-Resource-oriented+style
`rails generate model Comment commenter:string body:text article:references`
Ключевое слово `(:references)`, использованное в команде bash, это специальный тип данных для моделей. Он создает новый столбец в вашей базе данных с именем представленной модели с добавленным _id, который может содержать числовые значения. Чтобы лучше понять, проанализируйте файл db/schema.rb после выполнения миграции.

В дополнение к модели, Rails также сделал миграцию для создания соответствующей таблицы базы данных:
```
class CreateComments < ActiveRecord::Migration[6.0]
  def change
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :article, null: false, foreign_key: true

      t.timestamps
    end

  end
end
```
Строчка `t.references` создает числовой столбец с именем `article_id`, индекс для него, и ограничение внешнего ключа, указывающего на столбец id таблицы `articles`.

#### Добавляем маршрут для комментариев
```
resources :articles do
  resources :comments
end
```
`<%= form_with(model: [ @article, @article.comments.build ], local: true) do |form| %>`
```
<%= link_to 'Destroy Comment', [comment.article, comment],
               method: :delete,
               data: { confirm: 'Are you sure?' } %>
```
#### Удаление связанных объектов
`has_many :comments, dependent: :destroy`
### Безопасность <a name="1.1.4"></a>
Если вы опубликуете свой блог онлайн, любой сможет добавлять, редактировать и удалять статьи или удалять комментарии.

Rails предоставляет базовую аутентификационную систему HTTP, которая хорошо работает в этой ситуации.

В ArticlesController нам нужен способ блокировать доступ к различным экшнам, если пользователь не аутентифицирован. Тут мы можем использовать метод Rails `http_basic_authenticate_with`, разрешающий доступ к требуемым экшнам, если метод позволит это.

Чтобы использовать систему аутентификации, мы определим ее вверху нашего ArticlesController в app/controllers/articles_controller.rb. В нашем случае, мы хотим, чтобы пользователь был аутентифицирован для каждого экшна, кроме index и show, поэтому напишем так:
```
class ArticlesController < ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", except: [:index, :show]

  def index
    @articles = Article.all
  end
```
Мы также хотим позволить только аутентифицированным пользователям удалять комментарии, поэтому в CommentsController (app/controllers/comments_controller.rb) мы напишем:
```
class CommentsController < ApplicationController

  http_basic_authenticate_with name: "dhh", password: "secret", only: :destroy

  def create
    @article = Article.find(params[:article_id])
    # ...
  end
```
Теперь, если попытаетесь создать новую статью, то встретитесь с вызовом базовой аутентификации HTTP.
### Что дальше? <a name="1.1.5"></a>
тут ссылки на ресурсы в оригинале на RusRails 

# Модели <a name="2"></a>
## Основы Active record <a name="2.1"></a>
<a href="https://api.rubyonrails.org/classes/ActiveRecord/Base.html#class-ActiveRecord::Base-label-Single+table+inheritance">Active Record Documentation</a>
### Что такое Active record <a name="2.1.1"></a>
Active Record это M в MVC - модель - которая является слоем в системе, ответственным за представление бизнес-логики и данных. Active Record упрощает создание и использование бизнес-объектов, данные которых требуют персистентного хранения в базе данных. Сама по себе эта реализация паттерна Active Record является описанием системы ORM (Object Relational Mapping).

Active Record был описан Martin Fowler в его книге Patterns of Enterprise Application Architecture. В Active Record объекты содержат и персистентные данные, и поведение, которое работает с этими данными. Active Record исходит из мнения, что обеспечение логики доступа к данным как части объекта покажет пользователям этого объекта то, как читать и писать в базу данных

Object Relational Mapping (объектно-реляционное отображение), обычно упоминающееся как аббревиатура ORM, это техника, соединяющая сложные объекты приложения с таблицами в системе управления реляционными базами данных.

Active Record предоставляет нам несколько механизмов, наиболее важными из которых являются способности для:
* Представления моделей и их данных.
* Представления связей между этими моделями.
* Представления иерархий наследования с помощью связанных моделей.
* Валидации моделей до того, как они станут персистентными в базе данных.
* Выполнения операций с базой данных в объектно-ориентированном стиле. 
### Соглашения над конфигурацией <a name="2.1.2"></a>
Идея в том, что в большинстве случаев вы настраиваете свои приложения одинаковым образом, и этот способ должен быть способом по умолчанию. Таким образом, явная конфигурация потребуется только тогда, когда вы не следуете соглашениям по какой-то причине.
* Таблица базы данных - Множественная форма со словами, разделенными знаком подчеркивания (т.е., book_clubs).
* Класс модели - Единственное число с первой прописной буквой в каждом слове (т.е., BookClub).

| Модель / Класс | Таблица / Схема |
|----------------|-----------------|
| Article        |	articles       | 
| LineItem       |  line_items     |
| Deer           |  deers          |
| Mouse          |	mice           |
| Person         |  people         |

#### Cоглашения схемы
Active Record использует соглашения о именовании для столбцов в таблицах базы данных, зависящих от назначения этих столбцов.
* Внешние ключи - Эти поля должны именоваться по образцу singularized_table_name_id (т.е., item_id, order_id). Это поля, которые ищет Active Record при создании связей между вашими моделями.
* Первичные ключи - По умолчанию Active Record использует числовой столбец с именем id как первичный ключ таблицы. Этот столбец будет автоматически создан при использовании миграций Active Record для создания таблиц. 

Также имеются некоторые опциональные имена столбцов, добавляющие дополнительные особенности для экземпляров Active Record:
* created_at - Автоматически будут установлены текущие дата и время при изначальном создании записи.
* updated_at - Автоматически будут установлены текущие дата и время всякий раз, когда обновляется запись.
* lock_version - Добавляет оптимистическую блокировку к модели.
* type - Указывает, что модель использует Single Table Inheritance.
* (association_name)_type - Хранит тип для полиморфных связей.
* **(table_name)_count - Используется для кэширования количества принадлежащих по связи объектов. Например, столбец comments_count в классе Article, у которого может быть несколько связанных экземпляров Comment, закэширует количество существующих комментариев для каждой статьи.**

> Хотя эти имена столбцов опциональны, фактически они зарезервированы Active Record. Избегайте зарезервированных ключевых слов, если вы не желаете дополнительной функциональности. Например, type - это зарезервированное слово для определения таблицы, использующей наследование с единой таблицей (STI). Если вы не используете STI, попытайтесь использовать аналогичное слово, такое как "context", которое также может аккуратно описать данные, которые вы моделируете

### Создание моделей Active Record <a name="2.1.3"></a>
Создавать модели Active Record очень просто. Все, что необходимо сделать, - это создать подкласс ApplicationRecord, и готово:
```
class Product < ApplicationRecord
end
```
Это создаст модель Product, **связав ее с таблицей products в базе данных**. Сделав так, также появится способность связать столбцы каждой строки этой таблицы с атрибутами экземпляров вашей модели. Допустим, что таблица products была создана с использованием такого выражения SQL (или одно из его расширений):
```
CREATE TABLE products (
   id int(11) NOT NULL auto_increment,
   name varchar(255),
   PRIMARY KEY  (id)
);
```
Вышеуказанная схема объявляет таблицу с двумя столбцами: id и name. Каждая строка этой таблицы представляет собой определенный продукт с этими двумя параметрами. Таким образом, можно написать подобный код:
```
p = Product.new
p.name = "Some Book"
puts p.name # "Some Book"
```
### Переопределение соглашений об именовании <a name="2.1.4"></a>
Но что, если вы следуете другому соглашению по именованию или используете новое приложение Rails со старой базой данных? Не проблема, можно просто переопределить соглашения по умолчанию.

ApplicationRecord наследуется от `ActiveRecord::Base`, который определяет ряд полезных методов. Можно использовать метод `ActiveRecord::Base.table_name=` для указания имени таблицы, которая должна быть использована:
```
class Product < ApplicationRecord
  self.table_name = "my_products"
end
```
Если так сделать, нужно вручную определить имя класса, содержащего фикстуры (my_products.yml), используя метод set_fixture_class в определении теста:
```
class ProductTest < ActiveSupport::TestCase
  set_fixture_class my_products: Product
  fixtures :my_products
  ...
end
```
Также возможно переопределить столбец, который должен быть использован как первичный ключ таблицы, с помощью метода `ActiveRecord::Base.primary_key=`:
```
class Product < ApplicationRecord
  self.primary_key = "product_id"
end
```
### CRUD: Чтение и запись данных <a name="2.1.5"></a>
CRUD это сокращение для четырех глаголов, используемых для описания операций с данными: Create (создать), Read (прочесть), Update (обновить) и Delete (удалить). Active Record автоматически создает методы, позволяющие приложению читать и воздействовать на данные, хранимые в своих таблицах.
Если предоставлен блок и `create`, и `new` передадут новый объект в этот блок для инициализации:
```
user = User.new do |u|
  u.name = "David"
  u.occupation = "Code Artist"
end
```
Возвратит первого пользователя с именем David
```
david = User.find_by(name: 'David')
```
Найдет всех пользователей с именем David, которые Code Artists, и сортирует их по created_at в обратном хронологическом порядке:
```
users = User.where(name: 'David', occupation: 'Code Artist').order(created_at: :desc)
```
<a href="http://rusrails.ru/active-record-query-interface">Подробнее в интерфейсе запросов Active Record</a>

Обновление:
```
user = User.find_by(name: 'David')
user.update(name: 'Dave')
```
Это наиболее полезно, когда необходимо обновить несколько атрибутов за раз. Если, с другой стороны, необходимо обновить несколько записей за раз, полезен метод класса update_all:
```
User.update_all "max_login_attempts = 3, must_change_password = 'true'"
```
Более того, после получения, объект Active Record может быть уничтожен, что уберет его из базы данных.
```
user = User.find_by(name: 'David')
user.destroy
```
Если необходимо удалить сразу несколько записей, можно использовать метод destroy_all:
```
# найти и удалить всех пользователей с именем David
User.where(name: 'David').destroy_all

# удалить всех пользователей
User.destroy_all
```
### Валидации <a name="2.1.6"></a>
Active Record позволяет проверять состояние модели до того, как она будет записана в базу данных.
Валидация - это очень важный вопрос, который нужно рассмотреть при сохранении в базу данных, поэтому методы `save` и `update` учитывают ее при запуске: они возвращают `false`, когда валидация проваливается, и фактически они не выполняют каких-либо операций с базой данных. Каждый из этих методов имеет пару с восклицательным знаком (`save!` и `update!`), которые строже в том, что они вызывают исключение `ActiveRecord::RecordInvalid` если валидация провалится. Краткий пример:
```
class User < ApplicationRecord
  validates :name, presence: true
end

user = User.new
user.save  # => false
user.save! # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
```
<a href="http://rusrails.ru/active-record-validations">Валидации Active record</a>
### Колбэки <a name="2.1.7"></a>
Колбэки Active Record разрешают присоединить код к определенным событиям в жизненном цикле ваших моделей. Это позволяет добавить поведение модели, прозрачно выполнив код, когда эти события произойдут, например, когда вы создадите новую запись, обновите его, удалите его и так далее. Подробнее о колбэках можно прочитать в руководстве <a href="http://rusrails.ru/active-record-callbacks">Колбэки Active Record</a>.
### Миграции <a name="2.1.8"></a>
Rails предоставляет DSL для управления схемой базы данных, называемый миграциями. Миграции хранятся в файлах, выполняемых для любой базы данных, которую **поддерживает Active Record, с использованием `rake`**. Вот миграция, создающая таблицу:
```
class CreatePublications < ActiveRecord::Migration[5.0]
  def change
    create_table :publications do |t|
      t.string :title
      t.text :description
      t.references :publication_type
      t.integer :publisher_id
      t.string :publisher_type
      t.boolean :single_issue

      t.timestamps
    end
    add_index :publications, :publication_type_id
  end
end
```
Rails отслеживает, какие файлы переданы в базу данных, и представляет возможность отката. Чтобы фактически создать таблицу, нужно запустить rails `db:migrate`, **а чтобы ее откатить rails `db:rollback`**.
> Отметьте, что вышеприведенный код не зависит от базы данных: он выполнится в MySQL, PostgreSQL, Oracle и иных. 

## Миграции Active Record <a name="2.2"></a>
Миграции - это особенность Active Record, позволяющая изменять схему вашей базы данных время от времени.
### Обзор миграций <a name="2.2.1"></a>
В базах данных, поддерживающих транзакции с выражениями, изменяющими схему, миграции оборачиваются в транзакцию. Если база данных это не поддерживает, и миграция проваливается, части, которые прошли успешно, не будут откачены назад. Вам нужно произвести откат вручную.
> Некоторые запросы не могут быть запущены в транзакции. Если ваш адаптер поддерживает транзакции DDL, можно использовать `disable_ddl_transaction!` для их отключения для отдельной миграции.

Если хотите миграцию для чего-то, что Active Record не знает, как обратить, вы можете использовать `reversible`
```
class ChangeProductsPrice < ActiveRecord::Migration[5.0]
  def change
    reversible do |dir|
      change_table :products do |t|
        dir.up   { t.change :price, :string }
        dir.down { t.change :price, :integer }
      end
    end
  end
end
```
С другой стороны, можно использовать `up` и `down` вместо `change`:
```
class ChangeProductsPrice < ActiveRecord::Migration[5.0]
  def up
    change_table :products do |t|
      t.change :price, :string
    end
  end

  def down
    change_table :products do |t|
      t.change :price, :integer
    end
  end
end
```
### Создание миграции <a name="2.2.2"></a>
#### Создание автономной миграции
Миграции хранятся как файлы в директории `db/migrate`, один файл на каждый класс. Имя файла имеет вид `YYYYMMDDHHMMSS_create_products.rb`, это означает, что временная метка UTC идентифицирует миграцию, затем идет знак подчеркивания, затем идет имя миграции, где слова разделены подчеркиваниями. Имя класса миграции содержит буквенную часть названия файла, но уже в формате `CamelCase` (т.е. слова пишутся слитно, каждое слово начинается с большой буквы). Например, `20080906120000_create_products.rb` должен определять класс `CreateProducts`, а `20080906120001_add_details_to_products.rb` должен определять `AddDetailsToProducts`. Rails использует эту метку, чтобы определить, какая миграция должна быть запущена и в каком порядке, так что если вы копируете миграции из другого приложения или генерируете файл сами, будьте более бдительны.

**Пустая миграция**:
```
rails generate migration AddPartNumberToProducts
```
Это создаст правильно названную пустую миграцию:
```
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
  end
end
```
**Обычное поле столбец**.
```
rails generate migration AddPartNumberToProducts part_number:string
или
rails generate migration AddDetailsToProducts part_number:string price:decimal
```
генерирует
```
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
  end
end

и

class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end
```
**Индекс** на новый столбец, вы можете сделать это так
```
rails generate migration AddPartNumberToProducts part_number:string:index
```
генерирует
```
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_index :products, :part_number
  end
end
```
**Удаление столбца**
```
rails generate migration RemovePartNumberFromProducts part_number:string
```
генерирует
```
class RemovePartNumberFromProducts < ActiveRecord::Migration[5.0]
  def change
    remove_column :products, :part_number, :string
  end
end
```
**Cоздание таблицы** 
```
rails generate migration CreateProducts name:string part_number:string
```
генерирует
```
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.string :part_number

      t.timestamps
    end
  end
end
```
**Столбец references** <a href="https://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_reference">Документация</a>
```
rails generate migration AddUserRefToProducts user:references
```
генерирует 
```
class AddUserRefToProducts < ActiveRecord::Migration[5.0]
  def change
    add_reference :products, :user, foreign_key: true
  end
end
```
**Соединительная таблица**
```
rails generate migration CreateJoinTableCustomerProduct customer product
```
генерирует
```
class CreateJoinTableCustomerProduct < ActiveRecord::Migration[5.0]
  def change
    create_join_table :customers, :products do |t|
      # t.index [:customer_id, :product_id]
      # t.index [:product_id, :customer_id]
    end
  end
end
```
> Как всегда, то, что было сгенерировано, является всего лишь стартовой точкой. Вы можете добавлять и убирать строки, как считаете нужным, отредактировав файл `db/migrate/YYYYMMDDHHMMSS_add_details_to_products.rb`.
#### Генераторы модели
Генераторы модели и скаффолда создадут миграции, подходящие для создания новой модели.
```
rails generate model Product name:string description:text
```
-> 
```
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
```
#### Передача модификаторов
```
rails generate migration AddDetailsToProducts 'price:decimal{5,2}' supplier:references{polymorphic}
```
->
```
class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :price, :decimal, precision: 5, scale: 2
    add_reference :products, :supplier, polymorphic: true
  end
end
```
### Написание миграции <a name="2.2.3"></a>
#### Создание таблицы
По умолчанию `create_table` создаст первичный ключ, названный `id`. Вы можете изменить имя первичного ключа с помощью опции `:primary_key` (не забудьте также обновить соответствующую модель), или, если вы вообще не хотите первичный ключ, можно указать опцию `id: false`. Если нужно передать базе данных специфичные опции, вы можете поместить фрагмент SQL в опцию `:options`. Например:
```
create_table :products, options: "ENGINE=BLACKHOLE" do |t|
  t.string :name, null: false
end
```
добавит `ENGINE=BLACKHOLE` к SQL выражению, используемому для создания таблицы.
Также можно передать опцию `:comment` с любым описанием для таблицы, которое будет сохранено в самой базе данных, и может быть просмотрено с помощью инструментов администрирования базы данных
#### Создание соединительной таблицы
**Миграционный метод** `create_join_table` создает соединительную таблицу HABTM (has and belongs to many, многие ко многим).
```
create_join_table :products, :categories
```
что создаст таблицу categories_products с двумя столбцами по имени `category_id` и `product_id`. У этих столбцов есть опция `:null`, установленная в `false` по умолчанию. Это может быть переопределено опцией `:column_options:`
```
create_join_table :products, :categories, column_options: { null: true }
```

**По умолчанию**, имя соединительной таблицы получается как соединение первых двух аргументов, переданных в `create_join_table`, в алфавитном порядке. Чтобы настроить имя таблицы, передайте опцию `:table_name:`
```
create_join_table :products, :categories, table_name: :categorization
```
создает таблицу `categorization`

**По умолчанию** `create_join_table` создаст два столбца без опций, но можно определить эти опции с использованием опции `:column_options`. Например,
```
create_join_table :products, :categories, column_options: { null: true }
```
создаст `product_id` и `category_id` с опцией `:null` равной `true`.
`create_join_table` также принимает блок, который можно использовать для добавления индексов (которые по умолчанию не создаются) или дополнительных столбцов:
```
create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end
```
#### Изменение таблиц
```
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
```
удаляет столбцы `description` и `name`, создает строковый столбец `part_number` и добавляет индекс на него. Наконец, он переименовывает столбец `upccode`.
#### Изменение столбцов
```
change_column :products, :part_number, :text
```
Он меняет тип столбца `part_number` в таблице products на `:text`. Отметьте, что команда `change_column` — необратима.

**Кроме** `change_column`, методы `change_column_null` и `change_column_default` используются чтобы изменить ограничение не-null или значение столбца по умолчанию.
```
change_column_null :products, :name, false
change_column_default :products, :approved, from: true, to: false
```
Это настроит поле `:name` в products быть NOT NULL столбцом и изменит значение по умолчанию для поля `:approved` с `true` на `false`.

Также можно написать предыдущую миграцию `change_column_default` как `change_column_default :products, :approved, false`, но, в отличие от предыдущего примера, это сделало бы вашу миграцию необратимой
#### Модификаторы столбца
Модификаторы столбца могут быть применены при создании или изменении столбца:
* `limit` Устанавливает максимальный размер полей `string/text/binary/integer`.
* `precision` Определяет точность для полей `decimal`, определяющую общее количество цифр в числе.
* `scale` Определяет масштаб для полей `decimal`, определяющий количество цифр после запятой.
* `polymorphic` Добавляет столбец `type` для связей `belongs_to`.
* `null` Позволяет или запрещает значения `NULL` в столбце.
* `default` Позволяет установить значение по умолчанию для столбца. Отметьте, что если вы используете динамическое значение (такое как дату), значение по умолчанию будет вычислено лишь один раз (т.е. на дату, когда миграция будет применена).
* `comment` Добавляет комментарий для столбца.
Некоторые адаптеры могут поддерживать дополнительные опции; за подробностями обратитесь к документации API конкретных адаптеров.
> С помощью командной строки нельзя указать null и default
#### Внешние ключи
Хотя это и не требуется, вы можете захотеть добавить ограничения внешнего ключа для обеспечения ссылочной целостности.
```
add_foreign_key :articles, :authors
```
Это добавит новый внешний ключ к столбцу `author_id` таблицы `articles`. Ключ ссылается на столбец `id` таблицы `authors`. Если имена столбцов не могут быть произведены из имен таблиц, можно использовать опции `:column` и `:primary_key`.
Rails сгенерирует имя для каждого внешнего ключа, начинающееся с `fk_rails_` плюс 10 символов, которые детерминировано генерируются на основе `from_table` и `column`. Также есть опция `:name`, если хотите указать другое имя.

> Active Record поддерживает внешние ключи только для отдельных столбцов. Чтобы использовать составные внешние ключи, требуются `execute` и `structure.sql`.

**Убрать внешний ключ** также просто:
```
# позволим Active Record выяснить имя столбца
remove_foreign_key :accounts, :branches

# уберем внешний ключ для определенного столбца
remove_foreign_key :accounts, column: :owner_id

# уберем внешний ключ по имени
remove_foreign_key :accounts, name: :special_fk_name
```
#### Когда хелперов недостаточно
Если хелперов, предоставленных Active Record, недостаточно, можно использовать метод `execute` для выполнения произвольного SQL:
```
Product.connection.execute("UPDATE products SET price = 'free' WHERE 1=1")
```
Больше подробностей и примеров отдельных методов содержится в документации по API. В частности, документация для `ActiveRecord::ConnectionAdapters::SchemaStatements` (который обеспечивает методы, доступные в методах `up`, `down` и `change`), `ActiveRecord::ConnectionAdapters::TableDefinition` (который обеспечивает методы, доступные у объекта, переданного методом `create_table`) и `ActiveRecord::ConnectionAdapters::Table` (который обеспечивает методы, доступные у объекта, переданного методом `change_table`).
#### Использование метода change
Метод `change` это основной метод написания миграций. Он работает в большинстве случаев, когда `Active Record` знает, как обратить миграцию автоматически. На текущий момент метод change поддерживает только эти определения миграции:
* `add_column`
* `add_foreign_key`
* `add_index`
* `add_reference`
* `add_timestamps`
* `change_column_default` (необходимо указать опции :from и :to)
* `change_column_null`
* `create_join_table`
* `create_table`
* `disable_extension`
* `drop_join_table`
* `drop_table` (необходимо указать блок)
* `enable_extension`
* `remove_column` (необходимо указать тип)
* `remove_foreign_key` (необходимо указать вторую таблицу)
* `remove_index`
* `remove_reference`
* `remove_timestamps`
* `rename_column`
* `rename_index`
* `rename_table` 

`change_table` также является обратимым, пока блок не вызывает `change`, `change_default` или `remove`.

`remove_column` обратима, если предоставить тип столбца третьим аргументом. Также предоставьте опции оригинального столбца, иначе Rails не сможет в точности пересоздать этот столбец при откате:
```
remove_column :posts, :slug, :string, null: false, default: ''
```
**Если вы нуждаетесь в использовании иных методов**, следует использовать `reversible` или писать методы `up` и `down` вместо метода `change`.
#### Использование `reversible`
 Вы можете использовать reversible, чтобы указать что делать когда запускается миграция и когда она требует отката.
 ```
 class ExampleMigration < ActiveRecord::Migration
  def change
    create_table :distributors do |t|
      t.string :zipcode
    end

    reversible do |dir|
      dir.up do
        # добавим ограничение CHECK
        execute <<-SQL
          ALTER TABLE distributors
            ADD CONSTRAINT zipchk
              CHECK (char_length(zipcode) = 5) NO INHERIT;
        SQL
      end
      dir.down do
        execute <<-SQL
          ALTER TABLE distributors
            DROP CONSTRAINT zipchk
        SQL
      end
    end

    add_column :users, :home_page_url, :string
    rename_column :users, :email, :email_address
  end
end
```
Использование `reversible` гарантирует, что инструкции выполнятся в правильном порядке. Если предыдущий пример миграции откатывается, `down` блок начнёт выполнятся после того как столбец `home_page_url` будет удалён и перед перед тем как произойдёт удаление таблицы `distributors`.

Иногда миграция будет делать то, что просто необратимо; например, она может уничтожить некоторые данные. В таких случаях, вы можете вызвать `ActiveRecord::IrreversibleMigration` в вашем `down` блоке. Если кто-либо попытается отменить вашу миграцию, будет отображена ошибка, что это не может быть выполнено.
#### Использование методов `up/down`
По аналогии с верхним примером 
```
class ExampleMigration < ActiveRecord::Migration[5.0]
  def up
    create_table :distributors do |t|
      t.string :zipcode
    end

    #добавляем ограничение CHECK
    execute <<-SQL
      ALTER TABLE distributors
        ADD CONSTRAINT zipchk
        CHECK (char_length(zipcode) = 5);
    SQL

    add_column :users, :home_page_url, :string
    rename_column :users, :email, :email_address
  end

  def down
    rename_column :users, :email_address, :email
    remove_column :users, :home_page_url

    execute <<-SQL
      ALTER TABLE distributors
        DROP CONSTRAINT zipchk
    SQL

    drop_table :distributors
  end
end
```
#### Возвращение к предыдущим миграциям
```
require_relative '20121212123456_example_migration'

class FixupExampleMigration < ActiveRecord::Migration[5.0]
  def change
    revert ExampleMigration

    create_table(:apples) do |t|
      t.string :variety
    end
  end
end
```
Метод `revert` также может принимать блок. Это может быть полезно для отката выбранной части предыдущих миграций. Для примера, давайте представим, что `ExampleMigration` закоммичена, а позже мы решили, что было бы лучше использовать валидации `Active Record`, вместо ограничения `CHECK`, для проверки `zipcode`.
```
class DontUseConstraintForZipcodeValidationMigration < ActiveRecord::Migration[5.0]
  def change
    revert do
      reversible do |dir|
        dir.up do
          # добавим ограничение CHECK
          execute <<-SQL
            ALTER TABLE distributors
              ADD CONSTRAINT zipchk
                CHECK (char_length(zipcode) = 5);
          SQL
        end
        dir.down do
          execute <<-SQL
            ALTER TABLE distributors
              DROP CONSTRAINT zipchk
          SQL
        end
      end

      # The rest of the migration was ok
    end
  end
end
```
Подобная миграция также может быть написана без использования `revert`, но это бы привело к ещё нескольким шагам: изменение порядка (следования) `create table` и `reversible`, замена `create_table` на `drop_table` и в конечном итоге изменение `up` на `down` и наоборот. Обо всём этом уже позаботился `revert`.

> Если необходимо добавить ограничения `CHECK`, как в вышеуказанных примерах, нужно использовать `structure.sql` в качестве метода для выгрузки.
### Запуск миграций <a name="2.2.4"></a>
`rails db:migrate` запускает метод `change` или `up` для всех миграций, которые еще не были запущены. 3апуск команды `db:migrate` также вызывает команду `db:schema:dump`, которая обновляет ваш файл `db/schema.rb` в соответствии со структурой вашей базы данных.
Если вы определите целевую версию, `Active Record` запустит требуемые миграции (методы `up`, `down` или `change`), пока не достигнет требуемой версии. Версия это числовой префикс у файла миграции. Например, чтобы мигрировать к версии `20080906120000`, запустите:
```
$ rails db:migrate VERSION=20080906120000
```
Если миграция назад, это запустит метод `down` для всех миграций до, но не включая, `20080906120000`.
#### Откат
```
$ rails db:rollback
```
Если нужно отменить несколько миграций, можно указать параметр `STEP`:
```
$ rails db:rollback STEP=3
```
Команда `db:migrate:redo` это ярлык для выполнения отката, а затем запуска миграции снова.
```
rails db:migrate:redo STEP=3
```
#### Установка базы данных
Команда `rails db:setup` создаст базу данных, загрузит схему и инициализирует ее с помощью данных `seed`.
#### Сброс базы данных
Команда `rails db:reset` удалит базу данных и установит ее заново. Функционально это эквивалентно `rails db:drop db:setup`.
> Это не то же самое, что запуск всех миграций. Будет использовано только текущее содержимое файла `db/schema.rb` или `db/structure.sql`. Если миграцию откатить невозможно, `rails db:reset` может не помочь вам.
#### Запуск определенных миграций
Если необходимо запустить определённую миграцию вверх или вниз, это делают команды `db:migrate:up` и `db:migrate:down`. Просто укажите подходящую версию и у соответствующей миграции будет вызван метод `change`, `up` или `down`, например:
```
$ rails db:migrate:up VERSION=20080906120000
```
#### Запуск миграций в различных средах
По умолчанию запуск `rails db:migrate` запустится в окружении `development`.
```
rails db:migrate RAILS_ENV=test
```
#### Изменение вывода результата запущенных миграций
Метод             |	Назначение
------------------|---------------
suppress_messages | Принимает блок как аргумент и запрещает любой вывод, сгенерированный этим блоком.
say 	            | Принимает сообщение как аргумент и выводит его как есть. Может быть передан второй булевый аргумент для указания, нужен отступ или нет.
say_with_time     | Выводит текст вместе с продолжительностью выполнения блока. Если блок возвращает число, предполагается, что это количество затронутых строк.

Например, эта миграция:
```
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    suppress_messages do
      create_table :products do |t|
        t.string :name
        t.text :description
        t.timestamps
      end
    end

    say "Created a table"

    suppress_messages {add_index :products, :name}
    say "and an index!", true

    say_with_time 'Waiting for a while' do
      sleep 10
      250
    end
  end
end
```
сгенерирует следующий результат
```
==  CreateProducts: migrating =================================================
-- Created a table
   -> and an index!
-- Waiting for a while
   -> 10.0013s
   -> 250 rows
==  CreateProducts: migrated (10.0054s) =======================================
```
Если хотите, чтобы Active Record ничего не выводил, запуск `rails db:migrate VERBOSE=false` запретит любой вывод.

### Изменение существующих миграций <a name="2.2.5"></a>
Периодически вы будете делать ошибки при написании миграции. Если вы уже запустили миграцию, вы не сможете просто отредактировать миграцию и запустить ее снова: Rails посчитает, что он уже выполнял миграцию, и ничего не сделает при запуске `rails db:migrate`. Вы должны откатить миграцию (например, с помощью `rails db:rollback`), отредактировать миграцию и затем запустить `rails db:migrate` для запуска исправленной версии.

В целом, редактирование существующих миграций не хорошая идея. Вы создадите дополнительную работу себе и своим коллегам, и вызовете море головной боли, если существующая версия миграции уже была запущена в `production`. Вместо этого, следует написать новую миграцию, выполняющую требуемые изменения. Редактирование только что сгенерированные миграции, которая еще не была закоммичена в систему контроля версий (или, хотя бы, не ушла дальше вашей рабочей машины) относительно безвредно.

Метод `revert` может быть очень полезным при написании новой миграции для возвращения предыдущей в целом или какой то части.

### Выгрузка схемы <a name="2.2.6"></a>
#### Для чего нужны файлы схемы?
Миграции, какими бы не были они мощными, не являются авторитетным источником для схемы базы данных. База данных остается авторитетным источником. По умолчанию Rails генерирует `db/schema.rb`, которая пытается охватить текущее состояние схемы базы данных.

Она имеет тенденцию быть более быстрой и менее подверженной ошибкам, связанным с созданием нового экземпляра базы данных приложения, загружая файл схемы через `rails db:schema:load`, чем при повторном воспроизведении всей истории миграций. Старые миграции могут работать неправильно, если эти миграции используют изменения внешних зависимостей или полагаются на код приложения, который развивается отдельно от этих миграций.

Файлы схемы также полезны, если необходимо быстро посмотреть, какие атрибуты есть у объекта Active Record. Эта информация не содержится в коде модели и часто распределена по нескольким миграциям, но собрана воедино в файле схемы.
#### Типы выгрузок схемы
Формат выгрузки схемы, сгенерированный Rails, управляется настройкой `config.active_record.schema_format` в `config/application.rb`. Форматом по умолчанию является `:ruby`, но также он может быть установлен в `:sql`.

Если выбрано `:ruby`, тогда схема хранится в `db/schema.rb`. Посмотрев в этот файл, можно увидеть, что он очень похож на одну большую миграцию:
```
ActiveRecord::Schema.define(version: 2008_09_06_171750) do
  create_table "authors", force: true do |t|
    t.string   "name"
    t.datetime "created_at"
    t.datetime "updated_at"
  end

  create_table "products", force: true do |t|
    t.string   "name"
    t.text     "description"
    t.datetime "created_at"
    t.datetime "updated_at"
    t.string   "part_number"
  end
end
```
Во многих случаях этого достаточно. Этот файл создается путем проверки базы данных и описывает свою структуру, используя `create_table`, `add_index` и так далее.

`db/schema.rb` не может описать все, что может поддерживать база данных, например триггеры, последовательности, хранимые процедуры, ограничения `CHECK` и так далее. Отметьте, в то время как в миграциях можно выполнить произвольные выражения SQL, эти выражения не смогут быть воспроизведены выгрузчиком схемы. Если используете подобные особенности, необходимо установить формат схемы как `:sql`, чтобы получить точный файл схемы, который будет полезен для создания новых экземпляров базы данных.

Когда формат схемы установлен в `:sql`, структура базы данных будет выгружена с помощью инструмента, предназначенного для этой базы данных в `db/structure.sql`. Например, для PostgreSQL используется утилита `pg_dump`. Для MySQL и MariaDB этот файл будет содержать результат SHOW CREATE TABLE для разных таблиц.

Чтобы загрузить схему из `db/structure.sql`, запустите `rails db:structure:load`. Загрузка этого файла осуществляется путем выполнения содержащихся в нем выражений SQL. По определению создастся точная копия структуры базы данных.
#### Выгрузки схем и управление версиями
Поскольку файлы схемы обычно используются для создания новых баз данных, настоятельно рекомендуется проверять файл схемы в системе управления версиями.

Конфликты слияния могут возникать в файле схемы, когда две ветки модифицируют схему. Для разрешения этих конфликтов, запустите `rails db:migrate`, чтобы восстановить файл схемы.
### Active Record и ссылочная целостность <a name="2.2.7"></a>
Способ Active Record требует, чтобы логика была в моделях, а не в базе данных. По большому счету, функции, такие как триггеры или ограничения, которые переносят часть логики обратно в базу данных, не используются активно.

Валидации, такие как `validates :foreign_key, uniqueness: true`, это один из способов, которым ваши модели могут соблюдать ссылочную целостность. Опция :dependent в связях позволяет моделям автоматически уничтожать дочерние объекты при уничтожении родителя. Подобно всему, что работает на уровне приложения, это не может гарантировать ссылочной целостности, таким образом кто-то может добавить еще и внешние ключи как ограничители ссылочной целостности в базе данных.

Хотя Active Record не предоставляет каких-либо инструментов для работы напрямую с этими функциями, метод `execute` может использоваться для выполнения произвольного SQL.
### Миграции и сиды <a name="2.2.8"></a>
Основным назначением миграции Rails является запуск команд, последовательно модифицирующих схему. Миграции также могут быть использованы для добавления или модифицирования данных. Это полезно для существующей базы данных, которую нельзя удалить и пересоздать, такой как база данных на `production`.
```
class AddInitialProducts < ActiveRecord::Migration[5.0]
  def up
    5.times do |i|
      Product.create(name: "Product ##{i}", description: "A product.")
    end
  end

  def down
    Product.delete_all
  end
end
```
Чтобы добавить изначальные данные в базу данных после создания, в Rails имеется встроенная особенность 'seeds', которая делает процесс быстрым и простым. Это особенно полезно при частой перезагрузке базы данных в средах разработки и тестирования. Этой особенностью легко начать пользоваться: просто заполните `db/seeds.rb` некоторым кодом Ruby и запустите `rails db:seed`:
```
5.times do |i|
  Product.create(name: "Product ##{i}", description: "A product.")
end
```
В основном, это более чистый способ настроить базу данных для пустого приложения.
### Старые миграции <a name="2.2.9"></a>
`db/schema.rb` или `db/structure.sql` это снимок текущего состояния вашей базы данных и авторитетный источник для восстановления этой базы данных. Поэтому возможно удалить старые файлы миграций.

Когда вы удалите файлы миграций в директории `db/migrate/`, любая среда, в которой `rails db:migrate` была запущена, когда эти файлы еще существовали, будет хранить ссылки на временные метки миграций во внутренней таблице Rails по имени `schema_migrations`. Эта таблица используется для отслеживания, была ли миграция выполнена в указанной среде.

Если вы запустите команду `rails db:migrate:status`, которая отображает статус (`up` или `down`) каждой миграции, вы увидите `********** NO FILE **********`, отображенный рядом с каждым удаленным файлом миграции, который однажды был запущен в указанной среде, но больше не найден в директории db/migrate/.
## Валидации <a name="2.3"></a>
### Обзор валидаций <a name="2.3.1"></a>
```
class Person < ApplicationRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false
```
#### Зачем использовать валидации?
Есть несколько способов валидации данных, прежде чем они будут сохранены в вашу базу данных, включая ограничения, встроенные в базу данных, валидации на клиентской части и валидации на уровне контроллера. Вкратце о плюсах и минусах:
* Ограничения базы данных и/или хранимые процедуры делают механизмы валидации зависимыми от базы данных, что делает тестирование и поддержку более трудными. Однако, если ваша база данных используется другими приложениями, валидация на уровне базы данных может безопасно обрабатывать некоторые вещи (такие как уникальность в нагруженных таблицах), которые затруднительно выполнять по-другому.
* Валидации на клиентской части могут быть очень полезны, но в целом ненадежны, если используются в одиночку. Если они используют JavaScript, они могут быть пропущены, если JavaScript отключен в клиентском браузере. Однако, если этот способ комбинировать с другими, валидации на клиентской части могут быть удобным способом предоставить пользователям немедленную обратную связь при использовании вашего сайта.
* Валидации на уровне контроллера заманчиво делать, но это часто приводит к громоздкости и трудности тестирования и поддержки. Во всех случаях, когда это возможно, держите свои контроллеры 'тощими', тогда с вашим приложением будет приятно работать в долгосрочной перспективе. 

Выбирайте их под свои определенные специфичные задачи. Общее мнение команды Rails состоит в том, что валидации на уровне модели - наиболее подходящий вариант во многих случаях.
#### Когда происходит валидация?
Создание и сохранение новой записи посылает операцию `SQL INSERT` базе данных. Обновление существующей записи вместо этого посылает операцию `SQL UPDATE`. Валидации обычно запускаются до того, как эти команды посылаются базе данных. Если любая из валидаций проваливается, объект помечается как недействительный и Active Record не выполняет операцию `INSERT` или `UPDATE`. Это помогает избежать хранения невалидного объекта в базе данных. Можно выбирать запуск специфичных валидаций, когда объект создается, сохраняется или обновляется.

Есть разные методы изменения состояния объекта в базе данных. Некоторые методы вызывают валидации, некоторые нет. Это означает, что возможно сохранить в базу данных объект с недействительным статусом, если вы будете не внимательны.

Следующие методы вызывают валидацию, и сохраняют объект в базу данных только если он валиден:
* `create`
* `create!`
* `save`
* `save!`
* `update`
* `update!`

Версии с восклицательным знаком (т.е. `save!`) **вызывают исключение**, если запись недействительна. Невосклицательные версии не вызывают: `save` и `update` возвращают `false`, `create` **возвращает объект**.
#### Пропуск валидаций
Следующие методы пропускают валидации, и сохраняют объект в базу данных, независимо от его валидности. Их нужно использовать осторожно.
* `decrement!`
* `decrement_counter`
* `increment!`
* `increment_counter`
* `toggle!`
* `touch`
* `update_all`
* `update_attribute`
* `update_column`
* `update_columns`
* `update_counters`

Заметьте, что `save` также имеет способность пропустить валидации, если передать `validate: false` как аргумент. Этот способ нужно использовать осторожно.
```
save(validate: false) 
```
#### `valid?` или `invalid?`
Вы также можете запускать эти валидации самостоятельно. `valid?` вызывает ваши валидации и возвращает `true`, если ни одной ошибки не было найдено у объекта, иначе `false`.
```
class Person < ApplicationRecord
  validates :name, presence: true
end

Person.create(name: "John Doe").valid? # => true
Person.create(name: nil).valid? # => false
```
После того, как Active Record выполнит валидации, все найденные ошибки будут доступны в методе экземпляра `errors.messages`, возвращающем коллекцию ошибок.
`invalid?` это просто антипод `valid?`.
#### `errors[]`
Чтобы проверить, является или нет конкретный атрибут объекта валидным, можно использовать `errors[:attribute]`, который возвращает массив со всеми ошибками атрибута, когда нет ошибок по определенному атрибуту, возвращается пустой массив.
#### `errors.details`
Чтобы проверить, какие валидации упали на невалидном атрибуте, можно использовать `errors.details[:attribute]`. Он возвращает массив хэшей с ключом `:error`, чтобы получить символ валидатора:
```
class Person < ApplicationRecord
  validates :name, presence: true
end

>> person = Person.new
>> person.valid?
>> person.errors.details[:name] # => [{error: :blank}]
```
### Валидационные хелперы <a name="2.3.2"></a>
Каждый хелпер принимает произвольное количество имен атрибутов, поэтому в одной строчке кода можно добавить валидации одинакового вида для нескольких атрибутов.

Они все принимают опции `:on` и `:message`, которые определяют, когда валидация должна быть запущена, и какое сообщение должно быть добавлено в коллекцию `errors`, если она провалится. Опция `:on` принимает одно из значений `:create` или `:update`. Для каждого валидационного хелпера есть свое сообщение об ошибке по умолчанию. Эти сообщения используются, если не определена опция `:message`.
#### `acceptance`
Этот метод проверяет, что чекбокс в пользовательском интерфейсе был нажат, когда форма была подтверждена.
```
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: true
end
```
Эта проверка выполнится, только если `terms_of_service` не `nil`.
Можно передать произвольное сообщение с помощью опции `message`.
```
class Person < ApplicationRecord
  validates :terms_of_service, acceptance: { message: 'must be abided' }
end
```
Также он может получать опцию `:accept`, которая определяет допустимые значения, которые будут считаться принятыми. По умолчанию это "1", но его можно изменить.
```
class Person < ApplicationRecord
  validates :eula, acceptance: { accept: ['TRUE', 'accepted'] }
end
```
Эта валидация очень специфична для веб-приложений, и ее принятие не нужно записывать куда-либо в базу данных. Если у вас нет поля для него, хелпер всего лишь создаст виртуальный атрибут. Если поле существует в базе данных, опция `accept` должна быть установлена или включать `true`, а иначе эта валидация не будет выполнена.
#### `validates_associated`
Этот хелпер можно использовать, когда у вашей модели есть связи с другими моделями, и их также нужно проверить на валидность. Когда вы пытаетесь сохранить свой объект, будет вызван метод `valid?` для каждого из связанных объектов.
```
class Library < ApplicationRecord
  has_many :books
  validates_associated :books
end
```
Эта валидация работает со всеми типами связей.

> Не используйте `validates_associated` на обоих концах ваших связей, они будут вызывать друг друга в бесконечном цикле.

Для `validates_associated` сообщение об ошибке по умолчанию следующее "is invalid". Заметьте, что каждый связанный объект имеет свою собственную коллекцию `errors`; ошибки не добавляются к вызывающей модели.
#### `confirmation`
Этот хелпер можно использовать, если у вас есть два текстовых поля, из которых нужно получить полностью идентичное содержание.
Например, вы хотите подтверждение адреса электронной почты или пароля. Эта валидация создает виртуальный атрибут, имя которого равно имени подтверждаемого поля с добавлением "confirmation".
```
class Person < ApplicationRecord
  validates :email, confirmation: true
end
```
В вашем шаблоне вьюхи нужно использовать что-то вроде этого:
```
<%= text_field :person, :email %>
<%= text_field :person, :email_confirmation %>
```
Эта проверка выполняется, только если `email_confirmation` не равно `nil`. Чтобы требовать подтверждение, нужно добавить еще проверку на существование проверяемого атрибута (мы рассмотрим presence чуть позже):
```
class Person < ApplicationRecord
  validates :email, confirmation: true
  validates :email_confirmation, presence: true
end
```
Также имеется опция `:case_sensitive`, которую используют, чтобы определить, должно ли ограничение подтверждения быть чувствительным к регистру. Эта опция по умолчанию `true`.
```
class Person < ApplicationRecord
  validates :email, confirmation: { case_sensitive: false }
end
```
#### `exclusion`
Этот хелпер проводит валидацию того, что значения атрибутов не включены в указанный набор. Фактически, этот набор может быть любым перечисляемым объектом.
```
class Account < ApplicationRecord
  validates :subdomain, exclusion: { in: %w(www us ca jp),
    message: "%{value} is reserved." }
end
```
Хелпер exclusion имеет опцию `:in`, которая получает набор значений, которые не должны приниматься проверяемыми атрибутами. Опция `:in` имеет псевдоним `:within`, который используется для тех же целей. Этот пример использует опцию `:message`, чтобы показать вам, как можно включать значение атрибута.
#### `format`
Этот хелпер проводит валидацию значений атрибутов, тестируя их на соответствие указанному регулярному выражению, которое определяется с помощью опции `:with`.
```
class Product < ApplicationRecord
  validates :legacy_code, format: { with: /\A[a-zA-Z]+\z/,
    message: "only allows letters" }
end
```
В качестве альтернативы можно потребовать, чтобы указанный атрибут не соответствовал регулярному выражению, используя опцию `:without`.
#### `inclusion`
Этот хелпер проводит валидацию значений атрибутов на включение в указанный набор. Фактически этот набор может быть любым перечисляемым объектом.
```
class Coffee < ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }
end
```
#### `length`
```
class Person < ApplicationRecord
  validates :name, length: { minimum: 2 }
  validates :bio, length: { maximum: 500 }
  validates :password, length: { in: 6..20 }
  validates :registration_number, length: { is: 6 }
end
```
Возможные опции ограничения длины такие:
* `:minimum` - атрибут не может быть меньше определенной длины.
* `:maximum` - атрибут не может быть больше определенной длины.
* `:in` (или `:within`) - длина атрибута должна находиться в указанном интервале. Значение этой опции должно быть интервалом.
* `:is` - длина атрибута должна быть равной указанному значению. 

Значение сообщения об ошибке по умолчанию зависит от типа выполняемой валидации длины. Можно переопределить эти сообщения, используя опции `:wrong_length`, `:too_long` и `:too_short`, и `%{count}` как местозаполнитель (placeholder) числа, соответствующего длине используемого ограничения. Можете использовать опцию `:message` для определения сообщения об ошибке.
```
class Person < ApplicationRecord
  validates :bio, length: { maximum: 1000,
    too_long: "%{count} characters is the maximum allowed" }
end
```
Отметьте, что сообщения об ошибке по умолчанию во множественном числе (т.е., "is too short (minimum is %{count} characters)"). По этой причине, когда `:minimum` равно 1, следует предоставить собственное сообщение или использовать вместо него `presence: true`. Когда `:in` или `:within` имеют как нижнюю границу 1, следует или предоставить собственное сообщение, или вызвать `presence` перед `length`.
#### `numericality`
Этот хелпер проводит валидацию того, что ваши атрибуты имеют только числовые значения. По умолчанию, этому будет соответствовать возможный знак первым символом, и следующее за ним целочисленное или с плавающей запятой число. Чтобы определить, что допустимы только целочисленные значения, установите `:only_integer` в `true`.

Если установить `:only_integer` в `true`, тогда будет использоваться регулярное выражение
```
/\A[+-]?\d+\z/
```
для проведения валидации значения атрибута. В противном случае, он будет пытаться конвертировать значение в число, используя `Float`.
```
class Player < ApplicationRecord
  validates :points, numericality: true
  validates :games_played, numericality: { only_integer: true }
end
```

Кроме `:only_integer`, хелпер `validates_numericality_of` также принимает следующие опции для добавления ограничений к приемлемым значениям:
* `:greater_than` - определяет, что значение должно быть больше, чем значение опции.
* `:greater_than_or_equal_to` - определяет, что значение должно быть больше или равно значению опции.
* `:equal_to` - определяет, что значение должно быть равно значению опции.
* `:less_than` - определяет, что значение должно быть меньше, чем значение опции. 
* `:less_than_or_equal_to` - определяет, что значение должно быть меньше или равно значению опции.
* `:other_than` - определяет, что значение должно отличаться от представленного значения.
* `:odd` - определяет, что значение должно быть нечетным, если установлено true.
* `:even` - определяет, что значение должно быть четным, если установлено true.

> По умолчанию `numericality` не допускает значения `nil`. Чтобы их разрешить, можно использовать опцию `allow_nil: true`.
#### `presence`
Этот хелпер проводит валидацию того, что определенные атрибуты не пустые. Он использует метод `blank?` для проверки того, является ли значение или `nil`, или пустой строкой (это строка, которая или пуста, или состоит из пробелов).
```
class Person < ApplicationRecord
  validates :name, :login, :email, presence: true
end
```
Если хотите быть уверенным, **что связь существует**, нужно проверить, существует ли сам связанный объект, а не внешний ключ, используемый для связи.
```
class LineItem < ApplicationRecord
  belongs_to :order
  validates :order, presence: true
end
```
Для того, чтобы **проверять связанные записи**, чье присутствие необходимо, нужно определить опцию `:inverse_of` для связи:
```
class Order < ApplicationRecord
  has_many :line_items, inverse_of: :order
end
```
При проведении валидации существования объекта, связанного отношением `has_one` или `has_many`, будет проверено, что объект ни `blank?`, ни `marked_for_destruction?`.

Так как `false.blank?` это `true`, если хотите **провести валидацию существования булева поля**, нужно использовать одну из следующих валидаций:
```
validates :boolean_field_name, inclusion: { in: [true, false] }
validates :boolean_field_name, exclusion: { in: [nil] }
```
При использовании одной из этих валидаций, вы можете быть уверены, что значение не будет `nil`, которое в большинстве случаев преобразуется в `NULL` значение.
#### `absence`
Этот хелпер проверяет, что указанные атрибуты отсутствуют. Он использует метод `present?` для проверки, что значение является либо `nil`, либо пустой строкой (то есть либо нулевой длины, либо состоящей из пробелов).
```
class Person < ApplicationRecord
  validates :name, :login, :email, absence: true
end
```
Если хотите **убедиться, что отсутствует связь**, необходимо проверить, что отсутствует сам связанный объект, а не внешний ключ, используемый для связи.
```
class LineItem < ApplicationRecord
  belongs_to :order
  validates :order, absence: true
end
```
Чтобы проверять связанные объекты, отсутствие которых требуется, для связи необходимо указать опцию `:inverse_of`:
```
class Order < ApplicationRecord
  has_many :line_items, inverse_of: :order
end
```
Если проверяете отсутствие объекта, связанного отношением `has_one` или `has_many`, он проверит, что объект и не `present?`, и не `marked_for_destruction?`.

Поскольку `false.present?` является `false`, если хотите проверить отсутствие булева поля, следует использовать `validates :field_name, exclusion: { in: [true, false] }`
#### `uniqueness`
Этот хелпер проводит валидацию того, что значение атрибута уникально, перед тем, как объект будет сохранен. Он не создает условие уникальности в базе данных, следовательно, может произойти так, что два разных подключения к базе данных создадут две записи с одинаковым значением для столбца, который вы подразумеваете уникальным. Чтобы этого избежать, нужно создать индекс `unique` на оба столбцах в вашей базе данных.
```
class Account < ApplicationRecord
  validates :email, uniqueness: true
end
```
Валидация производится путем SQL-запроса в таблицу модели, поиска существующей записи с тем же значением атрибута.

Имеется опция `:scope`, которую можно использовать для определения одного и более атрибутов, используемых для ограничения проверки уникальности:
```
class Holiday < ApplicationRecord
  validates :name, uniqueness: { scope: :year,
    message: "should happen once per year" }
end
```
Если хотите создать ограничение на уровне базы данных, чтобы предотвратить возможные нарушения валидации уникальности с помощью опции `:scope`, необходимо создать индекс уникальности на обоих столбцах базы данных.
Также имеется опция `:case_sensitive`, которой можно определить, будет ли ограничение уникальности чувствительно к регистру или нет. Опция по умолчанию равна `true`.
```
class Person < ApplicationRecord
  validates :name, uniqueness: { case_sensitive: false }
end
```
> Отметьте, что некоторые базы данных настроены на выполнение чувствительного к регистру поиска в любом случае.
#### `validates_with`
```
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if record.first_name == "Evil"
      record.errors[:base] << "This person is evil"
    end
  end
end

class Person < ApplicationRecord
  validates_with GoodnessValidator
end
```
> Ошибки, добавляемые в `record.errors[:base]` относятся к состоянию записи в целом, а не к определенному атрибуту.
Хелпер `validates_with` принимает класс или список классов для использования в валидации. Для `validates_with` нет сообщения об ошибке по умолчанию. Следует вручную добавлять ошибки в коллекцию errors записи в классе валидатора.

Для применения метода validate, необходимо иметь определенным параметр record, который является записью, проходящей валидацию.

Подобно всем другим валидациям, `validates_with` принимает опции `:if`, `:unless` и `:on`. Если передадите любые другие опции, они будут переданы в класс валидатора как `options`:
```
class GoodnessValidator < ActiveModel::Validator
  def validate(record)
    if options[:fields].any?{|field| record.send(field) == "Evil" }
      record.errors[:base] << "This person is evil"
    end
  end
end

class Person < ApplicationRecord
  validates_with GoodnessValidator, fields: [:first_name, :last_name]
end
```
Отметьте, что валидатор будет инициализирован только один раз на протяжении всего жизненного цикла приложения, а не при каждом запуске валидации, поэтому будьте аккуратнее с использованием переменных экземпляра в нем.

Если ваш валидатор настолько сложный, что вы хотите использовать переменные экземпляра, вместо него проще использовать обычные объекты Ruby:
```
class Person < ApplicationRecord
  validate do |person|
    GoodnessValidator.new(person).validate
  end
end

class GoodnessValidator
  def initialize(person)
    @person = person
  end

  def validate
    if some_complex_condition_involving_ivars_and_private_methods?
      @person.errors[:base] << "This person is evil"
    end
  end

  # ...
end
```
#### `validates_each`
Этот хелпер помогает провести валидацию атрибутов с помощью блока кода. Он не имеет предопределенной валидационной функции. Вы должны создать ее, используя блок, и каждый атрибут, указанный в `validates_each`, будет протестирован в нем. В следующем примере нам не нужны имена и фамилии, начинающиеся с маленькой буквы.
```
class Person < ApplicationRecord
  validates_each :name, :surname do |record, attr, value|
    record.errors.add(attr, 'must start with upper case') if value =~ /\A[[:lower:]]/
  end
end
```
Блок получает запись, имя атрибута и значение атрибута. Вы можете делать что угодно для проверки валидности данных внутри блока. Если валидация проваливается, следует добавить сообщение об ошибке в модель, которое делает ее невалидной.
### Общие опции валидаций <a name="2.3.3"></a>
#### `:allow_nil`
Опция `:allow_nil` пропускает валидацию, когда проверяемое значение равно `nil`.
```
class Coffee < ApplicationRecord
  validates :size, inclusion: { in: %w(small medium large),
    message: "%{value} is not a valid size" }, allow_nil: true
end
```
#### `:allow_blank`

Опция `:allow_blank` подобна опции `:allow_nil`. Эта опция пропускает валидацию, если значение атрибута `blank?`, например `nil` или пустая строка.
```
class Topic < ApplicationRecord
  validates :title, length: { is: 5 }, allow_blank: true
end

Topic.create(title: "").valid?  # => true
Topic.create(title: nil).valid? # => true
```
#### `:message`
Значение `String` в `:message` может опционально содержать любые из `%{value}`, `%{attribute}` и `%{model}`, которые будут динамически заменены, когда валидация провалится. Эта замена выполняется, если используется гем `I18n`, и местозаполнитель должен полностью совпадать, пробелы не допускаются.

Значение `Proc` в `:message` задается с двумя аргументами: проверяемым объектом и хэшем с ключами `:model`, `:attribute` и `:value`.
```
class Person < ApplicationRecord
  # Жестко закодированное сообщение
  validates :name, presence: { message: "must be given please" }

  # Сообщение со значением с динамическим атрибутом. %{value} будет заменено
  # фактическим значением атрибута. Также доступны %{attribute} и %{model}.
  validates :age, numericality: { message: "%{value} seems wrong" }

  # Proc
  validates :username,
    uniqueness: {
      # object = person object being validated
      # data = { model: "Person", attribute: "Username", value: <username> }
      message: ->(object, data) do
        "Hey #{object.name}!, #{data[:value]} is taken already! Try again #{Time.zone.tomorrow}"
      end
    }
end
```
#### `:on`
Используйте `on: :create`, для запуска валидации только когда создается новая запись, или `on: :update`, для запуска валидации когда запись обновляется.
```
class Person < ApplicationRecord
  # будет возможно обновить email с дублирующим значением
  validates :email, uniqueness: true, on: :create

  # будет возможно создать запись с нечисловым возрастом
  validates :age, numericality: true, on: :update

  # по умолчанию (проверяет и при создании, и при обновлении)
  validates :name, presence: true
end
```
`on:` также можно использовать для **определения пользовательского контекста**. Пользовательские контексты должны быть явно включены с помощью передачи имени контекста в `valid?`, `invalid?` или `save`.
```
class Person < ApplicationRecord
  validates :email, uniqueness: true, on: :account_setup
  validates :age, numericality: true, on: :account_setup
end

person = Person.new
```
`person.valid?(:account_setup)` выполнит обе валидации без сохранения модели. И `person.save(context: :account_setup)` перед сохранением валидирует `person` в контексте `account_setup`. При явном включении модель валидируется только валидациями только этого контекста и валидациями без контекста.

### Строгие валидации <a name="2.3.4"></a>
Также можно определить валидации строгими, чтобы они вызывали `ActiveModel::StrictValidationFailed`, когда объект невалиден.
```
class Person < ApplicationRecord
  validates :name, presence: { strict: true }
end

Person.new.valid?  # => ActiveModel::StrictValidationFailed: Name can't be blank
```
Также возможно передать собственное исключение в опцию `:strict`.
```
class Person < ApplicationRecord
  validates :token, presence: true, uniqueness: true, strict: TokenGenerationException
end

Person.new.valid?  # => TokenGenerationException: Token can't be blank
```
### Условная валидация <a name="2.3.5"></a>
#### Использование символа с `:if` и `:unless`
```
class Order < ApplicationRecord
  validates :card_number, presence: true, if: :paid_with_card?

  def paid_with_card?
    payment_type == "card"
  end
end
```
#### Использование `Proc` с `:if` и `:unless`
Использование объекта `Proc` дает возможность написать встроенное условие вместо отдельного метода. Этот вариант лучше всего подходит для однострочного кода.
```
class Account < ApplicationRecord
  validates :password, confirmation: true,
    unless: Proc.new { |a| a.password.blank? }
end
```
#### Группировка условных валидаций `with_options`
```
class User < ApplicationRecord
  with_options if: :is_admin? do |admin|
    admin.validates :password, length: { minimum: 10 }
    admin.validates :email, presence: true
  end
end
````
Во все валидации внутри `with_options` будет автоматически передано условие `if: :is_admin?`
#### Объединение условий валидации
С другой стороны, может использоваться массив, когда несколько условий определяют, должна ли произойти валидация. Более того, в одной и той же валидации можно применить и `:if:`, и `:unless`.
```
class Computer < ApplicationRecord
  validates :mouse, presence: true,
                    if: [Proc.new { |c| c.market.retail? }, :desktop?],
                    unless: Proc.new { |c| c.trackpad.present? }
end
```
Валидация выполнится только тогда, когда все условия `:if` и ни одно из условий `:unless` будут вычислены со значением `true`.
### Выполнение собственных валидаций <a name="2.3.6"></a>
#### Собственные валидаторы
Собственные валидаторы это классы, наследуемые от `ActiveModel::Validator`. Эти классы должны реализовать метод `validate`, принимающий запись как аргумент и выполняющий валидацию на ней. Собственный валидатор вызывается с использованием метода `validates_with`
```
class MyValidator < ActiveModel::Validator
  def validate(record)
    unless record.name.starts_with? 'X'
      record.errors[:name] << 'Need a name starting with X please!'
    end
  end
end
 
class Person
  include ActiveModel::Validations
  validates_with MyValidator
end
```
Простейшим способом добавить собственные валидаторы для валидации отдельных атрибутов является наследуемость от `ActiveModel::EachValidator`. В этом случае класс собственного валидатора должен реализовать метод `validate_each`, принимающий три аргумента: запись, атрибут и значение. Это будут соответствующие экземпляр, атрибут, который будет проверяться и значение атрибута в переданном экземпляре:
```
class EmailValidator < ActiveModel::EachValidator
  def validate_each(record, attribute, value)
    unless value =~ /\A([^@\s]+)@((?:[-a-z0-9]+\.)`[a-z]{2,})\z/i
      record.errors[attribute] << (options[:message] || "is not an email")
    end
  end
end

class Person < ApplicationRecord
  validates :email, presence: true, email: true
end
```
Как показано в примере, можно объединять стандартные валидации со своими произвольными валидаторами.
#### Собственные методы
Метод `valid?` проверит, что коллекция ошибок пуста. поэтому ваши собственные методы валидации должны добавить ошибки в нее, когда вы хотите, чтобы валидация провалилась:
```
class Invoice < ApplicationRecord
  validate :expiration_date_cannot_be_in_the_past,
    :discount_cannot_be_greater_than_total_value

  def expiration_date_cannot_be_in_the_past
    if expiration_date.present? && expiration_date < Date.today
      errors.add(:expiration_date, "can't be in the past")
    end
  end

  def discount_cannot_be_greater_than_total_value
    errors.add(:discount, "can't be greater than total value") if
      discount > total_value
  end
end
```
По умолчанию такие валидации будут выполнены каждый раз при вызове `valid?` или сохранении объекта. Но также возможно контролировать, когда выполнять собственные валидации, передав опцию `:on` в метод `validate`, с ключами: `:create` или `:update`.
```
class Invoice < ApplicationRecord
  validate :active_customer, on: :create

  def active_customer
    errors.add(:customer_id, "is not active") unless customer.active?
  end
end
```
### Работаем с ошибками валидации <a name="2.3.7"></a>
#### `errors`
Возвращает экземпляр класса `ActiveModel::Errors`, содержащий все ошибки. Каждый ключ это имя атрибута и значение это массив строк со всеми ошибками.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors.messages
 # => {:name=>["can't be blank", "is too short (minimum is 3 characters)"]}

person = Person.new(name: "John Doe")
person.valid? # => true
person.errors.messages # => []
```
#### `errors[]`
Он возвращает массив строк со всеми сообщениями об ошибке для заданного атрибута, каждая строка с одним сообщением об ошибке. Если нет ошибок, относящихся к атрибуту, возвратится пустой массив.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new(name: "John Doe")
person.valid? # => true
person.errors[:name] # => []

person = Person.new(name: "JD")
person.valid? # => false
person.errors[:name] # => ["is too short (minimum is 3 characters)"]

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
```
#### `errors.add`
Метод add позволяет добавлять сообщение об ошибке, относящейся к определенному атрибуту. Он принимает в качестве аргументов атрибут и сообщение об ошибке.

Метод `errors.full_messages` (или его эквивалент `errors.to_a`) возвращает сообщения об ошибках в дружелюбном формате с именем атрибута с прописной буквы, предшествующим каждому сообщению, как показано в следующем примере.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors.add(:name, "cannot contain the characters !@#%*()_-+=")
  end
end

person = Person.create(name: "!@#")

person.errors[:name]
 # => ["cannot contain the characters !@#%*()_-+="]

person.errors.full_messages
 # => ["Name cannot contain the characters !@#%*()_-+="]
```
Эквивалентом `errors#add` является использование `<<` для добавления сообщения к массиву `errors.messages` атрибута:
```
  class Person < ApplicationRecord
    def a_method_used_for_validation_purposes
      errors.messages[:name] << "cannot contain the characters !@#%*()_-+="
    end
  end

  person = Person.create(name: "!@#")

  person.errors[:name]
   # => ["cannot contain the characters !@#%*()_-+="]

  person.errors.to_a
   # => ["Name cannot contain the characters !@#%*()_-+="]
```
#### `errors.details`
Можно указать тип валидатора в возвращаемом хэше подробностей об ошибке `detail` с помощью метода `errors.add`.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors.add(:name, :invalid_characters)
  end
end

person = Person.create(name: "!@#")

person.errors.details[:name]
# => [{error: :invalid_characters}]
```
Чтобы расширить хэш подробностей об ошибке `details`, добавив, к примеру, недопустимые символы, можно передать дополнительные ключи в `errors.add`.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors.add(:name, :invalid_characters, not_allowed: "!@#%*()_-+=")
  end
end

person = Person.create(name: "!@#")

person.errors.details[:name]
# => [{error: :invalid_characters, not_allowed: "!@#%*()_-+="}]
```
Все встроенные в Rails валидаторы заполняют хэш details соответствующим типом валидатора.
#### `errors[:base]`
Можете добавлять сообщения об ошибках, которые относятся к состоянию объекта в целом, а не к отдельному атрибуту. Этот метод можно использовать, если вы хотите сказать, что объект невалиден, независимо от значений его атрибутов. Поскольку `errors[:base]` массив, можете просто добавить строку к нему, и она будет использована как сообщение об ошибке.
```
class Person < ApplicationRecord
  def a_method_used_for_validation_purposes
    errors[:base] << "This person is invalid because ..."
  end
end
```
#### `errors.clear`
Метод `clear` используется, когда вы намеренно хотите очистить все сообщения в коллекции errors. Естественно, вызов `errors.clear` для невалидного объекта фактически не сделает его валидным: сейчас коллекция `errors` будет пуста, но в следующий раз, когда вы вызовете `valid?` или любой метод, который пытается сохранить этот объект в базу данных, валидации выполнятся снова. Если любая из валидаций провалится, коллекция errors будет заполнена снова.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]

person.errors.clear
person.errors.empty? # => true

person.save # => false

person.errors[:name]
 # => ["can't be blank", "is too short (minimum is 3 characters)"]
```
#### `errors.size`
Метод `size` возвращает количество сообщений об ошибке для объекта.
```
class Person < ApplicationRecord
  validates :name, presence: true, length: { minimum: 3 }
end

person = Person.new
person.valid? # => false
person.errors.size # => 2

person = Person.new(name: "Andrea", email: "andrea@example.com")
person.valid? # => true
person.errors.size # => 0
```
### Отображение ошибок валидации во вьюхах <a name="2.3.8"></a>
Как только вы создали модель и добавили валидации, если эта модель создается с помощью веб-формы, то вы, возможно хотите отображать сообщение об ошибке, когда одна из валидаций проваливается.

Поскольку каждое приложение обрабатывает подобные вещи по-разному, в Rails нет какого-то хелпера вьюхи для непосредственной генерации этих сообщений. Однако, благодаря богатому набору методов, Rails в целом дает способ взаимодействия с валидациями, очень просто создать свой собственный. Кроме того, при генерации скаффолда, Rails поместит некоторый ERB в `_form.html.erb`, генерируемый для отображения полного списка ошибок этой модели.

Допустим, у нас имеется модель, сохраненная в переменную экземпляра @article, это выглядит следующим образом:
```
<% if @article.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@article.errors.count, "error") %> prohibited this article from being saved:</h2>
    <ul>
    <% @article.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
```
Более того, при использовании хелперов форм Rails для создания форм, когда у поля происходит ошибка валидации, генерируется дополнительный `<div>` вокруг содержимого.
```
<div class="field_with_errors">
 <input id="article_title" name="article[title]" size="30" type="text" value="">
</div>
```
Этот `div` можно стилизовать по желанию. К примеру, дефолтный скаффолд, который генерирует Rails, добавляет это правило CSS:
```
.field_with_errors {
  padding: 2px;
  background-color: red;
  display: table;
}
```
## Колбэки Active Record <a name="2.4"></a>
### Жизненный цикл объекта <a name="2.4.1"></a>
В результате обычных операций приложения на Rails, объекты могут быть созданы, обновлены и уничтожены. Active Record дает возможность вмешаться в этот жизненный цикл объекта, таким образом, вы можете контролировать свое приложение и его данные.

Валидации позволяют вам быть уверенными, что только валидные данные хранятся в вашей базе данных. Колбэки позволяют вам переключать логику до или после изменения состояния объекта.
### Обзор колбэков <a name="2.4.2"></a>
#### Регистрация колбэков 
Для того, чтобы использовать доступные колбэки, их нужно зарегистрировать. Можно реализовать колбэки как обычные методы, а затем использовать макро-методы класса для их регистрации в качестве колбэков.
```
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_validation :ensure_login_has_a_value

  private
    def ensure_login_has_a_value
      if login.nil?
        self.login = email unless email.blank?
      end
    end
end
```
**Макро-методы** класса также могут получать блок. Их следует использовать, если код внутри блока такой короткий, что помещается в одну строчку.
```
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_create do
    self.name = login.capitalize if name.blank?
  end
end
```
Колбэки также могут быть зарегистрированы на выполнение **при определенных событиях жизненного цикла**:
```
class User < ApplicationRecord
  before_validation :normalize_name, on: :create

  # :on также принимает массив
  after_validation :set_location, on: [ :create, :update ]

  private
    def normalize_name
      self.name = name.downcase.titleize
    end

    def set_location
      self.location = LocationService.query(self)
    end
end
```
Считается **хорошей практикой** объявлять методы колбэков как `private`. Если их оставить `public`, они могут быть вызваны извне модели и нарушить принципы инкапсуляции объекта.
### Доступные колбэки <a name="2.4.3"></a>
Вот список всех доступных колбэков Active Record, перечисленных в том порядке, в котором они вызываются в течение соответствующих операций:
#### Создание объекта
* `before_validation`
* `after_validation`
* `before_save`
* `around_save`
* `before_create`
* `around_create`
* `after_create`
* `after_save`
* `after_commit/after_rollback` 
#### Обновление объекта
* `before_validation`
* `after_validation`
* `before_save`
* `around_save`
* `before_update`
* `around_update`
* `after_update`
* `after_save`
* `after_commit/after_rollback` 
#### Уничтожение объекта
* `before_destroy`
* `around_destroy`
* `after_destroy`
* `after_commit/after_rollback` 
> `after_save` запускается и при создании, и при обновлении, но всегда после более специфичных колбэков `after_create` и `after_update`, независимо от порядка, в котором выполняются макро-вызовы.
> Колбэк `before_destroy` должен быть размещен перед связями `dependent: :destroy` (или использовать опцию `prepend: true`), чтобы убедиться, что они выполняются до того, как записи будут удалены с помощью `dependent: :destroy`.

#### `after_initialize` и `after_find`
**Колбэк `after_initialize`** вызывается всякий раз, когда возникает экземпляр объекта Active Record, или непосредственно при использовании new, или когда запись загружается из базы данных. Он может быть полезен, чтобы избежать необходимости напрямую переопределять метод Active Record `initialize`.
**Колбэк `after_find`** будет вызван всякий раз, когда Active Record загружает запись из базы данных. `after_find` вызывается перед `after_initialize`, если они оба определены.
У колбэков `after_initialize` и `after_find` **нет пары `before_*`**, но они могут быть зарегистрированы подобно другим колбэкам Active Record.
```
class User < ApplicationRecord
  after_initialize do |user|
    puts "You have initialized an object!"
  end

  after_find do |user|
    puts "You have found an object!"
  end
end

>> User.new
You have initialized an object!
=> #<User id: nil>

>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
```
#### `after_touch`
Колбэк `after_touch` будет вызван, когда на объекте Active Record вызван `touch`.
```
class User < ApplicationRecord
  after_touch do |user|
    puts "You have touched an object"
  end
end

>> u = User.create(name: 'Kuldeep')
=> #<User id: 1, name: "Kuldeep", created_at: "2013-11-25 12:17:49", updated_at: "2013-11-25 12:17:49">

>> u.touch
You have touched an object
=> true
```
Он может быть **использован совместно с `belongs_to`**:
```
class Employee < ApplicationRecord
  belongs_to :company, touch: true
  after_touch do
    puts 'An Employee was touched'
  end
end

class Company < ApplicationRecord
  has_many :employees
  after_touch :log_when_employees_or_company_touched

  private
  def log_when_employees_or_company_touched
    puts 'Employee/Company was touched'
  end
end

>> @employee = Employee.last
=> #<Employee id: 1, company_id: 1, created_at: "2013-11-25 17:04:22", updated_at: "2013-11-25 17:05:05">

# вызывает @employee.company.touch
>> @employee.touch
Employee/Company was touched
An Employee was touched
=> true
```
### Запуск колбэков <a name="2.4.4"></a>
Следующие методы запускают колбэки:
* `create`
* `create!`
* `destroy`
* `destroy!`
* `destroy_all`
* `save`
* `save!`
* `save(validate: false)`
* `toggle!`
* `touch`
* `update_attribute`
* `update`
* `update!`
* `valid?` 

Дополнительно, **колбэк `after_find` запускается** следующими поисковыми методами:
* `all`
* `first`
* `find`
* `find_by`
* `find_by_*`
* `find_by_*!`
* `find_by_sql`
* `last` 

Колбэк **`after_initialize` запускается** всякий раз, **когда инициализируется** новый объект класса.

> Методы `find_by_*` и `find_by_*!` это динамические методы поиска, генерируемые автоматически для каждого атрибута.
### Пропуск колбэков <a name="2.4.5"></a>

Подобно валидациям, также возможно пропустить колбэки, используя следующие методы.
* `decrement`
* `decrement_counter`
* `delete`
* `delete_all`
* `increment`
* `increment_counter`
* `toggle`
* `update_column`
* `update_columns`
* `update_all`
* `update_counters` 

Однако, эти методы нужно использовать осторожно, поскольку важные бизнес-правила и логика приложения могут содержаться в колбэках. Пропуск их без понимания возможных последствий может привести к невалидным данным.
### Прерывание выполнения <a name="2.4.6"></a>
Как только вы зарегистрировали новые колбэки в своих моделях, они будут поставлены в очередь на выполнение. Эта очередь включает все валидации вашей модели, зарегистрированные колбэки и операции с базой данных для выполнения.

Вся цепочка колбэков упаковывается в операцию. **Если любой колбэк вызывает исключение, выполняемая цепочка прерывается** и запускается `ROLLBACK`. Чтобы преднамеренно остановить цепочку, используйте:
```
throw :abort
```
> Вызов произвольного исключения может прервать код, который предполагает, что save и тому подобное не будут провалены подобным образом. Исключение `ActiveRecord::Rollback` чуть точнее сообщает Active Record, что происходит откат. Он подхватывается изнутри, но не перевызывает исключение.
> Любое исключение, кроме `ActiveRecord::Rollback` или `ActiveRecord::RecordInvalid`, будет перевызвано Rails после того, как прервется цепочка колбэков. Вызов исключения, отличного от `ActiveRecord::Rollback` или `ActiveRecord::RecordInvalid`, может сломать код, который не ожидает, что методы, такие как `save` и `update` (которые обычно пытаются вернуть `true` или `false`) вызовут исключение.

### Колбэки для отношений <a name="2.4.7"></a>
Колбэки работают с отношениями между моделями, и даже могут быть определены ими. Представим пример, где пользователь имеет много статей. Статьи пользователя должны быть уничтожены, если уничтожается пользователь. Давайте добавим колбэк `after_destroy` в модель `User` через ее отношения с моделью `Article`.
```
class User < ApplicationRecord
  has_many :articles, dependent: :destroy
end

class Article < ActiveRecord::Base
  after_destroy :log_destroy_action

  def log_destroy_action
    puts 'Article destroyed'
  end
end

>> user = User.first
=> #<User id: 1>
>> user.articles.create!
=> #<Article id: 1, user_id: 1>
>> user.destroy
Article destroyed
=> #<User id: 1>
```
### Условные колбэки <a name="2.4.8"></a>
#### Использование `:if` и `:unless` с `Symbol`
При использовании такой формы регистрации, также возможно зарегистрировать несколько различных предикатов, которые будут вызваны, чтобы проверить, должен ли выполняться колбэк.
```
class Order < ApplicationRecord
  before_save :normalize_card_number, if: :paid_with_card?
end
```
#### Использование `:if` и `:unless` с `Proc`
Этот вариант больше всего подходит при написании коротких методов, обычно однострочных.
```
class Order < ApplicationRecord
  before_save :normalize_card_number,
    if: Proc.new { |order| order.paid_with_card? }
end
```
#### Составные условия для колбэков
```
class Comment < ApplicationRecord
  after_create :send_email_to_author, if: :author_wants_emails?,
    unless: Proc.new { |comment| comment.article.ignore_comments? }
end
```
### Классы колбэков <a name="2.4.9"></a>
Вот пример, где создается класс с колбэком `after_destroy` для модели `PictureFile`:
```
class PictureFileCallbacks
  def after_destroy(picture_file)
    if File.exist?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
```
При объявлении внутри класса, как выше, методы колбэка получают объект модели как параметр. Теперь можем использовать класс колбэка в модели:
```
class PictureFile < ApplicationRecord
  after_destroy PictureFileCallbacks.new
end
```
Заметьте, что нам нужно создать экземпляр нового объекта `PictureFileCallbacks`, после того, как объявили наш колбэк как отдельный метод. Это особенно полезно, если колбэки используют состояние экземпляра объекта. Часто, однако, более подходящим является объявление его в качестве метода класса.
```
class PictureFileCallbacks
  def self.after_destroy(picture_file)
    if File.exist?(picture_file.filepath)
      File.delete(picture_file.filepath)
    end
  end
end
```
Если метод колбэка объявляется таким образом, нет необходимости создавать экземпляр объекта `PictureFileCallbacks`.
```
class PictureFile < ApplicationRecord
  after_destroy PictureFileCallbacks
end
```
Внутри своего колбэк-класса можно создать сколько угодно колбэков.
### Транзакционные колбэки <a name="2.4.10"></a>
Имеются два дополнительных колбэка, которые включаются по завершению транзакции базы данных: `after_commit` и `after_rollback`. Эти колбэки очень похожи на колбэк `after_save`, за исключением того, что они не выполняются пока изменения в базе данных не будут подтверждены или обращены. Они наиболее полезны, когда вашим моделям Active Record необходимо взаимодействовать с внешними системами, не являющимися частью транзакции базы данных.

Рассмотрим, допустим, предыдущий пример, где модели `PictureFile` необходимо удалить файл после того, как запись уничтожена. Если что-либо вызовет исключение после того, как был вызван колбэк `after_destroy`, и транзакция откатывается, файл будет удален и модель останется в противоречивом состоянии. Например, предположим, что `picture_file_2` в следующем коде не валидна, и метод `save!` вызовет ошибку.
```
PictureFile.transaction do
  picture_file_1.destroy
  picture_file_2.save!
end
```
Используя колбэк `after_commit`, можно учесть этот случай.
```
class PictureFile < ApplicationRecord
  after_commit :delete_picture_file_from_disk, on: :destroy

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
```
> Опция `:on` определяет, когда будет запущен колбэк. Если не предоставить опцию `:on`, колбэк будет запущен для каждого экшна.

Так как принято использовать колбэк `after_commit` только при создании, обновлении или удалении, есть псевдонимы для этих операций:
* `after_create_commit`
* `after_update_commit`
* `after_destroy_commit` 
```
class PictureFile < ApplicationRecord
  after_destroy_commit :delete_picture_file_from_disk

  def delete_picture_file_from_disk
    if File.exist?(filepath)
      File.delete(filepath)
    end
  end
end
```
> Колбэки `after_commit` и `after_rollback` вызываются для всех созданных, обновленных или удаленных моделей внутри блока транзакции. Однако, если какое-либо исключение вызовется в одном из этих колбэков, это исключение всплывет, и любые оставшиеся методы `after_commit` или `after_rollback` не будут выполнены. По сути, если код вашего колбэка может вызвать исключение, нужно для него вызвать `rescue`, и обработать его в колбэке, чтобы позволить запуститься другим колбэкам.

> При одновременном **использовании `after_create_commit` и `after_update_commit`** в одной и той же модели сработает только колбэк, **определенный последним**, переопределив все остальные.

```
class User < ApplicationRecord
  after_create_commit :log_user_saved_to_db
  after_update_commit :log_user_saved_to_db

  private
  def log_user_saved_to_db
    puts 'User was saved to database'
  end
end

# ничего не выводит
>> @user = User.create

# обновление @user
>> @user.save
=> User was saved to database
```
Чтобы зарегистрировать **колбэки как для create, так и для update** экшнов, используйте **`after_commit`**.
```
class User < ApplicationRecord
  after_commit :log_user_saved_to_db, on: [:create, :update]
end
```


## Связи (ассоциации) <a name="2.5"></a>
### Зачем нужны связи <a name="2.5.1"></a>
```
class Author < ApplicationRecord
  has_many :books, dependent: :destroy
end

class Book < ApplicationRecord
  belongs_to :author
end
```
С этими изменениями создание новой книги для определенного автора проще:
```
@book = @author.books.create(published_at: Time.now)
```
Удаление автора и всех его книг намного проще:
```
@author.destroy
```
### Типы связей <a name="2.5.2"></a>
Rails поддерживает шесть типов связей:
* `belongs_to`
* `has_one`
* `has_many`
* `has_many :through`
* `has_one :through`
* `has_and_belongs_to_many` 
Связи реализуются с использованием макро-вызовов (macro-style calls), и, таким образом, вы можете декларативно добавлять возможности для своих моделей. Например, объявляя, что одна модель принадлежит (`belongs_to`) другой, вы указываете Rails сохранять информацию о первичном-внешнем ключах между экземплярами двух моделей, а также получаете несколько полезных методов, добавленных в модель.

#### Связь `belongs_to`
Связь belongs_to устанавливает соединение один-к-одному с другой моделью, когда один экземпляр объявляющей модели "принадлежит" одному экземпляру другой модели. Например, если в приложении есть авторы и книги, и одна книга может быть связана только с одним автором, нужно объявить модель book следующим образом:
```
class Book < ApplicationRecord
  belongs_to :author
end
```
> связи `belongs_to` обязаны использовать единственное число. Если использовать множественное число в вышеприведенном примере для связи `author` в модели `Book` и создать экземпляр с помощью `Book.create(authors: @author)`, будет сообщено "uninitialized constant `Book::Authors`". Это так, потому что Rails автоматически получает имя класса из имени связи. Если в имени связи неправильно использовано число, то получаемый класс также будет неправильного числа.

Соответствующая миграция может выглядеть так:
```
class CreateOrders < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```
#### Связь `has_one`
Связь `has_one` также устанавливает соединение один-к-одному с другой моделью, но в несколько ином смысле (и с другими последствиями). Эта связь показывает, что каждый экземпляр модели содержит или обладает одним экземпляром другой модели. Например, если каждый поставщик имеет только один аккаунт, можете объявить модель supplier подобно этому:
```
class Supplier < ApplicationRecord
  has_one :account
end
```
Соответствующая миграция может выглядеть так:
```
class CreateSuppliers < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end
  end
end
```
В зависимости от применения, возможно потребуется создать индекс уникальности и/или ограничение внешнего ключа на указанный столбец таблицы `accounts`. В этом случае определение столбца может выглядеть так:
```
create_table :accounts do |t|
  t.belongs_to :supplier, index: { unique: true }, foreign_key: true
  # ...
end
```
#### Связь `has_many`
Связь has_many указывает на соединение один-ко-многим с другой моделью. Эта связь часто бывает на "другой стороне" связи `belongs_to`. Эта связь указывает на то, что каждый экземпляр модели имеет ноль или более экземпляров другой модели. Например, в приложении, содержащем авторов и книги, модель `author` может быть объявлена следующим образом:
```
class Author < ApplicationRecord
  has_many :books
end
```
Имя другой модели указывается во множественном числе при объявлении связи `has_many`.
Соответствующая миграция может выглядеть так:
```
class CreateAuthors < ActiveRecord::Migration[5.0]
  def change
    create_table :authors do |t|
      t.string :name
      t.timestamps
    end

    create_table :books do |t|
      t.belongs_to :author
      t.datetime :published_at
      t.timestamps
    end
  end
end
```
####  Связь `has_many :through`
Связь `has_many :through` часто используется для настройки соединения многие-ко-многим с другой моделью. Эта связь указывает, что объявляющая модель может соответствовать нулю или более экземплярам другой модели через третью модель. Например, рассмотрим поликлинику, где пациентам (patients) дают направления (appointments) к врачам (physicians). Соответствующие объявления связей будут выглядеть следующим образом:
```
class Physician < ApplicationRecord
  has_many :appointments
  has_many :patients, through: :appointments
end

class Appointment < ApplicationRecord
  belongs_to :physician
  belongs_to :patient
end

class Patient < ApplicationRecord
  has_many :appointments
  has_many :physicians, through: :appointments
end
```
Соответствующая миграция может выглядеть так:
```
class CreateAppointments < ActiveRecord::Migration[5.0]
  def change
    create_table :physicians do |t|
      t.string :name
      t.timestamps
    end

    create_table :patients do |t|
      t.string :name
      t.timestamps
    end

    create_table :appointments do |t|
      t.belongs_to :physician
      t.belongs_to :patient
      t.datetime :appointment_date
      t.timestamps
    end
  end
end
```
Коллекция соединительных моделей может управляться с помощью методов связи `has_many`. Например, если вы присвоите:
```
physician.patients = patients
```
Тогда будут автоматически созданы новые соединительные модели для вновь связанных объектов. Если некоторые из ранее существующих сейчас отсутствуют, их соединительные строки автоматически удаляются.

> Автоматическое удаление соединительных моделей прямое, ни один из колбэков на уничтожение не включается.

Связь **`has_many :through` также полезна для настройки "ярлыков" через вложенные связи `has_many`**. Например, если документ имеет много секций, а секция имеет много параграфов, иногда хочется получить просто коллекцию всех параграфов в документе. Это можно настроить следующим образом:
```
class Document < ApplicationRecord
  has_many :sections
  has_many :paragraphs, through: :sections
end

class Section < ApplicationRecord
  belongs_to :document
  has_many :paragraphs
end

class Paragraph < ApplicationRecord
  belongs_to :section
end
```
С определенным `through: :sections` Rails теперь понимает:
```
@document.paragraphs
```
#### Связь `has_one :through`
Связь `has_one :through` настраивает соединение один-к-одному с другой моделью. Эта связь показывает, что объявляющая модель может быть связана с одним экземпляром другой модели через третью модель. Например, если каждый поставщик имеет один аккаунт, и каждый аккаунт связан с одной историей аккаунта, тогда модели могут выглядеть так:
```
class Supplier < ApplicationRecord
  has_one :account
  has_one :account_history, through: :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  has_one :account_history
end

class AccountHistory < ApplicationRecord
  belongs_to :account
end
```
Соответствующая миграция может выглядеть так:
```
class CreateAccountHistories < ActiveRecord::Migration[5.0]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.belongs_to :supplier
      t.string :account_number
      t.timestamps
    end

    create_table :account_histories do |t|
      t.belongs_to :account
      t.integer :credit_rating
      t.timestamps
    end
  end
end
```
#### Связь `has_and_belongs_to_many`
Связь `has_and_belongs_to_many` создает прямое соединение многие-ко-многим с другой моделью, без промежуточной модели. Например, если ваше приложение включает сборки (assemblies) и детали (parts), где каждый узел имеет много деталей, и каждая деталь встречается во многих сборках, модели можно объявить таким образом:
```
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```
Соответствующая миграция может выглядеть так:
```
class CreateAssembliesAndParts < ActiveRecord::Migration[5.0]
  def change
    create_table :assemblies do |t|
      t.string :name
      t.timestamps
    end

    create_table :parts do |t|
      t.string :part_number
      t.timestamps
    end

    create_table :assemblies_parts, id: false do |t|
      t.belongs_to :assembly
      t.belongs_to :part
    end
  end
end
```
#### Выбор между `belongs_to` и `has_one`

Если хотите настроить отношение один-к-одному между двумя моделями, необходимо добавить `belongs_to` к одной и `has_one` к другой. Как узнать что к какой?

Различие в том, где помещен внешний ключ (он должен быть в таблице для класса, объявляющего связь `belongs_to`), но вы также должны думать о реальном значении данных. Отношение `has_one` говорит, что что-то принадлежит вам - то есть что что-то указывает на вас. Например, больше смысла в том, что поставщик владеет аккаунтом, чем в том, что аккаунт владеет поставщиком. Это означает, что правильные отношения подобны этому:
```
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```
Соответствующая миграция может выглядеть так:
```
class CreateSuppliers < ActiveRecord::Migration[5.2]
  def change
    create_table :suppliers do |t|
      t.string :name
      t.timestamps
    end

    create_table :accounts do |t|
      t.bigint  :supplier_id
      t.string  :account_number
      t.timestamps
    end

    add_index :accounts, :supplier_id
  end
end
```
> Использование `t.bigint :supplier_id` указывает имя внешнего ключа очевидно и явно. В современных версиях Rails можно абстрагироваться от деталей реализации используя `t.references :supplier`

#### Выбор между `has_many :through` и `has_and_belongs_to_many`
Rails предлагает два разных способа объявления отношения многие-ко-многим между моделями. Простейший способ - использовать `has_and_belongs_to_many`, который позволяет создать связь напрямую:
```
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```
Второй способ объявить отношение многие-ко-многим - использование `has_many :through`. Это осуществляет связь не напрямую, а через соединяющую модель:
```
class Assembly < ApplicationRecord
  has_many :manifests
  has_many :parts, through: :manifests
end

class Manifest < ApplicationRecord
  belongs_to :assembly
  belongs_to :part
end

class Part < ApplicationRecord
  has_many :manifests
  has_many :assemblies, through: :manifests
end
```
Простейший признак того, что нужно настраивать отношение `has_many :through` - если необходимо работать с моделью отношений как с независимым объектом. Если вам не нужно ничего делать с моделью отношений, проще настроить связь `has_and_belongs_to_many` (хотя нужно не забыть создать соединяющую таблицу в базе данных).

Вы должны использовать `has_many :through`, если нужны валидации, колбэки или дополнительные атрибуты для соединительной модели.

#### Полиморфные связи
Полиморфные связи - это немного более "навороченный" вид связей. С полиморфными связями модель может принадлежать более чем одной модели, на одиночной связи. Например, имеется модель изображения, которая принадлежит или модели работника, или модели продукта. Вот как это объявляется:
```
class Picture < ApplicationRecord
  belongs_to :imageable, polymorphic: true
end

class Employee < ApplicationRecord
  has_many :pictures, as: :imageable
end

class Product < ApplicationRecord
  has_many :pictures, as: :imageable
end
```
Можно считать полиморфное объявление `belongs_to` как настройку интерфейса, которую может использовать любая другая модель. Из экземпляра модели `Employee` можно получить коллекцию изображений:` @employee.pictures`.

Подобным образом можно получить `@product.pictures`.

Если имеется экземпляр модели `Picture`, можно получить его родителя посредством `@picture.imageable`. Чтобы это работало, необходимо объявить столбец внешнего ключа и столбец типа в модели, объявляющей полиморфный интерфейс:
```
class CreatePictures < ActiveRecord::Migration[5.2]
  def change
    create_table :pictures do |t|
      t.string  :name
      t.bigint  :imageable_id
      t.string  :imageable_type
      t.timestamps
    end

    add_index :pictures, [:imageable_type, :imageable_id]
  end
end
```
Эта миграция может быть упрощена при использовании формы `t.references`:
```
class CreatePictures < ActiveRecord::Migration[5.0]
  def change
    create_table :pictures do |t|
      t.string :name
      t.references :imageable, polymorphic: true
      t.timestamps
    end
  end
end
```
#### Присоединение к себе
При разработке модели данных иногда находится модель, которая может иметь отношение сама к себе. Например, мы хотим хранить всех работников в одной модели базы данных, но нам нужно отслеживать отношения начальник-подчиненный. Эта ситуация может быть смоделирована с помощью связей, присоединяемых к себе:
```
class Employee < ApplicationRecord
  has_many :subordinates, class_name: "Employee",
                          foreign_key: "manager_id"

  belongs_to :manager, class_name: "Employee", optional: true
end
```
С такой настройкой, вы можете получить `@employee.subordinates` и `@employee.manager`.

В миграциях/схеме следует добавить столбец ссылки модели на саму себя.
```
class CreateEmployees < ActiveRecord::Migration[5.0]
  def change
    create_table :employees do |t|
      t.references :manager
      t.timestamps
    end
  end
end
```

### Полезные советы и предупреждения <a name="2.5.3"></a>
Вот некоторые вещи, которые необходимо знать для эффективного использования связей Active Record в вашем приложении на Rails:
* Управление кэшированием
* Предотвращение коллизий имен
* Обновление схемы
* Управление областью видимости связей
* Двусторонние связи 

#### Управление кэшированием
Все методы связи построены вокруг кэширования, которое хранит результаты последних запросов доступными для будущих операций. Кэш является общим для разных методов. Например:
```
author.books                 # получаем книги из базы данных
author.books.size            # используем кэшированную копию книг
author.books.empty?          # используем кэшированную копию книг
```
Но что если вы хотите перезагрузить кэш, так как данные могли быть изменены другой частью приложения? Всего лишь вызовите `reload` на связи:
```
author.books                 # получаем книги из базы данных
author.books.size            # используем кэшированную копию книг
author.books.reload.empty?   # отказываемся от кэшированной копии книг
                             # и снова обращаемся к базе данных
```
#### Предотвращение коллизий имен
Вы не свободны в выборе любого имени для своих связей. Поскольку создание связи добавляет метод с таким именем в модель, будет плохой идеей дать связи имя, уже используемое как метод экземпляра `ActiveRecord::Base`. Метод связи тогда переопределит базовый метод, и что-нибудь перестанет работать. Например, `attributes` или `connection` плохие имена для связей.

#### Обновление схемы
Связи очень полезные, но не волшебные. Вы ответственны за содержание вашей схемы базы данных в соответствии со связями. На практике это означает две вещи, в зависимости от того, какой тип связей создаете. Для связей `belongs_to` нужно создать внешние ключи, а для связей `has_and_belongs_to_many` нужно создать подходящую соединительную таблицу.

##### Создание внешних ключей для связей `belongs_to`
Когда объявляете связь `belongs_to`, нужно создать внешние ключи, при необходимости. Например, рассмотрим эту модель:
```
class Book < ApplicationRecord
  belongs_to :author
end
```
Это объявление нуждается в поддержке соответствующим столбцом внешнего ключа в таблице `books`. Для совершенно новой таблицы миграция может выглядеть примерно так:
```
class CreateBooks < ActiveRecord::Migration[5.0]
  def change
    create_table :books do |t|
      t.datetime   :published_at
      t.string     :book_number
      t.references :author
    end
  end
end
```
В то время как для существующей таблицы, это может выглядеть следующим образом:
```
class AddAuthorToBooks < ActiveRecord::Migration[5.0]
  def change
    add_reference :books, :author
  end
end
```
Если необходимо принудительно использовать ссылочную целостность на уровне базы данных, добавьте опцию `foreign_key: true` в вышеприведенное объявление 'reference' столбца

##### Создание соединительных таблиц для связей `has_and_belongs_to_many`
Если вы создали связь `has_and_belongs_to_many`, необходимо обязательно создать соединительную таблицу. Если имя соединительной таблицы явно не указано с использованием опции `:join_table`, `Active Record` создает имя, используя алфавитный порядок имен классов. Поэтому соединение между моделями author и book по умолчанию даст значение имени таблицы "authors_books", так как "a" идет перед "b" в алфавитном порядке.

> Приоритет между именами модели рассчитывается с использованием оператора `<=>` для `String`. Это означает, что если строки имеют разную длину и в своей короткой части они равны, тогда более длинная строка рассматривается как с более высоким лексическим приоритетом, по сравнению с короткой. Например, кто-то ожидает, что таблицы "paper_boxes" и "papers" создадут соединительную таблицу "papers_paper_boxes" поскольку имя "paper_boxes" длиннее, но фактически будет сгенерирована таблица с именем "paper_boxes_papers" (поскольку знак подчеркивания "`_`" лексикографически меньше, чем "s" в обычной кодировке).

Какое бы ни было имя, вы должны вручную сгенерировать соединительную таблицу в соответствующей миграции. Например, рассмотрим эти связи:
```
class Assembly < ApplicationRecord
  has_and_belongs_to_many :parts
end

class Part < ApplicationRecord
  has_and_belongs_to_many :assemblies
end
```
Теперь нужно написать миграцию для создания таблицы `assemblies_parts`. Эта таблица должна быть создана без первичного ключа:
```
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.2]
  def change
    create_table :assemblies_parts, id: false do |t|
      t.bigint :assembly_id
      t.bigint :part_id
    end

    add_index :assemblies_parts, :assembly_id
    add_index :assemblies_parts, :part_id
  end
end
```
Мы передаем `id: false в create_table`, так как эта таблица не представляет модель. Это необходимо, чтобы связь работала правильно. Если вы видите странное поведение в связи `has_and_belongs_to_many`, например, искаженные ID моделей, или исключения в связи с конфликтом ID, скорее всего вы забыли убрать первичный ключ.

Также можно использовать метод `create_join_table`
```
class CreateAssembliesPartsJoinTable < ActiveRecord::Migration[5.0]
  def change
    create_join_table :assemblies, :parts do |t|
      t.index :assembly_id
      t.index :part_id
    end
  end
end
```
#### Управление областью видимости связей
По умолчанию связи ищут объекты только в пределах области видимости текущего модуля. Это важно, когда вы объявляете модели Active Record внутри модуля. Например:
```
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end

    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```
Это будет работать, так как оба класса `Supplier` и `Account` определены в пределах одной области видимости. Но нижеследующее не будет работать, потому что `Supplier` и `Account` определены в разных областях видимости:
```
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier
    end
  end
end
```
Для связи модели с моделью в другом пространстве имен, необходимо указать полное имя класса в объявлении связи:
```
module MyApplication
  module Business
    class Supplier < ApplicationRecord
      has_one :account,
        class_name: "MyApplication::Billing::Account"
    end
  end

  module Billing
    class Account < ApplicationRecord
      belongs_to :supplier,
        class_name: "MyApplication::Business::Supplier"
    end
  end
end
```
#### Двусторонние связи
Для связей нормально работать в двух направлениях, затребовав объявление в двух различных моделях:
```
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
end
```
Active Record попытается автоматически определить, что эти две модели образуют двунаправленную связь, основываясь на имени связи. Таким образом, Active Record загрузит только одну копию объекта `Author`, делая ваше приложение более эффективным и предотвращая несогласованные данные:
```
a = Author.first
b = a.books.first
a.first_name == b.author.first_name # => true
a.first_name = 'David'
a.first_name == b.author.first_name # => true
```
Active Record **поддерживает автоматическое определение для большинства связей** со стандартными именами. Однако, Active Record **не будет автоматически определять двунаправленные связи**, содержащие область видимости или любые из следующих опций:
* `:through`
* `:foreign_key` 

Например, рассмотрим следующие объявления моделей:
```
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```
Active Record больше не будет автоматически распознавать двунаправленную связь:
```
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => false
```
Active Record представляет опцию `:inverse_of`, таким образом можно явно объявить двунаправленные связи:
```
class Author < ApplicationRecord
  has_many :books, inverse_of: 'writer'
end

class Book < ApplicationRecord
  belongs_to :writer, class_name: 'Author', foreign_key: 'author_id'
end
```
Включив опцию `:inverse_of` в объявлении связи `has_many`, Active Record будет распознавать двунаправленную связь:
```
a = Author.first
b = a.books.first
a.first_name == b.writer.first_name # => true
a.first_name = 'David'
a.first_name == b.writer.first_name # => true
```
### Подробная информация по связи `belongs_to` <a name="2.5.4"></a>
Связь `belongs_to` создает соответствие один-к-одному с другой моделью. В терминах базы данных эта связь сообщает, что этот класс содержит внешний ключ. Если внешний ключ содержит другой класс, вместо этого следует использовать `has_one`.
#### Методы, добавляемые `belongs_to`
Когда объявляете связь `belongs_to`, объявляющий класс автоматически получает 6 методов, относящихся к связи:
* `association`
* `association=(associate)`
* `build_association(attributes = {})`
* `create_association(attributes = {})`
* `create_association!(attributes = {})`
* `reload_association` 
Во всех четырех методах association заменяется символом, переданным как первый аргумент в `belongs_to`. Например, имеем объявление:
```
class Book < ApplicationRecord
  belongs_to :author
end
```
Каждый экземпляр модели `Book` будет иметь эти методы:
* `author`
* `author=`
* `build_author`
* `create_author`
* `create_author!`
* `reload_author`
> Когда устанавливаете новую связь `has_one` или `belongs_to`, следует использовать префикс `build_` для построения связи, в отличие от метода `association.build`, используемый для связей `has_many или has_and_belongs_to_many`. Чтобы создать связь, используйте префикс `create_`.
##### `association`
Метод `association` возвращает связанный объект, если он есть. Если объекта нет, возвращает `nil`.
```
@author = @book.author
```
Если связанный объект уже был получен из базы данных для этого объекта, возвращается кэшированная версия. Чтобы переопределить это поведение (и заставить прочитать из базы данных), вызовите `#reload_association` на родительском объекте.
```
@author = @book.reload_author
```
##### `association=(associate)`

Метод `association=` привязывает связанный объект к этому объекту. Фактически это означает извлечение первичного ключа из связанного объекта и присвоение его значения внешнему ключу.
```
@book.author = @author
```
##### `build_association(attributes = {})`

Метод `build_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, будет установлена связь с внешним ключом этого объекта, но связанный объект пока не будет сохранен.
```
@author = @book.build_author(author_number: 123,
                                  author_name: "John Doe")
```
##### `create_association(attributes = {})`

Метод `create_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, будет установлена связь с внешним ключом этого объекта, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен.
```
@author = @book.create_author(author_number: 123, author_name: "John Doe")
```
##### `create_association!(attributes = {})`

Работает так же, как и вышеприведенный `create_association`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

#### Опции для `belongs_to`
Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `belongs_to`. Такая настройка легко выполнима с помощью передачи опций и блоков со скоупом при создании связи. Например, эта связь использует две такие опции:
```
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at,
    counter_cache: true
end
```
Связь `belongs_to` поддерживает эти опции:
* `:autosave`
* `:class_name`
* `:counter_cache`
* `:dependent`
* `:foreign_key`
* `:primary_key`
* `:inverse_of`
* `:polymorphic`
* `:touch`
* `:validate`
* `:optional` 

##### `:autosave`
Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave в false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosave` отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.
##### `:class_name`
Если имя другой модели не может быть получено из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если книга принадлежит автору, но фактическое имя модели, содержащей авторов, `Patron`, можете установить это следующим образом:
```
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron"
end
```
##### `:counter_cache`
Опция `:counter_cache` может быть использована, чтобы сделать поиск количества принадлежащих объектов более эффективным. Рассмотрим эти модели:
```
class Book < ApplicationRecord
  belongs_to :author
end
class Author < ApplicationRecord
  has_many :books
end
```
С этими объявлениями запрос значения `@author.books.size` требует обращения к базе данных для выполнения запроса `COUNT(*)`. Чтобы этого избежать, можете добавить кэш счетчика в принадлежащую модель:
```
class Book < ApplicationRecord
  belongs_to :author, counter_cache: true
end
class Author < ApplicationRecord
  has_many :books
end
```
С этим объявлением, Rails будет хранить в кэше актуальное значение и затем возвращать это значение в отклик на метод `size`.

Хотя опция `:counter_cache` определяется в модели, включающей определение `belongs_to`, фактический столбец должен быть добавлен в связанную (`has_many`) модель. В вышеописанном случае, необходимо добавить столбец, названный `books_count` в модель `Author`.

Имя столбца по умолчанию можно переопределить, указав произвольное имя столбца в объявлении `counter_cache` вместо `true`. Например, для использования `count_of_books` вместо `books_count`:
```
class Book < ApplicationRecord
  belongs_to :author, counter_cache: :count_of_books
end
class Author < ApplicationRecord
  has_many :books
end
```
> Опцию `:counter_cache` необходимо указывать только на стороне `belongs_to` связи. Столбцы кэша счетчика добавляются в список атрибутов модели только для чтения посредством `attr_readonly`.

##### `:dependent`

Если установить опцию `:dependent` в:
* `:destroy`, когда объект будет уничтожен, `destroy` будет вызван на его связанных объектах.
* `:delete`, когда объект будет уничтожен, все его связанные объекты будут удалены прямо из базы данных без вызова метода `destroy`. 

> Не следует определять эту опцию в связи `belongs_to`, которая соединена со связью `has_many` в другом классе. Это приведет к "битым" связям в записях вашей базы данных.

##### `:foreign_key`

По соглашению Rails предполагает, что столбец, используемый для хранения внешнего ключа в этой модели, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class Book < ApplicationRecord
  belongs_to :author, class_name: "Patron", foreign_key: "patron_id"
end
```
> В любом случае, Rails не создаст столбцы внешнего ключа за вас. Вам необходимо явно определить их в своих миграциях.

##### `:primary_key`

По соглашению Rails предполагает, что для первичного ключа используется столбец `id` в таблице. Опция `:primary_key` позволяет указать иной столбец.

Например, имеется таблица `users` с `guid` в качестве первичного ключа. Если мы хотим отдельную таблицу `todos`, содержащую внешний ключ `user_id` из столбца `guid`, для этого можно использовать `primary_key` следующим образом:
```
class User < ApplicationRecord
  self.primary_key = 'guid' # primary key is guid and not id
end

class Todo < ApplicationRecord
  belongs_to :user, primary_key: 'guid'
end
```
При выполнении `@user.todos.create`, у записи `@todo` будет значение `user_id` таким же, как значение `guid` у `@user`.

##### `:inverse_of`

Опция `:inverse_of` определяет имя связи `has_many` или `has_one`, являющейся противоположностью для этой связи.
```
class Author < ApplicationRecord
  has_many :books, inverse_of: :author # книга имеет автора book.author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books # автор имеет книги author.books
end
```
##### `:polymorphic`

Передача `true` для опции `:polymorphic` показывает, что это полиморфная связь.

##### `:touch`

Если установите опцию `:touch` в `true`, то временные метки `updated_at` или `updated_on` на связанном объекте будут установлены в текущее время всякий раз, когда этот объект будет сохранен или уничтожен:
```
class Book < ApplicationRecord
  belongs_to :author, touch: true
end

class Author < ApplicationRecord
  has_many :books
end
```
В этом случае, сохранение или уничтожение книги обновит временную метку на связанном авторе. **Также можно определить конкретный атрибут** временной метки для обновления:
```
class Book < ApplicationRecord
  belongs_to :author, touch: :books_updated_at
end
```
##### `:validate`

Если установите опцию `:validate` в `true`, тогда связанные объекты будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `false`: связанные объекты не проходят валидацию, когда этот объект сохраняется.

##### `:optional`

Если установить `:optional` в `true`, тогда наличие связанных объектов не будет валидироваться. По умолчанию установлено в `false`.

#### Скоупы для `belongs_to`
Иногда хочется настроить запрос, используемый `belongs_to`. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `includes`
* `readonly`
* `select` 

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Book < ApplicationRecord
  belongs_to :author, -> { where active: true }
end
```
##### `includes`

Метод `includes` можно использовать для определения связей второго порядка, которые должны быть лениво загружены при использовании этой связи. Например, рассмотрим эти модели:
```
class Chapter < ApplicationRecord
  belongs_to :book
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```
Если вы часто получаете авторов непосредственно из глав (`@chapter.book.author`), то можно улучшить эффективность кода, включив авторов в связь между книгой и ее главами:
```
class Chapter < ApplicationRecord
  belongs_to :book, -> { includes :author }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Author < ApplicationRecord
  has_many :books
end
```
> Нет необходимости в использовании `includes` для ближайших связей - то есть, если есть `Book belongs_to :author`, то `author` автоматически лениво загружается при необходимости.

##### `readonly`

При использовании `readonly`, связанный объект будет только для чтения при получении через связь.

##### `select`

Метод `select` позволяет переопределить SQL выражение SELECT, используемое для получения данных о связанном объекте. **По умолчанию Rails получает все столбцы**.

> При использовании метода `select` на связи `belongs_to`, следует также установить опцию `:foreign_key` для гарантии правильных результатов.

#### Существуют ли связанные объекты?

Можно увидеть, существует ли какой-либо связанный объект, при использовании метода `association.nil?`:
```
if @book.author.nil?
  @msg = "No author found for this book"
end
```
#### Когда сохраняются объекты?

Присвоение связи `belongs_to` не приводит к автоматическому сохранению ни самого объекта, ни связанного объекта.

### Подробная информация по связи `has_one` <a name="2.5.5"></a>
Связь `has_one` создает соответствие один-к-одному с другой моделью. В терминах базы данных эта связь сообщает, что другой класс содержит внешний ключ. Если этот класс содержит внешний ключ, следует использовать `belongs_to`.

#### Методы, добавляемые `has_one`
Когда объявляете связь `has_one`, объявляющий класс автоматически получает 6 методов, относящихся к связи:
* `association`
* `association=(associate)`
* `build_association(attributes = {})`
* `create_association(attributes = {})`
* `create_association!(attributes = {})`
* `reload_association`

> При установлении новой связи `has_one` или `belongs_to`, следует использовать префикс `build_` для построения связи, в отличие от метода `association.build`, используемого для связей `has_many` или `has_and_belongs_to_many`. Чтобы создать связь, используйте префикс `create_`.

##### `association`
Метод `association` возвращает связанный объект, если таковой имеется. Если связанный объект не найден, возвращает `nil`.
```
@account = @supplier.account
```
Если связанный объект уже был получен из базы данных для этого объекта, возвращается кэшированная версия. Чтобы переопределить это поведение (и заставить прочитать из базы данных), вызовите `#reload_association` на родительском объекте.
```
@account = @supplier.reload_account
```
##### `association=(associate)`

Метод `association=` привязывает связанный объект к этому объекту. Фактически это означает извлечение первичного ключа этого объекта и присвоение его значения внешнему ключу связанного объекта.
```
@supplier.account = @account
```

##### `build_association(attributes = {})`

Метод `build_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, и будет установлена связь через внешний ключ, но связанный объект пока не будет сохранен.
```
@account = @supplier.build_account(terms: "Net 30")
```

##### `create_association(attributes = {})`

Метод `create_association` возвращает новый объект связанного типа. Этот объект будет экземпляром с переданными атрибутами, будет установлена связь через внешний ключ, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен
```
@account = @supplier.create_account(terms: "Net 30")
```

##### `create_association!(attributes = {})`

Работает так же, как и вышеприведенный `create_association`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

#### Опции для `has_one`
Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `has_one`. Такая настройка легко выполнима с помощью передачи опции при создании связи. Например, эта связь использует две такие опции:
```
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing", dependent: :nullify
end
```
Связь has_one поддерживает эти опции:
* `:as`
* `:autosave`
* `:class_name`
* `:dependent`
* `:foreign_key`
* `:inverse_of`
* `:primary_key`
* `:source`
* `:source_type`
* `:through`
* `:touch`
* `:validate`

##### `:as`
Установка опции `:as` показывает, что это полиморфная связь.

##### `:autosave`

Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave` в `false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosave` отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.

##### `:class_name`

Если имя другой модели не может быть образовано из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если поставщик имеет аккаунт, но фактическое имя модели, содержащей аккаунты, это `Billing`, можете установить это следующим образом:
```
class Supplier < ApplicationRecord
  has_one :account, class_name: "Billing"
end
```

##### `:dependent`

Управляет тем, что произойдет со связанным объектом, когда его владелец будет уничтожен:
* `:destroy` приведет к тому, что связанный объект также будет уничтожен
* `:delete` приведет к тому, что связанный объект будет удален из базы данных напрямую (таким образом не будут выполнены колбэки)
* `:nullify` приведет к тому, что внешний ключ будет установлен NULL. Столбцы полиморфного типа на полиморфных связях также обнуляются. Колбэки не выполняются.
* `:restrict_with_exception` приведет к вызову исключения `ActiveRecord::DeleteRestrictionError`, если есть связанный объект
* `:restrict_with_error` приведет к ошибке, добавляемой к владельцу, если есть связанный объект 

Нельзя устанавливать или оставлять опцию `:nullify` для связей, имеющих ограничение NOT NULL. Если не установить `dependent` для уничтожения таких связей, вы не сможете изменить связанный объект, так как внешнему ключу изначально связанного объекта будет назначено недопустимое значение NULL.

##### `:foreign_key`

По соглашению Rails предполагает, что столбец, используемый для хранения внешнего ключа в этой модели, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class Supplier < ApplicationRecord
  has_one :account, foreign_key: "supp_id"
end
```
> В любом случае, Rails не создаст столбцы внешнего ключа за вас. Вам необходимо явно определить их в своих миграциях.

##### `:inverse_of`

Опция `:inverse_of` определяет имя связи `belongs_to`, являющейся обратной для этой связи.
```
class Supplier < ApplicationRecord
  has_one :account, inverse_of: :supplier
end

class Account < ApplicationRecord
  belongs_to :supplier, inverse_of: :account
end
```

##### `:primary_key`

По соглашению, Rails предполагает, что столбец, используемый для хранения первичного ключа, это `id`. Вы можете переопределить это и явно определить первичный ключ с помощью опции `:primary_key`

##### `:source`

Опция `:source` определяет имя источника связи для связи `has_one :through`

##### `:source_type`

Опция `:source_type` определяет тип источника связи для связи `has_one :through`, который действует при полиморфной связи.
```
class Book < ApplicationRecord
  has_one :format, polymorphic: true
  has_one :dust_jacket, through: :format, source: :dust_jacket, source_type: "Hardback"
end

class Paperback < ApplicationRecord; end

class Hardback < ApplicationRecord
  has_one :dust_jacket
end

class DustJacket < ApplicationRecord; end
```

##### `:through`

Опция `:through` определяет соединительную модель, через которую выполняется запрос. 

##### `:touch`

Если опция `:touch` установлена `true`, тогда временные метки `updated_at` или `updated_on` у связанного объекта будут установлены в текущее время всякий раз, когда этот объект будет сохранен или уничтожен:
```
class Supplier < ApplicationRecord
  has_one :account, touch: true
end

class Account < ApplicationRecord
  belongs_to :supplier
end
```
В этом случае, сохранение или удаление поставщика обновит временную метку у связанного счета. Также можно указать конкретный атрибут временной метки для обновления:
```
class Supplier < ApplicationRecord
  has_one :account, touch: :suppliers_updated_at
end
```

##### `:validate`

Если установите опцию `:validate` в `true`, тогда связанные объекты будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `false`: связанные объекты не проходят валидацию, когда этот объект сохраняется.

#### Скоупы для `has_one`
Иногда хочется настроить запрос, используемый `has_one`. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Supplier < ApplicationRecord
  has_one :account, -> { where active: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `includes`
* `readonly`
* `select`

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Supplier < ApplicationRecord
  has_one :account, -> { where "confirmed = 1" }
end
```

##### `includes`

Метод `includes` позволяет определить связи второго порядка, которые должны быть лениво загружены при использовании этой связи. Например, рассмотрим эти модели:
```
class Supplier < ApplicationRecord
  has_one :account
end

class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end

class Representative < ApplicationRecord
  has_many :accounts
end
```
Если вы часто получаете `representatives` непосредственно из `suppliers` (`@supplier.account.representative`), то можно улучшить эффективность кода, включив `representatives` в связь между `suppliers` и `accounts`:
```
class Supplier < ApplicationRecord
  has_one :account, -> { includes :representative }
end

class Account < ApplicationRecord
  belongs_to :supplier
  belongs_to :representative
end

class Representative < ApplicationRecord
  has_many :accounts
end
```
##### `readonly`

При использовании `readonly`, связанный объект будет только для чтения при получении через связь

##### `select`

Метод `select` позволяет переопределить SQL выражение SELECT, используемое для получения данных о связанном объекте. По умолчанию Rails получает все столбцы.

#### Существуют ли связанные объекты?
Можно увидеть, существует ли какой-либо связанный объект, при использовании метода `association.nil?`:
```
if @supplier.account.nil?
  @msg = "No account found for this supplier"
end
```

#### Когда сохраняются объекты?

Когда вы назначаете объект связью `has_one`, этот объект автоматически сохраняется (для того, чтобы обновить его внешний ключ). Кроме того, любой заменяемый объект также автоматически сохраняется, поскольку его внешний ключ также изменяется.

Если одно из этих сохранений проваливается из-за ошибок валидации, тогда выражение назначения возвращает `false`, и само назначение отменяется.

Если родительский объект (который объявляет связь `has_one`) является несохраненным (то есть `new_record?` возвращает `true`), тогда дочерние объекты не сохраняются. Они сохранятся автоматически, когда сохранится родительский объект.

Если вы хотите назначить объект связью has_one без сохранения объекта, используйте метод `build_association`.

### Подробная информация по связи `has_many` <a name="2.5.6"></a>
Связь `has_many` создает отношение один-ко-многим с другой моделью. В терминах базы данных эта связь говорит, что другой класс будет иметь внешний ключ, относящийся к экземплярам этого класса.

#### Методы, добавляемые `has_many`
Когда объявляете связь `has_many`, объявляющий класс автоматически получает 17 методов, относящихся к связи:
* `collection`
* `collection<<(object, ...)`
* `collection.delete(object, ...)`
* `collection.destroy(object, ...)`
* `collection=(objects)`
* `collection_singular_ids`
* `collection_singular_ids=(ids)`
* `collection.clear`
* `collection.empty?`
* `collection.size`
* `collection.find(...)`
* `collection.where(...)`
* `collection.exists?(...)`
* `collection.build(attributes = {}, ...)`
* `collection.create(attributes = {})`
* `collection.create!(attributes = {})`
* `collection.reload` 
Во всех этих методах `collection` заменяется символом, переданным как первый аргумент в `has_many`, и `collection_singular` заменяется версией в единственном числе этого символа. Например, имеем объявление:
```
class Author < ApplicationRecord
  has_many :books
end
```
Каждый экземпляр модели `Author` будет иметь эти методы:
* `books`
* `books<<(object, ...)`
* `books.delete(object, ...)`
* `books.destroy(object, ...)`
* `books=(objects)`
* `book_ids`
* `book_ids=(ids)`
* `books.clear`
* `books.empty?`
* `books.size`
* `books.find(...)`
* `books.where(...)`
* `books.exists?(...)`
* `books.build(attributes = {}, ...)`
* `books.create(attributes = {})`
* `books.create!(attributes = {})`
* `books.reload`

##### `collection`

Метод `collection` возвращает Relation всех связанных объектов. Если нет связанных объектов, он возвращает пустой Relation.
```
@books = @author.books
```

##### `collection<<(object, ...)`

Метод `collection<<` добавляет один или более объектов в коллекцию, устанавливая их внешние ключи равными первичному ключу вызывающей модели.
```
@author.books << @book1
```
##### `collection.delete(object, ...)`

Метод `collection.delete` убирает один или более объектов из коллекции, установив их внешние ключи в NULL.
```
@author.books.delete(@book1)
```
> Объекты будут в дополнение уничтожены, если связаны с `dependent: :destroy`, и удалены, если они связаны с `dependent: :delete_all`.

##### `collection.destroy(object, ...)`

Метод `collection.destroy` убирает один или более объектов из коллекции, выполняя `destroy` для каждого объекта.
```
@author.books.destroy(@book1)
```
> Объекты будут всегда удаляться из базы данных, игнорируя опцию `:dependent`.

##### `collection=(objects)`

Метод `collection=` делает коллекцию содержащей только представленные объекты, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных

##### `collection_singular_ids`

Метод `collection_singular_ids` возвращает массив `id` объектов в коллекции.
```
@book_ids = @author.book_ids
```

##### `collection_singular_ids=(ids)`

Метод `collection_singular_ids=` делает коллекцию содержащей только объекты, идентифицированные представленными значениями первичного ключа, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных.

##### `collection.clear`

Метод `collection.clear` убирает каждый объект из коллекции в соответствии со стратегией, определенной опцией `dependent`. Если опция не указана, он следует стратегии по умолчанию. Стратегия по умолчанию для `has_many :through` это `delete_all`, а для связей `has_many` — установить их внешние ключи в NULL.
```
@author.books.clear
```
Объекты будут удалены, если они связаны с помощью `dependent: :destroy`, как и с помощью `dependent: :delete_all`.

##### `collection.empty?`

Метод `collection.empty?` возвращает `true`, если коллекция не содержит каких-либо связанных объектов.
```
<% if @author.books.empty? %>
  No Books Found
<% end %>
```

##### `collection.size`

Метод `collection.size` возвращает количество объектов в коллекции.
```
@book_count = @author.books.size
```

##### `collection.find(...)`

Метод `collection.find` ищет объекты в коллекции. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.find`.
```
@available_book = @author.books.find(1)
```

##### `collection.where(...)`

Метод `collection.where` ищет объекты в коллекции, основываясь на переданных условиях, но объекты загружаются лениво, что означает, что база данных запрашивается только когда происходит доступ к объекту(-там).
```
@available_books = @author.books.where(available: true) # Пока нет запроса
@available_book = @available_books.first # Теперь база данных будет запрошена
```

##### `collection.exists?(...)`

Метод `collection.exists?` проверяет, существует ли в коллекции объект, отвечающий представленным условиям. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.exists?`.

##### `collection.build(attributes = {}, ...)`

Метод `collection.build` возвращает один или массив объектов связанного типа. Объект(ы) будут экземплярами с переданными атрибутами, будет создана ссылка через их внешние ключи, но связанные объекты не будут пока сохранены.
```
@book = @author.books.build(published_at: Time.now,
                                book_number: "A12345")

@books = @author.books.build([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }])
```

##### `collection.create(attributes = {})`

Метод `collection.create` возвращает один или массив новых объектов связанного типа. Объект(ы) будут экземплярами с переданными атрибутами, будет создана ссылка через его внешний ключ, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен
```
@book = @author.books.create(published_at: Time.now,
                                 book_number: "A12345")

@books = @author.books.create([
  { published_at: Time.now, book_number: "A12346" },
  { published_at: Time.now, book_number: "A12347" }])
```

##### `collection.create!(attributes = {})`

Работает так же, как вышеприведенный `collection.create`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

##### `collection.reload`

Метод `collection.reload` возвращает Relation всех связанных объектов, принудительно читая базу данных. Если нет связанных объектов, он возвращает пустой Relation.
```
@books = @author.books.reload
```

#### Опции для `has_many`

Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `has_many`. Такая настройка легко выполнима с помощью передачи опций при создании связи. Например, эта связь использует две такие опции:
```
class Author < ApplicationRecord
  has_many :books, dependent: :delete_all, validate: false
end
```
Связь `has_many` поддерживает эти опции:
* `:as`
* `:autosave`
* `:class_name`
* `:counter_cache`
* `:dependent`
* `:foreign_key`
* `:inverse_of`
* `:primary_key`
* `:source`
* `:source_type`
* `:through`
* `:validate` 

##### `:as`

Установка опции `:as` показывает, что это полиморфная связь. 

##### `:autosave`

Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave` в `false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosav`e отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.

##### `:class_name`

Если имя другой модели не может быть произведено из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если автор имеет много книг, но фактическое имя модели, содержащей книги, это `Transaction`, можете установить это следующим образом:
```
class Author < ApplicationRecord
  has_many :books, class_name: "Transaction"
end
```

##### `:counter_cache`

Эта опция используется для настройки произвольно названного `:counter_cache`. Эту опцию нужно использовать, только если вы изменили имя вашего `:counter_cache` у связи `belongs_to`.

##### `:dependent`

Управляет тем, что произойдет со связанными объектами, когда его владелец будет уничтожен:
* `:destroy` приведет к тому, что связанные объекты также будут уничтожены
* `:delete_all` приведет к тому, что связанные объекты будут удалены из базы данных напрямую (таким образом не будут выполнены колбэки)
* `:nullify` приведет к тому, что внешние ключи будет установлен NULL. Столбцы полиморфного типа на полиморфных связях также обнуляются. Колбэки не выполняются.
* `:restrict_with_exception` приведет к вызову исключения `ActiveRecord::DeleteRestrictionError`, если есть какой-нибудь связанный объект
* `:restrict_with_error` приведет к ошибке, добавляемой к владельцу, если есть какой-нибудь связанный объект 

> Опции `:destroy` и `:delete_all` также влияют на семантику методов `collection.delete` и `collection=`, вынуждая их удалять связанные объекты при удалении из коллекции.

##### `:foreign_key`

По соглашению Rails предполагает, что столбец, используемый для хранения внешнего ключа в этой модели, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class Author < ActiveRecord::Base
  has_many :books, foreign_key: "cust_id"
end
```
##### `:inverse_of`

Опция `:inverse_of` определяет имя связи `belongs_to`, являющейся обратной для этой связи.
```
class Author < ApplicationRecord
  has_many :books, inverse_of: :author
end

class Book < ApplicationRecord
  belongs_to :author, inverse_of: :books
end
```

##### `:primary_key`

По соглашению, Rails предполагает, что столбец, используемый для хранения первичного ключа, это `id`. Вы можете переопределить это и явно определить первичный ключ с помощью опции `:primary_key`.

Допустим, в таблице `users` есть `id` в качестве `primary_key`, но также имеется столбец `guid`. Имеется требование, что таблица `todos` должна содержать значение столбца `guid`, а не значение `id`. Это достигается следующим образом:
```
class User < ApplicationRecord
  has_many :todos, primary_key: :guid
end
```
Теперь, если выполнить `@todo = @user.todos.create`, то в запись `@todo` значение `user_id` будет таким же, как значение `guid` в `@user`.

##### `:source`

Опция `:source` определяет имя источника связи для связи `has_many :through`. Эту опцию нужно использовать, только если имя источника связи не может быть автоматически выведено из имени связи.
```
class Author < ApplicationRecord
  has_many :books
  has_many :paperbacks, through: :books, source: :format, source_type: "Paperback"
end

class Book < ApplicationRecord
  has_one :format, polymorphic: true
end

class Hardback < ApplicationRecord; end
class Paperback < ApplicationRecord; end
```

##### `:source_type`

Опция `:source_type` определяет тип источника связи для связи `has_many :through`, который действует при полиморфной связи

##### `:through`

Опция `:through` определяет соединительную модель, через которую выполняется запрос. Связи `has_many :through` предоставляют способ осуществления отношений многие-ко-многим

##### `:validate`

Если установите опцию `:validate` в `false`, тогда связанные объекты не будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `true`: связанные объекты проходят валидацию, когда этот объект сохраняется.

#### Скоупы для `has_many`

Иногда хочется настроить запрос, используемый has_many. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Author < ApplicationRecord
  has_many :books, -> { where processed: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `extending`
* `group`
* `includes`
* `limit`
* `offset`
* `order`
* `readonly`
* `select`
* `distinct` 

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Author < ApplicationRecord
  has_many :confirmed_books, -> { where "confirmed = 1" },
    class_name: "Book"
end

Также можно задать условия хэшем:

class Author < ApplicationRecord
  has_many :confirmed_books, -> { where confirmed: true },
                              class_name: "Book"
end
```
> При использовании опции `where` хэшем, при создании записи через эту связь будет автоматически применен скоуп с использованием хэша. В этом случае при использовании` @author.confirmed_books.create` или `@author.confirmed_books.build` будут созданы книги, в которых столбец `confirmed` будет иметь значение `true`.

##### `extending`

Метод `extending` определяет именованный модуль для расширения прокси связи.

##### `group`

Метод `group` предоставляет имя атрибута, по которому группируется результирующий набор, используя выражение GROUP BY в поисковом SQL.
```
class Author < ApplicationRecord
  has_many :chapters, -> { group 'books.id' },
                      through: :books
end
```

##### `includes`

Можете использовать метод `includes` для определения связей второго порядка, которые должны быть нетерпеливо загружены, когда эта связь используется. Например, рассмотрим эти модели:
```
class Author < ApplicationRecord
  has_many :books
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Chapter < ApplicationRecord
  belongs_to :book
end
```
Если вы часто получаете главы прямо из авторов (`@author.books.chapters`), тогда можете сделать свой код более эффективным, включив главы в связь от авторов к книгам:
```
class Author < ApplicationRecord
  has_many :books, -> { includes :chapters }
end

class Book < ApplicationRecord
  belongs_to :author
  has_many :chapters
end

class Chapter < ApplicationRecord
  belongs_to :book
end
```
##### `limit`

Метод `limit` позволяет ограничить общее количество объектов, которые будут выбраны через связь.
```
class Author < ApplicationRecord
  has_many :recent_books,
    -> { order('published_at desc').limit(100) },
    class_name: "Book"
end
```

##### `offset`

Метод `offset` позволяет определить начальное смещение для выбора объектов через связь. Например, -> { offset(11) } пропустит первые 11 записей.

##### `order`

Метод `order` предписывает порядок, в котором связанные объекты будут получены (в синтаксисе SQL, используемом в условии ORDER BY).
```
class Author < ApplicationRecord
  has_many :books, -> { order "date_confirmed DESC" }
end
```

##### `readonly`

При использовании метода `readonly`, связанные объекты будут доступны только для чтения, когда получены посредством связи.

##### `select`

Метод `select` позволяет переопределить SQL условие SELECT, которое используется для получения данных о связанном объекте. По умолчанию Rails получает все столбцы.

> Если укажете свой собственный select, не забудьте включить столбцы первичного ключа и внешнего ключа в связанной модели. Если так не сделать, Rails выдаст ошибку.

##### `distinct`

Используйте метод `distinct`, чтобы убирать дубликаты из коллекции. Это полезно в сочетании с опцией `:through`.
```
class Person < ApplicationRecord
  has_many :readings
  has_many :articles, through: :readings
end

article   = Article.create(name: 'a1')
person.articles << article
person.articles << article
person.articles.inspect # => [#<Article id: 5, name: "a1">, #<Article id: 5, name: "a1">]
Reading.all.inspect     # => [#<Reading id: 12, person_id: 5, article_id: 5>, #<Reading id: 13, person_id: 5, article_id: 5>]
```
В вышеописанной задаче два `reading`, и `person.articles` выявляет их оба, даже если эти записи указывают на одну и ту же статью.

Давайте установим `distinct`:
```
class Person
  has_many :readings
  has_many :articles, -> { distinct }, through: :readings
end

person = Person.create(name: 'Honda')
article   = Article.create(name: 'a1')
person.articles << article
person.articles << article
person.articles.inspect # => [#<Article id: 7, name: "a1">]
Reading.all.inspect     # => [#<Reading id: 16, person_id: 7, article_id: 7>, #<Reading id: 17, person_id: 7, article_id: 7>]
```
В вышеописанной задаче все еще два `reading`. Однако `person.articles` показывает только одну статью, поскольку коллекция загружает только уникальные записи.

Если вы хотите быть уверенными, что **после вставки все записи персистентной связи различны** (и, таким образом, убедиться, что при просмотре связи никогда не будет дублирующихся записей), следует добавить уникальный индекс для самой таблицы. Например, если таблица называется `readings`, и вы хотите убедиться, что все публикации могут быть добавлены к персоне один раз, следует добавить в миграцию:
```
add_index :readings, [:person_id, :article_id], unique: true
```
Как только у вас появится этот индекс уникальности, попытка добавить статью к персоне дважды вызовет ошибку `ActiveRecord::RecordNotUnique`:
```
person = Person.create(name: 'Honda')
article = Article.create(name: 'a1')
person.articles << article
person.articles << article # => ActiveRecord::RecordNotUnique
```
Отметьте, что проверка уникальности при использовании чего-то, наподобие `include?`, подвержено состояниям гонки. Не пытайтесь использовать `include?` для соблюдения уникальности в связи. Используя вышеприведенный пример со статьёй, нижеследующий код вызовет гонку, поскольку несколько пользователей могут использовать его одновременно:
```
person.articles << article unless person.articles.include?(post)
```
#### Когда сохраняются объекты? 
Когда вы назначаете объект связью `has_many`, этот объект автоматически сохраняется (для того, чтобы обновить его внешний ключ). Если назначаете несколько объектов в одном выражении, они все будут сохранены.

Если одно из этих сохранений проваливается из-за ошибок валидации, тогда выражение назначения возвращает `false`, и само назначение отменяется.

Если родительский объект (который объявляет связь `has_many`) является несохраненным (то есть `new_record?` возвращает `true`), тогда дочерние объекты не сохраняются при добавлении. Все несохраненные члены связи сохранятся автоматически, когда сохранится родительский объект.

Если вы хотите назначить объект связью `has_many` без сохранения объекта, используйте метод `collection.build`.

### Подробная информация по связи `has_and_belongs_to_many` <a name="2.5.7"></a>
Связь `has_and_belongs_to_many` создает отношение многие-ко-многим с другой моделью. В терминах базы данных это связывает два класса через промежуточную соединительную таблицу, которая включает внешние ключи, относящиеся к каждому классу.

#### Методы, добавляемые `has_and_belongs_to_many`

Когда объявляете связь `has_and_belongs_to_many`, объявляющий класс автоматически получает 17 методов, относящихся к связи:
* `collection`
* `collection<<(object, ...)`
* `collection.delete(object, ...)`
* `collection.destroy(object, ...)`
* `collection=(objects)`
* `collection_singular_ids`
* `collection_singular_ids=(ids)`
* `collection.clear`
* `collection.empty?`
* `collection.size`
* `collection.find(...)`
* `collection.where(...)`
* `collection.exists?(...)`
* `collection.build(attributes = {})`
* `collection.create(attributes = {})`
* `collection.create!(attributes = {})`
* `collection.reload `
Во всех этих методах collection заменяется символом, переданным как первый аргумент в has_and_belongs_to_many, а collection_singular заменяется версией в единственном числе этого символа.

##### Дополнительные методы столбцов

Если соединительная таблица для связи `has_and_belongs_to_many` имеет дополнительные столбцы, кроме двух внешних ключей, эти столбцы будут добавлены как атрибуты к записям, получаемым посредством связи. Записи, возвращаемые с дополнительными атрибутами, будут всегда только для чтения, поскольку Rails не может сохранить значения этих атрибутов.

> Использование дополнительных атрибутов в соединительной таблице в связи `has_and_belongs_to_many` **устарело**. Если требуется этот тип сложного поведения таблицы, соединяющей две модели в отношениях многие-ко-многим, следует использовать связь `has_many :through` вместо `has_and_belongs_to_many`.

##### `collection`

Метод `collection` возвращает Relation всех связанных объектов. Если нет связанных объектов, он возвращает пустой Relation.
```
@assemblies = @part.assemblies
```

##### `collection<<(object, ...)`

Метод `collection<<` добавляет один или более объектов в коллекцию, создавая записи в соединительной таблице.
```
@part.assemblies << @assembly1
```
> Этот метод - просто псевдоним к `collection.concat` и `collection.push`.

##### `collection.delete(object, ...)`

Метод `collection.delete` убирает один или более объектов из коллекции, удаляя записи в соединительной таблице. Это не уничтожает объекты.
```
@part.assemblies.delete(@assembly1)
```

##### `collection.destroy(object, ...)`

Метод `collection.destroy` убирает один или более объектов из коллекции, удаляя записи в соединительной таблице. Это не уничтожает объекты.
```
@part.assemblies.destroy(@assembly1)
```

##### `collection=(objects)`

Метод `collection=` делает коллекцию содержащей только представленные объекты, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных.

##### `collection_singular_ids`

Метод `collection_singular_ids` возвращает массив `id` объектов в коллекции.
```
@assembly_ids = @part.assembly_ids
```

##### `collection_singular_ids=(ids)`

Метод `collection_singular_ids=` делает коллекцию содержащей только объекты, идентифицированные представленными значениями первичного ключа, добавляя и удаляя по мере необходимости. Изменения будут персистентными в базе данных.

##### `collection.clear`

Метод `collection.clear` убирает каждый объект из коллекции, удаляя строки из соединительной таблицы. Это не уничтожает связанные объекты.

##### `collection.empty?`

Метод `collection.empty?` возвращает `true`, если коллекция не содержит каких-либо связанных объектов.
```
<% if @part.assemblies.empty? %>
  This part is not used in any assemblies
<% end %>
```

##### `collection.size`

Метод `collection.size` возвращает количество объектов в коллекции.
```
@assembly_count = @part.assemblies.size
```

##### `collection.find(...)`

Метод `collection.find` ищет объекты в коллекции. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.find`. А также добавляет дополнительное условие, что объект должен быть в коллекции.
```
@assembly = @part.assemblies.find(1)
```

##### `collection.where(...)`

Метод `collection.where` ищет объекты в коллекции, основываясь на переданных условиях, но объекты загружаются лениво, что означает, что база данных запрашивается только когда происходит доступ к объекту(-там).
```
@new_assemblies = @part.assemblies.where("created_at > ?", 2.days.ago)
```

##### `collection.exists?(...)`

Метод `collection.exists?` проверяет, существует ли в коллекции объект, отвечающий представленным условиям. Он использует тот же синтаксис и опции, что и `ActiveRecord::Base.exists?`.

##### `collection.build(attributes = {})`

Метод `collection.build` возвращает один или более объектов связанного типа. Эти объекты будут экземплярами с переданными атрибутами, и будет создана связь через соединительную таблицу, но связанный объект пока не будет сохранен.
```
@assembly = @part.assemblies.build({assembly_name: "Transmission housing"})
```

##### `collection.create(attributes = {})`

Метод `collection.create` возвращает один или более объектов связанного типа. Эти объекты будут экземплярами с переданными атрибутами, будет создана связь через соединительную таблицу, и, если он пройдет валидации, определенные в связанной модели, связанный объект будет сохранен.
```
@assembly = @part.assemblies.create({assembly_name: "Transmission housing"})
```

##### `collection.create!(attributes = {})`

Работает так же, как вышеприведенный `collection.create`, но вызывает `ActiveRecord::RecordInvalid`, если запись невалидна.

##### `collection.reload`

Метод `collection.reload` возвращает Relation всех связанных объектов, принудительно читая базу данных. Если нет связанных объектов, он возвращает пустой Relation.
```
@assemblies = @part.assemblies.reload
```

#### Опции для `has_and_belongs_to_many`

Хотя Rails использует разумные значения по умолчанию, работающие во многих ситуациях, бывают случаи, когда хочется изменить поведение связи `has_and_belongs_to_many`. Такая настройка легко выполнима с помощью передачи опции при создании связи. Например, эта связь использует две такие опции:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { readonly },
                                       autosave: true
end
```
Связь `has_and_belongs_to_many` поддерживает эти опции:
* `:association_foreign_key`
* `:autosave`
* `:class_name`
* `:foreign_key`
* `:join_table`
* `:validate`

##### `:association_foreign_key`

По соглашению Rails предполагает, что столбец в соединительной таблице, используемый для хранения внешнего ключа, указываемого на другую модель, является именем этой модели с добавленным суффиксом `_id`. Опция `:association_foreign_key` позволяет установить имя внешнего ключа явно:

> Опции `:foreign_key` и `:association_foreign_key` полезны при настройке присоединения к себе многие-ко-многим. Например:

```
class User < ApplicationRecord
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id", # типа твой айди
      association_foreign_key: "other_user_id" # типа айди друга
end
```

##### `:autosave`

Если установить опцию `:autosave` в `true`, Rails сохранит любые загруженные связанные члены и уничтожит члены, помеченные для уничтожения, всякий раз, когда сохраняется родительский объект. Но установить `:autosave` в `false` - не то же самое, что не устанавливать опцию `:autosave`. Если опция `:autosave` отсутствует, то новые связанные объекты будут сохранены, но обновленные связанные объекты сохранены не будут.

##### `:class_name`

Если имя другой модели не может быть произведено из имени связи, можете использовать опцию `:class_name` для предоставления имени модели. Например, если часть имеет много сборок, но фактическое имя модели, содержащей сборки - это `Gadget`, можете установить это следующим образом:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, class_name: "Gadget"
end
```

##### `:foreign_key`

По соглашению Rails предполагает, что столбец в соединительной таблице, используемый для хранения внешнего ключа, указываемого на эту модель, имеет имя модели с добавленным суффиксом `_id`. Опция `:foreign_key` позволяет установить имя внешнего ключа явно:
```
class User < ApplicationRecord
  has_and_belongs_to_many :friends,
      class_name: "User",
      foreign_key: "this_user_id",
      association_foreign_key: "other_user_id"
end
```

##### `:join_table`

Если имя соединительной таблицы по умолчанию, основанное на алфавитном порядке, - это не то, что вам нужно, используйте опцию `:join_table`, чтобы переопределить его.

##### `:validate`

Если установите опцию `:validate` в `false`, тогда связанные объекты не будут проходить валидацию всякий раз, когда вы сохраняете этот объект. По умолчанию она равна `true:` связанные объекты проходят валидацию, когда этот объект сохраняется.

#### Скоупы для `has_and_belongs_to_many`

Иногда хочется настроить запрос, используемый `has_many`. Такая настройка может быть достигнута с помощью блока скоупа. Например:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { where active: true }
end
```
Внутри блока скоупа можно использовать любые стандартные методы запросов. Далее обсудим следующие из них:
* `where`
* `extending`
* `group`
* `includes`
* `limit`
* `offset`
* `order`
* `readonly`
* `select`
* `distinct`

##### `where`

Метод `where` позволяет определить условия, которым должен отвечать связанный объект.
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { where "factory = 'Seattle'" }
end
```
Также можно задать условия хэшем:
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { where factory: 'Seattle' }
end
```
При использовании опции `where` хэшем, при создание записи через эту связь будет автоматически применен скоуп с использованием хэша. В этом случае при использовании `@parts.assemblies.create` или `@parts.assemblies.build` будут созданы заказы, в которых столбец `factory` будет иметь значение `Seattle`.

##### `extending`

Метод `extending` определяет именованный модуль для расширения прокси связи. 

##### `group`

Метод `group` предоставляет имя атрибута, по которому группируется результирующий набор, используя выражение GROUP BY в поисковом запросе SQL.
```
class Parts < ApplicationRecord
  has_and_belongs_to_many :assemblies, -> { group "factory" }
end
```

##### `includes`

Можете использовать метод `includes` для определения связей второго порядка, которые должны быть нетерпеливо загружены, когда эта связь используется.

##### `limit`

Метод `limit` позволяет ограничить общее количество объектов, которые будут выбраны через связь.
```
class Customer < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { order("created_at DESC").limit(50) }
end
```

##### `offset`

Метод `offset` позволяет определить начальное смещение для выбора объектов через связь. Например, `-> { offset(11) }` пропустит первые 11 записей.

##### `order`

Метод `order` предписывает порядок, в котором связанные объекты будут получены (в синтаксисе SQL, используемом в условии ORDER BY).
```
class Customer < ApplicationRecord
  has_and_belongs_to_many :assemblies,
    -> { order "assembly_name ASC" }
end
```

##### `readonly`

При использовании метода `:readonly`, связанные объекты будут доступны только для чтения, когда получены посредством связи

##### `select`

Метод `select` позволяет переопределить SQL условие SELECT, которое используется для получения данных о связанном объекте. По умолчанию Rails получает все столбцы.

##### `distinct`

Используйте метод `distinct`, чтобы убирать дубликаты из коллекции.

#### Когда сохраняются объекты?

Когда вы назначаете объект связью `has_and_belongs_to_many`, этот объект автоматически сохраняется (в порядке обновления соединительной таблицы). Если назначаете несколько объектов в одном выражении, они все будут сохранены.

Если одно из этих сохранений проваливается из-за ошибок валидации, тогда выражение назначения возвращает `false`, a само назначение отменяется.

Если родительский объект (который объявляет связь has_and_belongs_to_many) является несохраненным (то есть `new_record?` возвращает `true`), тогда дочерние объекты не сохраняются при добавлении. Все несохраненные члены связи сохранятся автоматически, когда сохранится родительский объект.

Если вы хотите назначить объект связью `has_and_belongs_to_many` без сохранения объекта, используйте метод `collection.build`.

### Подробная информация по колбэкам и расширениям связи <a name="2.5.8"></a>
Обычно колбэки прицепляются к жизненному циклу объектов Active Record, позволяя вам работать с этими объектами в различных точках. Например, можете использовать колбэк `:before_save`, чтобы вызвать что-то перед тем, как объект будет сохранен.

Колбэки связи похожи на обычные колбэки, но они включаются событиями в жизненном цикле коллекции. Доступны четыре колбэка связи:
* `before_add`
* `after_add`
* `before_remove`
* `after_remove`

Колбэки связи объявляются с помощью добавления опций в объявление связи. Например:
```
class Author < ApplicationRecord
  has_many :books, before_add: :check_credit_limit

  def check_credit_limit(book)
    ...
  end
end
```
Rails передает добавляемый или удаляемый объект в колбэк.

Можете помещать колбэки в очередь на отдельное событие, передав их как массив:
```
class Author < ApplicationRecord
  has_many :books,
    before_add: [:check_credit_limit, :calculate_shipping_charges]

  def check_credit_limit(book)
    ...
  end

  def calculate_shipping_charges(book)
    ...
  end
end
```
Если колбэк `before_add` вызывает исключение, объект не будет добавлен в коллекцию. Подобным образом, если колбэк `before_remove` вызывает исключение, объект не убирается из коллекции.

Эти колбэки вызываются только когда связанные объекты добавляются или убираются через коллекцию связи:
```
# Вызывает колбэк `before_add`
author.books << book
author.books = [book, book2]

# Не вызывает колбэк `before_add`
book.update(author_id: 1)
```

#### Расширения связи
Вы не ограничены функциональностью, которую Rails автоматически встраивает в выданные по связи объекты. Можно расширить эти объекты с помощью анонимных модулей, добавив новые методы поиска, методы создания и иные методы. Например:
```
class Author < ApplicationRecord
  has_many :books do
    def find_by_book_prefix(book_number)
      find_by(category_id: book_number[0..2])
    end
  end
end
```
Если имеется расширение, которое должно быть общим для нескольких связей, можно использовать именованный модуль расширения. Например:
```
module FindRecentExtension
  def find_recent
    where("created_at > ?", 5.days.ago)
  end
end

class Author < ApplicationRecord
  has_many :books, -> { extending FindRecentExtension }
end

class Supplier < ApplicationRecord
  has_many :deliveries, -> { extending FindRecentExtension }
end
```
Расширения могут ссылаться на внутренние методы выданных по связи объектов, используя следующие три атрибута акцессора `proxy_association`:
* `proxy_association.owner` возвращает объект, в котором объявлена связь.
* `proxy_association.reflection` возвращает объект reflection, описывающий связь.
* `proxy_association.target` возвращает связанный объект для `belongs_to` или `has_one`, или коллекцию связанных объектов для `has_many` или `has_and_belongs_to_many`.

### Наследование с единой таблицей (STI) <a name="2.5.9"></a>
Иногда можно делиться полями и поведением между различными моделями. Скажем, у нас есть модели `Car`, `Motorcycle` и `Bicycle`. Мы хотим совместно использовать поля `color` и `price` и некоторые методы всеми из них, но иметь некоторое специфичное поведение для каждого, а также различные контроллеры.

Rails позволяет сделать это достаточно просто. Сначала нужно сгенерировать базовую модель `Vehicle`:
```
$ rails generate model vehicle type:string color:string price:decimal{10.2}
```
Вы заметили, что мы добавили поле "type"? Так как все модели будут сохранены в одну таблицу базы данных, Rails сохранит в этот столбец имя модели, которая сохраняется. В нашем примере это может быть "Car", "Motorcycle" или "Bicycle." STI не работает без поля "type" в таблице.

Затем мы сгенерируем три модели, унаследованные от `Vehicle`. Для этого можно использовать опцию `--parent=PARENT`, которая сгенерирует модель, унаследованную от указанного родителя и без эквивалентной миграции (так как таблица уже существует).

Например, чтобы сгенерировать модель `Car`:
```
$ rails generate model car --parent=Vehicle
```
Сгенерированная модель будет выглядеть так:
```
class Car < Vehicle
end
```
Это означает, что все поведение, такое как связи, публичные методы и так далее, добавленное в `Vehicle`, доступно также для `Car`.

Создание автомобиля сохранит его в таблице `vehicles` со значением "Car" в поле `type`:
```
Car.create(color: 'Red', price: 10000)
```
сгенерирует следующий SQL:
```
INSERT INTO "vehicles" ("type", "color", "price") VALUES ('Car', 'Red', 10000)
```
Запрос записей автомобилей будет просто искать среди транспортных средств, которые являются автомобилями:
```
Car.all
```
запустит подобный запрос:
```
SELECT "vehicles".* FROM "vehicles" WHERE "vehicles"."type" IN ('Car')
```

## Интерфейс запрососв <a name="2.6"></a>
Если вы использовали чистый SQL для поиска записей в базе данных, то скорее всего обнаружите, что в Rails есть лучшие способы выполнения тех же операций. Active Record ограждает вас от необходимости использования SQL во многих случаях.

Примеры кода далее в этом руководстве будут относиться к некоторым из этих моделей:

Все модели используют `id` как первичный ключ, если не указано иное.
```
class Client < ApplicationRecord
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end

class Address < ApplicationRecord
  belongs_to :client
end

class Order < ApplicationRecord
  belongs_to :client, counter_cache: true
end

class Role < ApplicationRecord
  has_and_belongs_to_many :clients
end
```
Active Record выполнит запросы в базу данных за вас, он совместим с большинством СУБД, включая MySQL, MariaDB, PostgreSQL и SQLite. Независимо от того, какая используется СУБД, формат методов Active Record будет всегда одинаковый.

### Получение объектов из базы данных <a name="2.6.1"></a>
Для получения объектов из базы данных Active Record предоставляет несколько методов поиска. В каждый метод поиска можно передавать аргументы для выполнения определенных запросов в базу данных без необходимости писать на чистом SQL.

Методы следующие:
* `find`
* `create_with`
* `distinct`
* `eager_load`
* `extending`
* `from`
* `group`
* `having`
* `includes`
* `joins`
* `left_outer_joins`
* `limit`
* `lock`
* `none`
* `offset`
* `order`
* `preload`
* `readonly`
* `references`
* `reorder`
* `reverse_order`
* `select`
* `where `

Методы поиска, возвращающие коллекцию, такие как where и group, возвращают экземпляр `ActiveRecord::Relation`. Методы, ищущие отдельную сущность, такие как `find` и `first`, возвращают отдельный экземпляр модели.

Вкратце основные операции `Model.find(options)` таковы:
* Преобразовать предоставленные опции в эквивалентный запрос SQL.
* Выполнить запрос SQL и получить соответствующие результаты из базы данных.
* Создать экземпляр эквивалентного объекта Ruby подходящей модели для каждой строки результата запроса.
* Запустить колбэки `after_find` и далее `after_initialize`, если таковые имеются. 

#### Получение одиночного объекта
##### `find`
Используя метод `find`, можно получить объект, соответствующий определенному первичному ключу (`primary key`) и предоставленным опциям. Например:
```
# Ищет клиента с первичным ключом (id) 10.
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
```
Метод `find` вызывает исключение `ActiveRecord::RecordNotFound`, если соответствующей записи не было найдено.

Этот метод также можно использовать для получения нескольких объектов. Вызовите метод find и передайте в него массив первичных ключей. Возвращенным результатом будет массив, содержащий все записи, соответствующие представленным первичным ключам. Например:
```
# Найдем клиентов с первичными ключами 1 и 10.
clients = Client.find([1, 10]) # Или даже Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients WHERE (clients.id IN (1,10))
```
##### `take`
Метод `take` получает запись без какого-либо явного упорядочивания. Например:
```
client = Client.take
# => #<Client id: 1, first_name: "Lifo">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients LIMIT 1
```
Метод `take` возвращает `nil`, если ни одной записи не найдено, и исключение не будет вызвано.

В метод take можно передать числовой аргумент, чтобы вернуть это количество результатов. Например
```
clients = Client.take(2)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 220, first_name: "Sara">
# ]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients LIMIT 2
```
Метод `take!` ведет себя подобно `take`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи.

> Получаемая запись может отличаться в зависимости от подсистемы хранения СУБД.

##### `first`

Метод `first` находит первую запись, упорядоченную по первичному ключу (по умолчанию). Например:
```
client = Client.first
# => #<Client id: 1, first_name: "Lifo">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
```
Метод `first` возвращает `nil`, если не найдено соответствующей записи, и исключение не вызывается.

Если скоуп по умолчанию содержит метод `order`, `first` возвратит первую запись в соответствии с этим упорядочиванием.

В метод `first` можно передать числовой аргумент, чтобы вернуть это количество результатов. Например
```
clients = Client.first(3)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 2, first_name: "Fifo">,
#   #<Client id: 3, first_name: "Filo">
# ]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3
```
На коллекции, упорядоченной с помощью `order`, `first` вернет первую запись, упорядоченную по указанному в order атрибуту.
```
client = Client.order(:first_name).first
# => #<Client id: 2, first_name: "Fifo">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.first_name ASC LIMIT 1
```
Метод `first!` ведет себя подобно `first`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи.

##### `last`

Метод `last` находит последнюю запись, упорядоченную по первичному ключу (по умолчанию). Например:
```
client = Client.last
# => #<Client id: 221, first_name: "Russel">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
```
Метод `last` возвращает `nil`, если не найдено соответствующей записи, и исключение не вызывается.

Если скоуп по умолчанию содержит метод `order`, `last` возвратит последнюю запись в соответствии с этим упорядочиванием.

В метод `last` можно передать числовой аргумент, чтобы вернуть это количество результатов. Например
```
clients = Client.last(3)
# => [
#   #<Client id: 219, first_name: "James">,
#   #<Client id: 220, first_name: "Sara">,
#   #<Client id: 221, first_name: "Russel">
# ]
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3
```
На коллекции, упорядоченной с помощью `order`, `last` вернет последнюю запись, упорядоченную по указанному в `order` атрибуту.
```
client = Client.order(:first_name).last
# => #<Client id: 220, first_name: "Sara">
```
SQL эквивалент этого такой:
```
SELECT * FROM clients ORDER BY clients.first_name DESC LIMIT 1
```
Метод `last!` ведет себя подобно `last`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи.

##### `find_by`

Метод `find_by` ищет первую запись, соответствующую некоторым условиям. Например:
```
Client.find_by first_name: 'Lifo'
# => #<Client id: 1, first_name: "Lifo">

Client.find_by first_name: 'Jon'
# => nil
```
Это эквивалент записи:
```
Client.where(first_name: 'Lifo').take
```
SQL эквивалент выражения выше, следующий:
```
SELECT * FROM clients WHERE (clients.first_name = 'Lifo') LIMIT 1
```
Метод `find_by!` ведет себя подобно `find_by`, за исключением того, что он вызовет `ActiveRecord::RecordNotFound`, если не найдено ни одной соответствующей записи. Например:
```
Client.find_by! first_name: 'does not exist'
# => ActiveRecord::RecordNotFound
```
Это эквивалент записи:
```
Client.where(first_name: 'does not exist').take!
```

#### Получение нескольких объектов пакетами

Часто необходимо перебрать огромный набор записей, например, когда рассылаем письма всем пользователям или импортируем некоторые данные.

Это может показаться простым:
```
# Это может потребить слишком много памяти, если таблица большая.
User.all.each do |user|
  NewsMailer.weekly(user).deliver_now
end
```
Но этот подход становится очень непрактичным с увеличением размера таблицы, поскольку `User.all.each` говорит Active Record извлечь таблицу полностью за один проход, создать объект модели для каждой строки и держать этот массив в памяти. В реальности, если имеется огромное количество записей, полная коллекция может превысить количество доступной памяти.

Rails предоставляет два метода, которые решают эту проблему путем разделения записей на дружелюбные к памяти пакеты для обработки. Первый метод, `find_each`, получает пакет записей и затем вкладывает каждую запись в блок отдельно как модель. Второй метод, `find_in_batches`, получает пакет записей и затем вкладывает весь пакет в блок как массив моделей.

> Методы `find_each` и `find_in_batches` предназначены для пакетной обработки большого числа записей, которые не поместятся в памяти за раз. Если нужно просто перебрать тысячу записей, более предпочтителен вариант обычных методов поиска.

##### `find_each`

Метод `find_each` получает пакет записей и затем передает каждую запись в блок. В следующем примере `find_each` получает пользователей пакетами по 1000 записей, а затем передает их в блок один за другим:
```
User.find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
```
Этот процесс повторяется, извлекая больше пакетов при необходимости, пока не будут обработаны все записи.

`find_each` работает на классах модели, как показано выше, а также на relation:
```
User.where(weekly_subscriber: true).find_each do |user|
  NewsMailer.weekly(user).deliver_now
end
```
только у них нет упорядочивания, так как методу необходимо собственное упорядочивание для работы.

Если у получателя есть упорядочивание, то поведение зависит от флажка `config.active_record.error_on_ignored_order`. Если `true`, вызывается `ArgumentError`, в противном случае упорядочивание игнорируется, что является поведением по умолчанию. Это можно переопределить с помощью опции `:error_on_ignore`, описанной ниже.

#### Опции для `find_each`

##### `:batch_size`

Опция `:batch_size` позволяет определить число записей, подлежащих получению в одном пакете, до передачи отдельной записи в блок. Например, для получения 5000 записей в пакете:
```
User.find_each(batch_size: 5000) do |user|
  NewsMailer.weekly(user).deliver_now
end
```
##### `:start`

По умолчанию записи извлекаются в порядке увеличения первичного ключа, который должен быть числом. Опция `:start` позволяет вам настроить первый ID последовательности, когда наименьший ID не тот, что вам нужен. Это может быть полезно, например, если хотите возобновить прерванный процесс пакетирования, предоставив последний обработанный ID как контрольную точку.

Например, чтобы выслать письма только пользователям с первичным ключом, начинающимся от 2000:
```
User.find_each(start: 2000) do |user|
  NewsMailer.weekly(user).deliver_now
end
```
##### `:finish`

Подобно опции `:start`, `:finish` позволяет указать последний ID последовательности, когда наибольший ID не тот, что вам нужен. Это может быть полезно, например, если хотите запустить процесс пакетирования, используя подмножество записей на основании `:start` и `:finish`

Например, чтобы выслать письма только пользователям с первичным ключом от 2000 до 10000:
```
User.find_each(start: 2000, finish: 10000) do |user|
  NewsMailer.weekly(user).deliver_now
end
```
Другим примером является наличие нескольких воркеров, работающих с одной и той же очередью обработки. Можно было бы обрабатывать каждым воркером 10000 записей, установив подходящие опции `:start` и `:finish` в каждом воркере.

##### `:error_on_ignore`

Переопределяет настройку приложения, указывающую, должна ли быть вызвана ошибка, если в relation присутствует упорядочивание.


#### `find_in_batches`

Метод `find_in_batches` похож на `find_each` тем, что они оба получают пакеты записей. Различие в том, что `find_in_batches` передает в блок пакеты как массив моделей, вместо отдельной модели. Следующий пример передаст в представленный блок массив из 1000 счетов за раз, а в последний блок содержащий все оставшиеся счета:
```
# Передает в add_invoices массив из 1000 счетов за раз.
Invoice.find_in_batches do |invoices|
  export.add_invoices(invoices)
end
```
`find_in_batches` работает на классах модели, как показано выше, а также на relation:
```
Invoice.pending.find_in_batches do |invoices|
  pending_invoices_export.add_invoices(invoices)
end
```
только у них нет упорядочивания, так как методу необходимо собственное упорядочивание для работы.

#### Опции для `find_in_batches`

Метод `find_in_batches` принимает те же опции, что и `find_each`.

### `Условия`<a name="2.6.2"></a>

Метод `where` позволяет определить условия для ограничения возвращаемых записей, которые представляют `WHERE`-часть выражения SQL. Условия могут быть заданы как строка, массив или хэш.

#### Чисто строковые условия

Если вы хотите добавить условия в свой поиск, можете просто определить их там, подобно `Client.where("orders_count = '2'")`. Это найдет всех клиентов, где значение поля `orders_count` равно 2.

> Создание условий в чистой строке подвергает вас риску SQL-инъекций. Например, `Client.where("first_name LIKE '%#{params[:first_name]}%'")` не безопасно.

#### Условия с использованием массива

Что если количество может изменяться, скажем, как аргумент откуда-то извне, возможно даже от пользователя? Поиск тогда принимает такую форму:
```
Client.where("orders_count = ?", params[:orders])
```
Active Record примет первый аргумент в качестве строки условия, а все остальные элементы подставит вместо знаков вопроса `(?)` в ней.

Если хотите определить несколько условий:
```
Client.where("orders_count = ? AND locked = ?", params[:orders], false)
```
В этом примере первый знак вопроса будет заменен на значение в `params[:orders]` и второй будет заменен SQL аналогом `false`, который зависит от адаптера.

Этот код значительно предпочтительнее:
```
Client.where("orders_count = ?", params[:orders])
```
чем такой код:
```
Client.where("orders_count = #{params[:orders]}")
```
по причине безопасности аргумента. Помещение переменной прямо в строку условий передает переменную в базу данных как есть. Это означает, что неэкранированная переменная, переданная пользователем, может иметь злой умысел. Если так сделать, вы подвергаете базу данных риску, так как если пользователь обнаружит, что он может использовать вашу базу данных, то он сможет сделать с ней что угодно. Никогда не помещайте аргументы прямо в строку условий!

##### Местозаполнители в условиях

Подобно тому, как `(?)` заменяют параметры, можно использовать ключи в условиях совместно с соответствующим хэшем ключей/значений:
```
Client.where("created_at >= :start_date AND created_at <= :end_date",
  {start_date: params[:start_date], end_date: params[:end_date]})
```
Читаемость улучшится, в случае если вы используете большое количество переменных в условиях.

#### Условия с использованием хэша

Active Record также позволяет передавать условия в хэше, что улучшает читаемость синтаксиса условий. В этом случае передается хэш с ключами, соответствующими полям, которые хотите уточнить, и с значениями, которые вы хотите к ним применить:

> Хэшем можно передать условия проверки только равенства, интервала и подмножества.


#### Условия с использованием хэша

Active Record также позволяет передавать условия в хэше, что улучшает читаемость синтаксиса условий. В этом случае передается хэш с ключами, соответствующими полям, которые хотите уточнить, и с значениями, которые вы хотите к ним применить:

Хэшем можно передать условия проверки только равенства, интервала и подмножества.

##### Условия равенства
```
Client.where(locked: true)
```
Это сгенерирует такой SQL:
```
SELECT * FROM clients WHERE (clients.locked = 1)
```
Имя поля также может быть строкой, а не символом:
```
Client.where('locked' => true)
```
В случае отношений `belongs_to`, может быть использован ключ связи для указания модели, если как значение используется объект Active Record. Этот метод также работает с полиморфными отношениями.
```
Article.where(author: author)
Author.joins(:articles).where(articles: { author: author })
```
##### Интервальные условия
```
Client.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
```
Это найдет всех клиентов, созданных вчера, с использованием SQL выражения `BETWEEN`:
```
SELECT * FROM clients WHERE (clients.created_at BETWEEN '2008-12-21 00:00:00' AND '2008-12-22 00:00:00')
```
Это была демонстрация более короткого синтаксиса для примеров в Условия с использованием массива

##### Условия подмножества

Если хотите найти записи, используя выражение `IN`, можете передать массив в хэш условий:
```
Client.where(orders_count: [1,3,5])
```
Этот код сгенерирует подобный SQL:
```
SELECT * FROM clients WHERE (clients.orders_count IN (1,3,5))
```

#### Условия `NOT`

Запросы `NOT` в SQL могут быть созданы с помощью `where.not`:
```
Client.where.not(locked: true)
```
Другими словами, этот запрос может быть сгенерирован с помощью вызова where без аргументов и далее присоединенным `not` с переданными условиями для `where`. Это сгенерирует такой SQL:
```
SELECT * FROM clients WHERE (clients.locked != 1)
```

#### Условия `OR`

Условия `OR` между двумя отношениями могут быть построены путем вызова or на первом отношении и передачи второго в качестве аргумента.
```
Client.where(locked: true).or(Client.where(orders_count: [1,3,5]))
```
```
SELECT * FROM clients WHERE (clients.locked = 1 OR clients.orders_count IN (1,3,5))
```

### `Сортировка` <a name="2.6.3"></a>

Чтобы получить записи из базы данных в определенном порядке, можете использовать метод `order`.

Например, если вы получаете ряд записей и хотите упорядочить их в порядке возрастания поля `created_at` в таблице:
```
Client.order(:created_at)
# ИЛИ
Client.order("created_at")
```
Также можете определить `ASC` или `DESC`:
```
Client.order(created_at: :desc)
# ИЛИ
Client.order(created_at: :asc)
# ИЛИ
Client.order("created_at DESC")
# ИЛИ
Client.order("created_at ASC")
```
Или сортировку по нескольким полям:
```
Client.order(orders_count: :asc, created_at: :desc)
# ИЛИ
Client.order(:orders_count, created_at: :desc)
# ИЛИ
Client.order("orders_count ASC, created_at DESC")
# ИЛИ
Client.order("orders_count ASC", "created_at DESC")
```
**Если хотите вызвать `order` несколько раз, последующие сортировки будут добавлены к первой**:
```
Client.order("orders_count ASC").order("created_at DESC")
# SELECT * FROM clients ORDER BY orders_count ASC, created_at DESC
```
> Если используется MySQL 5.7.5 и выше, то при выборе полей из результирующей выборки с помощью методов, таких как `select`, `pluck` и `ids`; метод `order` вызовет исключение `ActiveRecord::StatementInvalid`, если поля, используемые в выражении `order`, не включены в список выбора.

### Выбор определенных полей <a name="2.6.4"></a>

По умолчанию `Model.find` выбирает все множество полей результата, используя `select *`.

Чтобы выбрать подмножество полей из всего множества, можете определить его, используя метод `select`.

Например, чтобы выбрать только столбцы `viewable_by` и `locked`:
```
Client.select("viewable_by, locked")
```
Используемый для этого запрос SQL будет иметь подобный вид:
```
SELECT viewable_by, locked FROM clients
```
Будьте осторожны, поскольку это также означает, что будет инициализирован объект модели только с теми полями, которые вы выбрали. Если вы попытаетесь обратиться к полям, которых нет в инициализированной записи, то получите:
```
ActiveModel::MissingAttributeError: missing attribute: <attribute>
```
Где <attribute> это атрибут, который был запрошен. Метод `id` не вызывает `ActiveRecord::MissingAttributeError`, поэтому будьте аккуратны при работе со связями, так как они нуждаются в методе `id` для правильной работы.

Если хотите вытащить только по одной записи для каждого уникального значения в определенном поле, можно использовать `distinct`:
```
Client.select(:name).distinct
```
Это сгенерирует такой SQL:
```
SELECT DISTINCT name FROM clients
```
Также можно убрать ограничение уникальности:
```
query = Client.select(:name).distinct
# => Возвратит уникальные имена

query.distinct(false)
# => Возвратит все имена, даже если есть дубликаты
```
### Ограничение и смещение <a name="2.6.5"></a>
Чтобы применить `LIMIT` к SQL, запущенному с помощью `Model.find`, нужно определить LIMIT, используя методы `limit` и `offset` на relation.

Используйте `limit` для определения количества записей, которые будут получены, и `offset` - для числа записей, которые будут пропущены до начала возврата записей. Например:
```
Client.limit(5)
```
возвратит максимум 5 клиентов, и, поскольку не определено смещение, будут возвращены первые 5 клиентов в таблице. Выполняемый SQL будет выглядеть подобным образом:
```
SELECT * FROM clients LIMIT 5
```
Добавление `offset` к этому
```
Client.limit(5).offset(30)
```
Возвратит максимум 5 клиентов, начиная с 31-го. SQL выглядит так:
```
SELECT * FROM clients LIMIT 5 OFFSET 30
```

### Группировка <a name="2.6.6"></a>
Чтобы применить условие `GROUP BY` к SQL, можно использовать метод `group`.

Например, если хотите найти коллекцию дат, в которые были созданы заказы:
```
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)")
```
Это выдаст вам отдельный объект `Order` на каждую дату, для которой были заказы в базе данных.

SQL, который будет выполнен, будет выглядеть так:
```
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
```

#### Общее количество сгруппированных элементов

Чтобы получить общее количество сгруппированных элементов одним запросом, вызовите `count` после `group`.
```
Order.group(:status).count
# => { 'awaiting_approval' => 7, 'paid' => 12 }
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT COUNT (*) AS count_all, status AS status
FROM "orders"
GROUP BY status
```
### `Having` <a name="2.6.7"></a>

SQL использует условие `HAVING` для определения условий для полей, указанных в `GROUP BY`. Условие `HAVING`, определенное в SQL, запускается в `Model.find` с использованием метода `having` для поиска.

Например:
```
Order.select("date(created_at) as ordered_date, sum(price) as total_price").group("date(created_at)").having("sum(price) > ?", 100)
```
SQL, который будет выполнен, выглядит так:
```
SELECT date(created_at) as ordered_date, sum(price) as total_price
FROM orders
GROUP BY date(created_at)
HAVING sum(price) > 100
```
Это возвращает дату и итоговую цену для каждого объекта заказа, сгруппированные по дню, когда они были заказаны, и где цена больше $100.

### Переопределяющие условия<a name="2.6.8"></a>
#### `unscope`

Можете указать определенные условия, которые будут убраны, используя метод `unscope`. Например:
```
Article.where('id > 10').limit(20).order('id asc').unscope(:order)
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE id > 10 LIMIT 20

# Оригинальный запрос без `unscope`
SELECT * FROM articles WHERE id > 10 ORDER BY id asc LIMIT 20
```

Также можно убрать определенные условия `where`. Например:
```
Article.where(id: 10, trashed: false).unscope(where: :id)
# SELECT "articles".* FROM "articles" WHERE trashed = 0
```
Relation, использующий unscope повлияет на любой relation, в который он слит:
```
Article.order('id asc').merge(Article.unscope(:order))
# SELECT "articles".* FROM "articles"
```

#### `only`

Также можно переопределить условия, используя метод `only`. Например:
```
Article.where('id > 10').limit(20).order('id desc').only(:order, :where)
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE id > 10 ORDER BY id DESC

# Оригинальный запрос без `only`
SELECT * FROM articles WHERE id > 10 ORDER BY id DESC LIMIT 20
```

#### `reorder`

Метод `reorder` переопределяет сортировку скоупа по умолчанию. Например:
```
class Article < ApplicationRecord
  ..
  ..
  has_many :comments, -> { order('posted_at DESC') }
end

Article.find(10).comments.reorder('name')
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY name
```
В случае, когда условие reorder не было использовано, выполненный SQL будет:
```
SELECT * FROM articles WHERE id = 10 LIMIT 1
SELECT * FROM comments WHERE article_id = 10 ORDER BY posted_at DESC
```

#### `reverse_order`

Метод `reverse_order` меняет направление условия сортировки, если оно определено:
```
Client.where("orders_count > 10").order(:name).reverse_order
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM clients WHERE orders_count > 10 ORDER BY name DESC
```
Если условие сортировки не было определено в запросе, `reverse_order` сортирует по первичному ключу в обратном порядке:
```
Client.where("orders_count > 10").reverse_order
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM clients WHERE orders_count > 10 ORDER BY clients.id DESC
```
Этот метод не принимает аргументы.

#### `rewhere`

Метод `rewhere` переопределяет существующее именованное условие `where`. Например:
```
Article.where(trashed: true).rewhere(trashed: false)
```
SQL, который будет выполнен, будет выглядеть так:
```
SELECT * FROM articles WHERE `trashed` = 0
```
В случае, когда не используется условие `rewhere`,
```
Article.where(trashed: true).where(trashed: false)
```
выполненный SQL будет следующий:
```
SELECT * FROM articles WHERE `trashed` = 1 AND `trashed` = 0
```

### Нулевой Relation <a name="2.6.9"></a>

Метод none возвращает сцепляемый `relation` без записей. Любые последующие условия, сцепленные с возвращенным `relation`, продолжат генерировать пустые `relation`. Это полезно в случаях, когда необходим сцепляемый отклик на метод или скоуп, который может вернуть пустые результаты.
```
Article.none # возвращает пустой Relation и не вызывает запросов.

# От метода visible_articles ожидается, что он вернет Relation.
@articles = current_user.visible_articles.where(name: params[:name])

def visible_articles
  case role
  when 'Country Manager'
    Article.where(country: country)
  when 'Reviewer'
    Article.published
  when 'Bad User'
    Article.none # => если бы вернули [] или nil, код поломался бы в этом случае
  end
end
```

### Объекты только для чтения <a name="2.6.10"></a>

Active Record предоставляет relation метод `readonly` для явного запрета на модификацию любого из возвращаемых объектов. Любая попытка изменить запись, доступную только для чтения, не удастся, вызвав исключение `ActiveRecord::ReadOnlyRecord`.
```
client = Client.readonly.first
client.visits += 1
client.save
```
Так как `client` явно указан как объект доступный только для чтения, выполнение вышеуказанного кода выдаст исключение `ActiveRecord::ReadOnlyRecord` при вызове `client.save` с обновленным значением `visits`.


### `Блокировка записей для обновления` <a name="2.6.11"></a>

Блокировка полезна для предотвращения состояния гонки при обновлении записей в базе данных и обеспечения атомарного обновления.

Active Record предоставляет два механизма блокировки:
* Оптимистическая блокировка
* Пессимистическая блокировка 

#### Оптимистическая блокировка

Оптимистическая блокировка позволяет нескольким пользователям обращаться к одной и той же записи для редактирования и предполагает минимум конфликтов с данными. Она осуществляет это с помощью проверки, внес ли другой процесс изменения в записи, с тех пор как она была открыта. Если это происходит, вызывается исключение `ActiveRecord::StaleObjectError`, и обновление игнорируется.

**Столбец оптимистической блокировки**

Чтобы начать использовать оптимистическую блокировку, таблица должна иметь столбец, называющийся `lock_version`, с типом `integer`. Каждый раз, когда запись обновляется, Active Record увеличивает значение `lock_version`, и средства блокирования обеспечивают, что для записи, вызванной дважды, та, которая первая успеет, будет сохранена, а для второй будет вызвано исключение `ActiveRecord::StaleObjectError`. Пример:
```
c1 = Client.find(1)
c2 = Client.find(1)

c1.first_name = "Michael"
c1.save

c2.name = "should fail"
c2.save # вызывает исключение ActiveRecord::StaleObjectError
```
Вы ответственны за разрешение конфликта с помощью обработки исключения и либо отката, либо объединения, либо применения бизнес-логики, необходимой для разрешения конфликта.

Это поведение может быть отключено, если установить `ActiveRecord::Base.lock_optimistically = false`.

Для переопределения имени столбца `lock_version`, `ActiveRecord::Base` предоставляет атрибут класса `locking_column`:
```
class Client < ApplicationRecord
  self.locking_column = :lock_client_column
end
```
#### Пессимистическая блокировка

Пессимистическая блокировка использует механизм блокировки, предоставленный лежащей в основе базой данных. Использование `lock` при построении relation применяет эксклюзивную блокировку для выбранных строк. Relations, которые используют `lock`, обычно упакованы внутри `transaction` для предотвращения условий взаимной блокировки (дедлока).

Например:
```
Item.transaction do
  i = Item.lock.first
  i.name = 'Jones'
  i.save!
end
```
Вышеописанная сессия осуществляет следующие SQL для бэкенда MySQL:
```
SQL (0.2ms)   BEGIN
Item Load (0.3ms)   SELECT * FROM `items` LIMIT 1 FOR UPDATE
Item Update (0.4ms)   UPDATE `items` SET `updated_at` = '2009-02-07 18:05:56', `name` = 'Jones' WHERE `id` = 1
SQL (0.8ms)   COMMIT
```
Также можно передать чистый SQL в опцию `lock` для разрешения различных типов блокировок. Например, в MySQL есть выражение, называющееся `LOCK IN SHARE MODE`, которым можно заблокировать запись, но все же разрешить другим запросам читать ее. Чтобы указать это выражения, просто передайте его как опцию блокировки:
```
Item.transaction do
  i = Item.lock("LOCK IN SHARE MODE").find(1)
  i.increment!(:views)
end
```
Если у вас уже имеется экземпляр модели, можно одновременно начать транзакцию и затребовать блокировку, используя следующий код:
```
item = Item.first
item.with_lock do
  # Этот блок вызывается в транзакции,
  # элемент уже заблокирован.
  item.increment!(:views)
end
```

### Соединительные таблицы <a name="2.6.12"></a>

Active Record предоставляет два метода поиска для определения условия `JOIN` в результирующем SQL: `joins` и `left_outer_joins`. В то время, как `joins` следует использовать для `INNER JOIN` или пользовательских запросов, `left_outer_joins` используется для запросов с помощью `LEFT OUTER JOIN`.

#### `joins`

Существует несколько способов использования метода `joins`

##### Использование строкового фрагмента SQL

Можно просто передать чистый SQL, определяющий условие `JOIN` в `joins`.
```
Author.joins("INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'")
```
Это приведет к следующему SQL:
```
SELECT authors.* FROM authors INNER JOIN posts ON posts.author_id = authors.id AND posts.published = 't'
```

##### Использование массива/хэша именованных связей

Active Record позволяет использовать имена связей, определенных в модели, как ярлыки для определения условия `JOIN` этих связей при использовании метода `joins`.

Например, рассмотрим следующие модели `Category`, `Article`, `Comment`, `Guest` и `Tag`:
```
class Category < ApplicationRecord
  has_many :articles
end

class Article < ApplicationRecord
  belongs_to :category
  has_many :comments
  has_many :tags
end

class Comment < ApplicationRecord
  belongs_to :article
  has_one :guest
end

class Guest < ApplicationRecord
  belongs_to :comment
end

class Tag < ApplicationRecord
  belongs_to :article
end
```
Сейчас все нижеследующее создаст ожидаемые соединительные запросы с использованием `INNER JOIN`:

###### Соединение одиночной связи
```
Category.joins(:articles)
```
Это создаст:
```
SELECT categories.* FROM categories
  INNER JOIN articles ON articles.category_id = categories.id
```
Или, по-русски, "возвратить объект Category для всех категорий со статьями". Обратите внимание, что будут дублирующиеся категории, если более одной статьи имеют одинаковые категорию. Если нужны уникальные категории, можно использовать 
```
Category.joins(:articles).distinct.
```
###### Соединение нескольких связей
```
Article.joins(:category, :comments)
```
Это создаст:
```
SELECT articles.* FROM articles
  INNER JOIN categories ON categories.id = articles.category_id
  INNER JOIN comments ON comments.article_id = articles.id
```
Или, по-русски, "возвратить все статьи, у которых есть категория и как минимум один комментарий". Отметьте, что статьи с несколькими комментариями будут показаны несколько раз.

###### Соединение вложенных связей (одного уровня)
```
Article.joins(comments: :guest)
```
Это создаст:
```
SELECT articles.* FROM articles
  INNER JOIN comments ON comments.article_id = articles.id
  INNER JOIN guests ON guests.comment_id = comments.id
```
Или, по-русски, "возвратить все статьи, в которых есть комментарий, оставленный гостем".

##### Определение условий в соединительных таблицах

В соединительных таблицах можно определить условия, используя обычные массивные и строковые условия. Условия с использованием хэша предоставляют специальный синтаксис для определения условий в соединительных таблицах:
```
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where('orders.created_at' => time_range)
```
Альтернативный и более чистый синтаксис для этого - вложенные хэш-условия:
```
time_range = (Time.now.midnight - 1.day)..Time.now.midnight
Client.joins(:orders).where(orders: { created_at: time_range })
```
Будут найдены все клиенты, имеющие созданные вчера заказы, снова используя выражение SQL `BETWEEN`.

#### `left_outer_joins`

Если хотите выбрать ряд записей, независимо от того, имеют ли они связанные записи, можно использовать метод `left_outer_joins`.
```
Author.left_outer_joins(:posts).distinct.select('authors.*, COUNT(posts.*) AS posts_count').group('authors.id')
```
Который создаст:
```
SELECT DISTINCT authors.*, COUNT(posts.*) AS posts_count FROM "authors"
LEFT OUTER JOIN posts ON posts.author_id = authors.id GROUP BY authors.id
```
### Нетерпеливая загрузка связей <a name="2.6.13"></a>

Нетерпеливая загрузка - это механизм загрузки связанных записей объекта, возвращаемых `Model.find`, с использованием как можно меньшего количества запросов.

Проблема N + 1 запроса

Рассмотрим следующий код, который находит 10 клиентов и выводит их почтовые индексы:
```
clients = Client.limit(10)

clients.each do |client|
  puts client.address.postcode
end
```
На первый взгляд выглядит хорошо. Но проблема лежит в общем количестве выполненных запросов. Вышеупомянутый код выполняет 1 (чтобы найти 10 клиентов) + 10 (каждый на одного клиента для загрузки адреса) = итого 11 запросов.
Что означает: "возвратить всех авторов и количество их публикаций, независимо от того, имеются ли у них вообще публикации".

**Решение проблемы N + 1 запроса**

Active Record позволяет заранее указать все связи, которые должны быть загружены. Это возможно с помощью указания метода `includes` на вызове `Model.find`. Посредством `includes`, Active Record обеспечивает то, что все указанные связи загружаются с использованием минимально возможного количества запросов.

Пересмотрев вышеупомянутую задачу, можно переписать `Client.limit(10)`, чтобы нетерпеливо загрузить адреса:
```
clients = Client.includes(:address).limit(10)

clients.each do |client|
  puts client.address.postcode
end
```
Этот код выполнит всего 2 запроса, вместо 11 запросов из прошлого примера:
```
SELECT * FROM clients LIMIT 10
SELECT addresses.* FROM addresses
  WHERE (addresses.client_id IN (1,2,3,4,5,6,7,8,9,10))
```

#### Нетерпеливая загрузка нескольких связей
Массив нескольких связей
```
Article.includes(:category, :comments)
```
Это загрузит все статьи и связанные категорию, и комментарии для каждой статьи.

#### Вложенный хэш связей
```
Category.includes(articles: [{ comments: :guest }, :tags]).find(1)
```
Вышеприведенный код находит категории с `id 1` и нетерпеливо загружает все связанные статьи, теги и комментарии каждой статьи, а также гостей, связанных с комментариями.

#### Определение условий для нетерпеливой загрузки связей

Хотя Active Record и позволяет определить условия для нетерпеливой загрузки связей точно так же, как и в `joins`, рекомендуем использовать вместо этого `joins`.

Однако, если сделать так, то можно использовать `where` как обычно.
```
Article.includes(:comments).where(comments: { visible: true })
```
Это сгенерирует запрос с ограничением `LEFT OUTER JOIN`, в то время как метод `joins` сгенерировал бы его с использованием функции `INNER JOIN`.
```
  SELECT "articles"."id" AS t0_r0, ... "comments"."updated_at" AS t1_r5 FROM "articles"
    LEFT OUTER JOIN "comments" ON "comments"."article_id" = "articles"."id" WHERE (comments.visible = 1)
```
Если бы не было условия `where`, то сгенерировался бы обычный набор из двух запросов.

> Использование where подобным образом будет работать только, если передавать в него хэш. Для фрагментов SQL необходимо использовать `references` для принуждения соединения таблиц:
```
Article.includes(:comments).where("comments.visible = true").references(:comments)
```
Если, в случае с этим запросом `includes`, не будет ни одного комментария ни для одной статьи, все статьи все равно будут загружены. При использовании `joins` (`INNER JOIN`), соединительные условия должны соответствовать, иначе ни одной записи не будет возвращено.

> Если связь нетерпеливо загружена как часть `join`, любые поля из произвольного выражения `select` не будут присутствовать в загруженных моделях. Это так, потому что это избыточность, которая должна появиться или в родительской модели, или в дочерней.

### Скоупы <a name="2.6.14"></a>
Скоупы позволяют задавать часто используемые запросы, к которым можно обращаться как к вызовам метода в связанных объектах или моделях. С помощью этих скоупов можно использовать каждый ранее раскрытый метод, такой как `where`, `joins` и `includes`. Все методы скоупов возвращают объект `ActiveRecord::Relation`, который позволяет вызывать на нем дополнительные методы (такие как другие скоупы).

Для определения простого скоупа мы используем метод scope внутри класса, передав запрос, который хотим запустить при вызове этого скоупа:
```
class Article < ApplicationRecord
  scope :published, -> { where(published: true) }
end
```
Это в точности то же самое, что определение метода класса, и то, что именно вы используете, является вопросом профессионального предпочтения:
```
class Article < ApplicationRecord
  def self.published
    where(published: true)
  end
end
```
Скоупы также сцепляются с другими скоупами:
```
class Article < ApplicationRecord
  scope :published,               -> { where(published: true) }
  scope :published_and_commented, -> { published.where("comments_count > 0") }
end
```
Для вызова скоупа `published`, можно вызвать его либо на классе:
```
Article.published # => [опубликованные статьи]
```
Либо на связи, состоящей из объектов `Article`:
```
category = Category.first
category.articles.published # => [опубликованные статьи, принадлежащие этой категории]
```

#### Передача аргумента

Скоуп может принимать аргументы:
```
class Article < ApplicationRecord
  scope :created_before, ->(time) { where("created_at < ?", time) }
end
```
Вызывайте скоуп, как будто это метод класса:
```
Article.created_before(Time.zone.now)
```
Однако, это всего лишь дублирование функциональности, которая должна быть предоставлена методом класса.
```
class Article < ApplicationRecord
  def self.created_before(time)
    where("created_at < ?", time)
  end
end
```
Использование метода класса - более предпочтительный способ принятию аргументов скоупом. Эти методы также будут доступны на связанных объектах:
```
category.articles.created_before(time)
```

#### Использование условий

Ваши скоупы могут использовать условия:
```
class Article < ApplicationRecord
  scope :created_before, ->(time) { where("created_at < ?", time) if time.present? }
end
```
Подобно остальным примерам, это ведет себя подобно методу класса.
```
class Article < ApplicationRecord
  def self.created_before(time)
    where("created_at < ?", time) if time.present?
  end
end
```
Однако, имеется одно важное предостережение: скоуп всегда должен возвращать объект `ActiveRecord::Relation`, даже если условие вычисляется `false`, в отличие от метода класса, возвращающего `nil`. Это может вызвать `NoMethodError` при сцеплении методов класса с условиями, если одно из условий вернет `false`.

#### Применение скоупа по умолчанию

Если хотите, чтобы скоуп был применен ко всем запросам модели, можно использовать метод `default_scope` в самой модели.
```
class Client < ApplicationRecord
  default_scope { where("removed_at IS NULL") }
end
```
Когда запросы для этой модели будут выполняться, запрос SQL теперь будет выглядеть примерно так:
```
SELECT * FROM clients WHERE removed_at IS NULL
```
Если необходимо сделать более сложные вещи со скоупом по умолчанию, альтернативно его можно определить как метод класса:
```
class Client < ApplicationRecord
  def self.default_scope
    # Должен возвращать ActiveRecord::Relation.
  end
end
```
`default_scope` также применяется при создании записи, когда аргументы скоупа передаются как Hash. Он не применяется при обновлении записи. То есть:
```
class Client < ApplicationRecord
  default_scope { where(active: true) }
end

Client.new          # => #<Client id: nil, active: true>
Client.unscoped.new # => #<Client id: nil, active: nil>
```
Имейте в виду, что когда передаются в формате Array, аргументы запроса `default_scope` не могут быть преобразованы в Hash для назначения атрибутов по умолчанию. То есть:
```
class Client < ApplicationRecord
  default_scope { where("active = ?", true) }
end

Client.new # => #<Client id: nil, active: nil>
```

#### Объединение скоупов

Подобно условиям where, скоупы объединяются с использованием `AND`.
```
class User < ApplicationRecord
  scope :active, -> { where state: 'active' }
  scope :inactive, -> { where state: 'inactive' }
end

User.active.inactive
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'inactive'
```
Можно комбинировать условия `scope` и `where`, и результирующий sql будет содержать все условия, соединенные с помощью `AND`.
```
User.active.where(state: 'finished')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active' AND "users"."state" = 'finished'
```
Если необходимо, чтобы сработало только **последнее условие where**, тогда можно использовать `Relation#merge`.
```
User.active.merge(User.inactive)
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
```
Важным предостережением является то, что `default_scope` **переопределяется условиями `scope` и `where`**.
```
class User < ApplicationRecord
  default_scope { where state: 'pending' }
  scope :active, -> { where state: 'active' }
  scope :inactive, -> { where state: 'inactive' }
end

User.all
# SELECT "users".* FROM "users" WHERE "users"."state" = 'pending'

User.active
# SELECT "users".* FROM "users" WHERE "users"."state" = 'active'

User.where(state: 'inactive')
# SELECT "users".* FROM "users" WHERE "users"."state" = 'inactive'
```
Как видите, `default_scope` объединяется как со `scope`, так и с `where` условиями.

#### Удаление всех скоупов

Если хотите удалить скоупы по какой-то причине, можете использовать метод `unscoped`. Это особенно полезно, если в модели определен `default_scope`, и он не должен быть применен для конкретно этого запроса.
```
Client.unscoped.load
```
Этот метод удаляет все скоупы и выполняет обычный запрос к таблице.
```
Client.unscoped.all
# SELECT "clients".* FROM "clients"

Client.where(published: false).unscoped.all
# SELECT "clients".* FROM "clients"
```
`unscoped` также может принимать блок.
```
Client.unscoped {
  Client.created_before(Time.zone.now)
}
```
### Динамический поиск <a name="2.6.15"></a>

Для каждого поля (также называемого атрибутом), определенного в вашей таблице, Active Record предоставляет метод поиска. Например, если есть поле `first_name` в вашей модели `Client`, вы автоматически получаете `find_by_first_name` от Active Record. Если также есть поле `locked` в модели `Client`, вы также получаете `find_by_locked` метод.

Можете определить восклицательный знак (`!`) в конце динамического поиска, чтобы он вызвал ошибку `ActiveRecord::RecordNotFound`, если не возвратит ни одной записи, например так `Client.find_by_name!("Ryan")`

Если хотите искать и по `first_name`, и по `locked`, можете сцепить эти поиски вместе, просто написав "`and`" между полями, например, `Client.find_by_first_name_and_locked("Ryan", true)`.

### `Enum` <a name="2.6.16"></a>

Макрос `enum` связывает числовой столбец с набором возможных значений.
```
class Book < ApplicationRecord
  enum availability: [:available, :unavailable]
end
```
Это автоматически создаст соответствующие скоупы для запроса модели. Также добавляются методы для перехода между состояниями и запроса текущего состояния.
```
# Оба примера ниже запрашивают только доступные книги.
Book.available
# или
Book.where(availability: :available)

book = Book.new(availability: :available)
book.available?   # => true
book.unavailable! # => true
book.available?   # => false
```
Полную документацию об `enum` можно прочитать в <a href="https://api.rubyonrails.org/classes/ActiveRecord/Enum.html">документации Rails API</a>.

### Цепочки методов <a name="2.6.17"></a>

В Active Record есть полезный приём программирования Method Chaining, который позволяет нам комбинировать множество Active Record методов.

Можно сцепить несколько методов в единое выражение, если предыдущий вызываемый метод возвращает `ActiveRecord::Relation`, такие как `all`, `where` и `joins`. Методы, которые возвращают одиночный объект (смотрите раздел Получение одиночного объекта) должны вызываться в конце.

Ниже представлены несколько примеров. Это руководство не покрывает все возможности, а только некоторые, для ознакомления. Когда вызывается Active Record метод, запрос не сразу генерируется и отправляется в базу, это происходит только тогда, когда данные реально необходимы. Таким образом, каждый пример ниже генерирует только один запрос.

#### Получение отфильтрованных данных из нескольких таблиц
```
Person
  .select('people.id, people.name, comments.text')
  .joins(:comments)
  .where('comments.created_at > ?', 1.week.ago)
```
Результат должен быть примерно следующим:
```
SELECT people.id, people.name, comments.text
FROM people
INNER JOIN comments
  ON comments.person_id = people.id
WHERE comments.created_at > '2015-01-01'
```

#### Получение определённых данных из нескольких таблиц
```
Person
  .select('people.id, people.name, companies.name')
  .joins(:company)
  .find_by('people.name' => 'John') # это должно быть в конце
```
Выражение выше, сгенерирует следующий SQL-запрос:
```
SELECT people.id, people.name, companies.name
FROM people
INNER JOIN companies
  ON companies.person_id = people.id
WHERE people.name = 'John'
LIMIT 1
```
> Обратите внимание, что если запросу соответствует несколько записей, `find_by` вернет только первую запись и проигнорирует остальные (смотрите `LIMIT 1` выше).

### Поиск или создание нового объекта <a name="2.6.18"></a>

Часто бывает, что вам нужно найти запись или создать ее, если она не существует. Вы можете сделать это с помощью методов `find_or_create_by` и `find_or_create_by!`.

#### `find_or_create_by`

Метод `find_or_create_by` проверяет, существует ли запись с определенными атрибутами. Если нет, то вызывается `create`. Давайте рассмотрим пример.

Предположим, вы хотите найти клиента по имени 'Andy', и, если такого нет, создать его. Это можно сделать, выполнив:
```
Client.find_or_create_by(first_name: 'Andy')
# => #<Client id: 1, first_name: "Andy", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">
```
SQL, генерируемый этим методом, будет выглядеть так:
```
SELECT * FROM clients WHERE (clients.first_name = 'Andy') LIMIT 1
BEGIN
INSERT INTO clients (created_at, first_name, locked, orders_count, updated_at) VALUES ('2011-08-30 05:22:57', 'Andy', 1, NULL, '2011-08-30 05:22:57')
COMMIT
```
`find_or_create_by` возвращает либо уже существующую запись, либо новую запись. В нашем случае, у нас еще нет клиента с именем Andy, поэтому запись будет создана и возвращена.

Новая запись может быть не сохранена в базу данных; это зависит от того, прошли валидации или нет (подобно `create`).

Предположим, мы хотим установить атрибут `'locked'` как `false`, если создаем новую запись, но не хотим включать его в запрос. Таким образом, мы хотим найти клиента по имени "Andy" или, если этот клиент не существует, создать клиента по имени "Andy", который не заблокирован.

Этого можно достичь двумя способами. Первый - это использование `create_with`:
```
Client.create_with(locked: false).find_or_create_by(first_name: 'Andy')
```
Второй способ - это использование блока:
```
Client.find_or_create_by(first_name: 'Andy') do |c|
  c.locked = false
end
```
Блок будет выполнен, только если клиент был создан. Во второй раз, при запуске этого кода, блок будет проигнорирован.

#### `find_or_create_by!`

Можно также использовать `find_or_create_by!`, чтобы вызвать исключение, если новая запись невалидна. Валидации не раскрываются в этом руководстве, но давайте на момент предположим, что вы временно добавили
```
validates :orders_count, presence: true
```
в модель `Client`. Если попытаетесь создать нового `Client` без передачи `orders_count`, запись будет невалидной и будет вызвано исключение:
```
Client.find_or_create_by!(first_name: 'Andy')
# => ActiveRecord::RecordInvalid: Validation failed: Orders count can't be blank
```
#### `find_or_initialize_by`

Метод `find_or_initialize_by` работает похоже на `find_or_create_by`, но он вызывает не `create`, а `new`. Это означает, что новый экземпляр модели будет создан в памяти, но не будет сохранен в базу данных. Продолжая пример с `find_or_create_by`, теперь нам нужен клиент по имени 'Nick':
```
nick = Client.find_or_initialize_by(first_name: 'Nick')
# => #<Client id: nil, first_name: "Nick", orders_count: 0, locked: true, created_at: "2011-08-30 06:09:27", updated_at: "2011-08-30 06:09:27">

nick.persisted?
# => false

nick.new_record?
# => true
```
Поскольку объект еще не сохранен в базу данных, сгенерированный SQL выглядит так:
```
SELECT * FROM clients WHERE (clients.first_name = 'Nick') LIMIT 1
```
Когда захотите сохранить его в базу данных, просто вызовите `save`:
```
nick.save
# => true
```
### Поиск с помощью SQL <a name="2.6.19"></a>

Если вы предпочитаете использовать собственные запросы SQL для поиска записей в таблице, можете использовать `find_by_sql`. Метод `find_by_sql` возвратит массив объектов, даже если лежащий в основе запрос вернет всего лишь одну запись. Например, можете запустить такой запрос:
```
Client.find_by_sql("SELECT * FROM clients
  INNER JOIN orders ON clients.id = orders.client_id
  ORDER BY clients.created_at desc")
# =>  [
#   #<Client id: 1, first_name: "Lucas" >,
#   #<Client id: 2, first_name: "Jan" >,
#   ...
# ]
```
`find_by_sql` предоставляет простой способ создания произвольных запросов к базе данных и получения экземпляров объектов.

#### `select_all`

У `find_by_sql` есть близкий родственник, называемый `connection#select_all`. `select_all` получит объекты из базы данных, используя произвольный SQL, как и в `find_by_sql`, но не создаст их экземпляры. Этот метод вернет экземпляр класса `ActiveRecord::Result` и вызвав `to_hash` на этом объекте вернет массив хэшей, где каждый хэш указывает на запись.
```
Client.connection.select_all("SELECT first_name, created_at FROM clients WHERE id = '1'").to_hash
# => [
#   {"first_name"=>"Rafael", "created_at"=>"2012-11-10 23:23:45.281189"},
#   {"first_name"=>"Eileen", "created_at"=>"2013-12-09 11:22:35.221282"}
# ]
```

#### `pluck`

`pluck` может быть использован для запроса с одним или несколькими столбцами из таблицы, лежащей в основе модели. Он принимает список имен столбцов как аргумент и возвращает массив значений определенных столбцов соответствующего типа данных.
```
Client.where(active: true).pluck(:id)
# SELECT id FROM clients WHERE active = 1
# => [1, 2, 3]

Client.distinct.pluck(:role)
# SELECT DISTINCT role FROM clients
# => ['admin', 'member', 'guest']

Client.pluck(:id, :name)
# SELECT clients.id, clients.name FROM clients
# => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
```
`pluck` позволяет заменить такой код:
```
Client.select(:id).map { |c| c.id }
# или
Client.select(:id).map(&:id)
# или
Client.select(:id, :name).map { |c| [c.id, c.name] }
```
на:
```
Client.pluck(:id)
# или
Client.pluck(:id, :name)
```
В отличие от `select`, `pluck` непосредственно конвертирует результат запроса в массив Ruby, без создания объектов ActiveRecord. Это может означать лучшую производительность для больших или часто используемых запросов. Однако, любые **переопределения методов в модели будут недоступны**. Например:
```
class Client < ApplicationRecord
  def name
    "I am #{super}"
  end
end

Client.select(:name).map &:name
# => ["I am David", "I am Jeremy", "I am Jose"]

Client.pluck(:name)
# => ["David", "Jeremy", "Jose"]
```
Более того, в отличие от `select` и других скоупов Relation, `pluck` вызывает немедленный запрос, и поэтому **не может быть соединен с любыми последующими скоупами, хотя он может работать со скоупами, подключенными ранее**:
```
Client.pluck(:name).limit(1)
# => NoMethodError: undefined method `limit' for #<Array:0x007ff34d3ad6d8>

Client.limit(1).pluck(:name)
# => ["David"]
```

#### `ids`

`ids` может быть использован для сбора всех ID для relation, используя первичный ключ таблицы.
```
Person.ids
# SELECT id FROM people
```
```
class Person < ApplicationRecord
  self.primary_key = "person_id"
end

Person.ids
# SELECT person_id FROM people
```

### Существование объектов <a name="2.6.20"></a>

Если вы просто хотите проверить существование объекта, есть метод, называемый `exists?`. Этот метод запрашивает базу данных, используя тот же запрос, что и `find`, но вместо возврата объекта или коллекции объектов, он возвращает или `true`, или `false`.
```
Client.exists?(1)
```

Метод `exists?` также принимает несколько значений, при этом возвращает `true`, если хотя бы одна из этих записей существует.
```
Client.exists?(id: [1,2,3])
# или
Client.exists?(name: ['John', 'Sergei'])
```
Даже возможно использовать `exists?` без аргументов на модели или `relation`:
```
Client.where(first_name: 'Ryan').exists?
```
Пример выше вернет `true`, если есть хотя бы один клиент с `first_name 'Ryan'`, и `false` в противном случае.
```
Client.exists?
```
Это возвратит `false`, если таблица `clients` пустая, и `true` в противном случае.

Для проверки на существование также можно использовать `any?` и `many?` на модели или relation.
```
# на модели
Article.any?
Article.many?

# на именованном скоупе
Article.recent.any?
Article.recent.many?

# на relation
Article.where(published: true).any?
Article.where(published: true).many?

# на связи
Article.first.categories.any?
Article.first.categories.many?
```

### Вычисления <a name="2.6.21"></a>

Этот раздел использует count для примера в этой преамбуле, но описанные опции применяются ко всем подразделам.

Все методы вычисления работают прямо на модели:
```
Client.count
# SELECT COUNT(*) FROM clients
```
Или на relation:
```
Client.where(first_name: 'Ryan').count
# SELECT COUNT(*) FROM clients WHERE (first_name = 'Ryan')
```
Можно также использовать различные методы поиска на relation для выполнения сложных вычислений:
```
Client.includes("orders").where(first_name: 'Ryan', orders: { status: 'received' }).count
```
Что выполнит:
```
SELECT COUNT(DISTINCT clients.id) FROM clients
  LEFT OUTER JOIN orders ON orders.client_id = clients.id
  WHERE (clients.first_name = 'Ryan' AND orders.status = 'received')
```

#### Количество

Если хотите увидеть, сколько записей есть в таблице модели, можете вызвать `Client.count`, и он возвратит число. Если хотите быть более определенным и найти всех клиентов с присутствующим в базе данных возрастом, используйте `Client.count(:age)`.

#### Среднее

Если хотите увидеть среднее значение определенного показателя в одной из ваших таблиц, можно вызвать метод `average` для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.average("orders_count")
```
Это возвратит число (возможно, с плавающей запятой, такое как 3.14159265), представляющее среднее значение поля.

#### Минимум

Если хотите найти минимальное значение поля в таблице, можете вызвать метод minimum для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.minimum("age")
```

#### Максимум

Если хотите найти максимальное значение поля в таблице, можете вызвать метод maximum для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.maximum("age")
```

#### Сумма

Если хотите найти сумму полей для всех записей в таблице, можете вызвать метод sum для класса, относящегося к таблице. Вызов этого метода выглядит так:
```
Client.sum("orders_count")
```

### Запуск EXPLAIN <a name="2.6.22"></a>

Можно запустить `EXPLAIN` на запросах, вызываемых в relations. Например,
```
User.where(id: 1).joins(:articles).explain
```

может выдать
```
EXPLAIN for: SELECT `users`.* FROM `users` INNER JOIN `articles` ON `articles`.`user_id` = `users`.`id` WHERE `users`.`id` = 1
+----+-------------+----------+-------+---------------+
| id | select_type | table    | type  | possible_keys |
+----+-------------+----------+-------+---------------+
|  1 | SIMPLE      | users    | const | PRIMARY       |
|  1 | SIMPLE      | articles | ALL   | NULL          |
+----+-------------+----------+-------+---------------+
+---------+---------+-------+------+-------------+
| key     | key_len | ref   | rows | Extra       |
+---------+---------+-------+------+-------------+
| PRIMARY | 4       | const |    1 |             |
| NULL    | NULL    | NULL  |    1 | Using where |
+---------+---------+-------+------+-------------+

2 rows in set (0.00 sec)
```
для MySQL и MariaDB.

Active Record применяет красивое форматирование, эмулирующее работу соответствующей оболочки базы данных. Таким образом, запуск того же запроса с адаптером PostgreSQL выдаст вместо этого
```
EXPLAIN for: SELECT "users".* FROM "users" INNER JOIN "articles" ON "articles"."user_id" = "users"."id" WHERE "users"."id" = 1
                                  QUERY PLAN
------------------------------------------------------------------------------
 Nested Loop Left Join  (cost=0.00..37.24 rows=8 width=0)
   Join Filter: (articles.user_id = users.id)
   ->  Index Scan using users_pkey on users  (cost=0.00..8.27 rows=1 width=4)
         Index Cond: (id = 1)
   ->  Seq Scan on articles  (cost=0.00..28.88 rows=8 width=4)
         Filter: (articles.user_id = 1)
(6 rows)
```
Нетерпеливая загрузка может вызвать более одного запроса за раз, и некоторым запросам могут потребоваться результаты предыдущих. Поэтому `explain` фактически выполняет запрос, а затем запрашивает планы запросов. Например,
```
User.where(id: 1).includes(:articles).explain
```
выдаст
```
EXPLAIN for: SELECT `users`.* FROM `users`  WHERE `users`.`id` = 1
+----+-------------+-------+-------+---------------+
| id | select_type | table | type  | possible_keys |
+----+-------------+-------+-------+---------------+
|  1 | SIMPLE      | users | const | PRIMARY       |
+----+-------------+-------+-------+---------------+
+---------+---------+-------+------+-------+
| key     | key_len | ref   | rows | Extra |
+---------+---------+-------+------+-------+
| PRIMARY | 4       | const |    1 |       |
+---------+---------+-------+------+-------+

1 row in set (0.00 sec)

EXPLAIN for: SELECT `articles`.* FROM `articles`  WHERE `articles`.`user_id` IN (1)
+----+-------------+----------+------+---------------+
| id | select_type | table    | type | possible_keys |
+----+-------------+----------+------+---------------+
|  1 | SIMPLE      | articles | ALL  | NULL          |
+----+-------------+----------+------+---------------+
+------+---------+------+------+-------------+
| key  | key_len | ref  | rows | Extra       |
+------+---------+------+------+-------------+
| NULL | NULL    | NULL |    1 | Using where |
+------+---------+------+------+-------------+
```

1 row in set (0.00 sec)

для MySQL и MariaDB

## Active Record для PostgreSQL <a name="2.7"></a>
### Типы данных <a name="2.7.1"></a>
PostgreSQL предлагает достаточное количество специфичных типов данных. Далее представлен список типов, которые поддерживаются адаптером PostgreSQL.
#### Двоичные типы данных
```
# db/migrate/20140207133952_create_documents.rb
create_table :documents do |t|
  t.binary 'payload'
end

# app/models/document.rb
class Document < ApplicationRecord
end

# Использование
data = File.read(Rails.root + "tmp/output.pdf")
Document.create payload: data
```
#### Массивы
```
# db/migrate/20140207133952_create_books.rb
create_table :books do |t|
  t.string 'title'
  t.string 'tags', array: true
  t.integer 'ratings', array: true
end
add_index :books, :tags, using: 'gin'
add_index :books, :ratings, using: 'gin'

# app/models/book.rb
class Book < ApplicationRecord
end

# Использование
Book.create title: "Brave New World",
            tags: ["fantasy", "fiction"],
            ratings: [4, 5]

## Книги с одним тегом
Book.where("'fantasy' = ANY (tags)")

## Книги с несколькими тегами
Book.where("tags @> ARRAY[?]::varchar[]", ["fantasy", "fiction"])

## Книги с рейтингом 3 и более
Book.where("array_length(ratings, 1) >= 3")
```
#### `Hstore`
> Чтобы использовать `hstore`, необходимо включить расширение `hstore`.
```
# db/migrate/20131009135255_create_profiles.rb
ActiveRecord::Schema.define do
  enable_extension 'hstore' unless extension_enabled?('hstore')
  create_table :profiles do |t|
    t.hstore 'settings'
  end
end

# app/models/profile.rb
class Profile < ApplicationRecord
end

# Использование
Profile.create(settings: { "color" => "blue", "resolution" => "800x600" })

profile = Profile.first
profile.settings # => {"color"=>"blue", "resolution"=>"800x600"}

profile.settings = {"color" => "yellow", "resolution" => "1280x1024"}
profile.save!

Profile.where("settings->'color' = ?", "yellow")
# => #<ActiveRecord::Relation [#<Profile id: 1, settings: {"color"=>"yellow", "resolution"=>"1280x1024"}>]>
```
#### `JSON` и `JSONB`
```
# db/migrate/20131220144913_create_events.rb
# ... для типа данных json:
create_table :events do |t|
  t.json 'payload'
end
# ... или для типа данных jsonb:
create_table :events do |t|
  t.jsonb 'payload'
end

# app/models/event.rb
class Event < ApplicationRecord
end

# Использование
Event.create(payload: { kind: "user_renamed", change: ["jack", "john"]})

event = Event.first
event.payload # => {"kind"=>"user_renamed", "change"=>["jack", "john"]}

## Запрос, основанный на JSON документе
# Оператор -> возвращает исходный JSON тип (который может быть объектом), где ->> возвращает текст
Event.where("payload->>'kind' = ?", "user_renamed")
```
#### Диапазонные типы
Этот тип преобразуется в `Ruby Range` объекты.
```
# db/migrate/20130923065404_create_events.rb
create_table :events do |t|
  t.daterange 'duration'
end

# app/models/event.rb
class Event < ApplicationRecord
end

# Использование
Event.create(duration: Date.new(2014, 2, 11)..Date.new(2014, 2, 12))

event = Event.first
event.duration # => Tue, 11 Feb 2014...Thu, 13 Feb 2014

## Все события в заданную дату
Event.where("duration @> ?::date", Date.new(2014, 2, 12))

## Работает с границами диапазона
event = Event.
  select("lower(duration) AS starts_at").
  select("upper(duration) AS ends_at").first

event.starts_at # => Tue, 11 Feb 2014
event.ends_at # => Thu, 13 Feb 2014
```
#### Составные типы
На данный момент нет специальной поддержки для составных типов. Они преобразуются к обычным текстовым столбцам:
```
CREATE TYPE full_address AS
(
  city VARCHAR(90),
  street VARCHAR(90)
);
```
```
# db/migrate/20140207133952_create_contacts.rb
execute <<-SQL
 CREATE TYPE full_address AS
 (
   city VARCHAR(90),
   street VARCHAR(90)
 );
SQL
create_table :contacts do |t|
  t.column :address, :full_address
end

# app/models/contact.rb
class Contact < ApplicationRecord
end

# Использование
Contact.create address: "(Paris,Champs-Élysées)"
contact = Contact.first
contact.address # => "(Paris,Champs-Élysées)"
contact.address = "(Paris,Rue Basse)"
contact.save!
```
#### Типы перечислений

На данный момент нет специальной поддержки для типов перечислений. Они преобразуются к обычным текстовым столбцам:
```
# db/migrate/20131220144913_create_articles.rb
def up
  execute <<-SQL
    CREATE TYPE article_status AS ENUM ('draft', 'published');
  SQL
  create_table :articles do |t|
    t.column :status, :article_status
  end
end

# NOTE: Не забываем удалить таблицу перед удалением enum.
def down
  drop_table :articles

  execute <<-SQL
    DROP TYPE article_status;
  SQL
end

# app/models/article.rb
class Article < ApplicationRecord
end

# Использование
Article.create status: "draft"
article = Article.first
article.status # => "draft"

article.status = "published"
article.save!
```
Чтобы добавить новое значение до/после существующего, следует использовать `ALTER TYPE`:
```
# db/migrate/20150720144913_add_new_state_to_articles.rb
# NOTE: ALTER TYPE ... ADD VALUE нельзя выполнить в блоке транзакции, поэтому используется disable_ddl_transaction!
disable_ddl_transaction!

def up
  execute <<-SQL
    ALTER TYPE article_status ADD VALUE IF NOT EXISTS 'archived' AFTER 'published';
  SQL
end
```
> Значения `ENUM` сейчас нельзя удалять.

Hint: Чтобы показать все имеющиеся значения enum, можно выполнить этот запрос в консоле bin/rails db или psql:
```
SELECT n.nspname AS enum_schema,
       t.typname AS enum_name,
       e.enumlabel AS enum_value
  FROM pg_type t
      JOIN pg_enum e ON t.oid = e.enumtypid
      JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace
```
#### Тип `UUID`
> Для использования `uuid` необходимо включить расширение `pgcrypto` (только PostgreSQL >= 9.4).
```
Тип UUID

    определение типа
    pgcrypto generator function
    uuid-ossp generator functions 

Для использования uuid необходимо включить расширение pgcrypto (только PostgreSQL >= 9.4).

# db/migrate/20131220144913_create_revisions.rb
create_table :revisions do |t|
  t.uuid :identifier
end

# app/models/revision.rb
class Revision < ApplicationRecord
end

# Использование
Revision.create identifier: "A0EEBC99-9C0B-4EF8-BB6D-6BB9BD380A11"

revision = Revision.first
revision.identifier # => "a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11"

Вы можете использовать тип uuid для определения ссылок в миграции:

# db/migrate/20150418012400_create_blog.rb
enable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')
create_table :posts, id: :uuid, default: 'gen_random_uuid()'

create_table :comments, id: :uuid, default: 'gen_random_uuid()' do |t|
  # t.belongs_to :post, type: :uuid
  t.references :post, type: :uuid
end

# app/models/post.rb
class Post < ApplicationRecord
  has_many :comments
end

# app/models/comment.rb
class Comment < ApplicationRecord
  belongs_to :post
end
```
#### Битовые строки
```
# db/migrate/20131220144913_create_users.rb
create_table :users, force: true do |t|
  t.column :settings, "bit(8)"
end

# app/models/user.rb
class User < ApplicationRecord
end

# Использование
User.create settings: "01010011"
user = User.first
user.settings # => "01010011"
user.settings = "0xAF"
user.settings # => 10101111
user.save!
```
#### Типы, описывающие сетевые адреса
Типы `inet` и `cidr` преобразуются в Ruby `IPAddr` объекты. Тип `macaddr` преобразуется в обычный текст.
```
# db/migrate/20140508144913_create_devices.rb
create_table(:devices, force: true) do |t|
  t.inet 'ip'
  t.cidr 'network'
  t.macaddr 'address'
end

# app/models/device.rb
class Device < ApplicationRecord
end

# Использование
macbook = Device.create(ip: "192.168.1.12",
                        network: "192.168.2.0/24",
                        address: "32:01:16:6d:05:ef")

macbook.ip
# => #<IPAddr: IPv4:192.168.1.12/255.255.255.255>

macbook.network
# => #<IPAddr: IPv4:192.168.2.0/255.255.255.0>

macbook.address
# => "32:01:16:6d:05:ef"
```
#### Геометрические типы
Все геометрические типы, за исключением `points` преобразуются в обычный текст. А тип `point` соответствует массиву, содержащему координаты `x` и `y`

###  Первичные ключи `UUID` <a name="2.7.2"></a>
> Для генерации случайных `UUIDs` необходимо включить расширение `pgcrypto` (только PostgreSQL >= 9.4) или `uuid-ossp`.

```
# db/migrate/20131220144913_create_devices.rb
enable_extension 'pgcrypto' unless extension_enabled?('pgcrypto')
create_table :devices, id: :uuid, default: 'gen_random_uuid()' do |t|
  t.string :kind
end

# app/models/device.rb
class Device < ApplicationRecord
end

# Использование
device = Device.create
device.id # => "814865cd-5a1d-4771-9306-4268f188fe9e"
```
> Предполагается, что используется `gen_random_uuid()` (из `uuid-pgcrypto`) при отсутствии опции `:default`, переданной в `create_table`.

### Полнотекстовый поиск <a name="2.7.3"></a>
```
# db/migrate/20131220144913_create_documents.rb
create_table :documents do |t|
  t.string 'title'
  t.string 'body'
end

add_index :documents, "to_tsvector('english', title || ' ' || body)", using: :gin, name: 'documents_idx'

# app/models/document.rb
class Document < ApplicationRecord
end

# Использование
Document.create(title: "Cats and Dogs", body: "are nice!")

## Все документы совпадающие с 'cat & dog'
Document.where("to_tsvector('english', title || ' ' || body) @@ to_tsquery(?)",
                 "cat & dog")
```
### Представление базы данных <a name="2.7.4"></a>

Представим, что нам нужно работать со старой базой данных, содержащей следующую таблицу:
```
rails_pg_guide=# \d "TBL_ART"
                                        Table "public.TBL_ART"
   Column   |            Type             |                         Modifiers
------------+-----------------------------+------------------------------------------------------------
 INT_ID     | integer                     | not null default nextval('"TBL_ART_INT_ID_seq"'::regclass)
 STR_TITLE  | character varying           |
 STR_STAT   | character varying           | default 'draft'::character varying
 DT_PUBL_AT | timestamp without time zone |
 BL_ARCH    | boolean                     | default false
Indexes:
    "TBL_ART_pkey" PRIMARY KEY, btree ("INT_ID")
```
Данная таблица не соответствует общепринятым Rails соглашениям. Т.к. простые представление PostgreSQL обновляются по умолчанию, то можно обернуть их следующим образом:
```
# db/migrate/20131220144913_create_articles_view.rb
execute <<-SQL
CREATE VIEW articles AS
  SELECT "INT_ID" AS id,
         "STR_TITLE" AS title,
         "STR_STAT" AS status,
         "DT_PUBL_AT" AS published_at,
         "BL_ARCH" AS archived
  FROM "TBL_ART"
  WHERE "BL_ARCH" = 'f'
  SQL

# app/models/article.rb
class Article < ApplicationRecord
  self.primary_key = "id"
  def archive!
    update_attribute :archived, true
  end
end

# Использование
first = Article.create! title: "Winter is coming",
                        status: "published",
                        published_at: 1.year.ago
second = Article.create! title: "Brace yourself",
                         status: "draft",
                         published_at: 1.month.ago

Article.count # => 2
first.archive!
Article.count # => 1
```
> Это приложение обслуживает только не архивированные `Articles`. Представление также допускает условия, при которых можно напрямую исключать архивные `Articles`.

## Основы Active Model <a name="2.8"></a>
### Введение <a name="2.8.1"></a>
#### Методы атрибутов
Модуль `ActiveModel::AttributeMethods` позволяет добавлять различные суффиксы и префиксы к методам класса. Для использования необходимо определить суффиксы, префиксы, а также к каким методам объекта они будут применяться.
```
class Person
  include ActiveModel::AttributeMethods

  attribute_method_prefix 'reset_'
  attribute_method_suffix '_highest?'
  define_attribute_methods 'age'

  attr_accessor :age

  private
    def reset_attribute(attribute)
      send("#{attribute}=", 0)
    end

    def attribute_highest?(attribute)
      send(attribute) > 100
    end
end

person = Person.new
person.age = 110
person.age_highest?  # => true
person.reset_age     # => 0
person.age_highest?  # => false
```
#### Колбэки

Модуль `ActiveModel::Callbacks` дает Active Record возможность использования функций обратного вызова (колбэков). Это позволяет определять колбэки, вызываемые в определенное время. После определения колбэков можно обернуть их дополнительной функциональностью `before`, `after` и `around`, которые позволяют определить момент вызова колбэка "до", "после" и "до и после" вызова нужного метода.
```
class Person
  extend ActiveModel::Callbacks

  define_model_callbacks :update

  before_update :reset_me

  def update
    run_callbacks(:update) do
      # Этот метод вызывается при вызове у обьекта метода update.
    end
  end

  def reset_me
    # Этот метод вызывается при вызове у обьекта метода update, выполнение метода reset_me произойдет до вызова update, т.к он определен как колбэк before_update.
  end
end
```

#### Преобразования
Если для класса определены методы `persisted?` и `id`, то можно добавить модуль `ActiveModel::Conversion` в этот класс и вызывать методы преобразования Rails на объектах этого класса.
```
class Person
  include ActiveModel::Conversion

  def persisted?
    false
  end

  def id
    nil
  end
end

person = Person.new
person.to_model == person  # => true
person.to_key              # => nil
person.to_param            # => nil
```
#### Грязный объект

Объект становится грязным после одного или нескольких изменений его атрибутов, и при этом он не был сохранен. `ActiveModel::Dirty` дает возможность проверить, был ли объект изменен или нет. Также имеются атрибуты на основе акцессор-методов. Представим, что имеется класс Person с атрибутами `first_name` и `last_name`:
```
class Person
  include ActiveModel::Dirty
  define_attribute_methods :first_name, :last_name

  def first_name
    @first_name
  end

  def first_name=(value)
    first_name_will_change!
    @first_name = value
  end

  def last_name
    @last_name
  end

  def last_name=(value)
    last_name_will_change!
    @last_name = value
  end

  def save
    # метод для сохранения изменений...
    changes_applied
  end
end
```
##### Запрашиваем у объекта список всех измененных атрибутов
```
person = Person.new
person.changed? # => false

person.first_name = "First Name"
person.first_name # => "First Name"

# возвращает true, если хотя бы у одного из атрибутов есть несохраненное значение.
person.changed? # => true

# возвращает список атрибутов, которые были изменены до сохранения.
person.changed # => ["first_name"]

# возвращает хэш с измененными атрибутами вместе с их первоначальными значениями.
person.changed_attributes # => {"first_name"=>nil}

# возвращает хэш изменений с именами атрибутов в качестве ключей, и их значений как массива, который содержит старое и новое значение поля.
person.changes # => {"first_name"=>[nil, "First Name"]}
```
##### Атрибуты, основанные на акцессор-методах
Отслеживает, был ли атрибут изменен или нет.
```
# attr_name_changed?
person.first_name # => "First Name"
person.first_name_changed? # => true
```
Отслеживает предыдущее значение атрибута.
```
# акцессор attr_name_was
person.first_name_was # => nil
```
Отслеживает старое и новое значение измененного атрибута. Возвращает массив, если изменяли, в противном случае nil.
```
# attr_name_change
person.first_name_change # => [nil, "First Name"]
person.last_name_change # => nil
```
#### Валидации
Модуль `ActiveModel::Validations` добавляет возможность проверять объекты, как в Active Record.
```
class Person
  include ActiveModel::Validations

  attr_accessor :name, :email, :token

  validates :name, presence: true
  validates_format_of :email, with: /\A([^\s]+)((?:[-a-z0-9]\.)[a-z]{2,})\z/i
  validates! :token, presence: true
end

person = Person.new
person.token = "2b1f325"
person.valid?                        # => false
person.name = 'vishnu'
person.email = 'me'
person.valid?                        # => false
person.email = 'me@vishnuatrai.com'
person.valid?                        # => true
person.token = nil
person.valid?                        # => вызывается ActiveModel::StrictValidationFailed
```
#### Именование
`ActiveModel::Naming` добавляет ряд методов класса, упрощающие управление именованием и роутингом. Модуль определяет метод класса model_name, который определит несколько акцессоров с помощью методов `ActiveSupport::Inflector`.
```
class Person
  extend ActiveModel::Naming
end

Person.model_name.name                # => "Person"
Person.model_name.singular            # => "person"
Person.model_name.plural              # => "people"
Person.model_name.element             # => "person"
Person.model_name.human               # => "Person"
Person.model_name.collection          # => "people"
Person.model_name.param_key           # => "person"
Person.model_name.i18n_key            # => :person
Person.model_name.route_key           # => "people"
Person.model_name.singular_route_key  # => "person"
```
#### Модель
`ActiveModel::Model` добавляет для класса возможность работать из коробки с Action Pack и Action View.
```
class EmailContact
  include ActiveModel::Model

  attr_accessor :name, :email, :message
  validates :name, :email, :message, presence: true

  def deliver
    if valid?
      # отправить электронную почту 
    end
  end
end
```
При включении `ActiveModel::Model` вы получите несколько возможностей, таких как:

    интроспекция имени модели
    преобразования
    переводы
    валидации 

Он также дает возможность инициализировать объект с помощью хэша атрибутов, подобно любому объекту Active Record.
```
email_contact = EmailContact.new(name: 'David',
                                 email: 'david@example.com',
                                 message: 'Hello World')
email_contact.name       # => 'David'
email_contact.email      # => 'david@example.com'
email_contact.valid?     # => true
email_contact.persisted? # => false
```
Любой класс, включающий `ActiveModel::Model`, может быть использован с `form_for`, `render` и любыми другими методами хелпера `Action View`, точно так же, как и объекты `Active Record`.
#### Сериализация
`ActiveModel::Serialization` предоставляет базовую сериализацию для вашего объекта. Вам необходимо объявить хэш, содержащий атрибуты, которые вы хотите сериализовать. Атрибуты должны быть строками, не символами.
```
class Person
  include ActiveModel::Serialization

  attr_accessor :name

  def attributes
    {'name' => nil}
  end
end

Теперь можно получить доступ к сериализованному хэшу вашего объекта с помощью метода serializable_hash.

person = Person.new
person.serializable_hash   # => {"name"=>nil}
person.name = "Bob"
person.serializable_hash   # => {"name"=>"Bob"}
```
##### `ActiveModel::Serializers`
Active Model также предоставляет модуль `ActiveModel::Serializers::JSON` для сериализации/десериализации JSON. Этот модуль автоматически подключает ранее обсужденный модуль `ActiveModel::Serialization`.

###### `ActiveModel::Serializers::JSON`
Для использования `ActiveModel::Serializers::JSON` необходимо только изменить модуль, который вы подключали, с `ActiveModel::Serialization` на `ActiveModel::Serializers::JSON`.
```
class Person
  include ActiveModel::Serializers::JSON

  attr_accessor :name

  def attributes
    {'name' => nil}
  end
end
```
Метод `as_json`, подобно `serializable_hash`, предоставляет хэш, описывающий модель.
```
person = Person.new
person.as_json # => {"name"=>nil}
person.name = "Bob"
person.as_json # => {"name"=>"Bob"}
```
Также можно определить атрибуты для модели из строки JSON. Однако, в классе нужно определить метод `attributes=`:
```
class Person
  include ActiveModel::Serializers::JSON

  attr_accessor :name

  def attributes=(hash)
    hash.each do |key, value|
      send("#{key}=", value)
    end
  end

  def attributes
    {'name' => nil}
  end
end
```
Теперь есть возможность создавать экземпляры Person и устанавливать атрибуты с помощью `from_json`.
```
json = { name: 'Bob' }.to_json
person = Person.new
person.from_json(json) # => #<Person:0x00000100c773f0 @name="Bob">
person.name            # => "Bob"
```
#### Перевод
`ActiveModel::Translation` предоставляет интеграцию между вашим объектом и фреймворком интернационализации Rails (i18n).
```
class Person
  extend ActiveModel::Translation
end
```
С помощью метода `human_attribute_name` можно преобразовывать имена атрибутов в более удобочитаемый формат. Удобочитаемый формат определяется в вашем(-их) файле(-ах) локали.
```
    # config/locales/app.pt-BR.yml 

  pt-BR:
    activemodel:
      attributes:
        person:
          name: 'Nome'

Person.human_attribute_name('name') # => "Nome"
```
#### Тесты совместимости
`ActiveModel::Lint::Tests` позволяет проверить, совместим ли объект с Active Model API.
```
    app/models/person.rb

    class Person
      include ActiveModel::Model
    end

    test/models/person_test.rb

    require 'test_helper'

    class PersonTest < ActiveSupport::TestCase
      include ActiveModel::Lint::Tests

      setup do
        @model = Person.new
      end
    end
```
```
$ rails test

Run options: --seed 14596

# Running:

......

Finished in 0.024899s, 240.9735 runs/s, 1204.8677 assertions/s.

6 runs, 30 assertions, 0 failures, 0 errors, 0 skips
```
Объекту не нужно реализовывать все API, чтобы работать с Action Pack. Этот модуль всего лишь предназначен для предоставления руководства в случае, если вы хотите все особенности из коробки.
#### Безопасный пароль

`ActiveModel::SecurePassword` предоставляет способ безопасно хранить любой пароль в зашифрованном виде. При включении этого модуля предоставляется метод класса `has_secure_password`, определяющий акцессор `password` с определенными валидациями на нем.

##### Требования
`ActiveModel::SecurePassword` зависит от `bcrypt`, поэтому включите этот гем в свой Gemfile для правильного использования `ActiveModel::SecurePassword`. Чтобы он работал, в модели должен быть акцессор с именем `password_digest`. `has_secure_password` добавит следующие валидации на акцессор `password`:
* Пароль должен существовать.
* Пароль должен совпадать с подтверждением (проверяется, если передан `password_confirmation`).
* Максимальная длина пароля 72 (требуется `bcrypt`, от которого зависит `ActiveModel::SecurePassword`) 

#####  Примеры
```
class Person
  include ActiveModel::SecurePassword
  has_secure_password
  attr_accessor :password_digest
end

person = Person.new

# Когда пароль пустой.
person.valid? # => false

# Когда подтверждение не совпадает с паролем.
person.password = 'aditya'
person.password_confirmation = 'nomatch'
person.valid? # => false

# Когда длина пароля превышает 72.
person.password = person.password_confirmation = 'a' * 100
person.valid? # => false

# Когда предоставлен только пароль без password_confirmation.
person.password = 'aditya'
person.valid? # => true

# Когда проходят все валидации.
person.password = person.password_confirmation = 'aditya'
person.valid? # => true
```


# Вьюхи <a name="3"></a>
## Обзор Action View <a name="3.1"></a>
### Что такое Action View? <a name="3.1.1"></a>
В Rails веб-запросы обрабатываются Action Controller и Action View. Обычно Action Controller ответственен за связь с базой данных и выполнение экшнов CRUD. Тогда как Action View ответственен за компиляцию отклика.

Шаблоны Action View пишутся с помощью тегов встроенного Ruby, смешанных с HTML. Чтобы избежать загромождения вьюх шаблонным кодом, общее поведение для форм, дат и строк представлено рядом классов хелпера. В существующее приложение также легко добавлять новые хелперы.

> Некоторые особенности Action View связаны с Active Record, но это не означает, что Action View зависит от Active Record. Action View — это независимый пакет, который можно использовать с любой библиотекой Ruby.
### Использование Action View с Rails <a name="3.1.2"></a>
Для каждого контроллера имеется связанная директория в директории app/views, содержащая файлы шаблонов, которые формируют вьюхи, связанные с этим контроллером. Эти файлы используются для отображения вьюхи, являющейся результатом каждого экшна контроллера.

Давайте взглянем на то, что делает Rails по умолчанию, когда создает новый ресурс с помощью генератора скаффолда:
```
$ rails generate scaffold article
      [...]
      invoke  scaffold_controller
      create    app/controllers/articles_controller.rb
      invoke    erb
      create      app/views/articles
      create      app/views/articles/index.html.erb
      create      app/views/articles/edit.html.erb
      create      app/views/articles/show.html.erb
      create      app/views/articles/new.html.erb
      create      app/views/articles/_form.html.erb
      [...]
```
В Rails имеется соглашение по именованию вьюх. Как правило, имя вьюхи совпадает с соответствующим экшном контроллера, как вы могли видеть выше. Например, экшн index контроллера в `articles_controller.rb` будет использовать файл вьюхи `index.html.erb` в директории` app/views/articles`. Полный HTML, возвращенный клиенту, состоит из комбинации этого файла ERB, шаблона макета, оборачивающего его, и всех партиалов, на которые вьюха может ссылаться.
### Шаблоны, партиалы и макеты <a name="3.1.3"></a>
#### Шаблоны
Шаблоны Action View могут быть написаны несколькими способами. Если у файла шаблона расширение `.erb`, то он использует смесь ERB (Embedded Ruby) и HTML. Если у файла шаблона расширение `.builder`, то используется библиотека `Builder::XmlMarkup`.

Rails поддерживает несколько систем шаблонирования и использует расширение файла, чтобы различать их. Например, файл HTML, использующий систему шаблонирования ERB, будет иметь расширение файла `.html.erb.`
##### ERB
В шаблоне ERB код Ruby может быть включен с помощью тегов `<% %>` и `<%= %>`. Теги `<% %>` используются для выполнения кода Ruby, который ничего не возвращает, такого как условия, циклы или блоки, а теги `<%= %>` используются, когда вам нужен результат выполнения.

Рассмотрим следующий цикл для имен:
```
<h1>Names of all the people</h1>
<% @people.each do |person| %>
  Name: <%= person.name %><br>
<% end %>
```
Цикл настроен с помощью обычных встраиваемых тегов (`<% %>`), а имя вставлено с помощью выводящих встраиваемых тегов (`<%= %>`). Отметьте, что это не просто совет по использованию: обычные функции для вывода, такие как `print` и `puts` не будут рендериться во вьюху в шаблонах ERB. 
Чтобы запретить предварительные и завершающие пробелы можно использовать `<%-` `-%>` вместо `<%` и `%>`.

##### Builder
Шаблоны Builder — это более программная альтернатива ERB. Они особенно полезны для генерации содержимого в XML. Объект `XmlMarkup` с именем `xml` автоматически доступен в шаблонах с расширением `.builder`.

Вот несколько простых примеров:
```
xml.em("emphasized")
xml.em { xml.b("emph & bold") }
xml.a("A Link", "href" => "https://rubyonrails.org")
xml.target("name" => "compile", "option" => "fast")
```
которые создадут:
```
<em>emphasized</em>
<em><b>emph &amp; bold</b></em>
<a href="https://rubyonrails.org">A link</a>
<target option="fast" name="compile" />
```
Любой метод с блоком будет трактован как разметка тега XML с вложенной разметкой в блоке. Например, следующее:
```
xml.div {
  xml.h1(@person.name)
  xml.p(@person.bio)
}
```
создаст что-то вроде:
```
<div>
  <h1>David Heinemeier Hansson</h1>
  <p>A product of Danish Design during the Winter of '79...</p>
</div>
```
Ниже приведен полноценный пример RSS, фактически используемый в Basecamp:
```
xml.rss("version" => "2.0", "xmlns:dc" => "http://purl.org/dc/elements/1.1/") do
  xml.channel do
    xml.title(@feed_title)
    xml.link(@url)
    xml.description "Basecamp: Recent items"
    xml.language "en-us"
    xml.ttl "40"

    for item in @recent_items
      xml.item do
        xml.title(item_title(item))
        xml.description(item_description(item)) if item_description(item)
        xml.pubDate(item_pubDate(item))
        xml.guid(@person.firm.account.url + @recent_items.url(item))
        xml.link(@person.firm.account.url + @recent_items.url(item))
        xml.tag!("dc:creator", item.author_name) if item_has_creator?(item)
      end
    end
  end
end
```
##### Jbuilder
`Jbuilder` — это гем, поддерживаемый командой Rails и включенный в Rails `Gemfile` по умолчанию. Он похож на Builder, но используется для генерации JSON вместо XML.
Если у вас его нет, можно добавить следующее в Gemfile:
```
gem 'jbuilder'
```
Объект Jbuilder с именем json автоматически становится доступным в шаблонах с расширением `.jbuilder`.

Вот простой пример:
```
json.name("Alex")
json.email("alex@example.com")
```
что создаст:
```
{
  "name": "Alex",
  "email": "alex@example.com"
}
```
##### Кэширование шаблонов
По умолчанию Rails компилирует каждый шаблон в метод перед тем, как рендерить его. Когда вы измените шаблон в режиме `development`, Rails проверит время модификации файла и перекомпилирует его.

#### Партиалы
Частичные шаблоны - обычно называемые "партиалы" - это другая схема разделения процесса рендеринга на более управляемые части. С помощью партиалов можно извлечь части кода из ваших шаблонов в отдельные файлы, а также повторно использовать их в разных шаблонах.

##### Именование партиалов
Чтобы отрендерить партиал как часть вьюхи, в ней используется метод `render`:
```
<%= render "menu" %>
```
Это отрендерит файл с именем `_menu.html.erb` во вьюхе, которая рендерится. Обратите внимание на первый символ подчеркивания: партиалы именуются, начинаясь с подчеркивания, чтобы отличить их от обычных вьюх, хотя к ним и обращаются без подчеркивания. Это истинно, даже если вы вставляете партиал из другой директории:
```
<%= render "shared/menu" %>
```
Этот код вставит партиал из `app/views/shared/_menu.html.erb`.

##### Использование партиалов для упрощения вьюх
Одним из способов использования партиалов является трактовка их как эквивалента подпрограмм; способ выноса части разметки из вьюхи, чтобы можно было проще понять, что происходит. Например, у вас может быть такая вьюха:
```
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>

<%= render "shared/footer" %>
```
Здесь партиалы `_ad_banner.html.erb` и `_footer.html.erb` могут содержать контент, общий для многих страниц приложения. Нет необходимости видеть код этих разделов, чтобы сконцентрироваться на определенной странице.

##### `render` без опций `partial` и `locals`
В вышеприведенном примере render принимает 2 опции: `partial` и `locals`. Но если это единственные опции, которые нужно передать, их можно опустить. Например, вместо:
```
<%= render partial: "product", locals: { product: @product } %>
```
Можно сделать:
```
<%= render "product", product: @product %>
```

##### Опции `as` и `object`
По умолчанию у `ActionView::Partials::PartialRenderer` есть собственный объект в локальной переменной с тем же именем, как у шаблона. Так, если имеем:
```
<%= render partial: "product" %>
```
в партиале `_product` мы получим `@product` в локальной переменной `product`, как будто мы написали:
```
<%= render partial: "product", locals: { product: @product } %>
```
Опцию `object` можно использовать, чтобы непосредственно указать, какой объект рендерится в партиале; полезно, когда объект шаблона находится где-то еще (например, в другой переменной экземпляра или в локальной переменной).

Например, вместо:
```
<%= render partial: "product", locals: { product: @item } %>
```
можно сделать:
```
<%= render partial: "product", object: @item %>
```
С помощью опции as можно указать другое имя для данной локальной переменной. Например, если нам нужно, чтобы оно было `item` вместо `product`, мы сделаем:
```
<%= render partial: "product", object: @item, as: "item" %>
```
Это эквивалентно:
```
<%= render partial: "product", locals: { item: @item } %>
```
#####  Рендеринг коллекций
Часто бывает, что шаблону нужно пройтись по коллекции и отрендерить подшаблон для каждого элемента. Этот паттерн был реализован как отдельный метод, принимающий массив и рендерящий партиал для каждого элемента массива.

Поэтому такой пример для рендеринга всех продуктов:
```
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>
```
может быть переписан с помощью одной строчки:
```
<%= render partial: "product", collection: @products %>
```
Когда партиал вызывается с коллекцией, у отдельных экземпляров партиала есть доступ к рендерящемуся члену коллекции через переменную с именем партиала. В данном случае партиалом является `_product`, и внутри него можно обратиться к `product`, чтобы получить член коллекции, который будет отрендерен.

Для рендеринга коллекций можно использовать сокращенный синтаксис. Предположим, `@products` — это коллекция экземпляров `Product`, тогда можно просто написать следующее, чтобы получить тот же самый результат:
```
<%= render @products %>
```
Rails определяет имя используемого партиала по имени модели в коллекции, в данном случае `Product`. Фактически с помощью этого сокращенного синтаксиса можно рендерить коллекцию, состоящую из экземпляров различных моделей, и Rails выберет подходящий партиал для каждого члена коллекции.

##### Разделяющие шаблоны
Также можете определить второй партиал, который будет отрендерен между экземплярами главного партиала, используя опцию `:spacer_template`:
```
<%= render partial: @products, spacer_template: "product_ruler" %>
```
Rails отрендерит партиал `_product_ruler` (без переданных в него данных) между каждой парой партиалов `_product`.

##### Макеты
Макеты могут быть использованы для рендеринга общего шаблона вьюхи вокруг результатов экшна контроллера Rails. Обычно в приложении Rails несколько макетов, в которых будут рендериться страницы. Например, на сайте может быть один макет для авторизованного пользователя и другой для маркетинга или продаж. Макет для авторизованного пользователя может включать навигацию верхнего уровня, которая должна присутствовать во многих экшнах контроллера. Макет для продаж для приложения SaaS может включать верхнеуровневую навигацию для таких, скажем, страниц как "Pricing" и "Contact Us". Ожидается, что каждый макет должен выглядеть по разному.

### Макеты партиалов <a name="3.1.4"></a>
У партиалов могут быть собственные макеты, применимые к ним. Эти макеты отличаются от тех, которые применяются к экшну контроллера, хотя они работают подобным образом.

Допустим, мы отображаем статью на странице, которая должна быть обернута в `div`, с целью отображения ее как блочный элемент. Сначала мы создадим новую `Article`:
```
Article.create(body: 'Partial Layouts are cool!')
```
В шаблоне `show` мы отрендерим партиал `_article`, обернутый в макет `box`:
```
articles/show.html.erb

<%= render partial: 'article', layout: 'box', locals: { article: @article } %>
```
Макет box просто оборачивает партиал `_article` в `div`:
```
articles/_box.html.erb

<div class='box'>
  <%= yield %>
</div>
```
Отметьте, что у макета партиала есть доступ к локальной переменной `article`, переданной в вызов `render`. Однако, в отличие от макетов приложения, макеты партиалов должны начинаться с подчеркивания.

Также можно отрендерить блок кода в макете партиала вместо вызова `yield`. Например, если у нас нет партиала `_article`, вместо него можно использовать это:
```
articles/show.html.erb

<% render(layout: 'box', locals: { article: @article }) do %>
  <div>
    <p><%= article.body %></p>
  </div>
<% end %>
```
Предположив, что мы используем тот же партиал `_box`, мы получим тот же результат, что и в предыдущем примере.

### Пути вьюх <a name="3.1.5"></a>
При рендеринге отклика контроллер должен решить, где располагаются различные вьюхи. По умолчанию он смотрит только в директории `app/views`.

Мы можем добавить другие места расположения и дать им некий приоритет при определении путей с помощью методов `prepend_view_path` и `append_view_path`.

#### `Prepend view path`
Метод может быть полезным, например, когда мы хотим поместить вьюхи в разные директории для поддоменов.
Мы можем сделать это используя:
```
prepend_view_path "app/views/#{request.subdomain}"
```
Тогда Action View при поиске нужной вьюхи будет искать сначала в этой директории.

#### `Append view path`

Аналогично, мы можем добавить путь:
```
append_view_path "app/views/direct"
```
Это добавит путь `app/views/direct` в конец поиска путей.

### Обзор хелперов, предоставленных Action View <a name="3.1.6"></a>
Тут перечислены не все хелперы.

#### AssetTagHelper
Этот модуль предоставляет методы для генерации HTML, связывающего вьюхи с ресурсами, такими как картинки, файлы JavaScript, таблицы стилей и новостные ленты.

По умолчанию Rails связывается с этими ресурсами на текущем хосте в папке `public`, но можно заставить Rails связываться с ресурсами на выделенном сервере ресурсов, установив `config.action_controller.asset_host` в конфигурации приложения, обычно в `config/environments/production.rb`. Например, допустим хост ваших ресурсов `assets.example.com`:
```
config.action_controller.asset_host = "assets.example.com"
image_tag("rails.png") # => <img src="http://assets.example.com/images/rails.png" />
```

##### `auto_discovery_link_tag`
Возвращает тег ссылки, которую могут использовать браузеры и агрегаторы новостей для автоматического определения RSS, Atom или ленты JSON.
```
auto_discovery_link_tag(:rss, "http://www.example.com/feed.rss", { title: "RSS Feed" }) # =>
  <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="http://www.example.com/feed" />
```

##### `image_path`
Вычисляет путь до ресурса картинки в директории app/assets/images. Будут переданы полные пути от корня документа. Используется внутри `image_tag` для создания пути к картинке.
```
image_path("edit.png") # => /assets/edit.png
```
К имени файла будет добавлена метка, если `config.assets.digest` установлен в `true`.
```
image_path("edit.png") # => /assets/edit-2d1a2db63fc738690021fedb5a65b68e.png
```

##### `image_url`
Вычисляет URL ресурса картинки в директории `app/assets/images`. Он вызовет `image_path` и соединит с вашим текущим хостом или вашим хостом ресурсов.
```
image_url("edit.png") # => http://www.example.com/assets/edit.png
```

##### `image_tag`
Возвращает тег картинки HTML для источника. Источником может быть полный путь или файл, существующий в директории `app/assets/images`.
```
image_tag("icon.png") # => <img src="/assets/icon.png" />
```

##### `javascript_include_tag`
Возвращает HTML-тег script для каждого предоставленного источника. Можно передать имя файла (расширение `.js` опционально) или файлы JavaScript, существующие в директории `app/assets/javascripts` для включения в текущую страницу, или передать полный путь относительно корня документа.
```
javascript_include_tag "common" # => <script src="/assets/common.js"></script>
```

##### `javascript_path`
Вычисляет путь до ресурса JavaScript в директории `app/assets/javascripts`. Если у имени файла источника нет расширения, будет добавлено `.js`. Будут переданы полные пути от корня документа. Используется внутри `javascript_include_tag` для создания пути к скрипту.
```
javascript_path "common" # => /assets/common.js
```
##### `javascript_url`
Вычисляет URL ресурса JavaScript в директории `app/assets/javascripts`. Он вызовет `javascript_path` и соединит с вашим текущим хостом или вашим хостом ресурсов.
```
javascript_url "common" # => http://www.example.com/assets/common.js
```

##### `stylesheet_link_tag`
Возвращает тег `link` на таблицу стилей для источников, указанных в качестве аргументов. Если не указать расширение, автоматически будет добавлено `.css`.
```
stylesheet_link_tag "application" # => <link href="/assets/application.css" media="screen" rel="stylesheet" />
```
##### `stylesheet_path`
Вычисляет путь до ресурса таблицы стилей в директории `app/assets/stylesheets`. Если у имени файла источника нет расширения, будет добавлено `.css`. Будут переданы полные пути от корня документа. Используется внутри `stylesheet_link_tag` для создания пути к таблице стилей.
```
stylesheet_path "application" # => /assets/application.css
```
##### `stylesheet_url`
Вычисляет URL ресурса таблицы стилей в директории `app/assets/stylesheets`. Он вызовет `stylesheet_path` и соединит с вашим текущим хостом или вашим хостом ресурсов.
```
stylesheet_url "application" # => http://www.example.com/assets/application.css
```

#### AtomFeedHelper
##### `atom_feed`
Этот хелпер позволяет с легкостью создать новостную ленту Atom. Вот пример полного использования:
```
config/routes.rb

resources :articles

app/controllers/articles_controller.rb

def index
  @articles = Article.all

  respond_to do |format|
    format.html
    format.atom
  end
end

app/views/articles/index.atom.builder

atom_feed do |feed|
  feed.title("Articles Index")
  feed.updated(@articles.first.created_at)

  @articles.each do |article|
    feed.entry(article) do |entry|
      entry.title(article.title)
      entry.content(article.body, type: 'html')

      entry.author do |author|
        author.name(article.author_name)
      end
    end
  end
end
```
#### BenchmarkHelper
##### `benchmark`
Позволяет измерить время выполнения блока в шаблоне и записать результат в лог. Оберните этот блок вокруг затратных операций или потенциальных узких мест, чтобы получить время чтения для операций.
```
<% benchmark "Process data files" do %>
  <%= expensive_files_operation %>
<% end %>
```
Это добавит в лог что-то вроде `"Process data files (0.34523)"`, затем это можно использовать для сравнения времени при оптимизации кода.

#### CacheHelper
##### `cache`
Метод для кэширования фрагмента вьюхи, а не всего экшна или страницы. Эта техника полезна для кэширования таких кусочков, как меню, списки заголовков новостей, статичные фрагменты HTML и так далее. Этот метод принимает блок, содержащий код, который вы хотите закэшировать. Подробности смотрите в `AbstractController::Caching::Fragments`.
```
<% cache do %>
  <%= render "shared/footer" %>
<% end %>
```

#### CaptureHelper
##### `capture`
Метод capture позволяет извлечь часть шаблона в переменную. Эту переменную потом можно использовать в любом месте шаблона или макета.
```
<% @greeting = capture do %>
  <p>Welcome! The date and time is <%= Time.now %></p>
<% end %>
```
Захваченная переменная может быть потом где-то использована.
```
<html>
  <head>
    <title>Welcome!</title>
  </head>
  <body>
    <%= @greeting %>
  </body>
</html>
```

##### `content_for`
Вызов `content_for` хранит блок разметки как идентификатор для дальнейшего использования. Можно совершать последующие вызовы сохраненного содержимого в других шаблонах или макете, передав идентификатор в качестве аргумента в `yield`.

Например, допустим у нас есть стандартный макет приложения, но также есть специальная страница, требующая определенный JavaScript, который не требуется в остальных частях сайта. Можно использовать `content_for`, чтобы включить этот JavaScript на нашу специальную страницу без влияния на оставшуюся часть сайта.

`app/views/layouts/application.html.erb`
```
<html>
  <head>
    <title>Welcome!</title>
    <%= yield :special_script %>
  </head>
  <body>
    <p>Welcome! The date and time is <%= Time.now %></p>
  </body>
</html>
```
`app/views/articles/special.html.erb`
```
<p>This is a special page.</p>

<% content_for :special_script do %>
  <script>alert('Hello!')</script>
<% end %>
```

#### DateHelper
##### `date_select`
Возвращает набор тегов `select` (по одному для года, месяца и дня), предзаполненных для доступа к определенному атрибуту даты.
```
date_select("article", "published_on")
```
##### `datetime_select`
Возвращает набор тегов `select` (по одному для года, месяца, дня, часа и минуты), предзаполненных для доступа к определенному атрибуту даты-времени.
```
datetime_select("article", "published_on")
```
##### `distance_of_time_in_words`

Возвращает приблизительный промежуток времени между двумя объектами `Time` или `Date`, или целыми числами в секундах. Установите `include_seconds` в `true`, если хотите более детальное приближение.
```
distance_of_time_in_words(Time.now, Time.now + 15.seconds)        # => less than a minute
distance_of_time_in_words(Time.now, Time.now + 15.seconds, include_seconds: true)  # => less than 20 seconds
```

##### `select_date`
Возвращает набор HTML-тегов `select` (по одному для года, месяца и дня), предзаполненных предоставленной `date`.
```
# Создает select для date, который по умолчанию соответствует предоставленной дате (шесть дней, начиная с сегодняшнего)
select_date(Time.today + 6.days)

# Создает select для date, который по умолчанию соответствует сегодняшней дате (без аргумента)
select_date()
```

##### `select_datetime`
Возвращает набор HTML-тегов `select` (по одному для года, месяца, дня, часа и минуты), предзаполненных предоставленным `datetime`.
```
# Создает select для datetime, который по умолчанию соответствует предоставленной дате (четыре дня, начиная с сегодняшнего)
select_datetime(Time.now + 4.days)

# Создает select для datetime, который по умолчанию соответствует сегодняшней дате (без аргумента)
select_datetime()
```

##### `select_day`
Возвращает тег `select` с опциями для каждого дня с 1 по 31 и выбранным текущим днем.
```
# Создает поле select для дней с предоставленной датой как значение по умолчанию
select_day(Time.today + 2.days)

# Создает поле select для дней с данным числом как значение по умолчанию
select_day(5)
```
##### `select_hour`
Возвращает тег `select` с опциями для каждого часа с 0 по 23 и выбранным текущим часом.
```
# Создает поле select для часов с предоставленным временем как значение по умолчанию
select_hour(Time.now + 6.hours)
```

##### `select_minute`
Возвращает тег `select` с опциями для каждой минуты с 0 по 59 и выбранной текущей минутой.
```
# Создает поле select для минут с предоставленным временем как значение по умолчанию
select_minute(Time.now + 10.minutes)
```

##### `select_month`
Возвращает тег `select` с опциями для каждого месяца с January по December и выбранным текущим месяцем.
```
# Создает поле select для месяцев с текущим месяцем как значение по умолчанию
select_month(Date.today)
```

##### `select_second`
Возвращает тег `select` с опциями для каждой секунды с 0 по 59 и выбранной текущей секундой.
```
# Создает поле select для секунд с предоставленным временем как значение по умолчанию
select_second(Time.now + 16.seconds)
```

##### `select_time`
Возвращает набор тегов HTML `select` (по одному для часа и минуты).
```
# Создает поля select с предоставленным временем как значение по умолчанию
select_time(Time.now)
```

##### `select_year`
Возвращает тег `select` с опциями для каждого года из пяти от и до выбранного текущего. Пятилетний радиус может быть изменен с помощью опциональных ключей `:start_year` и `:end_year`.
```
# Создает поле select для пяти лет в обе стороны от Date.today, являющаяся значением по умолчанию для текущего года
select_year(Date.today)

# Создает поле select от 1900 до 2016 с текущим годом как значение по умолчанию
select_year(Date.today, start_year: 1900, end_year: 2016)
```

##### `time_ago_in_words`
Подобен `distance_of_time_in_words`, где `to_time` устанавливается `Time.now`.
```
time_ago_in_words(3.minutes.from_now)  # => 3 minutes
```

##### `time_select`
Возвращает набор тегов `select` (по одному для часа, минуты и, опционально, секунды), предзаполненных для доступа к определенному атрибуту времени. Этот набор подготовлен для назначения нескольких параметров в объекте Active Record.
```
# Создает тег select для времени, который при POST будет сохранен в переменную order атрибута submitted
time_select("order", "submitted")
```

#### DebugHelper
Возвращает тег `pre` с объектом, выгруженным в YAML. Это создает удобочитаемый способ проверки объекта.
```
my_hash = { 'first' => 1, 'second' => 'two', 'third' => [1,2,3] }
debug(my_hash)

<pre class='debug_dump'>---
first: 1
second: two
third:
- 1
- 2
- 3
</pre>
```

#### FormHelper
Хелперы форм предназначены для упрощения работы с моделями по сравнению с использованием только стандартных элементов HTML, предоставляя набор методов для создания форм на основе ваших моделей. Этот хелпер создает HTML для форм, предоставляя метод для каждого типа полей ввода (например `text`, `password`, `select` и так далее). Когда форма подтверждается (т.е. когда пользователь нажимает кнопку подтверждения или `form.submit`, вызывается в JavaScript), поля ввода формы будут объединены в объект params и переданы в контроллер.

Существует два типа хелперов форм: те, которые работают с атрибутами модели, и те, которые нет. Этот хелпер относится к тем, которые работают с атрибутами модели; чтобы посмотреть примеры хелперов форм, которые не работают с атрибутами модели, обратитесь к документации `ActionView::Helpers::FormTagHelper`.

Основной метод этого хелпера, `form_for`, дает возможность создавать форму для экземпляра модели; например, допустим, что имеется модель `Person`, и мы хотим создать ее новый экземпляр:
```
# Note: переменная @person была создана в контроллере (т.е. @person = Person.new)
<%= form_for @person, url: { action: "create" } do |f| %>
  <%= f.text_field :first_name %>
  <%= f.text_field :last_name %>
  <%= submit_tag 'Create' %>
<% end %>
```
Созданным HTML будет:
```
<form class="new_person" id="new_person" action="/people" accept-charset="UTF-8" method="post">
  <input name="utf8" type="hidden" value="&#x2713;" />
  <input type="hidden" name="authenticity_token" value="lTuvBzs7ANygT0NFinXj98tfw3Emfm65wwYLbUvoWsK2pngccIQSUorM2C035M9dZswXgWTvKwFS8W5TVblpYw==" />
  <input type="text" name="person[first_name]" id="person_first_name" />
  <input type="text" name="person[last_name]" id="person_last_name" />
  <input type="submit" name="commit" value="Create" data-disable-with="Create" />
</form>
```
Объект params, созданный при отправке этой формы, будет выглядеть так:
```
{"utf8" => "✓", "authenticity_token" => "lTuvBzs7ANygT0NFinXj98tfw3Emfm65wwYLbUvoWsK2pngccIQSUorM2C035M9dZswXgWTvKwFS8W5TVblpYw==", "person" => {"first_name" => "William", "last_name" => "Smith"}, "commit" => "Create", "controller" => "people", "action" => "create"}
```
В хэше params будет вложенное значение `person`, к которому можно получить доступ в контроллере с помощью `params[:person]`.

##### `check_box`
Возвращает тег чекбокса с учетом доступа к определенному атрибуту.
```
# Допустим, что @article.validated? равен 1:
check_box("article", "validated")
# => <input type="checkbox" id="article_validated" name="article[validated]" value="1" />
#    <input name="article[validated]" type="hidden" value="0" />
```
##### `fields_for`
Создает пространство имен вокруг определенного объекта модели наподобие `form_for`, но не создает сами теги формы. Это делает `fields_for` подходящим для указания дополнительных объектов модели в той же форме:
```
<%= form_for @person, url: { action: "update" } do |person_form| %>
  First name: <%= person_form.text_field :first_name %>
  Last name : <%= person_form.text_field :last_name %>

  <%= fields_for @person.permission do |permission_fields| %>
    Admin?  : <%= permission_fields.check_box :admin %>
  <% end %>
<% end %>
```
##### `file_field`
Возвращает поле для загрузки файла с учетом доступа к определенному атрибуту.
```
file_field(:user, :avatar)
# => <input type="file" id="user_avatar" name="user[avatar]" />
```
##### `form_for`
Создает форму и пространство имен вокруг определенного объекта модели, используемого как основа для опроса значений полей.
```
<%= form_for @article do |f| %>
  <%= f.label :title, 'Title' %>:
  <%= f.text_field :title %><br>
  <%= f.label :body, 'Body' %>:
  <%= f.text_area :body %><br>
<% end %>
```
##### `hidden_field`
Возвращает тег скрытого поля с учетом доступа к определенному атрибуту.
```
hidden_field(:user, :token)
# => <input type="hidden" id="user_token" name="user[token]" value="#{@user.token}" />
```
#####  `label`
Возвращает тег `label` с учетом поля ввода для определенного атрибута.
```
label(:article, :title)
# => <label for="article_title">Title</label>
```
##### `password_field`
Возвращает тег `input` типа "password" с учетом доступа к определенному атрибуту.
```
password_field(:login, :pass)
# => <input type="text" id="login_pass" name="login[pass]" value="#{@login.pass}" />
```
##### `radio_button`
Возвращает тег радио кнопки с учетом доступа к определенному атрибуту.
```
# Let's say that @article.category returns "rails":
radio_button("article", "category", "rails")
radio_button("article", "category", "java")
# => <input type="radio" id="article_category_rails" name="article[category]" value="rails" checked="checked" />
#    <input type="radio" id="article_category_java" name="article[category]" value="java" />
```
##### `text_area`
Возвращает набор открывающего и закрывающего тега `textarea` с учетом доступа к определенному атрибуту.
```
text_area(:comment, :text, size: "20x30")
# => <textarea cols="20" rows="30" id="comment_text" name="comment[text]">
#      #{@comment.text}
#    </textarea>
```

##### `text_field`
Возвращает тег `input` типа "text" с учетом доступа к определенному атрибуту.
```
text_field(:article, :title)
# => <input type="text" id="article_title" name="article[title]" value="#{@article.title}" />
```

##### `email_field`
Возвращает тег `input` типа "email" с учетом доступа к определенному атрибуту.
```
email_field(:user, :email)
# => <input type="email" id="user_email" name="user[email]" value="#{@user.email}" />
```

##### `url_field`
Возвращает тег `input` типа "url" с учетом доступа к определенному атрибуту.
```
url_field(:user, :url)
# => <input type="url" id="user_url" name="user[url]" value="#{@user.url}" />
```

#### FormOptionsHelper
Предоставляет ряд методов для превращения различного рода контейнеров в набор тегов `option`.

##### `collection_select`
Возвращает теги `select` и `option` для коллекции значений, возвращаемых `method` для класса `object`.

Пример структуры объекта для использования с этим методом:
```
class Article < ApplicationRecord
  belongs_to :author
end

class Author < ApplicationRecord
  has_many :articles
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
```
Пример использования (выбор связанного `Author` для экземпляра `Article, @article`):
```
collection_select(:article, :author_id, Author.all, :id, :name_with_initial, { prompt: true })
```
Если `@article.author_id` — 1, это вернет:
```
<select name="article[author_id]">
  <option value="">Please select</option>
  <option value="1" selected="selected">D. Heinemeier Hansson</option>
  <option value="2">D. Thomas</option>
  <option value="3">M. Clark</option>
</select>
```

##### `collection_radio_buttons`
Возвращает теги `radio_button` для коллекции значений, возвращаемых `method` для класса `object`.

Пример структуры объекта для использования с этим методом:
```
class Article < ApplicationRecord
  belongs_to :author
end

class Author < ApplicationRecord
  has_many :articles
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
```
Пример использования (выбор связанного Author для экземпляра `Article, @article`):
```
collection_radio_buttons(:article, :author_id, Author.all, :id, :name_with_initial)
```
Если `@article.author_id` — 1, это вернет:
```
<input id="article_author_id_1" name="article[author_id]" type="radio" value="1" checked="checked" />
<label for="article_author_id_1">D. Heinemeier Hansson</label>
<input id="article_author_id_2" name="article[author_id]" type="radio" value="2" />
<label for="article_author_id_2">D. Thomas</label>
<input id="article_author_id_3" name="article[author_id]" type="radio" value="3" />
<label for="article_author_id_3">M. Clark</label>
```
Раскрыть, что некоторый вариант выбран (т.е. программно отметить объект из коллекции):
```
collection_radio_buttons(:article, :author_id, Author.all, :id, :name_with_initial, {checked: Author.last})
```
В этом случае, последний объект из коллекции будет отмечен:
```
<input id="article_author_id_1" name="article[author_id]" type="radio" value="1" />
<label for="article_author_id_1">D. Heinemeier Hansson</label>
<input id="article_author_id_2" name="article[author_id]" type="radio" value="2" />
<label for="article_author_id_2">D. Thomas</label>
<input id="article_author_id_3" name="article[author_id]" type="radio" value="3" checked="checked" />
<label for="article_author_id_3">M. Clark</label>
```
Чтобы программно получить доступ к переданным опциям (например, добавить пользовательский класс, если отмечен):

Образец `html.erb`
```
<%= collection_radio_buttons(:article, :author_id, Author.all, :id, :name_with_initial, {checked: Author.last, required: rue} do |rb| %>
      <%= rb.label(class: "#{'my-custom-class' if rb.value == Author.last.id}") { rb.radio_button + rb.text } %>
<% end %>
```
##### `collection_check_boxes`
Возвращает теги `check_box` для коллекции значений, возвращаемых `method` для класса `object`.

Пример структуры объекта для использования с этим методом:
```
class Article < ApplicationRecord
  has_and_belongs_to_many :authors
end

class Author < ApplicationRecord
  has_and_belongs_to_many :articles
  def name_with_initial
    "#{first_name.first}. #{last_name}"
  end
end
```
Пример использования (выбор связанного `Author` для экземпляра `Article, @article`):
```
collection_check_boxes(:article, :author_ids, Author.all, :id, :name_with_initial)
```
Если `@article.author_id` — [1], это вернет:
```
<input id="article_author_ids_1" name="article[author_ids][]" type="checkbox" value="1" checked="checked" />
<label for="article_author_ids_1">D. Heinemeier Hansson</label>
<input id="article_author_ids_2" name="article[author_ids][]" type="checkbox" value="2" />
<label for="article_author_ids_2">D. Thomas</label>
<input id="article_author_ids_3" name="article[author_ids][]" type="checkbox" value="3" />
<label for="article_author_ids_3">M. Clark</label>
<input name="article[author_ids][]" type="hidden" value="" />
```

##### `option_groups_from_collection_for_select`
Возвращает строку с тегами `option`, подобно `options_from_collection_for_select`, но группирует их тегами optgroup на основе объектных отношений аргументов.

Пример структуры объекта для использования с этим методом:
```
class Continent < ApplicationRecord
  has_many :countries
  # attribs: id, name
end

class Country < ApplicationRecord
  belongs_to :continent
  # attribs: id, name, continent_id
end
```
Пример использования:
```
option_groups_from_collection_for_select(@continents, :countries, :name, :id, :name, 3)
```
Возможный результат:
```
<optgroup label="Africa">
  <option value="1">Egypt</option>
  <option value="4">Rwanda</option>
  ...
</optgroup>
<optgroup label="Asia">
  <option value="3" selected="selected">China</option>
  <option value="12">India</option>
  <option value="5">Japan</option>
  ...
</optgroup>
```
Возвращаются только теги `optgroup` и `option`, вам все еще нужно обернуть результат в подходящий тег `select`.

##### `options_for_select`
Принимает контейнер (хэш, массив, перечисление, ваш тип) и возвращает строку тегов `option`.
```
options_for_select([ "VISA", "MasterCard" ])
# => <option>VISA</option> <option>MasterCard</option>
```
Возвращаются только теги `option`, вам все еще нужно обернуть результат в обычный HTML-тег `select`.

##### `options_from_collection_for_select`
Возвращает строку тегов option, собранную с помощью итерации по collection и назначая результат вызова value_method как значение option и text_method как текст option.

##### options_from_collection_for_select(collection, value_method, text_method, selected = nil)

Например, представим цикл, проходящий по каждому человеку в `@project.people` для создания тега ввода:
```
options_from_collection_for_select(@project.people, "id", "name")
# => <option value="#{person.id}">#{person.name}</option>
```
> Возвращаются только теги `option`, вам все еще нужно обернуть результат в обычный HTML-тег `select`.

##### `select`
Создает тег `select` и ряд связанных тегов option для предоставленного объекта и метода.

Пример:
```
select("article", "person_id", Person.all.collect { |p| [ p.name, p.id ] }, { include_blank: true })
```
Если `@article.person_id` — 1, это выдаст:
```
<select name="article[person_id]">
  <option value=""></option>
  <option value="1" selected="selected">David</option>
  <option value="2">Eileen</option>
  <option value="3">Rafael</option>
</select>
```
##### `time_zone_options_for_select`
Возвращает строку тегов `option` для практически любой временной зоны в мире.

##### `time_zone_select`
Возвращает теги `select` и `option` для заданного объекта и метода, используя `time_zone_options_for_select` для создания списка тегов `option`.
```
time_zone_select("user", "time_zone")
```

##### `date_field`
Возвращает тег `input` типа "date" с учетом доступа к определенному атрибуту.
```
date_field("user", "dob")
```

#### FormTagHelper
Предоставляет ряд методов для создания тегов форм, которые не зависят от объекта Active Record, назначенного шаблону, как делает `FormHelper`. Вместо этого вы предоставляете вручную имена и значения

##### `check_box_tag`
Создает тег поля ввода формы в виде чекбокса.
```
check_box_tag 'accept'
# => <input id="accept" name="accept" type="checkbox" value="1" />
```

##### `field_set_tag`
Создает `fieldset` для группировки элементов формы HTML.
```
<%= field_set_tag do %>
  <p><%= text_field_tag 'name' %></p>
<% end %>
# => <fieldset><p><input id="name" name="name" type="text" /></p></fieldset>
```

##### `file_field_tag`
Создает поле для загрузки файла.
```
<%= form_tag({ action:"post" }, multipart: true) do %>
  <label for="file">File to Upload</label> <%= file_field_tag "file" %>
  <%= submit_tag %>
<% end %>
```
Примерный результат:
```
file_field_tag 'attachment'
# => <input id="attachment" name="attachment" type="file" />
```

##### `form_tag`
Открывает тег `form`, указывающий `action` по URL-адресу, настроенный с помощью `url_for_options`, как `ActionController::Base#url_for`.
```
<%= form_tag '/articles' do %>
  <div><%= submit_tag 'Save' %></div>
<% end %>
# => <form action="/articles" method="post"><div><input type="submit" name="submit" value="Save" /></div></form>
```

##### `hidden_field_tag`
Создает скрытое поле `input`, используемое для передачи данных, которые будут потеряны из-за протокола без сохранения состояния HTTP, или данные, которые должны быть скрыты от пользователя.
```
hidden_field_tag 'token', 'VUBJKB23UIVI1UU1VOBVI@'
# => <input id="token" name="token" type="hidden" value="VUBJKB23UIVI1UU1VOBVI@" />
```

##### `image_submit_tag`
Отображает изображение, при нажатии на которое будет отправлена форма.
```
image_submit_tag("login.png")
# => <input src="/images/login.png" type="image" />
```

##### `label_tag`
Создает тег `label`.
```
label_tag 'name'
# => <label for="name">Name</label>
```

##### `password_field_tag`
Создает поле для ввода пароля, скрытое текстовое поле, которое спрячет то, что вводит пользователь символами маски.
```
password_field_tag 'pass'
# => <input id="pass" name="pass" type="password" />
```

##### `radio_button_tag`
Создает радиокнопку; используйте группу радиокнопок с одинаковым именем, чтобы пользователи могли выбирать из группы опций.
```
radio_button_tag 'favorite_color', 'maroon'
# => <input id="favorite_color_maroon" name="favorite_color" type="radio" value="maroon" />
```
##### `select_tag`
Создает выпадающий список.
```
select_tag "people", "<option>David</option>"
# => <select id="people" name="people"><option>David</option></select>
```
##### `submit_tag`
Создает кнопку для отправки формы с текстом-заголовком.
```
submit_tag "Publish this article"
# => <input name="commit" type="submit" value="Publish this article" />
```
##### `text_area_tag`
Создает область ввода текста; используйте `textarea` для длинного ввода текста, такого как статьи в блоге или описания.
```
text_area_tag 'article'
# => <textarea id="article" name="article"></textarea>
```
##### `text_field_tag`

Создает стандартное поле ввода текста; используйте их для ввода небольших кусочков текста, таких как имя пользователя или поисковый запрос.
```
text_field_tag 'name'
# => <input id="name" name="name" type="text" />
```
##### `email_field_tag`
Создает стандартное поле ввода с типом `email`.
```
email_field_tag 'email'
# => <input id="email" name="email" type="email" />
```
##### `url_field_tag`
Создает стандартное поле ввода с типом `url`.
```
url_field_tag 'url'
# => <input id="url" name="url" type="url" />
```
##### `date_field_tag`
Создает стандартное поле ввода с типом `date`.
```
date_field_tag "dob"
# => <input id="dob" name="dob" type="date" />
```

#### JavaScriptHelper
Предоставляет функциональность для работы с JavaScript в ваших вьюхах.

##### `escape_javascript`
Экранирует переводы строк и одиночные и двойные кавычки во фрагментах JavaScript.

##### `javascript_tag`
Возвращает тег JavaScript, оборачивающий предоставленный код.
```
javascript_tag "alert('All is good')"

<script>
//<![CDATA[
alert('All is good')
//]]>
</script>
```

#### NumberHelper
Предоставляет методы для конвертации чисел в форматированные строки. Методы предоставлены для телефонных номеров, валют, процентов, позиционных систем счисления и размеров файла.

##### `number_to_currency`
Форматирует число в строку с символом валюты (например, $13.65).
```
number_to_currency(1234567890.50) # => $1,234,567,890.50
```

##### `number_to_human_size`
Форматирует размер в байтах в более понятное представление; полезно для показа размеров файла пользователям.
```
number_to_human_size(1234)          # => 1.2 KB
number_to_human_size(1234567)       # => 1.2 MB
```

##### `number_to_percentage`
Форматирует число в строку с символом процента.
```
number_to_percentage(100, precision: 0)        # => 100%
```

##### `number_to_phone`
Форматирует число в телефонный номер (по умолчанию США).
```
number_to_phone(1235551234) # => 123-555-1234
```

##### `number_with_delimiter`
Форматирует число с сгруппированными тысячами, используя разделитель.
```
number_with_delimiter(12345678) # => 12,345,678
```

##### `number_with_precision`
Форматирует число с помощью определенного уровня точности, по умолчанию 3.
```
number_with_precision(111.2345)                # => 111.235
number_with_precision(111.2345, precision: 2)  # => 111.23
```

#### SanitizeHelper
Модуль SanitizeHelper предоставляет набор методов для очистки текста от нежелательных элементов HTML.

##### `sanitize`
Хелпер `sanitize` экранирует все теги HTML и удаляет все атрибуты, которые не разрешены явно.
```
sanitize @article.body
```
Если переданы опции или `:attributes`, или `:tags`, разрешены только упомянутые теги и атрибуты, и ничего более.
```
sanitize @article.body, tags: %w(table tr td), attributes: %w(id class style)
```
Чтобы изменить значения по умолчанию для многократного использования, например, добавить теги таблиц к значениям по умолчанию:
```
class Application < Rails::Application
  config.action_view.sanitized_allowed_tags = 'table', 'tr', 'td'
end
```

##### `sanitize_css(style)`
Экранирует блок кода CSS.

##### `strip_links(html)`
Обрезает все теги ссылок в тексте, оставляя только текст ссылки.
```
strip_links('<a href="https://rubyonrails.org">Ruby on Rails</a>')
# => Ruby on Rails

strip_links('emails to <a href="mailto:me@email.com">me@email.com</a>.')
# => emails to me@email.com.

strip_links('Blog: <a href="http://myblog.com/">Visit</a>.')
# => Blog: Visit.
```
##### `strip_tags(html)`
Обрезает все теги HTML из `html`, включая комментарии. Эта функция доступна, если подключен гем `rails-html-sanitizer`.
```
strip_tags("Strip <i>these</i> tags!")
# => Strip these tags!

strip_tags("<b>Bold</b> no more!  <a href='more.html'>See more</a>")
# => Bold no more!  See more
```
NB: Результат все еще может содержать неэкранированные символы '<', '>', '&' и путать браузеры.

#### CsrfHelper
Возвращает метатеги "csrf-param" и "csrf-token" с, соответственно, именами параметра и токена против межсайтовой подделки запроса.
```
<%= csrf_meta_tags %>
```
> Обычные формы создают скрытые поля, поэтому они не используют эти теги.

### Локализованные вьюхи <a name="3.1.7"></a>
В Action View есть возможность рендерить различные шаблоны в зависимости от текущей локали.

Например, предположим, что у вас есть `ArticlesController` с экшном `show`. По умолчанию вызов этого экшна отрендерит `app/views/articles/show.html.erb`. Но если вы установите `I18n.locale = :de`, то вместо него будет отрендерен `app/views/articles/show.de.html.erb`. Если локализованный шаблон отсутствует, будет использована недекорированная версия. Это означает, что не нужно предоставлять локализованные вьюхи для всех случаев, но они будут предпочтительными и будут использоваться, если станут доступны.

Ту же технику можно использовать для локализации страниц ошибок в директории `public`. Например, установка `I18n.locale = :de` и создание `public/500.de.html` и `public/404.de.html` позволит иметь локализованные страницы ошибок.

Так как Rails не ограничивает символы, используемые для установления `I18n.locale`, эту систему можно использовать для отображения различного содержимого, зависящего от чего-либо иного. Например, предположим у вас есть пользователи "expert", которые должны видеть страницы иные, чем пользователи "normal". Можно добавить следующее в `app/controllers/application.rb`:
```
before_action :set_expert_locale

def set_expert_locale
  I18n.locale = :expert if current_user.expert?
end
```
Затем можно добавить специальные вьюхи, такие как `app/views/articles/show.expert.html.erb` которые будут отображены только пользователям `expert`.

## Макеты и рендеринг в Rails <a name="3.2"></a>

### Обзор: как кусочки складываются вместе <a name="3.2.1"></a>
Это руководство сосредотачивается на взаимодействии между контроллером и вьюхой (представлением) в треугольнике модель-представление-контроллер (MVC). Как вы знаете, контроллер ответственен за управление целым процессом обслуживания запросов в Rails, хотя обычно любой серьезный код переносится в модель. Но когда приходит время послать отклик обратно пользователю, контроллер передает все вьюхе. Именно этой передаче посвящено данное руководство.

В общих чертах все связано с решением, что же должно быть послано как отклик, и вызовом подходящего метода для создания этого отклика. Если откликом является полноценная вьюха, Rails также проводит дополнительную работу по упаковыванию вьюхи в макет и, возможно, по вставке частичных вьюх. В общем, все эти этапы вы увидите сами в следующих разделах.

### Создание откликов <a name="3.2.2"></a>
С точки зрения контроллера есть три способа создать отклик HTTP:
* Вызвать `render` для создания полного отклика, возвращаемого браузеру
* Вызвать `redirect_to` для передачи браузеру кода переадресации HTTP
* Вызвать `head` для создания отклика, включающего только заголовки HTTP, возвращаемого браузеру 

#### Рендеринг по умолчанию: соглашения по конфигурации в действии
Вы уже слышали, что Rails содействует принципу "соглашения по конфигурации". Рендеринг по умолчанию - прекрасный пример этого. По умолчанию контроллеры в Rails автоматически рендерят вьюхи с именами, соответствующими валидным маршрутам. 
Итак, в нашей вьюхе мы хотим отобразить свойства всех книг, это делается с помощью шаблона ERB, подобного следующему:
```
<h1>Listing Books</h1>

<table>
  <thead>
    <tr>
      <th>Title</th>
      <th>Content</th>
      <th colspan="3"></th>
    </tr>
  </thead>

  <tbody>
    <% @books.each do |book| %>
      <tr>
        <td><%= book.title %></td>
        <td><%= book.content %></td>
        <td><%= link_to "Show", book %></td>
        <td><%= link_to "Edit", edit_book_path(book) %></td>
        <td><%= link_to "Destroy", book, method: :delete, data: { confirm: "Are you sure?" } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to "New book", new_book_path %>
```
> Фактически рендеринг осуществляется вложенными классами модуля `ActionView::Template::Handlers`. Мы не будем углубляться в этот процесс, но важно знать, что расширение файла вьюхи контролирует выбор обработчика шаблона.

#### Использование `render`
Во многих случаях метод `ActionController::Base#render` выполняет большую работу по рендерингу содержимого Вашего приложения для использования в браузере. Имеются различные способы настройки возможностей render. Вы можете рендерить вьюху по умолчанию для шаблона Rails, или определенный шаблон, или файл, или встроенный код, или совсем ничего. Можно рендерить текст, JSON или XML. Также можно определить тип содержимого или статус HTTP отрендеренного отклика.

Если хотите увидеть точные результаты вызова `render` без необходимости проверять это в браузере, можете вызвать `render_to_string`. Этот метод принимает те же самые опции, что и render, но возвращает строку вместо отправки отклика обратно браузеру.

##### Рендеринг вьюхи экшна

Если хотите отрендерить вьюху, соответствующую другому шаблону этого же контроллера, можно использовать `render` с именем вьюхи:
```
def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render "edit"
  end
end
```
Если вызов `update` проваливается, вызов экшна `update` в этом контроллере отрендерит шаблон `edit.html.erb`, принадлежащий тому же контроллеру.

Если хотите, можете использовать символ вместо строки для определения экшна для рендеринга:
```
def update
  @book = Book.find(params[:id])
  if @book.update(book_params)
    redirect_to(@book)
  else
    render :edit
  end
end
```

##### Рендеринг шаблона экшна из другого контроллера

Что, если вы хотите отрендерить шаблон из абсолютно другого контроллера? Это можно также сделать с `render`, который принимает полный путь шаблона для рендеринга (относительно `app/views`). Например, если запускаем код в `AdminProductsController` который находится в `app/controllers/admin`, можете отрендерить результат экшна в шаблон в `app/views/products` следующим образом:
```
render "products/show"
```
Rails знает, что эта вьюха принадлежит другому контроллеру, поскольку содержит символ слэша в строке. Если хотите быть точными, можете использовать опцию `:template` (которая требовалась в Rails 2.2 и более ранних):
```
render template: "products/show"
```

##### Оборачивание
Вышеописанные три метода рендеринга (рендеринг другого шаблона в контроллере, рендеринг шаблона в другом контроллере и рендеринг произвольного файла в файловой системе) на самом деле являются вариантами одного и того же экшна.

Фактически в классе `BooksController`, в экшне `update`, в котором мы хотим отрендерить шаблон `edit`, если книга не была успешно обновлена, все нижеследующие вызовы отрендерят шаблон `edit.html.erb` в директории `views/books`:
```
render :edit
render action: :edit
render "edit"
render action: "edit"
render "books/edit"
render template: "books/edit"
```
Какой из них вы будете использовать - это вопрос стиля и соглашений, но практическое правило заключается в использовании простейшего, который больше подходит по стилю написания вашего кода.

##### Использование `render` с `:inline`
Метод `render` вполне может обойтись без вьюхи, если вы используете опцию `:inline` для поддержки ERB, как части вызова метода. Это вполне валидно:
```
render inline: "<% products.each do |p| %><p><%= p.name %></p><% end %>"
```
> Должно быть серьезное основание для использования этой опции. Вкрапление ERB в контроллер нарушает MVC ориентированность Rails и создает трудности для других разработчиков в следовании логике вашего проекта. Вместо этого используйте отдельную erb-вьюху.

По умолчанию встроенный рендеринг использует ERB. Можете принудить использовать вместо этого `Builder` с помощью опции `:type`:
```
render inline: "xml.p {'Horrid coding practice!'}", type: :builder
```

##### Рендеринг текста

Вы можете послать простой текст - совсем без разметки - обратно браузеру с использованием опции `:plain` в `render`:
```
render plain: "OK"
```
> Рендеринг чистого текста наиболее полезен, когда вы делаете Ajax-отклик или отвечаете на запросы веб-сервиса, ожидающего что-то иное, чем HTML.

> По умолчанию при использовании опции `:plain` текст рендерится без использования текущего макета. Если хотите, чтобы Rails вложил текст в текущий макет, необходимо добавить опцию `layout: true` и использовать расширение `.text.erb` для файла макета.

##### Рендеринг HTML
Вы можете вернуть HTML, используя опцию `:html` метода `render`:
```
render html: helpers.tag.strong('Not Found')
```

> Это полезно когда вы хотите отрендерить небольшой кусочек HTML-кода. Однако, если у вас достаточно сложная разметка, стоит рассмотреть выделение её в файл шаблона.

> Когда используется опция `html:`, HTML объекты будут экранироваться, если строка не состоит из API, поддерживающих `html_safe`.

##### Рендеринг JSON
JSON - это формат данных JavaScript, используемый многими библиотеками Ajax. Rails имеет встроенную поддержку для преобразования объектов в JSON и рендеринга этого JSON обратно браузеру:
```
render json: @product
```
> Не нужно вызывать `to_json` в объекте, который хотите рендерить. Если используется опция `:json`, `render` автоматически вызовет `to_json` за вас.

##### Рендеринг XML
Rails также имеет встроенную поддержку для преобразования объектов в XML и рендеринга этого XML обратно вызывающему:
```
render xml: @product
```
Не нужно вызывать `to_xml` в объекте, который хотите рендерить. Если используется опция `:xml`, render автоматически вызовет `to_xml` за вас.

##### Рендеринг внешнего JavaScript
Rails может рендерить чистый JavaScript:
```
render js: "alert('Hello Rails');"
```
Это пошлет указанную строку в браузер с типом MIME `text/javascript`.

##### Рендеринг необработанного содержимого
Вы можете вернуть необработанный текст, без установки типа содержимого, используя опцию `:body`, метода `render`:
```
render body: "raw"
```
> Эта опция должна использоваться, только если не важен тип содержимого отклика. Использование `:plain` или `:html` уместнее в большинстве случаев.

> Возвращенным откликом от этой опции будет `text/plain` (если не будет переопределен), так как это тип содержимого по умолчанию у отклика `Action Dispatch`.

##### Рендеринг необработанного файла
Rails может рендерить необработанный файл по абсолютному пути. Это полезно для условного рендеринга статичных файлов, таких как страницы ошибок.
```
render file: "#{Rails.root}/public/404.html", layout: false
```
Это отрендерит необработанный файл (ERB или другие обработчики не поддерживаются). По умолчанию файл рендерится с использованием текущего макета.

> Использование опции `:file` в комбинации с данными, введенными пользователем, может привести к проблемам безопасности, так как злоумышленник может использовать этот экшн для доступа к чувствительным, с точки зрения безопасности, файлам вашей файловой системы.

> `send_file` часто является более быстрым и лучшим вариантом, если макет не требуется.

##### Опции для render
Вызов метода render как правило принимает шесть опций:
* `:content_type`
* `:layout`
* `:location`
* `:status`
* `:formats`
* `:variants` 

###### Опция `:content_type`
По умолчанию Rails будет обрабатывать результаты операции рендеринга с типом содержимого MIME `text/html` (или `application/json`, если используется опция `:json`, или `application/xml` для опции `:xml`). Иногда бывает так, что нужно изменить это, и тогда необходимо настроить опцию `:content_type`:
```
render template: "feed", content_type: "application/rss"
```

###### Опция `:layout`
С большинством опций для render, отрендеренное содержимое отображается как часть текущего макета.
Опция `:layout` нужна, чтобы сообщить Rails о необходимости использовать определенный файл как макет для текущего экшна:
```
render layout: "special_layout"
```
Также можно сообщить Rails, что требуется рендерить вообще без макета:
```
render layout: false
```

###### Опция `:location`
Опцию `:location` можно использовать, чтобы установить заголовок HTTP Location:
```
render xml: photo, location: photo_url(photo)
```

###### Опция `:status`

Rails автоматически сгенерирует отклик с правильным кодом статуса HTML (в большинстве случаев равный 200 OK). Опцию `:status` можно использовать, чтобы изменить это:
```
render status: 500
render status: :forbidden
```
> Если попытаться отрендерить содержимое наряду с кодом статуса без содержимого (100-199, 204, 205 или 304), он будет исключён из отклика.

###### Опция `:formats`

Rails использует формат, определённый в запросе (или `:html` по умолчанию). Вы можете изменить его, передав в опцию `:formats` символ или массив:
```
render formats: :xml
render formats: [:json, :xml]
```
Если шаблон с указанным форматом не существует, вызывается ошибка `ActionView::MissingTemplate`.

###### Опция `:variants`
Она сообщает Rails искать варианты шаблона того же формата. Можно указать список вариантов, передав опции `:variants` символ или массив.

Пример использования.
```
# called in HomeController#index
render variants: [:mobile, :desktop]
```
С таком набором вариантов, Rails будет искать следующий набор шаблонов и использовать первый из существующих.
* `app/views/home/index.html+mobile.erb`
* `app/views/home/index.html+desktop.erb`
* `app/views/home/index.html.erb`
Если шаблон с указанным форматом не существует, будет вызвана ошибка `ActionView::MissingTemplate`.

Вместо указания варианта на вызове `render`, его также можно установить на объекте `request` в экшне контроллера.
```
def index
  request.variant = determine_variant
end

private

def determine_variant
  variant = nil
  # некоторый код для определения варианта(ов) для использования
  variant = :mobile if session[:use_mobile]

  variant    
end
```

###### Поиск макетов
Чтобы найти текущий макет, Rails сначала смотрит файл в `app/views/layouts` с именем, таким же, как имя контроллера. Например, рендеринг экшнов из класса `PhotosController` будет использовать `/app/views/layouts/photos.html.erb` (или `app/views/layouts/photos.builder`). Если такого макета нет, Rails будет использовать `/app/views/layouts/application.html.erb` или `/app/views/layouts/application.builder`. Если макет `.erb` отсутствует, Rails будет использовать макет `.builder`, если таковой имеется. Rails также предоставляет несколько способов для более точного назначения определенных макетов отдельным контроллерам и экшнам.

###### Определение макетов для контроллеров
Вы можете переопределить дефолтные соглашения по макетам в контроллере, используя объявление `layout`. Например:
```
class ProductsController < ApplicationController
  layout "inventory"
  #...
end
```
С этим объявлением все вьюхи, отрендеренные `ProductsController`, будут использовать `app/views/layouts/inventory.html.erb` как макет.

Чтобы привязать определенный макет к приложению в целом, используйте объявление `layout` в классе `ApplicationController`:
```
class ApplicationController < ActionController::Base
  layout "main"
  #...
end
```
С этим объявлением каждая из вьюх во всем приложении будет использовать `app/views/layouts/main.html.erb` как макет.

###### Выбор макетов во время выполнения
Можно использовать символ для отсрочки выбора макета до тех пор, пока не будет обработан запрос:
```
class ProductsController < ApplicationController
  layout :products_layout

  def show
    @product = Product.find(params[:id])
  end

  private
    def products_layout
      @current_user.special? ? "special" : "products"
    end
end
```
Теперь, если текущий пользователь является специальным, он получит специальный макет при просмотре продукта.

Можно даже использовать встроенный метод, такой как `Proc`, для определения макета. Например, если передать объект `Proc`, то блоку, которому вы передаете `Proc`, будет предоставлен экземпляр `controller`, поэтому макет может быть определен, основываясь на текущем запросе:
```
class ProductsController < ApplicationController
  layout Proc.new { |controller| controller.request.xhr? ? "popup" : "application" }
end
```

###### Условные макеты
Макеты, определенные на уровне контроллера, поддерживают опции `:only` и `:except`. Эти опции принимают либо имя метода, либо массив имен методов, соответствующих именам методов в контроллере:
```
class ProductsController < ApplicationController
  layout "product", except: [:index, :rss]
end
```
С таким объявлением макет `product` будет использован везде, кроме методов `rss` и `index`.

###### Наследование макета

Объявление макета ниже по иерархии и более специфическое объявление макета всегда переопределяет более общие. 

###### Наследование шаблона
Следуя логике наследования макета, если шаблон или партиал не найдены по обычному пути, контроллер будет искать шаблон или партиал для рендеринга по цепочке наследования. Например:
```
# in app/controllers/application_controller
class ApplicationController < ActionController::Base
end

# in app/controllers/admin_controller
class AdminController < ApplicationController
end

# in app/controllers/admin/products_controller
class Admin::ProductsController < AdminController
  def index
  end
end
```
Порядок поиска экшна admin/products#index будет такой:
* `app/views/admin/products/`
* `app/views/admin/`
* `app/views/application/` 

Это делает `app/views/application/` хорошим местом для общих партиалов, которые затем могут быть отрендерены в ERB следующим образом:
```
<%# app/views/admin/products/index.html.erb %>
<%= render @products || "empty_list" %>

<%# app/views/application/_empty_list.html.erb %>
There are no items in this list <em>yet</em>.
```

###### Избегание ошибок двойного рендеринга
Рано или поздно, большинство разработчиков на Rails увидят сообщение об ошибке "Can only render or redirect once per action". Хоть такое и раздражает, это относительно просто правится. Обычно такое происходит в связи с фундаментальным непониманием метода работы `render`.

Например, вот некоторый код, который вызовет эту ошибку:
```
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
  render action: "regular_show"
end
```
Если `@book.special?` вычисляется как `true`, Rails начинает процесс рендеринга, выгружая переменную `@book` во вьюху `special_show`. Но это не остановит от выполнения остальной код в экшне `show`, и когда Rails достигнет конца экшна, он начнет рендерить вьюху `show` - и выдаст ошибку. Решение простое: убедитесь, что у вас есть только один вызов `render` или `redirect` за один проход. Еще может помочь такая вещь, как `and return`. Вот исправленная версия метода:
```
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show" and return
  end
  render action: "regular_show"
end
```
Убедитесь, что используете `and return` вместо `&& return`, поскольку `&& return` не будет работать в связи с приоритетом операторов в языке Ruby.

Отметьте, что неявный рендер, выполняемый `ActionController`, определяет, был ли вызван render поэтому следующий код будет работать без проблем:
```
def show
  @book = Book.find(params[:id])
  if @book.special?
    render action: "special_show"
  end
end
```
Это отрендерит книгу (book) с `special?`, заданным с помощью шаблона `special_show`, в то время как остальные книги будут рендериться с дефолтным шаблоном `show`.

#### Использование `redirect_to`
Другой способ управлять возвратом отклика на HTTP-запрос - с помощью `redirect_to`. Как вы видели, render сообщает Rails, какую вьюху (или иной ассет) использовать при построении отклика. Метод `redirect_to` делает нечто совершенно отличное: он говорит браузеру послать новый запрос по другому URL. Например, можно перенаправить из любого места, где сейчас выполняется код, к экшну `index` фотографий вашего приложения с помощью этого вызова:
```
redirect_to photos_url
```
Можно использовать `redirect_back`, чтобы вернуть пользователя на страницу с которой он только что пришел. Это место расположения вытаскивается из заголовка HTTP_REFERER, который не обязательно будет установлен браузером, поэтому нужно предоставить `fallback_location` для использования в таком случае.
```
redirect_back(fallback_location: root_path)
```

> `redirect_to` и `redirect_back` не прерывают и не возвращают из выполняемого метода немедленно, а просто устанавливают отклики HTTP. Выражения, следующие после них в методе, будут выполнены. При необходимости можно прервать явным `return` или любым другим механизмом прерывания.

##### Получение различного кода статуса перенаправления

Rails использует код статуса HTTP 302, временное перенаправление, при вызове `redirect_to`. Если хотите использовать иной код статуса, возможно 301, постоянное перенаправление, можете использовать опцию `:status`:
```
redirect_to photos_path, status: 301
```
Подобно опции `:status` для render, `:status` для `redirect_to` принимает и числовые, и символьные обозначения заголовка.

##### Различие между `render` и `redirect_to`
Иногда неопытные разработчики думают о `redirect_to` как о разновидности команды `goto`, перемещающую выполнение из одного места в другое в вашем коде Rails. Это не верно. Ваш код останавливается и ждет нового запроса от браузера. Просто получается так, что вы говорите браузеру, какой запрос он должен сделать следующим, возвращая код статуса HTTP 302.

Рассмотрим эти экшны, чтобы увидеть разницу:
```
def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    render action: "index"
  end
end
```
С кодом в такой форме, вероятно, будет проблема, если переменная `@book` равна `nil`. Помните, `render :action` **не запускает какой-либо код в указанном экшне**, и таким образом ничего не будет присвоено переменной `@books`, которую, возможно, потребует вьюха `index`. Один из способов исправить это - использовать перенаправление вместо рендеринга:
```
def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    redirect_to action: :index
  end
end
```

С помощью этого кода браузер сделает новый запрос для индексной страницы, код в методе `index` запустится, и все будет хорошо.

Единственный недостаток этого кода в том, что он требует круговорот через браузер: браузер запрашивает экшн `show` с помощью `/books/1`, и контроллер обнаруживает, что книг нет, поэтому отсылает отклик-перенаправление 301 браузеру, сообщающий перейти на `/books/`, браузер выполняет и посылает новый запрос контроллеру, теперь запрашивая экшн `index`, затем контроллер получает все книги в базе данных и рендерит шаблон `index`, отсылает его обратно браузеру, который затем показывает его на экране.

Пока это небольшое приложение, такая добавленная задержка не может быть проблемой, но иногда стоит подумать о том, является ли время отклика проблемой. Можем продемонстрировать один из способов управления этим с помощью хитрого примера:
```
def index
  @books = Book.all
end

def show
  @book = Book.find_by(id: params[:id])
  if @book.nil?
    @books = Book.all
    flash.now[:alert] = "Your book was not found"
    render "index"
  end
end
```
Это обнаружит, что нет книг с определенным ID, заполнит переменную экземпляра @books всеми книгами в модели, и затем напрямую отрендерит шаблон `index.html.erb`, возвратив его браузеру с предупреждающим сообщением в `flash`, сообщающим пользователю, что произошло.

#### Использование `head` для создания отклика, содержащего только заголовок
Метод `head` может использоваться для отправки браузеру откликов, содержащих только заголовки. Метод `head` принимает число или символ (смотрите таблицу соответствия), представляющие код статуса HTTP. Аргумент опций интерпретируется как хэш заголовков имен и значений. Например, можно возвратить только заголовок ошибки:
```
head :bad_request
```
Это создаст следующий заголовок:
```
HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
```
Или можете использовать другие заголовки HTTP для передачи другой информации:
```
head :created, location: photo_path(@photo)
```
Что создаст:
```
HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
```

### Структурирование макетов <a name="3.2.3"></a>
В макетах у вас есть доступ к трем инструментам для объединения различных кусочков результата для формирования общего отклика:
* Теги ассетов
* `yield` и `content_for`
* Партиалы 

#### Хелперы ассетных тегов
Хелперы ассетных тегов предоставляют методы для генерации HTML, связывающие вьюхи с лентами новостей, JavaScript, таблицами стилей, изображениями, видео и аудио. В Rails доступно шесть хелперов ассетных тегов:
* `auto_discovery_link_tag`
* `javascript_include_tag`
* `stylesheet_link_tag`
* `image_tag`
* `video_tag`
* `audio_tag` 
Эти теги можно использовать в макетах или других вьюхах, хотя `auto_discovery_link_tag`, `javascript_include_tag` и `stylesheet_link_tag` как правило используются в разделе `<head>` макета.

> Хелперы ассетных тегов не проверяют существование ассетов по заданному месту расположения; они просто предполагают, что вы знаете, что делаете, и генерируют ссылку.

##### Присоединение каналов с помощью `auto_discovery_link_tag`

Хелпер `auto_discovery_link_tag` создает HTML-код, который большинство браузеров и агрегаторов новостей могут использовать для определения наличия каналов RSS, Atom или JSON лент. Он принимает тип ссылки (`:rss`, `:atom` или `:json`), хэш опций, которые передаются через `url_for`, и хэш опций для тега:
```
<%= auto_discovery_link_tag(:rss, {action: "feed"},
  {title: "RSS Feed"}) %>
```
Вот три опции тега, доступные для `auto_discovery_link_tag`:
* `:rel` определяет значение rel в ссылке. Значение по умолчанию "alternate"
* `:type` определяет явный тип MIME. Rails генерирует подходящий тип MIME автоматически
* `:title` определяет заголовок ссылки. Значение по умолчанию это значение `:type` в верхнем регистре, например, "ATOM" или "RSS". 

##### Присоединение файлов JavaScript с помощью `javascript_include_tag`
Хелпер `javascript_include_tag` возвращает HTML-тег script для каждого предоставленного источника.

При использовании Rails с включенным Asset Pipeline, этот хелпер сгенерирует ссылку на `/assets/javascripts/`, а не на `public/javascripts`, которая использовалась в более ранних версиях Rails. Затем эта ссылка обслуживается файлопроводом (`asset pipeline`).

Файл JavaScript в приложении Rails или Rails Engine размещается в одном из трех мест расположения: `app/assets`, `lib/assets` или `vendor/assets`.
Можно определить полный путь относительно корня документа или URL, по желанию. Например, сослаться на файл JavaScript, находящийся в директории с именем javascripts в одной из `app/assets`, `lib/assets` или `vendor/assets`, можно так:
```
<%= javascript_include_tag "main" %>
```
Rails тогда выдаст такой тег script:
```
<script src='/assets/main.js'></script>
```
Затем запрос к этому ассету будет обслужен гемом `Sprockets`.

Чтобы включить несколько файлов, таких как `app/assets/javascripts/main.js` и `app/assets/javascripts/columns.js` за один раз:
```
<%= javascript_include_tag "main", "columns" %>
```
Чтобы включить `app/assets/javascripts/main.js` и `app/assets/javascripts/photos/columns.js`:
```
<%= javascript_include_tag "main", "/photos/columns" %>
```
Чтобы включить `http://example.com/main.js`:
```
<%= javascript_include_tag "http://example.com/main.js" %>
```

##### Присоединение файлов CSS с помощью `stylesheet_link_tag`
Хелпер `stylesheet_link_tag` возвращает HTML-тег <link> для каждого предоставленного источника.

При использовании Rails с включенным "Asset Pipeline", этот хелпер сгенерирует ссылку на `/assets/stylesheets/`. Эта ссылка будет затем обработана гемом `Sprockets`. Файл таблицы стилей может быть размещен в одном из трех мест расположения: `app/assets`, `lib/assets` или `vendor/assets`.

Можно определить полный путь относительно корня документа или URL. Например, на файл таблицы стилей в директории `stylesheets`, размещенной в одной из `app/assets`, `lib/assets` или `vendor/assets`, можно сослаться так:
```
<%= stylesheet_link_tag "main" %>
```
Чтобы включить `app/assets/stylesheets/main.css` и `app/assets/stylesheets/columns.css`:
```
<%= stylesheet_link_tag "main", "columns" %>
```
Чтобы включить `app/assets/stylesheets/main.css` и `app/assets/stylesheets/photos/columns.css`:
```
<%= stylesheet_link_tag "main", "/photos/columns" %>
```
Чтобы включить `http://example.com/main.css`:
```
<%= stylesheet_link_tag "http://example.com/main.css" %>
```
По умолчанию `stylesheet_link_tag` создает ссылки с `media="screen" rel="stylesheet"`. Можно переопределить любое из этих дефолтных значений, указав соответствующую опцию (`:media`, `:rel`):
```
<%= stylesheet_link_tag "main_print", media: "print" %>
```

##### Присоединение изображений с помощью `image_tag`
Хелпер `image_tag` создает HTML-тег <img /> для определенного файла. По умолчанию файлы загружаются из `public/images`.

Обратите внимание, что нужно указывать расширение изображения.
```
<%= image_tag "header.png" %>
```
Вы можете предоставить путь к изображению, если желаете:
```
<%= image_tag "icons/delete.gif" %>
```
Вы можете предоставить хэш дополнительных опций HTML:
```
<%= image_tag "icons/delete.gif", {height: 45} %>
```
Или альтернативный текст, если пользователь отключил показ изображений в браузере. Если вы не определили явно тег `alt`, по умолчанию будет указано имя файла с большой буквы и без расширения. Например, эти два тега изображения возвратят одинаковый код:
```
<%= image_tag "home.gif" %>
<%= image_tag "home.gif", alt: "Home" %>
```
Можете указать специальный тег `size` в формате "{width}x{height}":
```
<%= image_tag "home.gif", size: "50x20" %>
```
В дополнение к вышеописанным специальным тегам, можно предоставить итоговый хэш стандартных опций HTML, таких как `:class` или `:id`, или `:name`:
```
<%= image_tag "home.gif", alt: "Go Home",
                          id: "HomeImage",
                          class: "nav_bar" %>
```

##### Присоединение видео с помощью `video_tag`
Хелпер `video_tag` создает тег HTML 5 `<video>` для определенного файла. По умолчанию файлы загружаются из `public/videos`.
```
<%= video_tag "movie.ogg" %>
```
Создаст
```
<video src="/videos/movie.ogg" />
```
Подобно `image_tag`, можно предоставить путь или абсолютный, или относительный к директории `public/videos`. Дополнительно можно определить опцию `size`: "#{width}x#{height}", как и в `image_tag`. Теги видео также могут иметь любые опции HTML, определенные в конце (`id`, `class` и др.).

Тег видео также поддерживает все HTML-опции <video> через хэш HTML-опций, включая:
* `poster`: "image_name.png", предоставляет изображение, которое будет отображаться вместо видео прежде, чем оно начнет проигрываться.
* `autoplay`: true, запускает проигрывание видео при загрузке страницы.
* `loop`: true, запускает видео сначала, как только оно достигает конца.
* `controls`: true, предоставляет пользователю поддерживаемую браузером панель управления для взаимодействия с видео.
* `autobuffer`: true, файл видео предварительно загружается для пользователя при загрузке страницы. 

Также можно определить несколько видео для проигрывания, передав массив видео в `video_tag`:
```
<%= video_tag ["trailer.ogg", "movie.ogg"] %>
```
Это создаст:
```
<video>
  <source src="/videos/trailer.ogg" />
  <source src="/videos/movie.ogg" />
</video>
```
##### Присоединение аудиофайлов с помощью `audio_tag`
Хелпер `audio_tag` создает тег HTML 5 `<audio>` для определенного файла. По умолчанию файлы загружаются из `public/audios`.
```
<%= audio_tag "music.mp3" %>
```
Если хотите, можете предоставить путь к аудио файлу:
```
<%= audio_tag "music/first_song.mp3" %>
```
Также можно предоставить хэш дополнительных опций, таких как `:id`, `:class` и т.д.

Подобно `video_tag`, `audio_tag` имеет специальные опции:
* `autoplay`: true, начинает воспроизведение аудио при загрузке страницы
* `controls`: true, предоставляет пользователю поддерживаемую браузером панель управления для взаимодействия с аудио.
* `autobuffer`: true, файл аудио предварительно загружается для пользователя при загрузке страницы. 

#### Понимание `yield`
В контексте макета, `yield` определяет раздел, где должно быть вставлено содержимое из вьюхи. Самый простой способ его использования - это иметь один `yield` там, куда вставится все содержимое вьюхи, которая в настоящий момент рендерится:
```
<html>
  <head>
  </head>
  <body>
  <%= yield %>
  </body>
</html>
```
Также можете создать макет с несколькими разделами `yield`:
```
<html>
  <head>
  <%= yield :head %>
  </head>
  <body>
  <%= yield %>
  </body>
</html>
```
Основное тело вьюхи всегда рендериться в неименованный `yield`. Чтобы рендерить содержимое в именованный `yield`, используйте метод `content_for`.

#### Использование метода `content_for`
Метод `content_for` позволяет вставлять содержимое в именованный блок `yield` в макете. Например, эта вьюха будет работать с макетом, который вы только что видели:
```
<% content_for :head do %>
  <title>A simple page</title>
<% end %>

<p>Hello, Rails!</p>
```
Результат рендеринга этой страницы в макет будет таким HTML:
```
<html>
  <head>
  <title>A simple page</title>
  </head>
  <body>
  <p>Hello, Rails!</p>
  </body>
</html>
```
Метод `content_for` может помочь, когда макет содержит отдельные разделы, такие как боковые панели или футеры, в которые нужно вставить свои блоки содержимого. Это также полезно при вставке тегов, загружающих специфичные для страницы файлы JavaScript или css в хедер макета в целом.

#### Использование партиалов
Частичные шаблоны - также называемые "партиалы" - являются еще одним подходом к разделению процесса рендеринга на более управляемые кусочки. С партиалами можно перемещать код для рендеринга определенных частей отклика в свои отдельные файлы.

##### Именование партиалов
Чтобы отрендерить партиал как часть вьюхи, используем метод render внутри вьюхи:
```
<%= render "menu" %>
```
Это отрендерит файл, названный `_menu.html.erb` в этом месте в пределах рендерящейся вьюхи. Обратите внимание на начальный символ подчеркивания: файлы партиалов начинаются со знака подчеркивания, чтобы отличать их от обычных вьюх, несмотря на то, что в вызове они указаны без подчеркивания. Это справедливо даже тогда, когда партиалы вызываются из другой папки:
```
<%= render "shared/menu" %>
```
Этот код вытянет партиал из `app/views/shared/_menu.html.erb`.

Использование партиалов для упрощения вьюх

Один из способов применения партиалов это использоваться их как эквивалент подпрограмм: способ переместить часть разметки из вьюхи так, чтобы можно было легче понять, что там происходит. Например, у вас может быть такая вьюха:
```
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
...

<%= render "shared/footer" %>
```
Здесь партиалы `_ad_banner.html.erb` и `_footer.html.erb` могут содержать контент, общий для многих страниц приложения. Нет необходимости видеть код этих разделов, чтобы сконцентрироваться на определенной странице.

Как видно из предыдущих разделов данного руководства, `yield` является очень мощным инструментом для очистки ваших макетов. Имейте в виду, что это чистый Ruby, так что можно использовать его практически везде. Например, его можно использовать для соблюдения принципа DRY при определении макета формы для нескольких похожих ресурсов:
```
    users/index.html.erb

    <%= render "shared/search_filters", search: @q do |f| %>
      <p>
        Name contains: <%= f.text_field :name_contains %>
      </p>
    <% end %>

    roles/index.html.erb

    <%= render "shared/search_filters", search: @q do |f| %>
      <p>
        Title contains: <%= f.text_field :title_contains %>
      </p>
    <% end %>

    shared/_search_filters.html.erb

    <%= form_for(search) do |f| %>
      <h1>Search form:</h1>
      <fieldset>
        <%= yield f %>
      </fieldset>
      <p>
        <%= f.submit "Search" %>
      </p>
    <% end %>
```
> Для содержимого, общего для всех страниц приложения, можно использовать партиалы прямо в макетах.

##### Макеты партиала
Партиал может использовать свой собственный файл макета, подобно тому, как вьюха может использовать макет. Например, можете вызвать подобный партиал:
```
<%= render partial: "link_area", layout: "graybar" %>
```
Это найдет партиал с именем `_link_area.html.erb` и отрендерит его, используя макет` _graybar.html.erb`. Отметьте, что макеты для партиалов также начинаются с подчеркивания, как и обычные партиалы, и размещаются в той же папке с партиалами, которым они принадлежат (не в основной папке `layouts`).

Также отметьте, что явное указание `partial` необходимо, когда передаются дополнительные опции, такие как `layout`

##### Передача локальных переменных

В партиалы также можно передавать локальные переменные, что делает их более мощными и гибкими. Например, можете использовать такую технику для уменьшения дублирования между страницами `new` и `edit`, сохранив немного различающееся содержимое:
```
    new.html.erb

    <h1>New zone</h1>
    <%= render partial: "form", locals: {zone: @zone} %>

    edit.html.erb

    <h1>Editing zone</h1>
    <%= render partial: "form", locals: {zone: @zone} %>

    _form.html.erb

    <%= form_for(zone) do |f| %>
      <p>
        <b>Zone name</b><br>
        <%= f.text_field :name %>
      </p>
      <p>
        <%= f.submit %>
      </p>
    <% end %>
```
Хотя тот же самый партиал будет отрендерен в обоих вьюхах, Action View отправит хелпер, который возвратит "Create Zone" для экшна new и "Update Zone" для экшна `edit`.

**Для передачи локальной переменной в партиал только в особых случаях, используйте `local_assigns`**.
```
    index.html.erb 

  <%= render user.articles %>

    show.html.erb 

  <%= render article, full: true %>

    _article.html.erb 

  <h2><%= article.title %></h2>

  <% if local_assigns[:full] %>
    <%= simple_format article.body %>
  <% else %>
    <%= truncate article.body %>
  <% end %>
```
Таким образом, можно использовать партиал без необходимости объявления всех локальных переменных.

Каждый партиал также имеет локальную переменную с именем, как у партиала (без начального символа подчеркивания). Можете передать объект в эту локальную переменную через опцию `:object`:
```
<%= render partial: "customer", object: @new_customer %>
```
В партиале `customer` переменная `customer` будет указывать на `@new_customer` из родительской вьюхи.

Если есть экземпляр модели для рендеринга в партиале, можно использовать сокращенный синтаксис:
```
<%= render @customer %>
```
Предположим, что переменная экземпляра `@customer` содержит экземпляр модели `Customer`. Эта переменная будет использовать `_customer.html.erb` для рендеринга модели и передаст локальную переменную `customer` в партиал, на который будет ссылаться на переменная экземпляра `@customer` в родительской вьюхе.

##### Рендеринг коллекций

Партиалы часто используют для рендеринга коллекций. Когда коллекция передается в партиал с помощью опции `:collection`, партиал будет вставлен один раз для каждого члена коллекции:
```
    index.html.erb

    <h1>Products</h1>
    <%= render partial: "product", collection: @products %>

    _product.html.erb

    <p>Product Name: <%= product.name %></p>
```
Когда партиал вызывается с коллекцией во множественном числе, то каждый отдельный экземпляр партиала имеет доступ к члену коллекции, подлежащей рендерингу, через переменную с именем партиала. В нашем случает партиал `_product`, и в партиале `_product` можете обращаться к `product` для получения экземпляра, который рендерится.

Имеется также сокращенная запись для этого. Предположив, что `@products` является коллекцией экземпляров `Product`, можно просто написать так в `index.html.erb` и получить аналогичный результат:
```
<h1>Products</h1>
<%= render @products %>
```
Rails определяет имя партиала, изучая имя модели в коллекции. Фактически, можно даже создать гетерогенную коллекцию и рендерить ее таким образом, и Rails подберет подходящий партиал для каждого члена коллекции:
```
    index.html.erb

    <h1>Contacts</h1>
    <%= render [customer1, employee1, customer2, employee2] %>

    customers/_customer.html.erb

    <p>Customer: <%= customer.name %></p>

    employees/_employee.html.erb

    <p>Employee: <%= employee.name %></p>
```
В этом случае Rails использует партиалы `customer` или `employee` по мере необходимости для каждого члена коллекции.

В случае, если коллекция пустая, `render` возвратит `nil`, поэтому очень просто предоставить альтернативное содержимое.
```
<h1>Products</h1>
<%= render(@products) || "There are no products available." %>
```
##### Локальные переменные

Чтобы использовать пользовательские имена локальных переменных в партиале, определите опцию `:as` в вызове партиала:
```
<%= render partial: "product", collection: @products, as: :item %>
```
С этим изменением можете получить доступ к экземпляру коллекции `@products` через локальную переменную `item` в партиале.

Также можно передавать произвольные локальные переменные в любой партиал, который рендерится с помощью опции `locals: {}`:
```
<%= render partial: "product", collection: @products,
           as: :item, locals: {title: "Products Page"} %>
```
В этом случае, партиал имеет доступ к локальной переменной `title` со значением "Products Page".

> Rails также создает переменную счетчика, доступную в партиале, вызываемом коллекцией, названную именем заголовка партиала с добавленным `_counter`. Например, при рендеринге коллекции `@products` партиал `_product.html.erb` может получить доступ к переменной `product_counter`, которая индексирует количество раз, сколько оно было отрендерено во внешнюю вьюху. Отметьте, что это также применимо, когда имя партиала было изменено с помощью опции `as:`. Например, переменная счетчика для вышеуказанного кода будет `item_counter`.

Также можно определить второй партиал, который будет отрендерен между экземплярами главного партиала, используя опцию `:spacer_template`.

##### Разделяющие шаблоны
```
<%= render partial: @products, spacer_template: "product_ruler" %>
```
Rails отрендерит партиал `_product_ruler` (без переданных в него данных) между каждой парой партиалов `_product`.

##### Макеты коллекции партиала

При рендеринге коллекций также возможно использовать опцию `:layout`:
```
<%= render partial: "product", collection: @products, layout: "special_layout" %>
```
Макет будет отрендерен вместе с партиалом для каждого элемента коллекции. Переменные текущего объекта и `object_counter` также будут доступны в макете, как это происходит в партиале.

##### Использование вложенных макетов

Возможно, ваше приложение потребует макет, немного отличающийся от обычного макета приложения, для поддержки одного определенного контроллера. Вместо повторения главного макета и редактирования его, можете выполнить это с помощью вложенных макетов (иногда называемых подшаблонами). Вот пример:

Предположим, имеется макет `ApplicationController`:
```
    app/views/layouts/application.html.erb

    <html>
    <head>
      <title><%= @page_title or "Page Title" %></title>
      <%= stylesheet_link_tag "layout" %>
      <style><%= yield :stylesheets %></style>
    </head>
    <body>
      <div id="top_menu">Top menu items here</div>
      <div id="menu">Menu items here</div>
      <div id="content"><%= content_for?(:content) ? yield(:content) : yield %></div>
    </body>
    </html>
```
На страницах, сгенерированных `NewsController`, допустим, нужно спрятать верхнее меню и добавить правое меню:
```
    app/views/layouts/news.html.erb

    <% content_for :stylesheets do %>
      #top_menu {display: none}
      #right_menu {float: right; background-color: yellow; color: black}
    <% end %>
    <% content_for :content do %>
      <div id="right_menu">Right menu items here</div>
      <%= content_for?(:news_content) ? yield(:news_content) : yield %>
    <% end %>
    <%= render template: "layouts/application" %>
```
Вот и все. Вьюхи News будут использовать новый макет, прячущий верхнее меню и добавляющий новое правое меню в "content" `div`.

Существует несколько способов получения похожих результатов с различными подшаблонными схемами, используя эту технику. Отметьте, что нет ограничений на уровень вложенности. Можно использовать метод `ActionView::render` через `render template: 'layouts/news'`, чтобы создать новый макет на основе макета `News`. Если есть уверенность, что не понадобятся подшаблоны для макета `News`, можно заменить строку `content_for?(:news_content) ? yield(:news_content) : yield` простым `yield`.

## Хелперы форм в Action View <a name="3.3"></a>
### Разбираемся с простыми формами <a name="3.3.1"></a>
Главный хелпер форм - это `form_with`.
```
<%= form_with do %>
  Содержимое формы
<% end %>
```
При подобном вызове без аргументов, он создает тег формы, который при отправке сформирует POST-запрос на текущую страницу. Например, предположим текущая страница является домашней, тогда сгенерированный HTML будет выглядеть следующим образом (некоторые разрывы строчек добавлены для читаемости):
```
<form accept-charset="UTF-8" action="/" data-remote="true" method="post">
  <input name="authenticity_token" type="hidden" value="J7CBxfHalt49OSHp27hblqK20c9PgwJ108nDHX/8Cts=" />
  Содержимое формы
</form>
```
Можно увидеть, что HTML содержит элемент `input` с типом `hidden`. Этот `input` важен, поскольку без него форма, у которой action не "GET", не может быть успешно отправлена. Скрытый элемент `input` с именем `authenticity_token` является особенностью безопасности Rails, называемой защитой от межсайтовой подделки запроса, и хелперы форм генерируют его для каждой формы, у которых action не "GET" (при условии, что эта особенность безопасности включена).

#### Характерная форма 
Одной из наиболее простых форм, встречающихся в вебе, является форма поиска. Эта форма содержит:
* элемент формы с методом "GET",
* метку для поля ввода,
* элемент поля ввода текста и
* элемент отправки. 

Чтобы создать эту форму, используем, соответственно, `form_with`, `label_tag`, `text_field_tag` и `submit_tag`. Как здесь:
```
<%= form_with(url: "/search", method: "get") do %>
  <%= label_tag(:q, "Search for:") %>
  <%= text_field_tag(:q) %>
  <%= submit_tag("Search") %>
<% end %>
```
Это сгенерирует следующий HTML:
```
<form accept-charset="UTF-8" action="/search" data-remote="true" method="get">
  <label for="q">Search for:</label>
  <input id="q" name="q" type="text" />
  <input name="commit" type="submit" value="Search" data-disable-with="Search" />
</form>
```
> Передача `url: my_specified_path` в `form_with` сообщает форме, куда осуществлять запрос. Однако, как объясняется ниже, в форму также можно передавать объекты ActiveRecord.

> Для каждого поля ввода формы генерируется атрибут ID из его имени ("q" в примере). Эти ID могут быть очень полезны для стилизации CSS или управления элементами форм с помощью JavaScript.

> Используйте "GET" как метод для форм поиска. Это позволяет пользователям добавлять в закладки определенный поиск и потом возвращаться к нему. В более общем смысле Rails призывает вас использовать правильный метод HTTP для экшна.

#### Хелперы для генерации элементов формы
##### Чекбоксы
Чекбоксы - это элементы управления формой, которые дают пользователю ряд опций, которые он может включить или выключить:
```
<%= check_box_tag(:pet_dog) %>
<%= label_tag(:pet_dog, "I own a dog") %>
<%= check_box_tag(:pet_cat) %>
<%= label_tag(:pet_cat, "I own a cat") %>
```
Это сгенерирует следующее:
```
<input id="pet_dog" name="pet_dog" type="checkbox" value="1" />
<label for="pet_dog">I own a dog</label>
<input id="pet_cat" name="pet_cat" type="checkbox" value="1" />
<label for="pet_cat">I own a cat</label>
```
Первый параметр у `check_box_tag` - это, разумеется, имя поля ввода. Второй параметр - это, естественно, значение поля ввода. Это значение будет включено в данные формы (и будет присутствовать в params), когда чекбокс нажат.

##### Радиокнопки
Радиокнопки, чем-то похожие на чекбоксы, являются элементами управления, которые определяют набор взаимоисключающих опций (т.е. пользователь может выбрать только одну):
```
<%= radio_button_tag(:age, "child") %>
<%= label_tag(:age_child, "I am younger than 21") %>
<%= radio_button_tag(:age, "adult") %>
<%= label_tag(:age_adult, "I am over 21") %>
```
Результат:
```
<input id="age_child" name="age" type="radio" value="child" />
<label for="age_child">I am younger than 21</label>
<input id="age_adult" name="age" type="radio" value="adult" />
<label for="age_adult">I am over 21</label>
```
Как и у `check_box_tag`, второй параметр для `radio_button_tag` - это значение поля ввода. Так как эти две радиокнопки имеют одинаковое имя (`age`), пользователь может выбрать одну, и `params[:age]` будет содержать или "child", или "adult".

> Всегда используйте метки (labels) для чекбоксов и радиокнопок. Они связывают текст с определенной опцией и, предоставляя большее пространство для клика, упрощают выбор пользователем нужного пункта радиокнопки.

#### Другие интересные хелперы
Среди других элементов управления формой стоит упомянуть текстовые области и следующие поля: паролей, скрытые, поиска, ввода телефона, даты, времени, цвета, локальных даты-времени, месяца, недели, url, email, числовые и интервалов:
```
<%= text_area_tag(:message, "Hi, nice site", size: "24x6") %>
<%= password_field_tag(:password) %>
<%= hidden_field_tag(:parent_id, "5") %>
<%= search_field(:user, :name) %>
<%= telephone_field(:user, :phone) %>
<%= date_field(:user, :born_on) %>
<%= datetime_local_field(:user, :graduation_day) %>
<%= month_field(:user, :birthday_month) %>
<%= week_field(:user, :birthday_week) %>
<%= url_field(:user, :homepage) %>
<%= email_field(:user, :address) %>
<%= color_field(:user, :favorite_color) %>
<%= time_field(:task, :started_at) %>
<%= number_field(:product, :price, in: 1.0..20.0, step: 0.5) %>
<%= range_field(:product, :discount, in: 1..100) %>
```
Результат:
```
<textarea id="message" name="message" cols="24" rows="6">Hi, nice site</textarea>
<input id="password" name="password" type="password" />
<input id="parent_id" name="parent_id" type="hidden" value="5" />
<input id="user_name" name="user[name]" type="search" />
<input id="user_phone" name="user[phone]" type="tel" />
<input id="user_born_on" name="user[born_on]" type="date" />
<input id="user_graduation_day" name="user[graduation_day]" type="datetime-local" />
<input id="user_birthday_month" name="user[birthday_month]" type="month" />
<input id="user_birthday_week" name="user[birthday_week]" type="week" />
<input id="user_homepage" name="user[homepage]" type="url" />
<input id="user_address" name="user[address]" type="email" />
<input id="user_favorite_color" name="user[favorite_color]" type="color" value="#000000" />
<input id="task_started_at" name="task[started_at]" type="time" />
<input id="product_price" max="20.0" min="1.0" name="product[price]" step="0.5" type="number" />
<input id="product_discount" max="100" min="1" name="product[discount]" type="range" />
```
Скрытые поля не отображаются пользователю, вместо этого они содержат данные, как и любое текстовое поле. Их значения могут быть изменены с помощью JavaScript.

> Поля поиска, ввода телефона, даты, времени, цвета, даты-времени, локальных даты-времени, месяца, недели, url, email, числовые и интервалов - это элементы управления HTML5. Если необходимо, чтобы у вашего приложения была совместимость со старыми браузерами, вам необходим HTML5 polyfill (предоставляемый с помощью CSS и/или JavaScript). Хотя в таких решениях нет недостатка, популярным инструментом на сегодняшний момент является Modernizr, предоставляющий простой способ добавить функциональность, основанной на обнаружении установленных особенностей HTML5.

> Если используются поля для ввода пароля (для любых целей), вы можете настроить свое приложение для предотвращения появления их значений в логах приложения.

### Работаем с объектами модели <a name="3.3.2"></a>
#### Хелперы объекта модели
Если ваш контроллер определил @person и имя этой персоны Henry, тогда форма, содержащая:
```
<%= text_field(:person, :name) %>
```
выдаст подобный результат
```
<input id="person_name" name="person[name]" type="text" value="Henry" />
```
После подтверждения формы, значение, введенное пользователем, будет храниться в `params[:person][:name]`.

> Необходимо передавать имя переменной экземпляра, т.е. `:person` или "person", а не фактический экземпляр объекта вашей модели.

Rails предоставляет хелперы для отображения ошибок валидации, связанных с объектом модели.

#### Привязывание формы к объекту
Допустим у нас есть контроллер для работы со статьями app/controllers/articles_controller.rb:

def new
  @article = Article.new
end

Соответствующая вьюха app/views/articles/new.html.erb, использующая form_with, выглядит так:

<%= form_with model: @article, class: "nifty_form" do |f| %>
  <%= f.text_field :title %>
  <%= f.text_area :body, size: "60x12" %>
  <%= f.submit "Create" %>
<% end %>

Следует отметить несколько вещей:
* `@article` - это фактический объект, который редактируется.
* Здесь есть одиночный хэш опций. Опции HTML передаются в хэше `:html`. Также для формы можно предоставить опцию `:namespace`, чтобы быть уверенным в уникальности атрибутов `id` элементов формы. Генерируемые для HTML `id` будут начинаться с префикса, заданного атрибутом пространства имен, плюс подчеркивание.
* Метод `form_with` предоставляет объект `form builder` (переменная f).
* Если хотите направить запрос формы на определенный `url`, вместо этого следует использовать `form_with url: my_nifty_url_path`. Подробнее об опциях, которые принимает `form_with`, можно узнать в документации API.
* Методы создания элементов управления формой вызываются для объекта `form builder f`. 

Итоговый HTML:
```
<form class="nifty_form" action="/articles" accept-charset="UTF-8" data-remote="true" method="post">
  <input type="hidden" name="authenticity_token" value="NRkFyRWxdYNfUg7vYxLOp2SLf93lvnl+QwDWorR42Dp6yZXPhHEb6arhDOIWcqGit8jfnrPwL781/xlrzj63TA==" />
  <input type="text" name="article[title]" id="article_title" />
  <textarea name="article[body]" id="article_body" cols="60" rows="12"></textarea>
  <input type="submit" name="commit" value="Create" data-disable-with="Create" />
</form>
```
Объект, переданный как `:model` в `form_with`, контролирует ключ, используемый в params для доступа к значениям формы. В примере имя `article`, и поэтому все поля ввода имеют имена формы `article[attribute_name]`. Соответственно, в экшне `create` хэш `params[:article]` имеет ключи `:title` и `:body`. 

> По соглашению, поля ввода будут отражать атрибуты модели. Однако, это необязательно! Если имеется иная необходимая информация, ее можно включить в форму, также как атрибут, и она будет доступна как `params[:article][:my_nifty_non_attribute_input]`.

Методы хелпера, вызываемые из `form builder`, идентичны хелперам объекта модели, за исключением того, что не нужно указывать, какой объект будет редактироваться, так как это уже регулируется в `form builder`.

**Можно создать подобное привязывание без фактического создания тега `<form>`** с помощью хелпера `fields_for`. Это полезно для редактирования дополнительных объектов модели в той же форме. Например, если имеется модель `Person` со связанной моделью `ContactDetail`, можно создать форму для создания обеих моделей подобным образом:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.text_field :name %>
  <%= fields_for :contact_detail, @person.contact_detail do |contact_detail_form| %>
    <%= contact_detail_form.text_field :phone_number %>
  <% end %>
<% end %>
```
которая выдаст такой результат:
```
<form action="/people" accept-charset="UTF-8" data-remote="true" method="post">
  <input type="hidden" name="authenticity_token" value="bL13x72pldyDD8bgtkjKQakJCpd4A8JdXGbfksxBDHdf1uC0kCMqe2tvVdUYfidJt0fj3ihC4NxiVHv8GVYxJA==" />
  <input type="text" name="person[name]" id="person_name" />
  <input type="text" name="contact_detail[phone_number]" id="contact_detail_phone_number" />
</form>
```
Объект, предоставляемый `fields_for` - это `form builder`, подобный тому, который предоставляется `form_with`.

#### Положитесь на идентификацию записи
Модель `Article` непосредственно доступна пользователям приложения, и таким образом, следуя лучшим рекомендациям разработки на Rails, вы должны объявить ее как ресурс.
```
resources :articles
```
Когда работаем с ресурсами RESTful, вызовы `form_with` становятся значительно проще, если они основываются на идентификации записи. Вкратце, вы должны всего лишь передать экземпляр модели и позволить Rails выяснить имя модели и остальное:
```
## Создание новой статьи
# длинный стиль:
form_with(model: @article, url: articles_path)
# короткий стиль:
form_with(model: @article)

## Редактирование существующей статьи
# длинный стиль:
form_with(model: @article, url: article_path(@article), method: "patch")
# короткий стиль:
form_with(model: @article)
```
Отметьте, что вызов короткого стиля `form_with` является идентичным, независимо от того, запись новая или уже существует. Идентификация записи достаточно сообразительная, чтобы выяснить, новая ли запись, запрашивая `record.new_record?`. Она также выбирает правильный путь для подтверждения и имя, основанное на классе объекта.

> Когда используется STI (наследование с единой таблицей) с вашими моделями, нельзя полагаться на идентификацию записей подкласса, если только их родительский класс определен ресурсом. Необходимо явно указывать `:url` и `:scope` (имя модели).

##### Работаем с пространствами имен
Если создать пространство имен для маршрутов, `form_with` также можно изящно сократить. Если в приложении есть пространство имен `admin`, то
```
form_with model: [:admin, @article]
```
создаст форму, которая передается `ArticlesController` в пространстве имен `admin` (передача в `admin_article_path(@article)` в случае с обновлением). Если у вас несколько уровней пространства имен, тогда синтаксис подобный:
```
form_with model: [:admin, :management, @article]
```
#### Как формы работают с методами `PATCH`, `PUT` или `DELETE?`
Фреймворк Rails поддерживает стиль RESTful в ваших приложениях, что подразумевает частое использование запросов "PATCH", "PUT" и "DELETE" (помимо "GET" и "POST"). Однако, большинство браузеров не поддерживают методы, отличные от "GET" и "POST", когда дело доходит до подтверждения форм.

Rails работает с этой проблемой, эмулируя другие методы с помощью POST со скрытым полем, названным "`_method`", который установлен для отображение желаемого метода:
```
form_with(url: search_path, method: "patch")
```
Результат:
```
<form accept-charset="UTF-8" action="/search" data-remote="true" method="post">
  <input name="_method" type="hidden" value="patch" />
  <input name="authenticity_token" type="hidden" value="f755bb0ed134b76c432144748a6d4b7a7ddf2b71" />
  ...
</form>
```
При парсинге данных, отправленных с помощью POST, Rails принимает во внимание специальный параметр `_method` и ведет себя так, как будто бы в нем был определен этот метод HTTP ("PATCH" в этом примере).

> Все формы с использованием `form_with` по умолчанию реализуют `remote: true`. Эти формы будут отправлять данные с помощью запроса XHR (Ajax). Чтобы это отключить, добавьте local: true.

### Легкое создание списков выбора <a name="3.3.3"></a>
#### Теги `Select` и `Option`
Наиболее простой хелпер - это `select_tag`, который, как следует из имени, просто сгенерирует тег SELECT, инкапсулирующий строку `option` (пунктов списка):
```
<%= select_tag(:city_id, raw('<option value="1">Lisbon</option><option value="2">Madrid</option><option value="3">Berlin</option>')) %>
```
Это закладывает начало, но пока еще динамически не создает теги пунктов списка. Можно сгенерировать теги пунктов с помощью хелпера `options_for_select`:
```
<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>
```
Результат:
```
<option value="1">Lisbon</option>
<option value="2">Madrid</option>
<option value="3">Berlin</option>
```
Первый аргумент для `options_for_select` - это вложенный массив, в котором каждый элемент содержит два элемента: текст пункта списка (название города) и значение пункта списка (id города). Значение пункта списка - это то, что будет передано в контроллер. Часто бывает, что значение - это `id` соответствующего объекта базы данных, но это не всегда так.

Зная это, вы можете комбинировать `select_tag` и `options_for_select` для достижения желаемой полной разметки:
```
<%= select_tag(:city_id, options_for_select(...)) %>
```
`options_for_select` позволяет предварительно выбрать пункт списка, передав его значение.
```
<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]], 2) %>
```
Результат:
```
<option value="1">Lisbon</option>
<option value="2" selected="selected">Madrid</option>
<option value="3">Berlin</option>
```
Всякий раз, когда Rails видит, что внутреннее значение сгенерированного пункта списка соответствует этому значению, он добавит атрибут `selected` к этому пункту.

С помощью хэшей можно добавить произвольные атрибуты в `option`:
```
<%= options_for_select(
  [
    ['Lisbon', 1, { 'data-size' => '2.8 million' }],
    ['Madrid', 2, { 'data-size' => '3.2 million' }],
    ['Berlin', 3, { 'data-size' => '3.4 million' }]
  ], 2
) %>
```
Результат:
```
<option value="1" data-size="2.8 million">Lisbon</option>
<option value="2" selected="selected" data-size="3.2 million">Madrid</option>
<option value="3" data-size="3.4 million">Berlin</option>
```
#### Списки выбора для работы с объектами модели
В большинстве случаев элементы управления формой будут связаны с определенной моделью, и, как вы, наверное, и ожидали, Rails предоставляет хелперы, предназначенные для этой цели. Как в случае с другими хелперами форм, когда работаете с объектами модели, суффикс `_tag` отбрасывается от `select_tag`:

Если ваш контроллер определил `@person`, и `city_id` этого `person` равен 2:
```
@person = Person.new(city_id: 2)
```
```
+<%= select(:person, :city_id, [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>
```
Создаст результат, подобный следующему
```
<select name="person[city_id]" id="person_city_id">
  <option value="1">Lisbon</option>
  <option value="2" selected="selected">Madrid</option>
  <option value="3">Berlin</option>
</select>
```
Отметьте, что третий параметр - массив пунктов списка - имеет тот же самый тип аргумента, что мы передавали в `options_for_select`. Одно из преимуществ заключается в том, что не стоит беспокоиться об предварительном выборе правильного города, если пользователь уже выбрал его - Rails сделает это за вас, прочитав из атрибута `@person.city_id`.

Как и в других хелперах, если хотите использовать хелпер `select` в `form builder` с областью видимостью объекта `@person`, синтаксис будет такой:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.select(:city_id, [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>
<% end %>
```
В хелпер `select` также можно передать блок:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.select(:city_id) do %>
    <% [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]].each do |c| %>
      <%= content_tag(:option, c.first, value: c.last) %>
    <% end %>
  <% end %>
<% end %>
```
> При использовании `select`, или подобных хелперов, чтобы установить связь `belongs_to`, необходимо передать имя внешнего ключа (в примере выше city_id), а не само имя связи.

> Когда отсутствует `:include_blank` или `:prompt`, `:include_blank` принудительно становится true, если атрибут `required` - true, отображаемый `size` - 1 и `multiple` не равен `true`.

#### Теги пункта списка из коллекции произвольных объектов

Генерация тегов пунктов списка с помощью `options_for_select` требует, чтобы был создан массив, содержащий текст и значение для каждого пункта. Но что, если есть модель `City` (вероятно даже модель Active Record) и нужно сгенерировать теги пунктов списка из коллекции этих объектов? Одним из решений будет сделать вложенный массив с помощью итераций по ним:
```
<% cities_array = City.all.map { |city| [city.name, city.id] } %>
<%= options_for_select(cities_array) %>
```
Хотя это и валидное решение, но Rails предоставляет менее сложную альтернативу: `options_from_collection_for_select`. Этот хелпер принимает коллекцию произвольных объектов и два дополнительных аргумента: имена методов для считывания значений `value` и `text` пункта списка, соответственно:
```
<%= options_from_collection_for_select(City.all, :id, :name) %>
```
Как следует из имени хелпера, это генерирует только теги пункта списка. Для генерации работающего списка выбора, необходимо использовать `collection_select`.
```
<%= collection_select(:person, :city_id, City.all, :id, :name) %>
```
Как и с другими хелперами, если нужно использовать хелпер `collection_select` в связке с `form builder`, привязанным к объекту `@person`, синтаксис будет следующим:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.collection_select(:city_id, City.all, :id, :name) %>
<% end %>
```
> Пары, переданные в `options_for_select` должны сперва иметь текст, затем значение, однако для `options_from_collection_for_select` первый аргумент - это метод для значения, а второй аргумент - метод для текста.

#### Выбор часового пояса и страны
Для управления поддержкой часовых поясов в Rails, можно спрашивать своих пользователей, в какой зоне они находятся. Это потребует сгенерировать пункты списка из списка предопределенных объектов `ActiveSupport::TimeZone`, используя `collection_select`, но можно просто использовать хелпер `time_zone_select`, который уже все это содержит:
```
<%= time_zone_select(:person, :time_zone) %>
```
Также есть хелпер `time_zone_options_for_select` для ручного (и поэтому гибко настраиваемого) способа осуществления этого. Читайте документацию по API, чтобы узнать о доступных аргументах для этих двух методов.

В Rails раньше был хелпер `country_select` для выбора стран, но сейчас он вынесен во внешний плагин `country_select`.

### Использование хелперов даты и времени <a name="3.3.4"></a>
Можно не использовать хелперы форм, генерирующие поля ввода даты и времени HTML5, а использовать альтернативные хелперы даты и времени. Эти хелперы даты и времени отличаются от остальных хелперов форм в двух важных аспектах:
* Дата и время не представлены отдельным элементом ввода. Вместо них есть несколько, один на каждый компонент (год, месяц, день и т.д.), и поэтому нет одного значения в хэше params с вашими датой и временем.
* Другие хелперы используют суффикс `_tag` для обозначения, является ли хелпер скелетным, либо работает на основе объектов модели. Что касается дат и времени, `select_date`, `select_time` и `select_datetime` - это скелетные хелперы, а `date_select`, `time_select` и `datetime_select` - это эквивалентные хелперы объекта модели. 

Оба эти семейства хелперов создадут ряд списков выбора для различных компонентов (год, месяц, день и т.д.)

#### Скелетные хелперы
Семейство хелперов `select_*` принимает как первый аргумент экземпляр `Date`, `Time` или `DateTime`, который используется как текущее выбранное значение. Можете опустить этот параметр в случае, если используется текущая дата. Например:
```
<%= select_date Date.today, prefix: :start_date %>
```
выведет (с опущенными для краткости начальными значениями пунктов списка)
```
<select id="start_date_year" name="start_date[year]">
</select>
<select id="start_date_month" name="start_date[month]">
</select>
<select id="start_date_day" name="start_date[day]">
</select>
```
Эти элементы ввода приведут к тому, что `params[:start_date]` будет хэшем с ключами `:year`, `:month`, `:day`. Чтобы получить фактический объект `Date`, `Time` или `DateTime`, необходимо извлечь эти значения и передать их в подходящий конструктор, например:
```
Date.civil(params[:start_date][:year].to_i, params[:start_date][:month].to_i, params[:start_date][:day].to_i)
```
Опция `:prefix` это ключ, используемый для получения хэша компонентов даты из хэша params. Здесь она была установлена как `start_date`, если опущена, то по умолчанию равна `date`.

#### Хелперы объекта модели
`select_date` не очень хорошо работает с формами, обновляющими или создающими объекты Active Record, так как Active Record ожидает, что каждый элемент хэша params соответствует одному атрибуту. Хелперы объекта модели для даты и времени возвращает параметры со специальными именами, и когда Active Record видит параметры с такими именами, он знает, что они должны быть скомбинированы с другими параметрами, и передает конструктору значения, соответствующему типу столбца. Например:
```
<%= date_select :person, :birth_date %>
```
выдаст (с опущенными для краткости начальными значениями пунктов списка)
```
<select id="person_birth_date_1i" name="person[birth_date(1i)]">
</select>
<select id="person_birth_date_2i" name="person[birth_date(2i)]">
</select>
<select id="person_birth_date_3i" name="person[birth_date(3i)]">
</select>
```
что приведет к такому результату в хэше params
```
{'person' => {'birth_date(1i)' => '2008', 'birth_date(2i)' => '11', 'birth_date(3i)' => '22'}}
```
Когда это передано в `Person.new` (или `update`), Active Record отмечает, что все эти параметры должны быть использованы для конструирования атрибута `birth_date` и использует суффиксную информацию для определения, в каком порядке должен передать эти параметры в такие функции, как `Date.civil`.

#### Общие опции
Оба семейства хелперов используют одинаковый базовый набор функций для генерации индивидуальных тегов `select`, таким образом, они оба принимают в основном одинаковые опции. В частности, по умолчанию Rails сгенерирует пункты списка года как текущий год плюс/минус пять лет. Если это неподходящий интервал, опции `:start_year` и `:end_year` переопределяют это. Для полного списка доступных опции обратитесь к документации по API.

Как правило, следует использовать `date_select` при работе с объектами модели и `select_date` в иных случаях, например, таких как форма поиска, которая фильтрует результаты по дате.

#### Индивидуальные компоненты
Иногда необходимо отобразить лишь одиночный компонент даты, такой как год или месяц. Rails предоставляет ряд хелперов для этого, по одному для каждого компонента `select_year`, `select_month`, `select_day`, `select_hour`, `select_minute`, `select_second`. Эти хелперы достаточно простые. По умолчанию они сгенерируют поле ввода, названное по имени компонента времени (например, "year" для `select_year`, "month" для `select_month` и т.д.), хотя это может быть переопределено в опции `:field_name`. Опция `:prefix` работает так же, как работает для `select_date` и `select_time` и имеет такое же значение по умолчанию.

Первый параметр определяет значение даты, которое будет предложено для выбора (соответствующий элемент может быть извлечен из экземпляра Date, Time или DateTime), либо сразу задается числовым значением. Например:
```
<%= select_year(2009) %>
<%= select_year(Time.new(2009)) %>
```
создадут одинаковый результат, и значение, выбранное пользователем, может быть получено как `params[:date][:year]`.

### Загрузка файлов <a name="3.3.5"></a>
Частой задачей является загрузка некоторого файла, аватарки или файла CSV, содержащего информацию для обработки. Самое важное, это помнить при загрузке файла, что атрибут enctype формы должен быть установлен как "multipart/form-data". Если используете `form_with с :model`, это будет выполнено автоматически. Если используете `form_with без :model`, нужно установить это самому, как в следующем примере.

Следующие две формы обе загружают файл.
```
<%= form_with(url: {action: :upload}, multipart: true) do %>
  <%= file_field_tag 'picture' %>
<% end %>

<%= form_with model: @person do |f| %>
  <%= f.file_field :picture %>
<% end %>
```
Rails предоставляет обычную пару хелперов: скелетный `file_field_tag` и модельно-ориентированный `file_field`. Как и следует ожидать, в первом случае загруженный файл находится в `params[:picture]`, а во втором случае - в `params[:person][:picture]`.

#### Что имеем загруженным
Объект в хэше `params` - это экземпляр `ActionDispatch::Http::UploadedFile`. Следующий образец кода сохраняет загруженное содержимое в `#{Rails.root}/public/uploads` под тем же именем, что и исходный файл.
```
def upload
  uploaded_file = params[:picture]
  File.open(Rails.root.join('public', 'uploads', uploaded_file.original_filename), 'wb') do |file|
    file.write(uploaded_file.read)
  end
end
```
Как только файл был загружен, появляется множество потенциальных задач, начиная от того, где хранить файлы (на диске, Amazon S3 и т.д.), как связать их с моделями, изменить размер файлов изображений и сгенерировать миниатюры. Для помощи с такими задачами разработан Active Storage.

### Настройка Form Builder <a name="3.3.6"></a>
Объект, который передается от `form_with` и `fields_for`, - это экземпляр `ActionView::Helpers::FormBuilder`. `Form builder` инкапсулирует представление элементов формы для отдельного объекта. Хотя, конечно, можно писать хелперы для своих форм обычным способом, так же как можно объявить подкласс `ActionView::Helpers::FormBuilder` и добавить хелперы туда. Например:
```
<%= form_with model: @person do |f| %>
  <%= text_field_with_label f, :first_name %>
<% end %>
```
может быть заменено этим
```
<%= form_with model: @person, builder: LabellingFormBuilder do |f| %>
  <%= f.text_field :first_name %>
<% end %>
```
через определение класса `LabellingFormBuilder` подобным образом:
```
class LabellingFormBuilder < ActionView::Helpers::FormBuilder
  def text_field(attribute, options={})
    label(attribute) + super
  end
end
```
Если это используется часто, можно определить хелпер `labeled_form_with` который автоматически определяет опцию `builder: LabellingFormBuilder`:
```
def labeled_form_with(model: nil, scope: nil, url: nil, format: nil, **options, &block)
  options.merge! builder: LabellingFormBuilder
  form_with model: model, scope: scope, url: url, format: format, **options, &block
end
```
Form builder также определяет, что произойдет, если вы сделаете
```
<%= render partial: f %>
```
Если f - это экземпляр `ActionView::Helpers::FormBuilder`, тогда это отрендерит партиал `form`, установив объект партиала как `form builder`. Если у `form builder` есть класс `LabellingFormBuilder`, тогда вместо него будет отрендерен партиал `labelling_form`.

### Понимание соглашений по именованию параметров <a name="3.3.7"></a>
Значения из форм могут быть на верхнем уровне хэша params или вложены в другой хэш. Например, в стандартном экшне `create` для модели `Person`, `params[:person]` будет обычно хэшем всех атрибутов для создания персоны. Хэш `params` может также содержать массивы, массивы хэшей и тому подобное.

В основном формы HTML не знают о каких-либо структурировании данных, все, что они генерируют - это пары имя-значение, где пары являются обычными строками. Массивы и хэши, которые можно увидеть в своем приложении, - это результат некоторых соглашений по именованию параметров, которые использует Rails.

#### Базовые структуры
Две базовые структуры - это массивы и хэши. Хэши отражают синтаксис, используемый для доступа к значению в params. Например, если форма содержит
```
<input id="person_name" name="person[name]" type="text" value="Henry"/>
```
хэш `params` будет содержать
```
{'person' => {'name' => 'Henry'}}
```
и `params[:person][:name]` получит отправленное значение в контроллере.

Хэши могут быть вложены на столько уровней, сколько требуется, например:
```
<input id="person_address_city" name="person[address][city]" type="text" value="New York"/>
```
вернет такой хэш params
```
{'person' => {'address' => {'city' => 'New York'}}}
```
Обычно Rails игнорирует дублирующиеся имена параметра. Если имя параметра содержит пустой набор квадратных скобок `[]`, то они будут накоплены в массиве. Если нужно, чтобы пользователи могли оставить несколько телефонных номеров, можно поместить это в форму:
```
<input name="person[phone_number][]" type="text"/>
<input name="person[phone_number][]" type="text"/>
<input name="person[phone_number][]" type="text"/>
```
Что приведет к тому, что `params[:person][:phone_number]` будет массивом, содержащим введенные телефонные номера.

#### Комбинируем их
Можно смешивать и сочетать эти две концепции. Один из элементов хэша может быть массивом, как в предыдущем примере, или вы можете иметь массив хэшей. Например, форма может позволить вам создать любое количество адресов, повторяя следующий фрагмент кода
```
<input name="person[addresses][][line1]" type="text"/>
<input name="person[addresses][][line2]" type="text"/>
<input name="person[addresses][][city]" type="text"/>
<input name="person[addresses][][line1]" type="text"/>
<input name="person[addresses][][line2]" type="text"/>
<input name="person[addresses][][city]" type="text"/>
```
Это приведет к тому, что `params[:person][:addresses]` будет массивом хэшей с ключами line1, line2 и city.

Однако, имеется ограничение, в то время как хэши могут быть вложены произвольно, является допустимым только один уровень "массивности". Массивы обычно могут быть заменены хэшами; например, вместо массива объектов модели можно иметь хэш объектов модели с ключами, равными их `id`, индексу массива или любому другому параметру.

> Параметры массива не очень хорошо работают с хелпером `check_box`. В соответствии со спецификацией HTML, невыбранные чекбоксы не возвращают значения. Хелпер `check_box` обходит это, создавая вспомогательное скрытое поле с тем же именем. Если чекбокс не нажат, подтверждается только скрытое поле, а если он нажат, то они оба подтверждаются, но значение от чекбокса получает приоритет.

#### Использование хелперов форм
Предыдущие разделы совсем не использовали хелперы Rails. Хотя можно создавать имена полей ввода самому и передавать их напрямую хелперам, таким как `text_field_tag`, Rails также предоставляет поддержку на более высоком уровне. В вашем распоряжении имеются два инструмента: параметр имени для `form_with` и `fields_for`, и опция `:index`, принимаемая этими хелперами.

Вы возможно захотите рендерить форму с набором полей ввода для каждого адреса человека. Например:
```
<%= form_with model: @person do |person_form| %>
  <%= person_form.text_field :name %>
  <% @person.addresses.each do |address| %>
    <%= person_form.fields_for address, index: address.id do |address_form| %>
      <%= address_form.text_field :city %>
    <% end %>
  <% end %>
<% end %>
```
Предположим, у кого-то есть два адреса с id 23 и 45, это создаст что-то подобное:
```
<form accept-charset="UTF-8" action="/people/1" data-remote="true" method="post">
  <input name="_method" type="hidden" value="patch" />
  <input id="person_name" name="person[name]" type="text" />
  <input id="person_address_23_city" name="person[address][23][city]" type="text" />
  <input id="person_address_45_city" name="person[address][45][city]" type="text" />
</form>
```
Это приведет к тому, что хэш params будет выглядеть так
```
{'person' => {'name' => 'Bob', 'address' => {'23' => {'city' => 'Paris'}, '45' => {'city' => 'London'}}}}
```
Rails знает, что все эти поля ввода должны быть частью хэша person, так как `fields_for` вызывается для первого `form builder`. Определив опцию `:index`, сообщается Rails, что вместо именования полей ввода `person[address][city]`, он должен вставить индекс, заключенный в `[]`, между `address` и `city`. Это часто бывает полезно, так как тогда просто обнаружить, какая запись `Address` должна быть модифицирована. Также можно передавать числа с некоторым другим значением, строками или даже `nil` (который приведет к созданию параметра в массиве).

Чтобы создать более замысловатые вложения, можно явно указать первую часть имени поля ввода (`person[address]` в предыдущем примере):
```
<%= fields_for 'person[address][primary]', address, index: address.id do |address_form| %>
  <%= address_form.text_field :city %>
<% end %>
```
создаст такие поля ввода
```
<input id="person_address_primary_1_city" name="person[address][primary][1][city]" type="text" value="Bologna" />
```
Как правило, конечное имя поля ввода - это сцепление имени, переданного в `fields_for/form_with`, значения индекса и имени атрибута. Можно также передать опцию `:index` прямо в хелперы, такие как `text_field`, но обычно будет меньше повторов, если определить это на уровне `form builder`, а не для отдельных элементах управления `input`.

Как ярлык вы можете добавить `[]` к имени и опустить опцию `:index`. Это то же самое, что определение `index: address.id`, таким образом
```
<%= fields_for 'person[address][primary][]', address do |address_form| %>
  <%= address_form.text_field :city %>
<% end %>
```
создаст абсолютно тот же результат, что и предыдущий пример.

### Формы к внешним ресурсам <a name="3.3.8"></a>
Хелперы форм Rails можно использовать и для создания форм для передачи данных внешнему ресурсу. Однако, иногда необходимо установить `authenticity_token` для ресурса; это можно осуществить, передав параметр `authenticity_token: 'your_external_token'` в опциях `form_with`:
```
<%= form_with url: 'http://farfar.away/form', authenticity_token: 'external_token' do %>
  Form contents
<% end %>
```
Иногда при отправке данных внешнему ресурсу, такому как платежный шлюз, поля, которые можно использовать в форме, ограничены внешним API, и генерация `authenticity_token` нежелательна. Чтобы не посылать токен, просто передайте false в опцию `:authenticity_token`:
```
<%= form_with url: 'http://farfar.away/form', authenticity_token: false do %>
  Form contents
<% end %>
```

### Создание сложных форм <a name="3.3.9"></a>
Многие приложения выходят за рамки простых форм, редактирующих одиночные объекты. Например, при создании `Person` можно позволить пользователю (в той же самой форме) создать несколько записей адресов (домашний, рабочий и т.д.). При последующем редактировании этого person, пользователю должно быть доступно добавление, удаление или правка адреса, если это необходимо.

#### Настройка модели
Active Record предоставляет поддержку на уровне модели с помощью метода `accepts_nested_attributes_for`:
```
class Person < ApplicationRecord
  has_many :addresses, inverse_of: :person
  accepts_nested_attributes_for :addresses

end

class Address < ApplicationRecord
  belongs_to :person
end
```
Это создаст метод `addresses_attributes=` в `Person`, позволяющий создавать, обновлять и (опционально) уничтожать адреса.

#### Вложенные формы
Следующая форма позволяет пользователю создать `Person` и связанные с ним адреса.
```
<%= form_with model: @person do |f| %>
  Addresses:
  <ul>
    <%= f.fields_for :addresses do |addresses_form| %>
      <li>
        <%= addresses_form.label :kind %>
        <%= addresses_form.text_field :kind %>

        <%= addresses_form.label :street %>
        <%= addresses_form.text_field :street %>
        ...
      </li>
    <% end %>
  </ul>
<% end %>
```
Когда связь принимает вложенные атрибуты, `fields_for` рендерит свой блок для каждого элемента связи. В частности, если у person нет адресов, он ничего не рендерит. Обычным паттерном для контроллера является построение одного или более пустых дочерних элементов, чтобы как минимум один набор полей был показан пользователю. Следующий пример покажет 2 набора полей адресов в форме нового `person`.
```
def new
  @person = Person.new
  2.times { @person.addresses.build }
end
```
`fields_for` вкладывает `form builder`. Имя параметра будет таким, какое ожидает `accepts_nested_attributes_for`. К примеру, при создании пользователя с 2 адресами, отправленные параметры будут выглядеть так
```
{
  'person' => {
    'name' => 'John Doe',
    'addresses_attributes' => {
      '0' => {
        'kind' => 'Home',
        'street' => '221b Baker Street'
      },
      '1' => {
        'kind' => 'Office',
        'street' => '31 Spooner Street'
      }
    }
  }
}
```
Ключи хэша `:addresses_attributes` не важны, они всего лишь должны быть различными для каждого адреса.

Если связанный объект уже сохранен, `fields_for` автоматически генерирует скрытое поле с id сохраненной записи. Это можно отключить, передав `include_id: false` в `fields_for`.

#### Контроллер
Как обычно, в контроллере необходимо объявить разрешенные параметры, перед их передачей в модель:
```
def create
  @person = Person.new(person_params)
  # ...
end

private
  def person_params
    params.require(:person).permit(:name, addresses_attributes: [:id, :kind, :street])
  end
```

#### Удаление объектов
Можно позволить пользователям удалять связанные объекты, передав `allow_destroy: true` в `accepts_nested_attributes_for`
```
class Person < ApplicationRecord
  has_many :addresses
  accepts_nested_attributes_for :addresses, allow_destroy: true
end
```
Если хэш атрибутов для объекта содержит ключ `_destroy` со значением, вычисляющимся как 'true' (например, 1, '1', true или 'true'), тогда объект будет уничтожен. Эта форма позволяет пользователям удалять адреса:
```
<%= form_with model: @person do |f| %>
  Addresses:
  <ul>
    <%= f.fields_for :addresses do |addresses_form| %>
      <li>
        <%= addresses_form.check_box :_destroy %>
        <%= addresses_form.label :kind %>
        <%= addresses_form.text_field :kind %>
        ...
      </li>
    <% end %>
  </ul>
<% end %>
```
Не забудьте обновить список разрешенных параметров в вашем контроллере, а также включить туда поле `_destroy`:
```
def person_params
  params.require(:person).
    permit(:name, addresses_attributes: [:id, :kind, :street, :_destroy])
end
```

#### Предотвращение пустых записей
Часто полезно игнорировать наборы полей, которые пользователь не заполнял. Этим можно управлять, передав `:reject_if proc` в `accepts_nested_attributes_for`. Этот proc будет вызван для каждого хэша атрибутов, отправляемого формой. Если `proc` возвращает false, тогда Active Record не создаст связанный объект для этого хэша. Следующий пример пытается создать адрес, если установлен атрибут `kind`.
```
class Person < ApplicationRecord
  has_many :addresses
  accepts_nested_attributes_for :addresses, reject_if: lambda {|attributes| attributes['kind'].blank?}
end
```
Вместо этого для удобства можно передать символ `:all_blank`, который создаст `proc`, который отвергнет записи, когда все атрибуты пустые, за исключением любого значения для `_destroy`.

#### Добавление полей на лету
Вместо того, чтобы рендерить несколько наборов полей раньше времени, можно добавить их только тогда, когда пользователь нажимает на кнопку 'Добавить новый адрес'. Rails не предоставляет какой-либо встроенной поддержки для этого. При генерации новых наборов полей следует убедиться, что ключ связанного массива уникальный - наиболее распространенным выбором является текущий JavaScript date (миллисекунды после epoch).

### Использование `form_for` и `form_tag` <a name="3.3.10"></a>
До того, как `form_with` был представлен в Rails 5.1, его функционал был разделен между `form_tag` и `form_for`. Последние сейчас мягко устаревшие. Документация по их использованию находится в старых версиях этого руководства.



# Контроллеры <a name="4"></a>
## Обзор Action Controller <a name="4.1"></a>
### Что делает контроллер? <a name="4.1.1"></a>
После того, как роутер определит, какой контроллер использовать для обработки запроса, контроллер ответственен за осмысление запроса и генерацию подходящего ответа.
Для большинства приложений, основанных на RESTful, контроллер получает запрос (это невидимо для вас, как для разработчика), извлекает или сохраняет данные в модели и использует вьюху для создания результирующего HTML. Если контроллеру необходимо работать немного по-другому, не проблема, это всего лишь наиболее распространенный способ работы контроллера.

Таким образом, контроллер можно рассматривать как посредника между моделями и вьюхами. Он делает данные модели доступными вьюхе, так что она может отображать эти данные пользователю, и он сохраняет или обновляет данные от пользователя в модель.

### Соглашение по именованию контроллеров <a name="4.1.2"></a>
Соглашение по именованию контроллеров в Rails устанавливает предпочтение множественного числа в последнем слове имени контроллера, хотя строго это не требуется (например, ApplicationController). К примеру, `ClientsController` более предпочтителен, чем `ClientController`, `SiteAdminsController` более предпочтителен, чем `SiteAdminController` или `SitesAdminsController`, и так далее.

Следование этому соглашению позволяет вам использовать генераторы маршрутов по умолчанию (например, `resources` и т.п.) без необходимости определять каждый `:path` или `:controller`, и сохраняет последовательным использование хелперов URL и путей во всем вашем приложении.

### Методы и экшны <a name="4.1.3"></a>
Контроллер - это класс Ruby, унаследованный от `ApplicationController` и содержащий методы, как и любой другой класс. Когда ваше приложение получает запрос, роутинг определяет, какой контроллер и экшн нужно запустить, затем Rails создает экземпляр этого контроллера и запускает метод с именем, как у экшна.
```
class ClientsController < ApplicationController
  def new
  end
end
```
В качестве примера, если пользователь перейдет на `/clients/new` в приложении, чтобы добавить нового клиента, Rails создаст экземпляр `ClientsController` и вызовет метод `new`. Отметьте, что пустой метод из вышеприведенного примера будет прекрасно работать, так как Rails по умолчанию отрендерит вьюху `new.html.erb`, если в экшне не будет указано иное. При создании нового `Client`, метод new может сделать переменную экземпляра `@client` доступной во вьюхе:
```
def new
  @client = Client.new
end
```
`ApplicationController` унаследован от `ActionController::Base`, который определяет несколько полезных методов. Это руководство раскроет часть из них, но если вы любопытны, можете увидеть их все в документации по API.

Только `public` методы могут быть вызваны как экшны. Хорошей практикой является уменьшение области видимости методов (при помощи `private` или `protected`), не предназначенных быть экшнами, таких как вспомогательные методы и фильтры.

### Параметры
Возможно, вы хотите получить доступ к данным, посланным пользователем, или к другим параметрам в экшнах вашего контроллера. Существует два типа параметров, доступных в веб-приложениях. Первый - это параметры, посланные как часть URL, называемые параметрами строки запроса. Строка запроса всегда следует после "?" в URL. Второй тип параметров обычно упоминается как данные POST. Эта информация обычно приходит из формы HTML, заполняемой пользователем. Эти параметры еще называют данными POST, так как могут быть посланы только как часть HTTP-запроса метода POST. Rails не делает каких-либо различий между строковыми параметрами и параметрами POST, и они оба доступны в хэше params в вашем контроллере:
```
class ClientsController < ApplicationController
  # Этот экшн использует параметры строки запроса, потому что он
  # запускается HTTP-запросом метода GET, но это не влияет на
  # способ, с помощью которого можно получить доступ к ним.
  # URL для этого экшна выглядит как этот, запрашивающий список
  # активированных клиентов: /clients?status=activated
  def index
    if params[:status] == "activated"
      @clients = Client.activated
    else
      @clients = Client.inactivated
    end
  end

  # Этот экшн использует параметры POST. Они, скорее всего, пришли от
  # формы HTML, которую подтвердил пользователь. URL для этого
  # RESTful запроса будет "/clients", и данные будут посланы
  # как часть тела запроса.
  def create
    @client = Client.new(params[:client])
    if @client.save
      redirect_to @client
    else
      # Эта строчка переопределяет поведение рендеринга по умолчанию,
      # который отрендерил бы вьюху "create".
      render "new"
    end
  end
end
```

#### Параметры в хэше и в массиве
Хэш `params` не ограничен одномерными ключами и значениями. Он может содержать вложенные массивы и хэши. Чтобы послать массив значений, добавьте пустую пару квадратных скобок "[]" к имени ключа:
```
GET /clients?ids[]=1&ids[]=2&ids[]=3
```
> Фактический URL в этом примере будет перекодирован как "/clients?ids%5b%5d=1&ids%5b%5d=2&ids%5b%5b=3", так как "[" и "]" недопустимы в URL. В основном, вам не придется беспокоиться об этом, так как браузер позаботится об этом за вас, а Rails декодирует это обратно, когда получит, но если вы когда-нибудь будете отправлять эти запросы вручную, имейте это в виду.

Значение `params[:ids]` теперь будет `["1", "2", "3"]`. Отметьте, что значения параметра всегда строковое; Rails не делает попыток угадать или предсказать тип.

> Значения, такие как `[nil]` или `[nil, nil, ...]` в `params` по умолчанию заменяются на `[]` по причине безопасности.

Чтобы послать хэш, следует заключить имя ключа в скобки:
```
<form accept-charset="UTF-8" action="/clients" method="post">
  <input type="text" name="client[name]" value="Acme" />
  <input type="text" name="client[phone]" value="12345" />
  <input type="text" name="client[address][postcode]" value="12345" />
  <input type="text" name="client[address][city]" value="Carrot City" />
</form>
```
Когда эта форма будет подтверждена, значение `params[:client]` будет `{ "name" => "Acme", "phone" => "12345", "address" => { "postcode" => "12345", "city" => "Carrot City" } }`. Обратите внимание на вложенный хэш в `params[:client][:address]`.

Объект params ведет себя как хэш, но позволяет взаимозаменяемо использовать символы и строки как ключи.

#### Параметры JSON
Если вы пишете приложение веб-сервиса, возможно вам более комфортно принимать параметры в формате JSON. Если заголовок `"Content-Type"` вашего запроса установлен в `"application/json"`, Rails автоматически загружает ваши параметры в хэш params, к которому можно получить доступ обычным образом.

Так, к примеру, если вы пошлете такое содержимое JSON:
```
{ "company": { "name": "acme", "address": "123 Carrot Street" } }
```
Ваш контроллер будет получать `params[:company]` как `{ "name" => "acme", "address" => "123 Carrot Street" }`.

Также, если включите `config.wrap_parameters` в своем инициализаторе или вызовете wrap_parameters в своем контроллере, можно безопасно опустить корневой элемент в параметре JSON. Параметры будут клонированы и обернуты в ключ, соответствующий по умолчанию имени вашего контроллера. Таким образом, вышеупомянутый запрос JSON может быть записан как:
```
{ "name": "acme", "address": "123 Carrot Street" }
```
И предположим, что мы посылаем данные в `CompaniesController`, тогда он будет обернут в ключ `:company` следующим образом:
```
{ name: "acme", address: "123 Carrot Street", company: { name: "acme", address: "123 Carrot Street" } }
```
Вы сможете настроить имя ключа или определенные параметры, которые вы хотите обернуть, ознакомившись с документацией по API.

> Поддержка парсинга параметров XML была извлечена в гем `actionpack-xml_parser`.

#### Параметры роутинга
Хэш params будет всегда содержать ключи `:controller` и `:action`, но следует использовать методы `controller_name` и `action_name` вместо них для доступа к этим значениям. Любой другой параметр, определенный роутингом, такой как `:id`, также будет доступен. Например, рассмотрим перечень клиентов, где список может быть показан либо для активных, либо для неактивных клиентов. Мы можем добавить маршрут, который перехватывает параметр `:status` в "красивом" URL:
```
get '/clients/:status' => 'clients#index', foo: 'bar'
```
В этом случае, когда пользователь откроет URL `/clients/active`, `params[:status]` будет установлен в "active". Когда использован этот маршрут, `params[:foo]` также будет установлен в "bar", как будто он был передан в строке запроса. Ваш контроллер также получит `params[:action]` как "index" и `params[:controller]` как "clients".

#### `default_url_options`
Можно установить глобальные параметры по умолчанию для генерации URL, определив в контроллере метод по имени `default_url_options`. Этот метод должен возвращать хэш с желаемыми значениями по умолчанию, ключи которого должны быть символами:
```
class ApplicationController < ActionController::Base
  def default_url_options
    # /ru/clients/hub
    # GET /:locale/clients/hub возвращает локаль
    # возможно я не так понял
    { locale: I18n.locale }
  end
end
```
Эти опции будут использованы как начальная точка при генерации URL, поэтому они могут быть переопределены опциями, переданными в `url_for`.

Если определить `default_url_options` в `ApplicationController`, как это показано в вышеприведенном примере, эти значения по умолчанию будут использованы для генерации всех URL. Этот метод также может быть определен в одном отдельном контроллере, и в этом случае он влияет только на URL, сгенерированные в нем.

В данном запросе, на самом деле, метод не вызывается для каждого сгенерированного URL; для повышения производительности, возвращаемый хэш кэшируется, метод выполняется не более одного раза за запрос.

#### Strong Parameters
С помощью сильных параметров (strong parameters) параметры Action Controller запрещены к использованию в массовых назначениях Active Model до тех пор, пока они не добавлены в белый список. Это означает, что нужно будет принять осознанное решение о том, какие атрибуты будут доступны для массового обновления. Это лучший способ предотвратить случайную уязвимость, позволяющую пользователям обновлять чувствительные атрибуты модели.

Кроме того, параметры могут быть помечены как обязательные и будут проходить через предопределенные raise/rescue, что приведет к 400 Bad Request, если не будут переданы все обязательные параметры.
```
class PeopleController < ActionController::Base
  # Это вызовет исключение ActiveModel::ForbiddenAttributesError,
  # так как используется массовое назначение без явного шага permit.
  def create
    Person.create(params[:person])
  end

  # Это будет выполняться должным образом, пока в параметрах есть ключ person, иначе будет
  # вызвано исключение ActionController::ParameterMissing, которое будет
  # поймано в ActionController::Base и превращено в ошибку 400 Bad Request.
  def update
    person = current_account.people.find(params[:id])
    person.update!(person_params)
    redirect_to person
  end

  private
    # Использование приватного метода для инкапсуляции разрешенных параметров -
    # это всего лишь хороший паттерн, с помощью которого можно повторно
    # использовать тот же самый список разрешений при создании и обновлении.
    # Этот метод также можно адаптировать к проверке разрешенных атрибутов для
    # каждого пользователя.
    def person_params
      params.require(:person).permit(:name, :age)
    end
end
```
#####  Разрешенные скалярные значения
Для данного
```
params.permit(:id)
```
ключ `:id` пройдет проверку белым списком, если он появится в `params` и будет иметь разрешенное скалярное значение. В ином случае ключ будет отфильтрован, таким образом, массивы, хэши и любые другие объекты не смогут быть переданы.

Разрешенные скалярные типы следующие `String, Symbol, NilClass, Numeric, TrueClass, FalseClass, Date, Time, DateTime, StringIO, IO, ActionDispatch::Http::UploadedFile и Rack::Test::UploadedFile`.

Чтобы объявить, что значение в params должно быть массивом разрешенных скалярных значений, свяжите ключ с пустым массивом:
```
params.permit(id: [])
```
Иногда невозможно или неудобно объявлять валидные ключи параметров хэша или его внутреннюю структуру. Просто укажите пустой хэш:
```
params.permit(preferences: {})
```
но будьте осторожны, так это открывает возможность произвольного ввода. В этом случае `permit` гарантирует, что значения в возвращаемой структуре являются разрешенными скалярными величинами и отфильтровывает все иное.

Чтобы добавить в белый список полный хэш параметров, может быть использован метод `permit!`
```
params.require(:log_entry).permit!
```
Это помечает хэш параметров `:log_entry` и любые вложенные хэши как разрешенные, и не проверяет разрешенные скалярные величины, принимается все. Следует соблюдать предельную осторожность при использовании `permit!`, так как он позволит массовое назначение всех текущих и будущих атрибутов модели.

##### Вложенные параметры
Также можно использовать `permit` c вложенными параметрами, например:
```
params.permit(:name, { emails: [] },
              friends: [ :name,
                         { family: [ :name ], hobbies: [] }])
```
Это объявление поместит в белый список атрибуты `name`, `emails` и `friends`. Ожидается, что `emails` будет массивом разрешенных скалярных значений, и что `friends` будет массивом ресурсов с определенными атрибутами: у них будет атрибут name (допустимо любое скалярное значение), атрибут `hobbies` как массив разрешенных скалярных значений, и атрибут `family`, который может иметь только name (также допустимо любое скалярное значение).

##### Дополнительные примеры
Возможно вы захотите использовать разрешенные атрибуты в экшне `new`. В этой связи возникает проблема, из-за которой нельзя использовать `require` на корневом ключе, так как обычно он не существует при вызове `new`:
```
# используя `fetch`, можно предоставить значение по умолчанию и использовать
# далее Strong Parameters API.
params.fetch(:blog, {}).permit(:title, :author)
```
Метод класса модели `accepts_nested_attributes_for` позволяет обновлять и удалять связанные записи. Он основывается на параметрах `id` и `_destroy`:
```
# permit :id и :_destroy
params.require(:author).permit(:name, books_attributes: [:title, :id, :_destroy])
```
Хэши с числовыми ключами трактуются по-другому, и можно объявить атрибуты так, как будто они являются прямыми детьми. Такой тип параметров можно получить при использовании `accepts_nested_attributes_for` в сочетании со связью `has_many`:
```
# Чтобы добавить в белый список следующие данные:
# {"book" => {"title" => "Some Book",
#             "chapters_attributes" => { "1" => {"title" => "First Chapter"},
#                                        "2" => {"title" => "Second Chapter"}}}}

params.require(:book).permit(:title, chapters_attributes: [:title])
```
##### За пределами области видимости Strong Parameters
Strong parameter API был разработан для наиболее общих вариантов использования. Это не панацея от всех ваших проблем белого списка. Однако можно легко смешивать API с вашим собственным кодом для адаптации к вашей ситуации.

Рассмотрим ситуацию, когда есть параметры, представляющие имя продукта, и хэш произвольных данных, связанных с этим продуктом, и нужно поместить в белый список атрибут name продукта, а также весь хэш данных. API в strong parameters не позволит явно добавить в белый список весь вложенный хэш с любыми ключами, но можно использовать ключи вложенного хэша для объявления, что следует добавить в белый список:
```
def product_params
  params.require(:product).permit(:name, data: params[:product][:data].try(:keys))
end
```

###  Сессия <a name="4.1.5"></a>
В приложении есть сессия для каждого пользователя, в которой можно хранить небольшие объемы данных, которые будут персистентными между запросами. Сессия доступна только в контроллере и во вьюхе, и может использовать один из нескольких механизмов хранения:
* `ActionDispatch::Session::CookieStore` - Хранит все на клиенте.
* `ActionDispatch::Session::CacheStore` - Хранит данные в кэше Rails.
* `ActionDispatch::Session::ActiveRecordStore` - Хранит данные в базе данных с использованием Active Record. (требует гем `activerecord-session_store`).
* `ActionDispatch::Session::MemCacheStore` - Хранит данные в кластере memcached (эта устаревшая реализация, вместо нее рассмотрите использование `CacheStore`). 

Все хранилища сессии используют куки для хранения уникального ID каждой сессии (вы должны использовать куки, Rails не позволяет передавать ID сессии в URL, так как это менее безопасно).

В большинстве хранилищ этот ID используется для поиска данных сессии на сервере, в т.ч. в таблице базы данных. Имеется одно исключение, это дефолтное и рекомендуемое хранилище сессии - `CookieStore` - которое хранит все данные сессии в куки (ID остается по-прежнему доступным, если он нужен). Преимущества его заключаются в легкости, отсутствии необходимости настройки для нового приложения в порядке использования сессии. Данные в куки криптографически подписаны, что делает их защищенными от взлома. И они также зашифрованы, таким образом любой получивший к ним доступ, не сможет прочитать их содержимое (Rails не примет их, если они были отредактированы).

CookieStore могут хранить около 4 Кбайт данных - намного меньше, чем остальные - но этого обычно хватает. Хранение большего количества данных в сессии не рекомендуется, вне зависимости от того, какое хранилище сессии используется в приложении. Особенно следует избегать хранения в сессии сложных объектов (ничего, кроме базовых объектов Ruby, наиболее распространенным примером является экземпляры модели), так как сервер может не собрать их между запросами, что приведет к ошибке.

Если пользовательские сессии не хранят критически важные данные или нет необходимости в ее сохранности на долгий период (скажем, если она используется только для флеш-сообщений), можно рассмотреть использование `ActionDispatch::Session::CacheStore`. Он сохранит сессии с использованием реализации кэша, которая была настроена для приложения. Преимущество этого заключается в том, что для хранения сессий можно использовать существующую инфраструктуру кэширования без необходимости дополнительных настроек или администрирования. Недостатком, разумеется, является то, что сессии будут недолговечными и могут исчезнуть в любое время.

Читайте подробнее о хранении сессий в руководстве Безопасность приложений на Rails.

Если вы нуждаетесь в другом механизме хранения сессий, измените его в инициализаторе:
```
# Use the database for sessions instead of the cookie-based default,
# which shouldn't be used to store highly confidential information
# (create the session table with "rails g active_record:session_migration")
# Rails.application.config.session_store :active_record_store
```
Rails устанавливает ключ сессии (имя куки) при подписании данных сессии. Он также может быть изменен в инициализаторе:
```
# Be sure to restart your server when you modify this file.
Rails.application.config.session_store :cookie_store, key: '_your_app_session'
```
Можете также передать ключ `:domain` и определить имя домена для куки:
```
# Be sure to restart your server when you modify this file.
Rails.application.config.session_store :cookie_store, key: '_your_app_session', domain: ".example.com"
```
Rails устанавливает (для CookieStore) секретный ключ, используемый для подписания данных сессии, в `config/credentials.yml.enc`. Он может быть изменен с помощью `bin/rails credentials:edit`.
```
# aws:
#   access_key_id: 123
#   secret_access_key: 345

# Used as the base secret for all MessageVerifiers in Rails, including the one protecting cookies.
secret_key_base: 492f...
```
> Изменение `secret_key_base` при использовании `CookieStore` делает все предыдущие сессии невалидными.

#### Доступ к сессии
В контроллере можно получить доступ к сессии с помощью метода экземпляра `session`.

Сессии лениво загружаются. Если не получать доступ к сессиям в коде экшна, они не будут загружаться. Следовательно, никогда не придется отключать сессии, просто не обращайтесь к ним, и они будут выполнять свое задание.

Значения сессии хранятся, используя пары ключ/значение, подобно хэшу:
```
class ApplicationController < ActionController::Base

  private

  # Находим пользователя с ID, хранящимся в сессии с ключом
  # :current_user_id Это обычный способ обрабатывать вход пользователя
  # в приложении на Rails; вход устанавливает значение сессии, а
  # выход убирает его.
  def current_user
    @_current_user ||= session[:current_user_id] &&
      User.find_by(id: session[:current_user_id])
  end
end
```
Чтобы что-то хранить в сессии, просто присвойте это ключу, как в хэше:
```
class LoginsController < ApplicationController
  # "Создаем" логин (при входе пользователя)
  def create
    if user = User.authenticate(params[:username], params[:password])
      # Сохраняем ID пользователя в сессии, так что он может быть использован
      # в последующих запросах
      session[:current_user_id] = user.id
      redirect_to root_url
    end
  end
end
```
Чтобы убрать что-то из сессии, удалите пару ключ/значение:
```
class LoginsController < ApplicationController
  # "Удаляем" логин (при выходе пользователя)
  def destroy
    # Убираем id пользователя из сессии
    session.delete(:current_user_id)
    # Очистить мемоизированного текущего пользователя
    @_current_user = nil
    redirect_to root_url
  end
end
```
Для сброса текущей сессии, используйте `reset_session`.

#### Flash
Flash - это специальная часть сессии, которая очищается с каждым запросом. Это означает, что сохраненные там значения будут доступны только в следующем запросе, что полезно для передачи сообщений об ошибках и т.п.

Доступ к нему можно получить так же, как к сессии, подобно хэшу (это экземпляр FlashHash).

Давайте рассмотрим случай логаута в качестве примера. Контроллер может послать сообщение, которое будет отображено пользователю при следующем запросе:
```
class LoginsController < ApplicationController
  def destroy
    session.delete(:current_user_id)
    flash[:notice] = "You have successfully logged out."
    redirect_to root_url
  end
end
```
Отметьте, что также возможно назначить сообщение флэш как часть перенаправления. Можно назначить `:notice`, `:alert` или общего назначения `:flash`:
```
redirect_to root_url, notice: "You have successfully logged out."
redirect_to root_url, alert: "You're stuck here!"
redirect_to root_url, flash: { referral_code: 1234 }
```
Экшн destroy перенаправляет на `root_url` приложения, где будет отображено сообщение. Отметьте, что от следующего экшна полностью зависит решение, будет ли он или не будет что-то делать с тем, что предыдущий экшн вложил во `flash`. Принято отображать любые сообщения об ошибке или уведомления из `flash` в макете приложения:
```
<html>
  <!-- <head/> -->
  <body>
    <% flash.each do |name, msg| -%>
      <%= content_tag :div, msg, class: name %>
    <% end -%>

    <!-- дальнейшее содержимое -->
  </body>
</html>
```
В этом случае, если экшн установил сообщения уведомления или предупреждения, макет отобразит их автоматически.

Можно передать все, что только сессия может хранить; вы не ограничены уведомлениями или предупреждениями:
```
<% if flash[:just_signed_up] %>
  <p class="welcome">Welcome to our site!</p>
<% end %>
```
Если хотите, чтобы значение `flash` было перенесено в другой запрос, используйте метод `keep`:
```
class MainController < ApplicationController
  # Давайте скажем этому экшну, соответствующему root_url, что хотим
  # все запросы сюда перенаправить на UsersController#index. Если
  # экшн установил flash и направил сюда, значения в нормальной ситуации
  # будут потеряны, когда произойдет другой редирект, но Вы можете
  # использовать 'keep', чтобы сделать его персистентным для другого запроса.
  def index
    # Все значения flash будут персистентными.
    flash.keep

    # Можете также использовать ключ для сохранения определенных значений.
    # flash.keep(:notice)
    redirect_to users_url
  end
end
```

##### `flash.now`
По умолчанию, добавление значений во `flash` делает их доступными для следующего запроса, но иногда хочется иметь доступ к этим значениям в том же запросе. Например, если экшн `create` проваливается при сохранении ресурса, и будет отрендерен непосредственно макет new, что не приведет к новому запросу, но все равно можно отобразить сообщение, используя `flash`. Чтобы это сделать, используйте `flash.now` так же, как используете обычный `flash`:
```
class ClientsController < ApplicationController
  def create
    @client = Client.new(params[:client])
    if @client.save
      # ...
    else
      flash.now[:error] = "Could not save client"
      render action: "new"
    end
  end
end
```

### Куки <a name="4.1.6"></a>
Приложение может хранить небольшое количество данных у клиента - в так называемых куки - которые будут персистентными между запросами и даже сессиями. Rails обеспечивает простой доступ к куки посредством метода `cookies`, который - очень похож на `session` - и работает как хэш:
```
class CommentsController < ApplicationController
  def new
    # Автозаполнение имени комментатора, если оно хранится в куки.
    @comment = Comment.new(author: cookies[:commenter_name])
  end

  def create
    @comment = Comment.new(params[:comment])
    if @comment.save
      flash[:notice] = "Thanks for your comment!"
      if params[:remember_name]
        # Запоминаем имя комментатора.
        cookies[:commenter_name] = @comment.author
      else
        # Удаляем из куки имя комментатора, если оно есть.
        cookies.delete(:commenter_name)
      end
      redirect_to @comment.article
    else
      render action: "new"
    end
  end
end
```
Отметьте, что если для удаления значений сессии ключ устанавливается в nil, то для удаления значений куки следует использовать `cookies.delete(:key)`.

Rails также предоставляет подписанные куки и зашифрованные куки для хранения чувствительных данных. В подписанные куки добавляется криптографическая сигнатура значений куки для защиты их целостности. Зашифрованные куки шифруют значения в дополнение к их подписи, поэтому они не могут быть прочитаны пользователем. За подробностями обратитесь к документации API.

Эти специальные куки используют сериализатор для сериализации назначенных значений в строки и десериализации их в объекты Ruby при чтении.

Можно определить, какой сериализатор использовать:
```
Rails.application.config.action_dispatch.cookies_serializer = :json
```
Для новых приложений сериализатором по умолчанию является `:json`. Для совместимости со старыми приложениями с существующими куки, используется `:marshal`, когда не определена опция `serializer`.

Также можно установить этой опции ``:hybrid`, в этом случае Rails десериализует существующие (сериализованные Marshal) куки при чтении и перезапишет их в формате JSON. Это полезно при миграции существующих приложений на сериализатор `:json`.

Также возможно передать произвольный сериализатор, откликающийся на `load` и `dump`:
```
Rails.application.config.action_dispatch.cookies_serializer = MyCustomSerializer
```
При использовании сериализатора `:json` или `:hybrid`, следует знать, что не все объекты Ruby могут быть сериализованы как JSON. Например, объекты `Date` и `Time` будут сериализованы как строки, и у хэшей ключи будут преобразованы в строки.
```
class CookiesController < ApplicationController
  def set_cookie
    cookies.encrypted[:expiration_date] = Date.tomorrow # => Thu, 20 Mar 2014
    redirect_to action: 'read_cookie'
  end

  def read_cookie
    cookies.encrypted[:expiration_date] # => "2014-03-20"
  end
end
```
Желательно, чтобы в куки хранились только простые данные (строки и числа). Если храните сложные объекты, вам необходимо преобразовывать вручную при чтении значений в последующих запросах.

Если вы храните сессию в куки, все перечисленное также применяется к хэшам `session` и `flash`.

### Рендеринг данных XML и JSON <a name="4.1.7"></a>
ActionController позволяет очень просто рендерить данные XML или JSON. Если сгенерируете контроллер с помощью скаффолда, то он будет выглядеть следующим образом.
```
class UsersController < ApplicationController
  def index
    @users = User.all
    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render xml: @users }
      format.json { render json: @users }
    end
  end
end
```
Отметьте, что в вышеописанном коде использован `render xml: @users`, а не `render xml: @users.to_xml`. Если объект не String, то Rails автоматически вызовет `to_xml`.

### Фильтры <a name="4.1.8"></a>
Фильтры - это методы, которые запускаются "до", "после" или "до и после" экшна контроллера.

Фильтры наследуются, поэтому, если вы установите фильтр в `ApplicationController`, он будет запущен в каждом контроллере вашего приложения.

Фильтры "before" могут прерывать цикл запроса. Обычный фильтр "before" - это, например, тот, который требует, чтобы пользователь был авторизован для запуска экшна. Метод фильтра можно определить следующим образом:
```
class ApplicationController < ActionController::Base
  before_action :require_login

  private

  def require_login
    unless logged_in?
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url # прерывает цикл запроса
    end
  end
end
```
Метод просто записывает сообщение об ошибке во `flash` и перенаправляет на форму авторизации, если пользователь не авторизовался. Если фильтр "before" рендерит или перенаправляет, экшн не запустится. Если есть дополнительные фильтры в очереди, они также будут отменены.

В этом примере фильтр добавлен в `ApplicationController`, и поэтому все контроллеры в приложении наследуют его. Это приводит к тому, что всё в приложении требует, чтобы пользователь был авторизован, чтобы пользоваться им. По понятным причинам (пользователь не сможет зарегистрироваться в первую очередь!), не все контроллеры или экшны должны требовать его. Вы можете не допустить запуск этого фильтра перед определенными экшнами с помощью `skip_before_action`:
```
class LoginsController < ApplicationController
  skip_before_action :require_login, only: [:new, :create]
end
```
Теперь, экшны `LoginsController` `new` и `create` будут работать как раньше, без требования к пользователю быть зарегистрированным. Опция `:only` используется для пропуска фильтра только для этих экшнов, а также есть опция `:except`, которая работает наоборот. Эти опции можно использовать и при добавлении фильтров, поэтому необходимо добавить фильтр, который запускается только для выбранных экшнов в первую очередь.

> Вызов одного и того же фильтра несколько раз с разными опциями не будет работать, поскольку последнее определение фильтра перезапишет предыдущие.

#### After фильтры и around фильтры
В дополнение к фильтрам "before", можно запустить фильтры после того, как экшн был выполнен, или "и до, и после".

Фильтры "after" похожи на "before", но поскольку экшн уже был запущен, у них есть доступ к данным отклика, которые будут отосланы клиенту. Очевидно, фильтры "after" не могут остановить экшн от запуска. Обратите внимание, что фильтры "after" выполняются только после успешного выполнения экшна, но не при возникновении исключения в цикле запроса.

Фильтры "around" ответственны за запуск связанных с ними экшнов с помощью `yield`, подобно тому, как работают промежуточные программы Rack.

Например, на веб-сайте, где для изменений есть процедура утверждения информации, администратор может легко их просмотреть, просто применив их внутри транзакции:
```
class ChangesController < ApplicationController
  around_action :wrap_in_transaction, only: :show

  private

  def wrap_in_transaction
    ActiveRecord::Base.transaction do
      begin
        yield
      ensure
        raise ActiveRecord::Rollback
      end
    end
  end
end
```
Отметьте, что фильтры "around" также оборачивают рендеринг. В частности, если в вышеуказанном примере вьюха сама начнет считывать из базы данных (например через скоуп), она это осуществит внутри транзакции, предоставив, таким образом, данные для предварительного просмотра.

Можно не вызывать `yield` и создать отклик самостоятельно, в этом случае экшн не будет запущен.

#### Другие способы использования фильтров
Хотя наиболее распространенный способ использование фильтров - это создание `private` методов и использование `*_action` для их добавления, есть два других способа делать то же самое.

Первый - это использовать блок прямо в методах `*_action`. Блок получает контроллер как аргумент. Фильтр `require_login` может быть переписан с использованием блока:
```
class ApplicationController < ActionController::Base
  before_action do |controller|
    unless controller.send(:logged_in?)
      flash[:error] = "You must be logged in to access this section"
      redirect_to new_login_url
    end
  end
end
```
Отметьте, что фильтр в этом случае использует метод send, так как `logged_in?` является `private`, и фильтр не запустится в области видимости контроллера. Это не рекомендуемый способ применения такого особого фильтра, но в простых задачах он может быть полезен.

Второй способ - это использовать класс (фактически, подойдет любой объект, реагирующий правильными методами) для управления фильтрацией. Это полезно для более сложных задач, которые не могут быть осуществлены предыдущими двумя способами по причине трудности читаемости и повторного использования. Как пример, можете переписать фильтр авторизации снова, использовав класс:
```
class ApplicationController < ActionController::Base
  before_action LoginFilter
end

class LoginFilter
  def self.before(controller)
    unless controller.send(:logged_in?)
      controller.flash[:error] = "You must be logged in to access this section"
      controller.redirect_to controller.new_login_url
    end
  end
end
```
Опять же, это не идеальный пример для этого фильтра, поскольку он не запускается в области видимости контроллера, а получает контроллер как аргумент. Класс фильтра должен реализовывать метод с тем же именем, что и фильтр, поэтому для фильтра `before_action` класс должен реализовать метод `before`, и так далее. Метод around должен иметь `yield` для выполнения экшна.

### Защита от подделки запроса <a name="4.1.9"></a>
Межсайтовая подделка запроса (CSRF, Cross-Site Request Forgery) - это тип атаки, в которой сайт обманом заставляет пользователя сделать запрос на другой сайт, возможно, добавляя, модифицируя или удаляя данные на этом сайте без ведома или прав доступа пользователя.

Первый шаг, чтобы избежать это - убедиться, что все "разрушительные" экшны (создание, обновление и уничтожение) могут быть доступны только не-GET-запросам. Если вы следуете соглашениям RESTful, то уже делаете это. Однако, сайт злоумышленника может также легко послать не-GET-запрос на ваш сайт, поэтому и необходима защита от подделки запроса. Как сказано в названии, он защищает от подделки запроса.

Это можно сделать, добавив неугадываемый токен, известный только вашему серверу, в каждый запрос. При этом способе, если запрос приходит без подходящего токена, ему будет отказано в доступе.

Если вы генерируете подобную форму:
```
<%= form_with model: @user, local: true do |form| %>
  <%= form.text_field :username %>
  <%= form.text_field :password %>
<% end %>
```
то увидите, как токен будет добавлен в скрытое поле:
```
<form accept-charset="UTF-8" action="/users/1" method="post">
<input type="hidden"
       value="67250ab105eb5ad10851c00a5621854a23af5489"
       name="authenticity_token"/>
<!-- fields -->
</form>
```
Rails добавит этот токен в каждую форму, генерируемую с помощью хелперов форм, таким образом, большую часть времени можете об этом не беспокоиться. Если вы пишете формы вручную или хотите добавить токен по другой причине, это можно сделать, используя метод `form_authenticity_token`:

`form_authenticity_token` генерирует валидный аутентификационный токен. Его полезно размещать в тех местах, куда Rails не добавляет его автоматически, например в произвольные вызовы Ajax.

В руководстве Безопасность приложений на Rails имеется более подробная информация об этом, и множество других вопросов, посвященных безопасности, которые вы должны принимать во внимание при разработке веб-приложения.

### Объекты Request и Response <a name="4.1.10"></a>
В каждом контроллере есть два акцессор-метода, указывающих на объекты запроса и отклика, связанные с циклом запроса, находящегося в текущее время на стадии выполнения. Метод request содержит экземпляр `ActionDispatch::Request`, а метод `response` возвращает объект отклика, представляющий то, что будет отправлено обратно на клиента.

#### Объект `request`
Объект `request` содержит множество полезной информации о запросе, полученном с клиента. Чтобы получить полный перечень доступных методов, обратитесь к документации по Rails API и документации по Rack. В числе свойств, доступных для этого объекта, следующие:

|Свойство | Назначение |
|---------|------------|
| `host` 	| Имя хоста, используемого для этого запроса. |
| `domain(n=2)` | Первые n сегментов имени хоста, начиная справа (домен верхнего уровня).|
| `format` | 	Тип содержимого, запрошенного с клиента. |
| `method` | 	Метод HTTP, использованного для запроса. |
| `get?`, `post?`, `patch?`, `put?`, `delete?`, `head?` | Возвращает `true`, если метод HTTP - это GET/POST/PATCH/PUT/DELETE/HEAD. |
| `headers` |	Возвращает хэш, содержащий заголовки, связанные с запросом. |
| `port` | Номер порта (целое число), использованного для запроса. |
| `protocol` | Возвращает строку, содержащую использованный протокол плюс "://", например "http://". |
| `query_string` | 	Часть URL со строкой запроса, т.е. все после "?". |
| `remote_ip` |	Адрес IP клиента. |
| `url` | Полный URL, использованный для запроса. |

##### `path_parameters`, `query_parameters` и `request_parameters`
Rails собирает все параметры, посланные вместе с запросом, в хэше `params`, были ли они посланы как часть строки запроса, либо в теле запроса `post`. У объекта `request` имеется три акцессора, которые предоставляют доступ к этим параметрам в зависимости от того, откуда они пришли. Хэш `query_parameters` содержит параметры, посланные как часть строки запроса, в то время как хэш `request_parameters` содержит параметры, посланные как часть тела `post`. Хэш `path_parameters` содержит параметры, распознанные роутингом как часть пути, ведущего к определенному контроллеру и экшну.


#### Объект `response`

Объект `response` (отклик) обычно не используется напрямую, а создается во время выполнения экшна и рендеринга данных, которые посылаются обратно пользователю, но иногда - например, в последующем фильтре - бывает полезно иметь доступ к отклику напрямую. Некоторые из этих акцессор-методов имеют сеттеры, позволяющие изменять их значения. Чтобы получить полный перечень доступных методов, обратитесь к документации по Rails API и документации по Rack.

| Свойство | Назначение |
|----------|------------|
| `body` 	 | Это строка данных, которая будет возвращена клиенту. Чаще всего это HTML. |
| `status` |	Код статуса HTTP для отклика, например 200 для успешного запроса или 404 для ненайденного файла. |
| `location` | URL, по которому клиент будет перенаправлен, если указан. |
| `content_type` | Тип содержимого отклика. |
| `charset` |	Кодировка, используемая для отклика. По умолчанию это "utf-8". |
| `headers` | Заголовки, используемые для отклика. |

##### Установка пользовательских заголовков
Если хотите установить произвольные заголовки для отклика, то `response.headers` - как раз то место, что нужно. Атрибут `headers` - это хэш, который связывает имена заголовков с их значениями, а Rails устанавливает некоторые из них автоматически. Если нужно добавить или изменить заголовок, просто назначьте его `response.headers` следующим образом:
```
response.headers["Content-Type"] = "application/pdf"
```
В вышеприведенном случае более очевидным было бы использование сеттера `content_type`.

### Аутентификации HTTP <a name="4.1.11"></a>
Rails поставляется с двумя встроенными механизмами аутентификации HTTP:
* Базовая аутентификация
* Дайджест-аутентификация 

#### Базовая аутентификация HTTP
Базовая аутентификация HTTP - это аутентификационная схема, поддерживаемая большинством браузеров и других клиентов HTTP. Как пример, рассмотрим раздел администрирования, который доступен только при вводе имени пользователя и пароля в основном диалоговом окне браузера. Использование встроенной аутентификации достаточно простое и требует использования одного метода `http_basic_authenticate_with`.
```
class AdminsController < ApplicationController
  http_basic_authenticate_with name: "humbaba", password: "5baa61e4"
end
```
Благодаря этому можно создавать именованные контроллеры, наследуемые от `AdminsController`. Таким образом, предварительный фильтр будет запущен для всех экшнов в этих контроллерах, защищая их с помощью базовой аутентификации HTTP.

#### Дайджест-аутентификация HTTP
Дайджест-аутентификация HTTP превосходит базовую аутентификацию, так как она не требует от клиента посылать незашифрованный пароль по сети (хотя базовая аутентификация HTTP безопасна через HTTPS). Использовать дайджест-аутентификацию с Rails просто, и это потребует только один метод `authenticate_or_request_with_http_digest`.
```
class AdminsController < ApplicationController
  USERS = { "lifo" => "world" }

  before_action :authenticate

  private

    def authenticate
      authenticate_or_request_with_http_digest do |username|
        USERS[username]
      end
    end
end
```
Как мы видим из примера, блок `authenticate_or_request_with_http_digest` принимает только один аргумент - имя пользователя. И блок возвращает пароль. Возврат `false` или `nil` из `authenticate_or_request_with_http_digest` вызовет провал аутентификации.

### Потоки и загрузка файлов <a name="4.1.12"></a>
Иногда хочется послать пользователю файл вместо рендеринга страницы HTML. Все контроллеры в Rails имеют методы `send_data` и `send_file`, которые направляют данные на клиента. `send_file` - это удобный метод, который позволяет указать имя файла на диске, а он направит содержимое этого файла вам.

Чтобы направить данные на клиента, используйте `send_data`:
```
require "prawn"
class ClientsController < ApplicationController
  # Генерирует документ PDF с информацией на клиента и возвращает
  # его. Пользователь получает PDF как загрузку файла.
  def download_pdf
    client = Client.find(params[:id])
    send_data generate_pdf(client),
              filename: "#{client.name}.pdf",
              type: "application/pdf"
  end

  private

    def generate_pdf(client)
      Prawn::Document.new do
        text client.name, align: :center
        text "Address: #{client.address}"
        text "Email: #{client.email}"
      end.render
    end
end
```
Экшн `download_pdf` в примере вызовет private метод, который фактически сгенерирует документ PDF и возвратит его как строку. Эта строка будет направлена клиенту как загрузка файла, и пользователю будет предложено имя файла. Иногда при потоковой передаче файлов пользователю может не потребоваться загрузка файла. Возьмите, например, изображения, которые могут быть встроены в страницы HTML. Чтобы сказать браузеру, что файл не предназначен для скачивания, нужно установить опцию `:disposition` как "inline". Противоположное дефолтное значение этой опции - "attachment".

####  Отправка файлов
Если хотите отправить файл, уже существующий на диске, используйте метод `send_file`.
```
class ClientsController < ApplicationController
  # Потоковая передача файла, который уже был сгенерирован и сохранен на диск.
  def download_pdf
    client = Client.find(params[:id])
    send_file("#{Rails.root}/files/clients/#{client.id}.pdf",
              filename: "#{client.name}.pdf",
              type: "application/pdf")
  end
end
```
Это прочтет и передаст файл блоками в 4 Кбайт за раз, избегая загрузки в память сразу целого файла. Можно отключить потоковую передачу с помощью опции `:stream` или отрегулировать размер блока с помощью опции `:buffer_size`.

Если не указан `:type`, он будет определяться по расширению файла, указанного в `:filename`. Если для расширения не зарегистрирован тип содержимого, будет использован `application/octet-stream`.

> Будьте осторожны, когда используете данные, пришедшие с клиента (params, куки и т.д.), для обнаружения файла на диске, так как есть риск безопасности в том, что кто-то может получить доступ к файлам, к которым иметь он не должен.

> Не рекомендуется передавать в потоке статичные файлы через Rails, если можно вместо этого разместить их в папке public на веб-сервере. Более эффективно разрешить пользователям скачивать файлы напрямую, используя Apache или другой веб-сервер, сохраняя запрос от ненужного прогона через весь стек Rails.

#### Загрузка RESTful
Хотя `send_data` работает прекрасно, если вы создаете приложение на принципах RESTful, наличие отдельных экшнов для загрузок файла обычно не требуется. В терминологии REST файл PDF из вышеприведенного примера можно рассматривать еще одним представлением ресурса client. Rails предоставляет простой и наглядный способ осуществления загрузок в стиле RESTful. Вот как можно переписать пример, чтобы загрузка PDF была частью экшна show без какой-либо потоковой передачи:
```
class ClientsController < ApplicationController
  # Пользователь может запросить получение этого ресурса как HTML или PDF.
  def show
    @client = Client.find(params[:id])

    respond_to do |format|
      format.html
      format.pdf { render pdf: generate_pdf(@client) }
    end
  end
end
```
Для того, чтобы этот пример заработал, нужно добавить PDF тип MIME в Rails. Это можно сделать, добавив следующую строчку в файл `config/initializers/mime_types.rb`:
```
Mime::Type.register "application/pdf", :pdf
```
> Конфигурационные файлы не перезагружаются с каждым запросом, поэтому необходимо перезапустить сервер для того, чтобы изменения вступили в силу.

Теперь пользователь может запрашивать получение версии в PDF, просто добавив ".pdf" в URL:
```
GET /clients/1.pdf
```

#### Live Streaming произвольных данных
Rails позволяет отдавать в потоке не только файлы. Фактически, в объекте отклика можно отдать все, что хотите. Модуль `ActionController::Live` позволяет создать персистентное соединение с браузером. Используя этот модуль, можно послать в браузер произвольные данные в определенные моменты времени.

##### Подключение Live Streaming
Включение `ActionController::Live` в класс вашего контроллера предоставит всем экшнам контроллера возможность отдавать данные в потоке. Этот модуль можно включить следующим образом:
```
class MyController < ActionController::Base
  include ActionController::Live

  def stream
    response.headers['Content-Type'] = 'text/event-stream'
    100.times {
      response.stream.write "hello world\n"
      sleep 1
    }
  ensure
    response.stream.close
  end
end
```
Вышеприведенный код будет поддерживать персистентное соединение с браузером и пошлет 100 сообщений "hello world\n", раз в секунду каждое.

В вышеприведенном примере нужно обратить внимание на ряд вещей. Необходимо убедиться, что потоковый отклик будет закрыт. Если забыть закрыть, поток оставит навсегда открытым сокет. Также необходимо установить тип содержимого `text/event-stream` до записи в поток отклика. Это так, потому что заголовки не могут быть записаны после того, как отклик был совершен (когда `response.committed?` возвращает истинное значение), которое возникает, когда вызывается `write` или `commit` для потокового отклика.

##### Пример использования
Предположим, мы создаем машину караоке, и пользователь хочет получить слова для определенной песни. В каждом Song имеется определенное количество строчек, и у каждой строчки есть время `num_beats` для завершения пения.

Если мы хотим возвращать слова по принципу караоке (посылая строчку, только когда певец закончил предыдущую), можно использовать `ActionController::Live` следующим образом:
```
class LyricsController < ActionController::Base
  include ActionController::Live

  def show
    response.headers['Content-Type'] = 'text/event-stream'
    song = Song.find(params[:id])

    song.each do |line|
      response.stream.write line.lyrics
      sleep line.num_beats
    end
  ensure
    response.stream.close
  end
end
```
Вышеприведенный код посылает следующую строчку только после того, как певец завершил предыдущую строчку.

##### Обсуждение потоковой передачи
Потоковая передача произвольных данных – чрезвычайно мощный инструмент. Как показано в предыдущих примерах, можно выбирать, когда и что посылать в потоковом отклике. Однако, также необходимо отметить следующие вещи:
* Каждый потоковый отклик создает новый тред и копирует тредовые локальные переменные из текущего треда. Наличие большого количество тредовых локальных переменных может отрицательно сказаться на производительности. Большое количество тредов также препятствует производительности.
* Незакрытие потокового отклика оставит соответствующий сокет открытым навсегда. Убедитесь, что вызываете close при использовании потокового отклика.
* Серверы WEBrick буферизируют все отклики, поэтому включение `ActionController::Live` не будет работать. Необходимо использовать веб-сервер, не буферизирующий отклики автоматически. 
    
### Фильтрация лога <a name="4.1.13"></a>
Rails ведет лог-файл для каждой среды в папке `log`. Это чрезвычайно полезно при отладке того, что происходит в приложении, но в реальной жизни может быть не нужно хранение каждого бита информации в лог-файле.
    
#### Фильтрация параметров
Можно фильтровать чувствительные параметры запроса в файлах лога, присоединив их к `config.filter_parameters` в настройках приложения. Эти параметры будут помечены в логе как [FILTERED].
```
config.filter_parameters << :password
```
Предоставленные параметры будут отфильтрованы с помощью частично соответствующего регулярного выражения. По умолчанию Rails добавляет `:password` в соответствующем инициализаторе (`initializers/filter_parameter_logging.rb`) и заботится о типичных параметрах приложения `password` и `password_confirmation`.

#### Фильтрация редиректов
Иногда нужно фильтровать из файлов лога некоторые чувствительные места расположения, на которые перенаправляет приложение. Это можно осуществить с использованием конфигурационной опции `config.filter_redirect`:
```
config.filter_redirect << 's3.amazonaws.com'
```
Ей можно передать строку, регулярное выражение или массив из них.
```
config.filter_redirect.concat ['s3.amazonaws.com', /private_path/]
```
Соответствующие URL будут помечены как '[FILTERED]'.

### Обработка ошибок <a name="4.1.14"></a>
Скорее всего, ваше приложение будет содержать программные ошибки или, другими словами, вызывать исключения, которые нужно обработать. Например, если пользователь переходит по ссылке на ресурс, который больше не существует в базе данных, Active Record вызовет исключение `ActiveRecord::RecordNotFound`.

Дефолтный обработчик исключений Rails отображает сообщение "500 Server Error" для всех исключений. Если запрос сделан локально, отображается прекрасная трассировка и добавляется дополнительная информация, чтобы можно было выяснить, что пошло не так, и разобраться с этим. Если запрос был удаленным, Rails отобразит пользователю лишь простое сообщение "500 Server Error", или "404 Not Found", если была проблема с роутингом или запись не была найдена. Иногда может понадобиться настроить, как эти ошибки будут перехвачены и как они будут отображены пользователю. В приложении на Rails доступны несколько уровней обработки исключений:

#### Дефолтные шаблоны 500 и 404
По умолчанию приложение в среде `production` будет рендерить или 404, или 500 сообщение об ошибке, в среде development будут вызываться все необрабатываемые исключения. Эти сообщения содержатся в статичных файлах HTML в папке public, в 404.html и 500.html соответственно. Можно настроить эти файлы, добавив дополнительную информацию и стили, но помните, что они статичные; т.е. нельзя использовать ERB, SCSS, CoffeeScript или макеты для них.

#### `rescue_from`
Если хотите сделать нечто более сложное при перехвате ошибок, можете использовать `rescue_from`, который обрабатывает исключения определенного типа (или нескольких типов) во всем контроллере и его подклассах.

Когда возникает исключение, которое перехватывается директивой `rescue_from`, объект исключения передается в обработчик. Обработчик может быть методом или объектом `Proc`, переданным опции `:with`. Также можно использовать блок вместо объекта `Proc`.

Вот как можно использовать `rescue_from` для перехвата всех ошибок `ActiveRecord::RecordNotFound` и что-то с ними делать.
```
class ApplicationController < ActionController::Base
  rescue_from ActiveRecord::RecordNotFound, with: :record_not_found

  private

    def record_not_found
      render plain: "404 Not Found", status: 404
    end
end
```
Конечно, этот пример далеко недоработан, и ничуть не улучшает обработку исключений по умолчанию, но раз вы уже перехватили все эти исключения, то вольны делать с ними все, что хотите. Например, можете создать свои классы исключений, которые будут вызваны, когда у пользователя нет доступа в определенные разделы вашего приложения:
```
class ApplicationController < ActionController::Base
  rescue_from User::NotAuthorized, with: :user_not_authorized

  private

    def user_not_authorized
      flash[:error] = "You don't have access to this section."
      redirect_back(fallback_location: root_path)
    end
end

class ClientsController < ApplicationController
  # Проверим, что пользователь имеет права авторизации для доступа к клиентам.
  before_action :check_authorization

  # Отметьте, как экшны не беспокоятся об авторизационных делах.
  def edit
    @client = Client.find(params[:id])
  end

  private

    # Если пользователь не авторизован, просто вызываем исключение.
    def check_authorization
      raise User::NotAuthorized unless current_user.admin?
    end
end
```
> Использование `rescue_from` c `Exception` или `StandardError` вызовет серьезные побочные эффекты, поскольку это препятствует Rails правильно обрабатывать исключения. Таким образом, это не рекомендуется делать, если нет для того веской причины.

> При запуске в среде running production все ошибки `ActiveRecord::RecordNotFound` рендерят страницу ошибки 404. Если вам не нужно другое поведение, их не нужно обрабатывать.

> Некоторые исключения перехватываемы только из класса `ApplicationController`, так как они вызываются до того, как контроллер будет инициализирован и экшны будут выполнены.

### Навязывание протокола HTTPS <a name="4.1.15"></a>
Если необходимо обеспечить доступ к определенному контроллеру только через HTTPS, нужно сделать это, включив промежуточную программу `ActionDispatch::SSL` через `config.force_ssl` в конфигурациях среды.



## Роутинг в Rails <a name="4.2"></a>
### Цель роутера Rails <a name="4.2.1"></a>
Роутер Rails распознает URL и направляет его в экшн контроллера или в приложение Rack. Он также может генерировать пути и URL, избегая необходимость жестко прописывать строки в ваших вьюхах.

#### Соединение URL с кодом
Когда ваше приложение на Rails получает входящий запрос для:
```
GET /patients/17
```
оно опрашивает роутер на предмет соответствия экшну контроллера. Если первый соответствующий маршрут это:
```
get '/patients/:id', to: 'patients#show'
```
то запрос будет направлен в контроллер `patients` в экшн `show` с `{ id: '17' }` в `params`.

> Rails здесь использует именование в змеином_регистре (snake_case) для имен контроллера, если имя контроллера состоит из несколько слов, то, например, `MonsterTrucksController` необходимо использовать как `monster_trucks#show`.

#### Создание URL из кода
Также можно генерировать пути и URL. Если вышеуказанный маршрут модифицировать на:
```
get '/patients/:id', to: 'patients#show', as: 'patient'
```
и ваше приложение содержит код в контроллере:
```
@patient = Patient.find(params[:id])
```
и такой в соответствующей вьюхе:
```
<%= link_to 'Patient Record', patient_path(@patient) %>
```
тогда роутер сгенерирует путь `/patients/17`. Это увеличит устойчивость вашей вьюхи и упростит код для понимания. Отметьте, что id не нужно указывать в маршрутном хелпере.

#### Настройка маршрутизатора Rails
Маршруты для приложения или engine располагаются в файле `config/routes.rb` и обычно выглядят так:
```
Rails.application.routes.draw do
  resources :brands, only: [:index, :show] do
    resources :products, only: [:index, :show]
  end

  resource :basket, only: [:show, :update, :destroy]

  resolve("Basket") { route_for(:basket) }
end
```
Поскольку это обычный исходный файл Ruby, можно использовать все его особенности, чтобы помочь определять маршруты, но необходимо быть осторожным с именами переменных, так как они могут конфликтовать с методами DSL маршрутизатора.

> Блок `Rails.application.routes.draw do ... end`, который оборачивает определения маршрутов, требует создания области видимости для DSL маршрутизатора и не должен быть удален.

### Ресурсный роутинг <a name="4.2.2"></a>
Вместо объявления отдельных маршрутов для экшнов, ресурсный маршрут объявляет их одной строчкой кода.

#### Ресурсы в вебе
Браузеры запрашивают страницы от Rails, выполняя запрос по URL, используя определенный метод HTTP, такой как GET, POST, PATCH, PUT и DELETE. Каждый метод - это запрос на выполнение операции с ресурсом. Ресурсный маршрут соединяет несколько родственных запросов с экшнами в одном контроллере.

Когда приложение на Rails получает входящий запрос для:
```
DELETE /photos/17
```
оно просит роутер соединить его с экшном контроллера. Если первый соответствующий маршрут такой:
```
resources :photos
```
Rails будет направлять этот запрос в экшн `destroy` контроллера `photos` с `{ id: '17' }` в `params`.

#### CRUD, методы и экшны
В Rails ресурсный маршрут предоставляет сопоставление между методами HTTP и URL к экшнам контроллера. По соглашению, каждый экшн также соединяется с определенной операцией CRUD в базе данных. Одна запись в файле роутинга, такая как:
```
resources :photos
```
создает семь различных маршрутов в приложении, все сопоставления с контроллером Photos:
| Метод HTTP | Путь | Контроллер#Экшн | Использование |
|------------|------|-----------------|---------------|
| GET        | /photos | photos#index |	отображает список всех фото |
| GET        | /photos/new | photos#new | возвращает форму HTML для создания нового фото |
| POST       | /photos | photos#create | создает новое фото |
| GET        | /photos/:id | photos#show | отображает определенное фото |
| GET 	     | /photos/:id/edit | photos#edit | возвращает форму HTML для редактирования фото |
| PATCH/PUT  | /photos/:id | photos#update | обновляет определенное фото |
| DELETE     | /photos/:id | photos#destroy | удаляет определенное фото |

> Поскольку роутер использует как метод HTTP, так и URL, для сопоставления с входящими запросами, четыре URL соединяют с семью различными экшнами.

> Маршруты Rails сравниваются в том порядке, в котором они определены, поэтому, если имеется `resources :photos` до `get 'photos/poll'` маршрут для экшна `show` в строчке `resources` совпадет до строчки `get`. Чтобы это исправить, переместите строчку `get` выше строчки `resources`, чтобы она сравнивалась первой.

#### Путь и хелперы URL
Создание ресурсного маршрута также сделает доступными множество хелперов в контроллере вашего приложения. В случае с `resources :photos`:
* `photos_path` возвращает `/photos`
* `new_photo_path` возвращает `/photos/new`
* `edit_photo_path(:id)` возвращает `/photos/:id/edit` (например, `edit_photo_path(10)` возвращает `/photos/10/edit`)
* `photo_path(:id)` возвращает `/photos/:id` (например, `photo_path(10)` возвращает `/photos/10`) 

Каждый из этих хелперов имеет соответствующий хелпер `_url` (такой как `photos_url`), который возвращает тот же путь с добавленными текущими хостом, портом и префиксом пути.

#### Определение нескольких ресурсов одновременно
Если необходимо создать маршруты для более чем одного ресурса, можете сократить ввод, определив их в одном вызове `resources`:
```
resources :photos, :books, :videos
```
Это приведет к такому же результату, как и:
```
resources :photos
resources :books
resources :videos
```
#### Одиночные ресурсы
Иногда имеется ресурс, который клиенты всегда просматривают без ссылки на ID. Обычный пример, `/profile` всегда показывает профиль текущего зарегистрированного пользователя. Для этого можно использовать одиночный ресурс, чтобы связать `/profile` (а не `/profile/:id`) с экшном `show`:
```
get 'profile', to: 'users#show'
```
Передавая `String` в `to:` ожидается следующий формат - `controller#action`. Когда используется `Symbol`, опция `to:` должна быть заменена на `action:`. Когда используется `String` без `#`, опция `to:` должна быть заменена на `controller:`:
```
get 'profile', action: :show, controller: 'users'
```
Этот ресурсный маршрут:
```
resource :geocoder
resolve('Geocoder') { [:geocoder] }
```
создаст шесть различных маршрутов в приложении, все сопоставления с контроллером `Geocoders`:

| Метод HTTP  |	Путь | Контроллер#Экшн | Использование |
|-------------|------|-----------------|---------------|
| GET         | /geocoder/new | geocoders#new | возвращает форму HTML для создания нового геокодера |
| POST        | /geocoder | geocoders#create | создает новый геокодер |
| GET         | /geocoder | geocoders#show | отображает один и только один ресурс геокодера |
| GET         | /geocoder/edit | geocoders#edit | возвращает форму HTML для редактирования геокодера |
| PATCH/PUT   | /geocoder | geocoders#update | обновляет один и только один ресурс геокодера |
| DELETE      | /geocoder | geocoders#destroy | удаляет ресурс геокодера |

> Поскольку вы можете захотеть использовать один и тот же контроллер и для одиночного маршрута (`/account`), и для множественного маршрута (`/accounts/45`), одиночные ресурсы ведут на множественные контроллеры. По этой причине, например, `resource :photo` и `resources :photos` создадут и одиночные, и множественные маршруты, привязанные к одному и тому же контроллеру (`PhotosController`).

Одиночный ресурсный маршрут генерирует эти хелперы:
* `new_geocoder_path` возвращает `/geocoder/new`
* `edit_geocoder_path` возвращает `/geocoder/edit`
* `geocoder_path` возвращает `/geocoder` 

Как и в случае с множественными ресурсами, те же хелперы, оканчивающиеся на `_url` также включают хост, порт и префикс пути.

#### Пространство имен контроллера и роутинг
Возможно, вы захотите организовать группы контроллеров в пространстве имен. Чаще всего группируют административные контроллеры в пространство имен `Admin::`. Следует поместить эти контроллеры в директорию `app/controllers/admin` и затем можно сгруппировать их вместе в роутере:
```
namespace :admin do
  resources :articles, :comments
end
```
Это создаст ряд маршрутов для каждого контроллера `articles` и `comments`. Например `admin/articles`

Если хотите маршрут `/articles` (без префикса `/admin`) к `Admin::ArticlesController`, можете использовать:
```
scope module: 'admin' do
  resources :articles, :comments
end
```
или для отдельного случая:
```
resources :articles, module: 'admin'
```
Если хотите маршрут `/admin/articles` к `ArticlesController` (без префикса модуля `Admin::`), можно использовать:
```
scope '/admin' do
  resources :articles, :comments
end
```
или для отдельного случая:
```
resources :articles, path: '/admin/articles'
```
> Если хотите использовать другое пространство имен контроллера в блоке `namespace`, можно указать абсолютный путь контроллера, т.е: `get '/foo'`, `to: '/foo#index'`.

#### Вложенные ресурсы
Нормально иметь ресурсы, которые логически подчинены другим ресурсам. Например, предположим ваше приложение включает эти модели:
```
class Magazine < ApplicationRecord
  has_many :ads
end

class Ad < ApplicationRecord
  belongs_to :magazine
end
```
Вложенные маршруты позволяют захватить эти отношения в вашем роутинге. В этом случае можете включить такое объявление маршрута:
```
resources :magazines do
  resources :ads
end
```
В дополнение к маршрутам для magazines, это объявление также создаст маршруты для `ads` в `AdsController`. URL с ad требует magazine:

| Метод HTTP | Путь |	Контроллер#Экшн | Использование |
|------------|------|-----------------|---------------|
| GET        | /magazines/:magazine_id/ads | ads#index | отображает список всех ads для определенного magazine |
| GET        | /magazines/:magazine_id/ads/new | ads#new | возвращает форму HTML для создания новой ad, принадлежащей определенному magazine |
| POST       | /magazines/:magazine_id/ads | ads#create | создает новую ad, принадлежащую указанному magazine |
| GET        | /magazines/:magazine_id/ads/:id | ads#show | отражает определенную ad, принадлежащую определенному magazine |
| GET        | /magazines/:magazine_id/ads/:id/edit | ads#edit | возвращает форму HTML для редактирования ad, принадлежащей определенному magazine |
| PATCH/PUT  | /magazines/:magazine_id/ads/:id | ads#update | обновляет определенную ad, принадлежащую определенному magazine |
| DELETE     | /magazines/:magazine_id/ads/:id | ads#destroy | удаляет определенную ad, принадлежащую определенному magazine |

Также будут созданы маршрутные хелперы, такие как `magazine_ads_url` и `edit_magazine_ad_path`. Эти хелперы принимают экземпляр `Magazine` как первый параметр (`magazine_ads_url(@magazine)`).

##### Ограничения для вложения
Вы можете вкладывать ресурсы в другие вложенные ресурсы, если хотите. Например:
```
resources :publishers do
  resources :magazines do
    resources :photos
  end
end
```
Глубоко вложенные ресурсы быстро становятся громоздкими. В этом случае, например, приложение будет распознавать пути, такие как:
```
/publishers/1/magazines/2/photos/3
```
Соответствующий маршрутный хелпер будет `publisher_magazine_photo_url`, требующий определения объектов на всех трех уровнях. Действительно, эта ситуация достаточно запутана, так что в статье Jamis Buck предлагает правило хорошей разработки на Rails:

> Ресурсы никогда не должны быть вложены глубже, чем на 1 уровень.

##### Мелкое вложение
Один из способов избежать глубокой вложенности (как рекомендовано выше) состоит в том, чтобы генерировать экшны коллекции в области видимости родителя, получая представление об иерархии, но не вкладывать экшны элементов. Другими словами, создавать маршруты с минимальным количеством информации для однозначной идентификации ресурса, например так:
```
resources :articles do
  resources :comments, only: [:index, :new, :create]
end
resources :comments, only: [:show, :edit, :update, :destroy]
```
Эта идея балансирует на грани между наглядностью маршрутов и глубоким вложением. Существует сокращенный синтаксис для получения подобного с помощью опции `:shallow`:
```
resources :articles do
  resources :comments, shallow: true
end
```
Это сгенерирует те же самые маршруты из первого примера. Также можно определить опцию `:shallow` в родительском ресурсе, в этом случае все вложенные ресурсы будут мелкие:
```
resources :articles, shallow: true do
  resources :comments
  resources :quotes
  resources :drafts
end
```
Метод `shallow` в DSL создает область видимости, в котором каждое вложение мелкое. Это генерирует те же самые маршруты из предыдущего примера:
```
shallow do
  resources :articles do
    resources :comments
    resources :quotes
    resources :drafts
  end
end
```
**Также существуют две опции для `scope` для настройки мелких маршрутов**. `:shallow_path` добавляет к путям элемента префикс с указанным параметром:
```
scope shallow_path: "sekret" do
  resources :articles do
    resources :comments, shallow: true
  end
end
```
Для ресурса комментариев будут сгенерированы следующие маршруты:

| Метод HTTP | Путь | Контроллер#Экшн | Именованный хелпер маршрута |
|------------|------|-----------------|-----------------------------|
| GET 	     | /articles/:article_id/comments(.:format) | comments#index | article_comments_path |
| POST       | /articles/:article_id/comments(.:format) | comments#create | article_comments_path |
| GET        | /articles/:article_id/comments/new(.:format) | comments#new 	new_article_comment_path |
| GET        | /sekret/comments/:id/edit(.:format) | comments#edit | edit_comment_path |
| GET        | /sekret/comments/:id(.:format) | comments#show | comment_path |
| PATCH/PUT  | /sekret/comments/:id(.:format) | comments#update | comment_path |
| DELETE  	 | /sekret/comments/:id(.:format) | comments#destroy | comment_path |

**Опция `:shallow_prefix` добавляет указанный параметр к именованным хелперам маршрута**:
```
scope shallow_prefix: "sekret" do
  resources :articles do
    resources :comments, shallow: true
  end
end
```
Для ресурса комментариев будут сгенерированы следующие маршруты:

| Метод HTTP | Путь | Контроллер#Экшн | Именованный хелпер маршрута |
|------------|------|-----------------|-----------------------------|
| GET | /articles/:article_id/comments(.:format) | comments#index | article_comments_path |
| POST | /articles/:article_id/comments(.:format) | comments#create | article_comments_path |
| GET | /articles/:article_id/comments/new(.:format) | comments#new | new_article_comment_path |
| GET | /comments/:id/edit(.:format) | comments#edit | **edit_sekret_comment_path** |
| GET | /comments/:id(.:format) | comments#show | sekret_comment_path |
| PATCH/PUT | /comments/:id(.:format) | comments#update | sekret_comment_path |
| DELETE | /comments/:id(.:format) | comments#destroy | sekret_comment_path |

#### Концерны маршрутов
Концерны маршрутов позволяют объявлять общие маршруты, которые затем могут быть повторно использованы внутри других ресурсов и маршрутов. Чтобы определить концерн:
```
concern :commentable do
  resources :comments
end

concern :image_attachable do
  resources :images, only: :index
end
```
Эти концерны могут быть использованы в ресурсах, чтобы избежать дублирования кода и разделить поведение между несколькими маршрутами:
```
resources :messages, concerns: :commentable

resources :articles, concerns: [:commentable, :image_attachable]
```
Вышеуказанное эквивалентно:
```
resources :messages do
  resources :comments
end

resources :articles do
  resources :comments
  resources :images, only: :index
end
```
Также их можно использовать в любом месте внутри маршрутов, например, в вызове `scope` или `namespace`:
```
namespace :articles do
  concerns :commentable
end
```

#### Создание путей и URL из объектов
В дополнение к использованию маршрутных хелперов, Rails может также создавать пути и URL из массива параметров. Например, предположим, у вас есть этот набор маршрутов:
```
resources :magazines do
  resources :ads
end
```
При использовании `magazine_ad_path`, можно передать экземпляры `Magazine` и `Ad` вместо числовых ID:
```
<%= link_to 'Ad details', magazine_ad_path(@magazine, @ad) %>
```
Можно также использовать `url_for` с набором объектов, и Rails автоматически определит, какой маршрут вам нужен:
```
<%= link_to 'Ad details', url_for([@magazine, @ad]) %>
```
В этом случае Rails увидит, что `@magazine` это `Magazine` и `@ad` это `Ad`, и поэтому использует хелпер `magazine_ad_path`. В хелперах, таких как `link_to`, можно определить лишь объект вместо полного вызова `url_for`:
```
<%= link_to 'Ad details', [@magazine, @ad] %>
```
Если хотите ссылку только на `magazine`:
```
<%= link_to 'Magazine details', @magazine %>
```
Для других экшнов следует всего лишь вставить имя экшна как первый элемент массива:
```
<%= link_to 'Edit Ad', [:edit, @magazine, @ad] %>
```
Это позволит рассматривать экземпляры модели как URL, что является ключевым преимуществом ресурсного стиля.

#### Определение дополнительных экшнов RESTful
Вы не ограничены семью маршрутами, которые создает роутинг RESTful по умолчанию. Если хотите, можете добавить дополнительные маршруты, применяющиеся к коллекции или отдельным элементам коллекции.

##### Добавление маршрутов к элементам
Для добавления маршрута к элементу, добавьте блок `member` в блок ресурса:
```
resources :photos do
  member do
    get 'preview'
  end
end
```
Это распознает `/photos/1/preview` с GET и направит в экшн preview контроллера `PhotosController` со значением `id` ресурса, переданного в `params[:id]`. Это также создаст хелперы `preview_photo_url` и `preview_photo_path`.

В блоке маршрутов элемента каждое имя маршрута определяет метод HTTP, с которым он будет связан. Тут можно использовать `get`, `patch`, `put`, `post` или `delete`. Если у вас нет нескольких маршрутов к `member`, также можно передать `:on` к маршруту, избавившись от блока:
```
resources :photos do
  get 'preview', on: :member
end
```
**Можно опустить опцию `:on`**, это создаст такой же маршрут для элемента, за исключением того, что значение `id` ресурса будет доступно в `params[:photo_id]` вместо `params[:id]`. Хелперы маршрутов также будут переименованы из `preview_photo_url` и `preview_photo_path` в `photo_preview_url` и `photo_preview_path`.


 ##### Добавление маршрутов к коллекции
Чтобы добавить маршрут к коллекции:
```
resources :photos do
  collection do
    get 'search'
  end
end
```
Это позволит Rails распознавать пути, такие как `/photos/search` с GET и направить в экшн `search` контроллера `PhotosController`. Это также создаст маршрутные хелперы `search_photos_url` и `search_photos_path`.

Как и с маршрутами к элементу, можно передать `:on` к маршруту:
```
resources :photos do
  get 'search', on: :collection
end
```
Если определяете дополнительные ресурсные маршруты с символом в качестве первого аргумента, помните, что это не эквивалент использования строки. Символы означают экшны контроллера, а строки означают пути.

##### Добавление маршрутов для дополнительных экшнов `new`
Чтобы добавить альтернативный экшн `new`, используйте сокращенный вариант `:on`:
```
resources :comments do
  get 'preview', on: :new
end
```
Это позволит Rails распознавать пути, такие как `/comments/new/preview` с GET, и направлять их в экшн `preview` в `CommentsController`. Он также создаст маршрутные хелперы `preview_new_comment_url` и `preview_new_comment_path`.

> Если вдруг вы захотели добавить много дополнительных экшнов в ресурсный маршрут, нужно остановиться и спросить себя, может быть, от вас утаилось присутствие другого ресурса.

### Нересурсные маршруты <a name="4.2.3"></a>
В дополнению к ресурсному роутингу, Rails поддерживает роутинг произвольных URL к экшнам. Тут не будет групп маршрутов, генерируемых автоматически ресурсным роутингом. Вместо этого вы должны настроить каждый маршрут отдельно в вашем приложении.

Хотя обычно следует пользоваться ресурсным роутингом, все еще есть много мест, где более подходит простой роутинг. Нет необходимости пытаться заворачивать каждый кусочек своего приложения в ресурсные рамки, если это менее удобно.

В частности, простой роутинг облегчает привязку унаследованных URL к новым экшнам Rails.

#### Необязательные параметры
При настройке обычного маршрута вы предоставляете ряд символов, которые Rails связывает с частями входящего запроса HTTP. Например, рассмотрим следующий маршрут:
```
get 'photos(/:id)', to: 'photos#display'
```
Если входящий запрос `/photos/1` обрабатывается этим маршрутом (так как он не соответствует любому предыдущему маршруту до этого), то результатом будет вызов экшна `display` в `PhotosController`, и результирующий параметр "1" будет доступен как `params[:id]`. **Этот маршрут также свяжет входящий запрос `/photos` с `PhotosController#display`**, поскольку `:id` — опциональный параметр, обозначенный скобками.

#### Динамические сегменты
Можете настроить сколько угодно динамических сегментов в обычном маршруте. Любой сегмент будет доступен для соответствующего экшна как часть хэша params. Таким образом, если настроите такой маршрут:
```
get 'photos/:id/:user_id', to: 'photos#show'
```
Входящий путь `/photos/1/2` будет направлен на экшн `show` в `PhotosController`. `params[:id]` будет установлен как "1", и `params[:user_id]` будет установлен как "2".

> По умолчанию динамические сегменты не принимают точки - потому что точка используется как разделитель для формата маршрутов. Если в динамическом сегменте необходимо использовать точку, добавьте ограничение, переопределяющее это – к примеру, `id: /[^\/]+/` позволяет все, кроме слэша.

#### Статичные сегменты
Можете определить статичные сегменты при создании маршрута, не начинающиеся с двоеточия в фрагменте:
```
get 'photos/:id/with_user/:user_id', to: 'photos#show'
```
Этот маршрут соответствует путям, таким как `/photos/1/with_user/2`. В этом случае params будет `{ controller: 'photos', action: 'show', id: '1', user_id: '2' }`.

#### Параметры строки запроса
`params` также включает любые параметры из строки запроса. Например, с таким маршрутом:
```
get 'photos/:id', to: 'photos#show'
```
Входящий путь `/photos/1?user_id=2` будет направлен на экшн `show` контроллера `Photos`. `params` будет `{ controller: 'photos', action: 'show', id: '1', user_id: '2' }`.

#### Определение значений по умолчанию
Можно определить значения по умолчанию в маршруте, предоставив хэш для опции `:defaults`. Это также относится к параметрам, которые не определены как динамические сегменты. Например:
```
get 'photos/:id', to: 'photos#show', defaults: { format: 'jpg' }
```
Rails направит `photos/12` в экшн `show` `PhotosController`, и установит `params[:format]` как "jpg".

Вы также можете использовать `defaults` в формате блока, чтобы определить значения по умолчанию для нескольких элементов:
```
defaults format: :json do
  resources :photos
end
```
> Невозможно переопределить значения по умолчанию с помощью параметров строки запроса - по причине безопасности. Единственные значения по умолчанию, которые могут быть переопределены - это динамические сегменты, с помощью подстановки в путь URL.

#### Именование маршрутов
Можно определить имя для любого маршрута, используя опцию `:as`:
```
get 'exit', to: 'sessions#destroy', as: :logout
```
Это создаст `logout_path` и `logout_url` как именованные хелперы маршрута в вашем приложении. Вызов `logout_path` вернет `/exit`

Также это можно использовать для переопределения маршрутных методов, определенных ресурсами, следующим образом:
```
get ':username', to: 'users#show', as: :user
```
Что определит метод `user_path`, который будет доступен в контроллерах, хелперах и вьюхах, и будет вести на маршрут, такой как `/bob`. В экшне `show` из `UsersController`, `params[:username]` будет содержать имя пользователя. Измените `:username` в определении маршрута, если не хотите, чтобы имя параметра было `:username`.

```
The :as option forms a named route.

Usually it's used in a non-root route. For example:

match '/search' => 'search#search', :as => 'search' # SearchController#search

You could then do something like:

<%= link_to search_path, 'Click Here to Search!' %>

search_path and search_url are defined because of the :as

For a root route, you don't really need :as because the the URL helpers root_path and root_url are defined for you by Rails.
```
#### Ограничения метода HTTP
В основном следует использовать методы `get`, `post`, `put`, `patch` и `delete` для ограничения маршрута определенным методом. Можно использовать метод `match` с опцией `:via` для соответствия нескольким методам сразу:
```
match 'photos', to: 'photos#show', via: [:get, :post]
```
Также можно установить соответствие всем методам для определенного маршрута, используя `:via: :all`:
```
match 'photos', to: 'photos#show', via: :all
```
> Роутинг запросов GET и POST одновременно в один экшн небезопасен. В основном, следует избегать роутинг всех методов в экшн, если нет веской причины делать так.

> GET в Rails не проверяет токен CSRF. Никогда не пишите в базу данных из GET запросов, подробнее о контрмерах CSRF смотрите в руководстве Безопасность приложений на Rails.

#### Ограничения сегмента
Можно использовать опцию `:constraints` для соблюдения формата динамического сегмента:
```
get 'photos/:id', to: 'photos#show', constraints: { id: /[A-Z]\d{5}/ }
```
Этот маршрут соответствует путям, таким как `/photos/A12345`, но не `/photos/893`. Можно выразить тот же маршрут более кратко:
```
get 'photos/:id', to: 'photos#show', id: /[A-Z]\d{5}/
```
`:constraints` принимает регулярное выражение c тем ограничением, что якоря `regexp` не могут использоваться. Например, следующий маршрут не работает:
```
get '/:id', to: 'articles#show', constraints: {id: /^\d/}
```
Однако отметьте, что нет необходимости использовать якоря, поскольку все маршруты заякорены изначально.

Например, следующие маршруты приведут к `articles` со значениями `to_param` наподобие 1-hello-world, которые всегда начинаются с цифры, и к `users` со значениями `to_param` наподобие david, которые никогда не начинаются с цифры, чтобы можно было использовать общее корневое пространство имен:
```
get '/:id', to: 'articles#show', constraints: { id: /\d.+/ }
get '/:username', to: 'users#show'
```

#### Ограничения, основанные на запросе
Также можно ограничить маршрут, основываясь на любом методе в объекте `Request`, который возвращает `String`.

Ограничение, основанное на запросе, определяется так же, как и сегментное ограничение:
```
get 'photos', to: 'photos#index', constraints: { subdomain: 'admin' }
```
Также можно определить ограничения в форме блока:
```
namespace :admin do
  constraints subdomain: 'admin' do
    resources :photos
  end
end
```
> Ограничения запроса работают, вызывая метод на объекте Request с тем же именем, что и ключ хэша, а затем сравнивают возвращенное значение со значением хэша. Следовательно, значения ограничений должны соответствовать возвращаемому типу соответствующего метода объекта Request. Например: `constraints: { subdomain: 'api' }` будет соответствовать поддомену api, как и ожидалось, однако, использование символа `constraints: { subdomain: :api }` не будет, так как request.subdomain возвращает 'api' как строку.

> Имеется исключения для ограничения `format:` так как это метод на объекте Request, это также неявный опциональный параметр для каждого пути. Ограничения сегмента имеют приоритет, и ограничение `format` применяется как есть, даже когда передано в хэше. Например, get 'foo', `constraints: { format: 'json' }` будет соответствовать GET /foo, так как формат опциональный по умолчанию. Однако, используя lambda, как в `get 'foo'`, `constraints: lambda { |req| req.format == :json }`, маршрут будет соответствовать только явным запросам JSON.

#### Продвинутые ограничения
Если имеется более продвинутое ограничение, можете предоставить объект, отвечающий на `matches?`, который будет использовать Rails. Скажем, вы хотите направить всех пользователей через список ограничений в `RestrictedListController`. Можно сделать так:
```
class RestrictedListController
  def initialize
    @ips = RestrictedList.retrieve_ips
  end

  def matches?(request)
    @ips.include?(request.remote_ip)
  end
end

Rails.application.routes.draw do
  get '*path', to: 'restricted_list#index',
    constraints: RestrictedListConstraint.new
end
```
Ограничения также можно определить как лямбду:
```
Rails.application.routes.draw do
  get '*path', to: 'restricted_list#index',
    constraints: lambda { |request| RestrictedList.retrieve_ips.include?(request.remote_ip) }
end
```
И метод `matches?`, и лямбда получают объект `request` в качестве аргумента.

#### Подстановка маршрутов и подстановочные сегменты
Подстановка маршрутов - это способ указать, что определенные параметры должны соответствовать остальным частям маршрута. Например:
```
get 'photos/*other', to: 'photos#unknown'
```
Этот маршрут будет соответствовать photos/12 или /photos/long/path/to/12, установив `params[:other]` как "12", или "long/path/to/12". Фрагменты, начинающиеся со звездочки, называются "подстановочные сегменты" ("wildcard segments").

Подстановочные сегменты могут быть где угодно в маршруте. Например:
```
get 'books/*section/:title', to: 'books#show'
```
будет соответствовать books/some/section/last-words-a-memoir с `params[:section]` равным 'some/section', и `params[:title]` равным 'last-words-a-memoir'.

На самом деле технически маршрут может иметь более одного динамического сегмента, matcher назначает параметры интуитивным образом. Для примера:
```
get '*a/foo/*b', to: 'test#index'
```
будет соответствовать zoo/woo/foo/bar/baz с `params[:a]` равным 'zoo/woo', и `params[:b]` равным 'bar/baz'.

Запросив '/foo/bar.json', ваш `params[:pages]` будет равен 'foo/bar' с форматом запроса JSON. Если вам нужно вернуть старое поведение 3.0.x, можете предоставить `format: false` вот так:
```
get '*pages', to: 'pages#show', format: false
```
Если хотите сделать сегмент формата обязательным, чтобы его нельзя было опустить, укажите `format: true` подобным образом:
```
get '*pages', to: 'pages#show', format: true
```

#### Перенаправление
Можно перенаправить любой путь на другой путь, используя хелпер `redirect` в вашем роутере:
```
get '/stories', to: redirect('/articles')
```
Также можно повторно использовать динамические сегменты для соответствия пути, на который перенаправляем:
```
get '/stories/:name', to: redirect('/articles/%{name}')
```
Также можно предоставить блок для перенаправления, который получает символизированные параметры пути и объект `request`:
```
get '/stories/:name', to: redirect { |path_params, req| "/articles/#{path_params[:name].pluralize}" }
get '/stories', to: redirect { |path_params, req| "/articles/#{req.subdomain}" }
```
Пожалуйста, отметьте, что перенаправлением по умолчанию является 301 "Moved Permanently". Учтите, что некоторые браузеры или прокси серверы закэшируют этот тип перенаправления, сделав старые страницы недоступными. Чтобы изменить статус отклика, можно использовать опцию `:status`:
```
get '/stories/:name', to: redirect('/articles/%{name}', status: 302)
```
Во всех этих случаях, если не предоставить предшествующий хост (http://www.example.com), Rails возьмет эти детали из текущего запроса.

#### Роутинг к приложениям Rack
Вместо строки, подобной `'articles#index'`, соответствующей экшну `index` в `ArticlesController`, можно определить любое приложение Rack как конечную точку совпадения.
```
match '/application.js', to: MyRackApp, via: :all
```
Пока `MyRackApp` отвечает на `call` и возвращает [status, headers, body], роутер не будет различать приложение Rack и экшн. Здесь подходит использование `via: :all`, если вы хотите позволить своему приложению Rack обрабатывать все методы так, как оно посчитает нужным.

Для любопытства, `'articles#index'` фактически расширяется до `ArticlesController.action(:index)`, который возвращает валидное приложение Rack.

Если вы указываете приложение Rack как конечную точку совпадения, помните что маршрут будет неизменным в принимающем приложении. Со следующим маршрутом ваше приложение Rack будет ожидать маршрут `/admin`:
```
match '/admin', to: AdminApp, via: :all
```
Если вы предпочитаете, чтобы ваше приложение Rack получало запросы на корневой путь, используйте вместо этого `mount`:
```
mount AdminApp, at: '/admin'
```

#### Использование `root`
Можно определить, с чем Rails должен связать '/' с помощью метода `root`:
```
root to: 'pages#main'
root 'pages#main' # то же самое в краткой форме
```
Следует поместить маршрут root в начало файла, поскольку это наиболее популярный маршрут и должен быть проверен первым.

Маршрут root связывает с экшном только запросы GET.

`root` также можно использовать внутри пространств имен и областей видимости. Например:
```
namespace :admin do
  root to: "admin#index"
end

root to: "home#index"
```

#### Маршруты с символами Unicode
Маршруты с символами `unicode` можно определять явно. Например:
```
get 'こんにちは', to: 'welcome#index'
```

#### Прямые маршруты
Можно создавать собственные хелперы URL напрямую. Например:
```
direct :homepage do
  "http://www.rubyonrails.org"
end

# >> homepage_url
# => "http://www.rubyonrails.org"
```
Возвращаемое значение блока должно быть валидным аргументом для метода `url_for`. Таким образом, можно передать валидный строковый URL, хэш, массив, экземпляр Active Model или класс Active Model.
```
direct :commentable do |model|
  [ model, anchor: model.dom_id ]
end

direct :main do
  { controller: 'pages', action: 'index', subdomain: 'www' }
end
```

#### Использование `resolve`
Метод `resolve` позволяет настраивать полиморфное сопоставление моделей. Например:
```
resource :basket

resolve("Basket") { [:basket] }

<%= form_with model: @basket do |form| %>
  <!-- basket form -->
<% end %>
```
Это сгенерирует URL в единственном числе `/basket` вместо обычного `/baskets/:id`.

### Настройка ресурсных маршрутов <a name="4.2.4"></a>
Хотя дефолтные маршруты и хелперы, сгенерированные `resources :articles`, как правило, нормально работают, возможно, может понадобиться некоторым образом их настроить. Rails позволяет настроить практически любую часть ресурсных хелперов.

#### Определение используемого контроллера
Опция `:controller` позволяет явно определить контроллер, используемый ресурсом. Например:
```
resources :photos, controller: 'images'
```
распознает входящие пути, начинающиеся с /photos, но смаршрутизирует к контроллеру `Images`:

| Метод HTTP | Путь |	Контроллер#Экшн | Именованный хелпер маршрута |
|------------|------|-----------------|-----------------------------|
| GET | /photos | images#index | photos_path |
| GET | /photos/new | images#new | new_photo_path |
| POST | /photos | images#create | photos_path |
| GET | /photos/:id | images#show | photo_path(:id) |
| GET | /photos/:id/edit | images#edit | edit_photo_path(:id) |
| PATCH/PUT | /photos/:id | images#update | photo_path(:id) |
| DELETE | /photos/:id | images#destroy | photo_path(:id) |

> Используйте `photos_path`, `new_photo_path` и т.д. для генерации путей для этого ресурса.

Для контроллеров в пространстве имен можно использовать нотацию директории. Например:
```
resources :user_permissions, controller: 'admin/user_permissions'
```
Это будет смаршрутизировано на контроллер `Admin::UserPermissions`.

> Поддерживается только нотация директории. Определение контроллера с помощью нотации константы Ruby (т.е. `controller: 'Admin::UserPermissions'`) может привести к маршрутным проблемам, и в итоге к предупреждению.

#### Определение ограничений
Можно использовать опцию `:constraints` для определения требуемого формата на неявном `id`. Например:
```
resources :photos, constraints: { id: /[A-Z][A-Z][0-9]+/ }
```
Это объявление ограничивает параметр `:id` соответствием предоставленному регулярному выражению. Итак, в этом случае роутер больше не будет сопоставлять `/photos/1` этому маршруту. Вместо этого он будет соответствовать `/photos/RR27`.

Можно определить одиночное ограничение, применив его к ряду маршрутов, используя блочную форму:
```
constraints(id: /[A-Z][A-Z][0-9]+/) do
  resources :photos
  resources :accounts
end
```
Конечно, можно использовать более продвинутые ограничения, доступные в нересурсных маршрутах, в этом контексте.

> По умолчанию параметр `:id` не принимает точки - так как точка используется как разделитель для отформатированного маршрута. Если необходимо использовать точку в `:id`, добавьте ограничение, которое переопределит это - к примеру, `id: /[^\/]+/` позволяет все, кроме слэша.

#### Переопределение именованных хелперов маршрута
Опция `:as` позволяет переопределить нормальное именование для именованных маршрутных хелперов. Например:
```
resources :photos, as: 'images'
```
распознает входящие пути, начинающиеся с `/photos` и смаршрутизирует запросы к `PhotosController`, но использует значение опции `:as` для наименования хелпера:
```
GET 	/photos 	photos#index 	images_path
```

#### Переопределение сегментов `new` и `edit`
Опция `:path_names` позволяет переопределить автоматически генерируемые сегменты `new` и `edit` в путях:
```
resources :photos, path_names: { new: 'make', edit: 'change' }
```
Это приведет к тому, что роутинг распознает пути, такие как:
```
/photos/make
/photos/1/change
```
Фактические имена экшнов не меняются этой опцией. Два показанных пути все еще ведут к экшнам `new` и `edit`.

Если вдруг захотите изменить эту опцию одинаково для всех маршрутов, можно использовать `scope`:
```
scope path_names: { new: 'make' } do
  # остальные ваши маршруты
end
```

#### Префикс именованных маршрутных хелперов
Можно использовать опцию `:as` для задания префикса именованных маршрутных хелперов, генерируемых Rails для маршрута. Используйте эту опцию для предотвращения коллизий имен между маршрутами, использующими область видимости пути. Например:
```
scope 'admin' do
  resources :photos, as: 'admin_photos'
end

resources :photos
```
Это предоставит маршрутные хелперы, такие как `admin_photos_path`, `new_admin_photo_path` и т.д.

Для задания префикса группы маршрутов, используйте `:as` со `scope`:
```
scope 'admin', as: 'admin' do
  resources :photos, :accounts
end

resources :photos, :accounts
```
Это сгенерирует маршруты такие как `admin_photos_path` и `admin_accounts_path`, ведущие соответственно к `/admin/photos` и `/admin/accounts`.

> Область видимости namespace автоматически добавляет `:as`, так же как и префиксы `:module` и `:path`.

Можно задать префикс маршрута именованным параметром также и так:
```
scope ':username' do
  resources :articles
end
```
Это предоставит URL, такие как `/bob/articles/1` и позволит обратиться к части пути username в контроллерах, хелперах и вьюхах как `params[:username]`.

####  Ограничение создаваемых маршрутов
По умолчанию Rails создает маршруты для всех семи дефолтных экшнов (`index`, `show`, `new`, `create`, `edit`, `update` и `destroy`) для каждого маршрута RESTful вашего приложения. Можно использовать опции `:only` и `:except` для точной настройки этого поведения. Опция `:only` говорит Rails создать только определенные маршруты:
```
resources :photos, only: [:index, :show]
```
Теперь запрос GET к /photos будет успешным, а запрос POST к /photos (который обычно соединяется с экшном `create`) провалится.

Опция `:except` определяет маршрут или перечень маршрутов, который Rails не должен создавать:
```
resources :photos, except: :destroy
```
В этом случае Rails создаст все нормальные маршруты за исключением маршрута для `destroy` (запрос DELETE к `/photos/:id`).

> Если в вашем приложении много маршрутов RESTful, использование `:only` и `:except` для генерации только тех маршрутов, которые Вам фактически нужны, позволит снизить использование памяти и ускорить процесс роутинга.

#### Переведенные пути
Используя scope, можно изменить имена путей, генерируемых с помощью `resources`:
```
scope(path_names: { new: 'neu', edit: 'bearbeiten' }) do
  resources :categories, path: 'kategorien'
end
```
Rails теперь создаст маршруты к `CategoriesController`:
```
GET 	/kategorien 	categories#index 	categories_path
```

#### Переопределение единственного числа
Если хотите определить единственное число ресурса, следует добавить дополнительные правила в `Inflector`:
```
ActiveSupport::Inflector.inflections do |inflect|
  inflect.irregular 'tooth', 'teeth'
end
```

#### Использование `:as` во вложенных ресурсах
Опция `:as` переопределяет автоматически генерируемое имя для ресурса в хелперах вложенного маршрута. Например:
```
resources :magazines do
  resources :ads, as: 'periodical_ads'
end
```
Это создаст маршрутные хелперы, такие как `magazine_periodical_ads_url` и `edit_magazine_periodical_ad_path`.

#### Переопределение параметров именованных маршрутов
Опция `:param` переопределяет дефолтный идентификатор ресурса `:id` (имя динамического сегмента, используемого для генерации маршрутов). К этому сегменту можно обратиться из контроллера с помощью `params[<:param>]`.
```
resources :videos, param: :identifier

    videos GET  /videos(.:format)                  videos#index
           POST /videos(.:format)                  videos#create
 new_video GET  /videos/new(.:format)              videos#new
edit_video GET  /videos/:identifier/edit(.:format) videos#edit

Video.find_by(identifier: params[:identifier])
```
Можно переопределить `ActiveRecord::Base#to_param` соответствующей модели, чтобы создать URL:
```
class Video < ApplicationRecord
  def to_param
    identifier
  end
end

video = Video.find_by(identifier: "Roman-Holiday")
edit_video_path(video) # => "/videos/Roman-Holiday/edit"
```
### Разделение очень большого маршрутного файл на несколько небольших: <a name="4.2.5"></a>
Если вы работаете в большом приложении с тысячами маршрутов, единственный файл `config/routes.rb` может стать громоздким и тяжелым для прочтения.

Rails предлагает способ разделения гигантского единого `routes.rb` на несколько небольших с помощью макроса `draw`.
```
# config/routes.rb

Rails.application.routes.draw do
  get 'foo', to: 'foo#bar'

  draw(:admin) # Загрузит другой маршрутный файл, расположенный в `config/routes/admin.rb`
end

# config/routes/admin.rb

namespace :admin do
  resources :comments
end
```
Вызов `draw(:admin)` в блоке `Rails.application.routes.draw` попытается загрузить маршрутный файл, по имени. заданному аргументом (в нашем случае `admin.rb`). Файл должен быть расположен в директории `config/routes` или любой поддиректории (например, `config/routes/admin.rb `, `config/routes/external/admin.rb`).

Внутри маршрутного файла `admin.rb` можно использовать любой маршрутный DSL, но не следует оборачивать его в блок `Rails.application.routes.draw`, как это сделано в основном файле `config/routes.rb`.

#### Когда использовать или не использовать эту особенность
Отрисовка маршрутов из внешних файлов может быть очень полезной для организации большого набора маршрутов на несколько организованных. Может быть маршрут `admin.rb`, содержащий все маршруты из области администрирования, другой файл `api.rb` для маршрутов к API ресурсов, и так далее...

Однако, не следует злоупотреблять этой особенностью, так как множество маршрутных файлов может делает сложными понятность и понимание. В зависимости от приложения, разработчикам может быть проще иметь один маршрутный файл, если у вас всего лишь несколько сотен маршрутов. Не следует пытаться создать новый маршрутный файл для каждой категории (admin, api ...) любой ценой; DSL маршрутизации Rails уже предлагает способ разделения маршрутов организованным способом с помощью `namespaces` и `scopes`.

### Осмотр и тестирование маршрутов <a name="4.2.6"></a>
#### Список существующих маршрутов
Чтобы получить полный список всех доступных маршрутов вашего приложения, посетите `http://localhost:3000/rails/info/routes` в браузере, в то время как ваш сервер запущен в режиме development. Команда `rails routes`, выполненная в терминале, выдаст тот же результат.

Оба метода напечатают все ваши маршруты, в том же порядке, что они появляются в `config/routes.rb`. Для каждого маршрута вы увидите:
* Имя маршрута (если имеется)
* Используемый метод HTTP (если маршрут реагирует не на все методы)
* Шаблон URL
* Параметры роутинга для этого маршрута 

Например, вот небольшая часть результата команды `rails routes` для маршрута RESTful:
```
    users GET    /users(.:format)          users#index
          POST   /users(.:format)          users#create
 new_user GET    /users/new(.:format)      users#new
edit_user GET    /users/:id/edit(.:format) users#edit
```
Также можно использовать опцию `--expanded` для включения режима расширенного табличного форматирования.
```
$ rails routes --expanded

--[ Route 1 ]----------------------------------------------------
Prefix            | users
Verb              | GET
URI               | /users(.:format)
Controller#Action | users#index
--[ Route 2 ]----------------------------------------------------
Prefix            |
Verb              | POST
URI               | /users(.:format)
Controller#Action | users#create
--[ Route 3 ]----------------------------------------------------
Prefix            | new_user
Verb              | GET
URI               | /users/new(.:format)
Controller#Action | users#new
--[ Route 4 ]----------------------------------------------------
Prefix            | edit_user
Verb              | GET
URI               | /users/:id/edit(.:format)
Controller#Action | users#edit
```
Можно искать маршруты с помощью опции `grep`: -g. Это выведет любые маршруты, которые частично соответствуют по имени метода хелпера URL, метода HTTP или пути URL.
```
$ rails routes -g new_comment
$ rails routes -g POST
$ rails routes -g admin
```
Если хотите просмотреть маршруты, ведущие на определенный контроллер, имеется опция -c.
```
$ rails routes -c users
$ rails routes -c admin/users
$ rails routes -c Comments
$ rails routes -c Articles::CommentsController
```
> Результат команды rails routes более читаемый, если у вас в окне терминала прокрутка, а не перенос строчек.

#### Тестирование маршрутов

Маршруты должны быть включены в вашу стратегию тестирования (так же, как и остальное в вашем приложении). Rails предлагает три встроенных оператора контроля, разработанных для того, чтобы сделать тестирование маршрутов проще:
* `assert_generates`
* `assert_recognizes`
* `assert_routing` 

##### Оператор контроля `assert_generates`
Используйте `assert_generates`, чтобы убедиться в том, что определенный набор опций генерирует конкретный путь и может использоваться с дефолтными маршрутами или своими маршрутами. Например:
```
assert_generates '/photos/1', { controller: 'photos', action: 'show', id: '1' }
assert_generates '/about', controller: 'pages', action: 'about'
```
##### Оператор контроля `assert_recognizes`
Оператор контроля `assert_recognizes` - это противоположность `assert_generates`. Он убеждается, что Rails распознает предложенный путь и маршрутизирует его в конкретную точку в вашем приложении. Например:
```
assert_recognizes({ controller: 'photos', action: 'show', id: '1' }, '/photos/1')
```
Можете задать аргумент `:method`, чтобы определить метод HTTP:
```
assert_recognizes({ controller: 'photos', action: 'create' }, { path: 'photos', method: :post })
```
##### Оператор контроля `assert_routing`
Оператор контроля `assert_routing` проверяет маршрут с двух сторон: он тестирует, что путь создает опции, и что опции создают путь. Таким образом, он комбинирует функции `assert_generates` и `assert_recognizes`:
```
assert_routing({ path: 'photos', method: :post }, { controller: 'photos', action: 'create' })
```


# Копаем глубже <a name="5"></a>
## Расширения ядра Active Support <a name="5.1"></a>
Active Support - это компонент Ruby on Rails, отвечающий за предоставление расширений для языка Ruby, утилит и множества других вещей.

Он предлагает более ценные функции на уровне языка, нацеленные как на разработку приложений на Rails, так и на разработку самого Ruby on Rails.

После прочтения этого руководства, вы узнаете:
* Что такое расширения ядра.
* Как загрузить все расширения.
* Как подобрать только те расширения, которые вам нужны.
* Какие расширения предоставляет Active Support.

### Как загрузить расширения ядра <a name="5.1.1"></a>
#### Автономный Active Support
Для обеспечения минимума влияния, Active Support по умолчанию ничего не загружает. Он разбит на маленькие части, поэтому можно загружать лишь то, что нужно, и имеет некоторые точки входа, которые по соглашению загружают некоторые расширения за раз, или даже все.

Таким образом, после обычного `require`:
```
require 'active_support'
```
объекты не будут даже реагировать на `blank?`. Давайте посмотрим, как загрузить эти определения.

##### Подбор определений
Наиболее легкий способ получить `blank?` - подцепить файл, который его определяет.

Для каждого отдельного метода, определенного как расширение ядра, в этом руководстве имеется заметка, сообщающая, где такой метод определяется. В случае с `blank?` заметка гласит:

> Определено в active_support/core_ext/object/blank.rb.

Это означает, что это можно затребовать следующим образом:
```
require 'active_support'
require 'active_support/core_ext/object/blank'
```
Active Support был тщательно пересмотрен и теперь подхватывает только те файлы для загрузки, которые содержат строго необходимые зависимости, если такие имеются.

##### Загрузка сгруппированных расширений ядра
Следующий уровень - это просто загрузка всех расширений к `Object`. Как правило, расширения к `SomeClass` доступны за раз при загрузке `active_support/core_ext/some_class`.

Таким образом, чтобы загрузить все расширения `Object` (в том числе `blank?`):
```
require 'active_support'
require 'active_support/core_ext/object'
```
##### Загрузка всех расширений ядра
Возможно, вы предпочтете загрузить все расширения ядра, вот файл для этого необходимо:
```
require 'active_support'
require 'active_support/core_ext'
```

##### Загрузка всего Active Support
И наконец, если необходимо получить доступ ко всему Active Support, просто выполните:
```
require 'active_support/all'
```
В действительности это даже не поместит весь Active Support в память, так как некоторые вещи настроены через `autoload`, поэтому они загружаются только когда используются.

#### Active Support в приложении на Ruby on Rails
Приложение на Ruby on Rails загружает весь Active Support, кроме случая когда` config.active_support.bare` равен `true`. В этом случае приложение загрузит только сам фреймворк и подберет файлы для собственных нужд, и позволит подобрать вам файлы самостоятельно на любом уровне, как описано в предыдущем разделе.

### Расширения ко всем объектам <a name="5.1.2"></a>
#### `blank?` и `present?`
Следующие значения рассматриваются как пустые в Rails приложении:
* `nil` и `false`,
* строки, состоящие только из пробелов (смотрите примечание ниже),
* пустые массивы и хэши,
* и любые другие объекты, откликающиеся на `empty?` и являющиеся пустыми. 

> Предикат для строк использует совместимый с Unicode символьный класс `[:space:]`, поэтому, к примеру, U+2029 (разделитель параграфов) рассматривается как пробел.

> Отметьте, что числа тут не упомянуты, в частности, 0 и 0.0 не являются пустыми.

Например, этот метод из `ActionController::HttpAuthentication::Token::ControllerMethods` использует `blank?` для проверки, существует ли токен:
```
def authenticate(controller, &login_procedure)
  token, options = token_and_options(controller.request)
  unless token.blank?
    login_procedure.call(token, options)
  end
end
```
Метод `present?` является эквивалентом `!blank?`. Этот пример взят из `ActionDispatch::Http::Cache::Response`:
```
def set_conditional_cache_control!
  return if self["Cache-Control"].present?
  ...
end
```
Определено в `active_support/core_ext/object/blank.rb`.

#### `presence`
Метод `presence` возвращает его получателя, если `present?`, и `nil` в противном случае. Он полезен для подобных идиом:
```
host = config[:host].presence || 'localhost'
```
Определено в `active_support/core_ext/object/blank.rb`.

#### `duplicable?`
В Ruby 2.5 большинство объектов могут дублироваться с помощью `dup` или `clone`:
```
"foo".dup           # => "foo"
"".dup              # => ""
Rational(1).dup     # => (1/1)
Complex(0).dup      # => (0+0i)
1.method(:+).dup    # => TypeError (allocator undefined for Method)
```
Active Support предоставляет `duplicable?` для запроса к объекту об этой возможности:
```
"foo".duplicable?        # => true
"".duplicable?           # => true
Rational(1).duplicable?  # => true
Complex(1).duplicable?   # => true
1.method(:+).duplicable? # => false
```
`duplicable?` соответствует поведению `dup` текущей версии Ruby, поэтому результаты будут варьироваться в зависимости от используемой версии Ruby. В Ruby 2.4, например, `Complex` и `Rational` не дублируются:
```
Rational(1).duplicable?     # => false
Complex(1).duplicable?      # => false
```
> Любой класс может запретить дублирование, убрав `dup` и `clone`, или вызвав исключение в них. Таким образом, только rescue может сказать, является ли данный произвольный объект дублируемым. `duplicable?` зависит от жестко заданного вышеуказанного перечня, но он **намного быстрее, чем `rescue`**. Используйте его только в том случае, если знаете, что жесткий перечень достаточен в конкретном случае.

> Определено в `active_support/core_ext/object/duplicable.rb`.

#### `deep_dup`

Метод deep_dup возвращает "глубокую" копию данного объекта. Обычно при вызове `dup` на объекте, содержащем другие объекты, Ruby не вызывает `dup` для них, поэтому он создает "мелкую" копию объекта. Если, к примеру, имеется массив со строкой, это будет выглядеть так:
```
array     = ['string']
duplicate = array.dup

duplicate.push 'another-string'

# объект был дублирован, поэтому элемент был добавлен только в дубликат
array     # => ['string']
duplicate # => ['string', 'another-string']

duplicate.first.gsub!('string', 'foo')

# первый элемент не был дублирован, он будет изменен в обоих массивах
array     # => ['foo']
duplicate # => ['foo', 'another-string']
```

Как видите, после дублирования экземпляра `Array`, мы получили еще один объект, следовательно мы можем его модифицировать, и исходный объект останется нетронутым. Однако, это не истинно для элементов массива. Поскольку dup не делает "глубокую" копию, строка внутри массива остается тем же самым объектом.

Если нужна "глубокая" копия объекта, следует использовать `deep_dup`. Вот пример:
```
array     = ['string']
duplicate = array.deep_dup

duplicate.first.gsub!('string', 'foo')

array     # => ['string']
duplicate # => ['foo']
```
Если объект нельзя дублировать, deep_dup просто возвратит его:
```
number = 1
duplicate = number.deep_dup
number.object_id == duplicate.object_id   # => true
```
> Определено в `active_support/core_ext/object/deep_dup.rb`.

#### `try`
Когда необходимо вызвать метод на объекте, но только в том случае, если он не `nil`, то простейшим способом достичь этого является условное выражение, добавляющее ненужный код. Альтернативой является использование `try`. `try` похож на `Object#send` за исключением того, что он возвращает `nil`, если вызван на `nil`.

Вот пример:
```
# без try
unless @number.nil?
  @number.next
end

# используя try
@number.try(:next)
```
Другим примером является этот код из `ActiveRecord::ConnectionAdapters::AbstractAdapter`, где `@logger` может быть `nil`. Код использует `try` и позволяет избегать ненужной проверки.
```
def log_info(sql, name, ms)
  if @logger.try(:debug?)
    name = '%s (%.1fms)' % [name || 'SQL', ms]
    @logger.debug(format_log_entry(name, sql.squeeze(' ')))
  end
end
```
`try` также может быть вызван не с аргументами, а с блоком, который будет выполнен, если объект не `nil`:
```
@person.try { |p| "#{p.first_name} #{p.last_name}" }
```
Отметьте, что `try` поглотит ошибки об отсутствующем методе, возвратив вместо них `nil`. **Если необходимо защититься от таких ошибок, используйте вместо него `try!`**:
```
@number.try(:nest)  # => nil
@number.try!(:nest) # NoMethodError: undefined method `nest' for 1:Integer
```
Определено в `active_support/core_ext/object/try.rb`.

#### `class_eval(*args, &block)`
Можно вычислить код в контексте синглтон-класса любого объекта, используя `class_eval`:
```
class Proc
  def bind(object)
    block, time = self, Time.current
    object.class_eval do
      method_name = "__bind_#{time.to_i}_#{time.usec}"
      define_method(method_name, &block)
      method = instance_method(method_name)
      remove_method(method_name)
      method
    end.bind(object)
  end
end
```
> Определено в `active_support/core_ext/kernel/singleton_class.rb`.

#### `acts_like?(duck)`
Метод `acts_like?` предоставляет возможность проверить, работает ли некий класс как некоторый другой класс, основываясь на простом соглашении: класс предоставляющий тот же интерфейс, как у `String` определяет
```
def acts_like_string?
end
```
являющийся всего лишь маркером, его содержимое или возвращаемое значение ничего не значит. Затем, код клиента может запросить "безопасную утиную типизацию" следующим образом:
```
some_klass.acts_like?(:string)
```
В Rails имеются классы, действующие как `Date` или `Time` и следующие этому соглашению.

> Определено в `active_support/core_ext/object/acts_like.rb`.

#### `to_param`

Все объекты в Rails отвечают на метод `to_param`, который предназначен для возврата чего-то, что представляет их в строке запроса или как фрагменты URL.

По умолчанию `to_param` просто вызывает `to_s`:
```
7.to_param # => "7"
```
Возвращаемое значение `to_param` не должно быть экранировано:
```
"Tom & Jerry".to_param # => "Tom & Jerry"
```
Некоторые классы в Rails переопределяют этот метод.

Например, `nil`, `true` и `false` возвращают сами себя. `Array#to_param` вызывает `to_param` на элементах и соединяет результат с помощью "/":
```
[0, true, String].to_param # => "0/true/String"
```
В частности, система роутинга Rails вызывает `to_param` на моделях, чтобы получить значение для местозаполнителя `:id`. `ActiveRecord::Base#to_param` возвращает `id` модели, но можно переопределить этот метод в своих моделях. Например, задав
```
class User
  def to_param
    "#{id}-#{name.parameterize}"
  end
end
```
мы получим:
```
user_path(@user) # => "/users/357-john-smith"
```
> Контроллерам нужно быть в курсе любых переопределений `to_param`, поскольку в подобном запросе "357-john-smith" будет значением `params[:id]`.

> Определено в `active_support/core_ext/object/to_param.rb`.

#### `to_query`

За исключением хэшей, для заданного неэкранированного ключа этот метод создает часть строки запроса, который связывает с этим ключом то, что возвращает `to_param`. Например, задав
```
class User
  def to_param
    "#{id}-#{name.parameterize}"
  end
end
```
мы получим:
```
current_user.to_query('user') # => "user=357-john-smith"
```
Этот метод экранирует все, что требуется: и ключ, и значение:
```
account.to_query('company[name]')
# => "company%5Bname%5D=Johnson+%26+Johnson"
```
поэтому результат готов для использования в строке запроса.

Массивы возвращают результат применения `to_query` к каждому элементу с `key[]` в качестве ключа, и соединяет результат с помощью "&":
```
[3.4, -45.6].to_query('sample')
# => "sample%5B%5D=3.4&sample%5B%5D=-45.6"
```
Хэши также отвечают на `to_query`, но c другой сигнатурой. Если аргумент не передается, вызов генерирует отсортированную серию присваиваний ключ/значение, вызвав `to_query(key)` на этих значениях. Затем он соединяет результат с помощью "&":
```
{c: 3, b: 2, a: 1}.to_query # => "a=1&b=2&c=3"
```
Метод `Hash#to_query` принимает опциональное пространство имен для ключей:
```
{id: 89, name: "John Smith"}.to_query('user')
# => "user%5Bid%5D=89&user%5Bname%5D=John+Smith"
```
> Определено в `active_support/core_ext/object/to_query.rb`.

#### `with_options`

Метод `with_options` предоставляет способ для выделения общих опций в серии вызовов метода.

Задав дефолтный хэш опций, `with_options` предоставляет прокси-объект в блок. Внутри блока методы, вызванные на прокси, отправляются получателю с объединением своих опций. Например, чтобы избавиться от дублирования:
```
class Account < ApplicationRecord
  has_many :customers, dependent: :destroy
  has_many :products,  dependent: :destroy
  has_many :invoices,  dependent: :destroy
  has_many :expenses,  dependent: :destroy
end
```
заменяем на:
```
class Account < ApplicationRecord
  with_options dependent: :destroy do |assoc|
    assoc.has_many :customers
    assoc.has_many :products
    assoc.has_many :invoices
    assoc.has_many :expenses
  end
end
```
Эта идиома может передавать группировку в ридер (reader). Например скажем, что нужно послать `newsletter`, язык которого зависит от пользователя. Где-нибудь в рассыльщике можно сгруппировать кусочки, зависимые от локали, следующим образом:
```
I18n.with_options locale: user.locale, scope: "newsletter" do |i18n|
  subject i18n.t :subject
  body    i18n.t :body, user_name: user.name
end
```
Поскольку `with_options` переадресовывает вызовы получателю, они могут быть вложены. Каждый уровень вложенности будет объединять унаследованные дефолтные значения со своими собственными.

> Определено в `active_support/core_ext/object/with_options.rb`.

#### Поддержка JSON
Active Support обеспечивает лучшую реализацию `to_json`, чем гем `json`, обычно предоставленный для объектов Ruby. Это так, потому что некоторые классы, такие как `Hash`, `OrderedHash` и `Process::Status`, нуждаются в специальной обработке для обеспечения подходящего JSON.

> Определено в `active_support/core_ext/object/json.rb`.

#### Переменные экземпляра
Active Support предоставляет несколько методов для облегчения доступа к переменным экземпляра.

##### `instance_values`
Метод `instance_values` возвращает хэш, который связывает имена переменных экземпляра без "@" с их соответствующими значениями. Ключи являются строками:
```
class C
  def initialize(x, y)
    @x, @y = x, y
  end
end

C.new(0, 1).instance_values # => {"x" => 0, "y" => 1}
```
> Определено в `active_support/core_ext/object/instance_variables.rb`.

##### `instance_variable_names`
Метод `instance_variable_names` возвращает массив. Каждое имя включает знак "@".
```
class C
  def initialize(x, y)
    @x, @y = x, y
  end
end

C.new(0, 1).instance_variable_names # => ["@x", "@y"]
```
> Определено в `active_support/core_ext/object/instance_variables.rb`.

#### Отключение предупреждений и исключения
Методы `silence_warnings` и `enable_warnings` изменяют значение `$VERBOSE` в течение исполнения блока, и сбрасывают в исходное значение после его окончания:
```
silence_warnings { Object.const_set "RAILS_DEFAULT_LOGGER", logger }
```
Отключение исключений также возможно с помощью `suppress`. Этот метод получает определенное количество классов исключений. Если вызывается исключение во время выполнения блока, и `kind_of?` соответствует любому аргументу, `suppress` ловит его и возвращает отключенным. В противном случае исключение не захватывается:
```
# Если пользователь под блокировкой, инкремент теряется, ничего страшного.
suppress(ActiveRecord::StaleObjectError) do
  current_user.increment! :visits
end
```
> Определено в `active_support/core_ext/kernel/reporting.rb`.

#### `in?`

Предикат `in?` проверяет, включен ли объект в другой объект. Если переданный элемент не отвечает на `include?`, будет вызвано исключение `ArgumentError`.

Примеры применения `in?`:
```
1.in?([1,2])        # => true
"lo".in?("hello")   # => true
25.in?(30..50)      # => false
1.in?(1)            # => ArgumentError
```
> Определено в `active_support/core_ext/object/inclusion.rb`.

### Расширения для `Module` <a name="5.1.3"></a>
#### Атрибуты
##### `alias_attribute`
В атрибутах модели есть ридер (reader), райтер (writer) и предикат. Можно создать псевдоним к атрибуту модели, в котором будут определены сразу три соответствующих метода. Как и в других создающих псевдоним методах, новое имя - это первый аргумент, а старое имя - второй (мнемоническое правило такое: они идут в том же порядке, как если бы делалось присваивание):
```
class User < ApplicationRecord
  # Теперь можно обращаться к столбцу email как "login".
  # Это имеет больше смысла для кода аутентификации.
  alias_attribute :login, :email
end
```
> Определено в `active_support/core_ext/module/aliasing.rb`.

##### Внутренние атрибуты
При определении атрибута в классе, который предназначен для подкласса, есть риск коллизии подклассовых имен. Это особенно важно для библиотек.

Active Support определяет макросы `attr_internal_reader`, `attr_internal_writer` и `attr_internal_accessor`. Они ведут себя подобно встроенным в Ruby коллегам `attr_*`, за исключением того, что они именуют лежащую в основе переменную экземпляра способом, наиболее снижающим коллизии.

Макрос `attr_internal` - это синоним для `attr_internal_accessor`:
```
# библиотека
class ThirdPartyLibrary::Crawler
  attr_internal :log_level
end

# код клиента
class MyCrawler < ThirdPartyLibrary::Crawler
  attr_accessor :log_level
end
```
В предыдущем примере мог быть случай, при котором `:log_level` не принадлежит публичному интерфейсу библиотеки и используется только для разработки. Код клиента, не подозревающий о потенциальном конфликте, создает подкласс и определяет внутри него свой `:log_level`. Благодаря `attr_internal` здесь не будет коллизий.

**По умолчанию внутренняя переменная экземпляра именуется с предшествующим подчеркиванием**, `@_log_level` в примере выше. Это настраивается через `Module.attr_internal_naming_format`, куда можно передать любую строку в формате `sprintf` с предшествующими `@` и `%s` в любом месте, которая означает место, куда вставляется имя. По умолчанию `"@_%s"`.

Rails использует внутренние атрибуты в некоторых местах, например для вьюх:
```
module ActionView
  class Base
    attr_internal :captures
    attr_internal :request, :layout
    attr_internal :controller, :template
  end
end
```
> Определено в `active_support/core_ext/module/attr_internal.rb`.

##### Атрибуты модуля

Макросы `mattr_reader`, `mattr_writer` и `mattr_accessor` - это те же самые макросы `cattr_*`, определенным для класса. Фактически, макросы `cattr_*` — это всего лишь псевдонимы для макросов `mattr_*`.

Например, их использует механизм зависимостей:
```
module ActiveSupport
  module Dependencies
    mattr_accessor :warnings_on_first_load
    mattr_accessor :history
    mattr_accessor :loaded
    mattr_accessor :mechanism
    mattr_accessor :load_paths
    mattr_accessor :load_once_paths
    mattr_accessor :autoloaded_constants
    mattr_accessor :explicitly_unloadable_constants
    mattr_accessor :constant_watch_stack
    mattr_accessor :constant_watch_stack_mutex
  end
end
```
> Определено в `active_support/core_ext/module/attribute_accessors.rb`.

#### Родители
##### `module_parent`
Метод `module_parent` на вложенном именованном модуле возвращает модуль, содержащий его соответствующую константу:
```
module X
  module Y
    module Z
    end
  end
end
M = X::Y::Z

X::Y::Z.module_parent # => X::Y
M.module_parent       # => X::Y
```
Если модуль анонимный или относится к верхнему уровню, `module_parent` возвращает `Object`.

> Отметьте, что в этом случае `module_parent_name` возвращает `nil`.

> Определено в `active_support/core_ext/module/introspection.rb`.

##### `module_parent_name`
Метод `module_parent_name` на вложенном именованном модуле возвращает полностью определенное имя модуля, содержащего его соответствующую константу:
```
module X
  module Y
    module Z
    end
  end
end
M = X::Y::Z

X::Y::Z.module_parent_name # => "X::Y"
M.module_parent_name       # => "X::Y"
```
Для верхнеуровневых и анонимных модулей `module_parent_name` возвращает `nil`.

> Отметьте, что в этом случае `module_parent` возвращает `Object`.

> Определено в `active_support/core_ext/module/introspection.rb`.

##### `parents`
Метод `module_parents` вызывает `module_parent` на получателе и вверх по иерархии, пока не будет достигнут `Object`. Цепочка возвращается в массиве, от низшего к высшему:
```
module X
  module Y
    module Z
    end
  end
end
M = X::Y::Z

X::Y::Z.module_parents # => [X::Y, X, Object]
M.module_parents       # => [X::Y, X, Object]
```
> Определено в `active_support/core_ext/module/introspection.rb`.

#### `Anonymous`
У модуля может быть или не быть имени:
```
module M
end
M.name # => "M"

N = Module.new
N.name # => "N"

Module.new.name # => nil
```
Можно проверить, имеет ли модуль имя с помощью предиката `anonymous?`:
```
module M
end
M.anonymous? # => false

Module.new.anonymous? # => true
```
Отметьте, что быть недостижимым не означает быть анонимным:
```
module M
end

m = Object.send(:remove_const, :M)

m.anonymous? # => false
```
хотя анонимный модуль недостижим по определению.

> Определено в `active_support/core_ext/module/anonymous.rb`.

#### Делегирование метода
##### `delegate`
Макрос `delegate` предлагает простой способ передать методы.

Давайте представим, что у пользователей в неком приложении имеется информация о логинах в модели `User`, но имена и другие данные в отдельной модели `Profile`:
```
class User < ApplicationRecord
  has_one :profile
end
```
С такой конфигурацией можно получить имя пользователя через его профиль, `user.profile.name`, но было бы удобнее обеспечить доступ к такому атрибуту напрямую:
```
class User < ApplicationRecord
  has_one :profile

  def name
    profile.name
  end
end
```
Это как раз то, что делает `delegate`:
```
class User < ApplicationRecord
  has_one :profile

  delegate :name, to: :profile
end
```
Это короче, и намерения более очевидные.

Целевой метод должен быть публичным.

Макрос `delegate` принимает несколько методов:
```
delegate :name, :age, :address, :twitter, to: :profile
```
При интерполяции в строку опция `:to` должна стать выражением, вычисляемым объектом, метод которого делегируется. Обычно строка или символ. Такое выражение вычисляется в контексте получателя:
```
# делегирует константе Rails
delegate :logger, to: :Rails

# делегирует классу получателя
delegate :table_name, to: :class
```
> Если опция `:prefix` установлена в `true` - это менее характерно, смотрите ниже.

По умолчанию, если делегирование вызывает `NoMethodError` и цель является `nil`, выводится исключение. Можно попросить с помощью опции `:allow_nil`, чтобы вместо этого возвращался `nil`:
```
delegate :name, to: :profile, allow_nil: true
```
С `:allow_nil` вызов `user.name` возвратит `nil`, если у пользователя нет профиля.

Опция `:prefix` добавляет префикс к имени генерируемого метода. Это может быть удобно, например, для получения более благозвучного имени:
```
delegate :street, to: :address, prefix: true
```
Предыдущий пример сгенерирует `address_street`, а не `street`.

> Поскольку в этом случае имя генерируемого метода составляется из имен целевого объекта и целевого метода, опция `:to` должна быть именем метода.

Также может быть настроен произвольный префикс:
```
delegate :size, to: :attachment, prefix: :avatar
```
В предыдущем примере макрос генерирует `avatar_size`, а не `size`.

Опция `:private` изменяет область видимости методов:
```
delegate :date_of_birth, to: :profile, private: true
```
Делегированные методы являются публичными по умолчанию. Передайте `private: true`, чтобы изменить это.

> Определено в `active_support/core_ext/module/delegation.rb`

##### `delegate_missing_to`
Представьте, что нужно делегировать все, отсутствующее в объекте `User` в `Profile`. Макрос `delegate_missing_to` позволяет реализовать это быстро:
```
class User < ApplicationRecord
  has_one :profile

  delegate_missing_to :profile
end
```
Целью может быть все что угодно, вызываемое внутри объекта, например, переменные экземпляра, методы, константы и т.д. Делегируются только публичные методы цели.

> Определено в `active_support/core_ext/module/delegation.rb`.

#### Переопределение методов
Бывают ситуации, когда нужно определить метод с помощью `define_method`, но вы не знаете, существует ли уже метод с таким именем. Если так, то выдается предупреждение, если оно включено. Такое поведение хоть и не ошибочно, но не элегантно.

Метод `redefine_method` предотвращает такое потенциальное предупреждение, предварительно убирая существующий метод, если нужно.

Также можно использовать `silence_redefinition_of_method`, если необходимо определить заменяющий метод отдельно (потому что используется `delegate`, например).

> Определено в `active_support/core_ext/module/redefine_method.rb`.

### Расширения для `Class` <a name="5.1.4"></a>
#### Атрибуты класса
##### `class_attribute`
Метод `class_attribute` объявляет один или более наследуемых атрибутов класса, которые могут быть переопределены на низшем уровне иерархии:
```
class A
  class_attribute :x
end

class B < A; end

class C < B; end

A.x = :a
B.x # => :a
C.x # => :a

B.x = :b
A.x # => :a
C.x # => :b

C.x = :c
A.x # => :a
B.x # => :b
```
Например, `ActionMailer::Base определяет`:
```
class_attribute :default_params
self.default_params = {
  mime_version: "1.0",
  charset: "UTF-8",
  content_type: "text/plain",
  parts_order: [ "text/plain", "text/enriched", "text/html" ]
}.freeze
```
К ним также есть доступ, и они могут быть переопределены на уровне экземпляра:
```
A.x = 1

a1 = A.new
a2 = A.new
a2.x = 2

a1.x # => 1, приходит из A
a2.x # => 2, переопределено в a2
```
Генерация райтер-метода экземпляра может быть отключена установлением опции `:instance_writer` в `false`.
```
module ActiveRecord
  class Base
    class_attribute :table_name_prefix, instance_writer: false, default: "my"
  end
end
```
В модели такая опция может быть полезной как способ предотвращения массового назначения для установки атрибута.

Генерация ридер-метода экземпляра может быть отключена установлением опции `:instance_reader` в `false`.
```
class A
  class_attribute :x, instance_reader: false
end

A.new.x = 1
A.new.x # NoMethodError
```
Для удобства `class_attribute` определяет также предикат экземпляра, являющийся двойным отрицанием того, что возвращает ридер экземпляра. В вышеописанном примере оно может вызываться `x?`.

Когда `instance_reader` равен `false`, предикат экземпляра возвратит `NoMethodError`, как и ридер-метод.

Если не нужен предикат, передайте `instance_predicate: false`, и он не будет определен.

> Определено в `active_support/core_ext/class/attribute.rb`.

##### `cattr_reader`, `cattr_writer` и `cattr_accessor`
Макросы `cattr_reader`, `cattr_writer` и `cattr_accessor` являются аналогами их коллег `attr_*`, но для классов. Они инициализируют переменную класса как `nil`, если она еще не существует, и генерируют соответствующие методы класса для доступа к ней:
```
class MysqlAdapter < AbstractAdapter
  # Генерирует методы класса для доступа к @@emulate_booleans.
  cattr_accessor :emulate_booleans
end
```
Также можно передать блок в `cattr_*` для настройки атрибута со значением по умолчанию:
```
class MysqlAdapter < AbstractAdapter
  # Генерирует методы класса для доступа к @@emulate_booleans со значением по умолчанию true.
  cattr_accessor :emulate_booleans, default: true
end
```
Методы экземпляра также создаются для удобства, они всего лишь прокси к атрибуту класса. Таким образом, **экземпляры могут менять атрибут класса, но не могут переопределять его**, как это происходит в случае с `class_attribute` (смотрите выше). К примеру, задав
```
module ActionView
  class Base
    cattr_accessor :field_error_proc, default: Proc.new { ... }
  end
end
```
мы получим доступ к `field_error_proc` во вьюхах.

Генерация ридер-метода экземпляра предотвращается установкой `:instance_reader` в `false` и генерация райтер-метода экземпляра предотвращается установкой `:instance_writer` в `false`. Генерация обоих методов предотвращается установкой `:instance_accessor` в `false`. Во всех случаях, должно быть не любое ложное значение, а именно `false`:
```
module A
  class B
    # first_name ридер экземпляра не генерируется.
    cattr_accessor :first_name, instance_reader: false
    # last_name= райтер экземпляра не генерируется.
    cattr_accessor :last_name, instance_writer: false
    # surname ридер экземпляра или surname= райтер экземпляра не генерируется.
    cattr_accessor :surname, instance_accessor: false
  end
end
```
В модели может быть полезным установить `:instance_accessor` в `false` как способ предотвращения массового назначения для установки атрибута.

> Определено в `active_support/core_ext/class/attribute_accessors.rb`.

#### Подклассы и потомки
##### `subclasses`
Метод `subclasses` возвращает подклассы получателя:
```
class C; end
C.subclasses # => []

class B < C; end
C.subclasses # => [B]

class A < B; end
C.subclasses # => [B]

class D < C; end
C.subclasses # => [B, D]
```
Порядок, в котором эти классы возвращаются, не определен.

> Определено в `active_support/core_ext/class/subclasses.rb`.

##### `descendants`
Метод `descendants` возвращает все классы, которые являются `<` к его получателю:
```
class C; end
C.descendants # => []

class B < C; end
C.descendants # => [B]

class A < B; end
C.descendants # => [B, A]

class D < C; end
C.descendants # => [B, A, D]
```
Порядок, в котором эти классы возвращаются, не определен.

> Определено в `active_support/core_ext/class/subclasses.rb`.

### Расширения для `String` <a name="5.1.5"></a>
#### Безопасность вывода
##### Мотивация
Вставка данных в шаблоны HTML требует дополнительной осторожности. Например, нельзя просто интерполировать @review.title на страницу HTML. С одной стороны, если заголовок рецензии "Flanagan & Matz rules!", то результат не будет правильно отображен, поскольку амперсанд должен быть экранирован как "&amp;". К тому же, в зависимости от приложения, это может быть большой дырой в безопасности, так как пользователи могут внедрить вредоносный HTML, устанавливающий вручную изготовленный заголовок рецензии.

##### Безопасные строки
В Active Support есть концепция (html) безопасных строк. Безопасная строка - это та, которая помечена как подлежащая вставке в HTML как есть. Ей можно доверять, независимо от того, была она экранирована или нет.

Строки рассматриваются как небезопасные по умолчанию:
```
"".html_safe? # => false
```
Можно получить безопасную строку из заданной с помощью метода `html_safe`:
```
s = "".html_safe
s.html_safe? # => true
```
Важно понять, что `html_safe` не выполняет какого бы то ни было экранирования, это всего лишь утверждение:
```
s = "<script>...</script>".html_safe
s.html_safe? # => true
s            # => "<script>...</script>"
```
Вы ответственны за обеспечение вызова `html_safe` на подходящей строке.

При присоединении к безопасной строке или с помощью `concat/<<`, или с помощью `+`, результат будет безопасной строкой. Небезопасные аргументы экранируются:
```
"".html_safe + "<" # => "&lt;"
```
Безопасные аргументы непосредственно присоединяются:
```
"".html_safe + "<".html_safe # => "<"
```
Эти методы не должны использоваться в обычных вьюхах. Небезопасные значения автоматически экранируются:
```
<%= @review.title %> <%# прекрасно, экранируется, если нужно %>
```
Чтобы вставить что-либо дословно, используйте хелпер raw вместо вызова `html_safe`:
```
<%= raw @cms.current_template %> <%# вставляет @cms.current_template как есть %>
```
или используйте эквивалентную запись `<%==`:
```
<%== @cms.current_template %> <%# вставляет @cms.current_template как есть %>
```
Хелпер `raw` вызывает за вас хелпер `html_safe`:
```
def raw(stringish)
  stringish.to_s.html_safe
end
```
> Определено в `active_support/core_ext/string/output_safety.rb`.

##### Преобразование
Как правило, за исключением, разве что, конкатенации, как объяснялось выше, любой метод, который может изменить строку, дает небезопасную строку. Это `downcase`, `gsub`, `strip`, `chomp`, `underscore` и т.д.

В случае встроенного преобразования, такого как `gsub!`, получатель сам становится небезопасным.

> Бит безопасности всегда теряется, независимо от того, изменило ли что-то преобразование или нет.

##### Конверсия и принуждение
Вызов `to_s` на безопасной строке возвратит безопасную строку, но принуждение с помощью `to_str` возвратит небезопасную строку.

##### Копирование
Вызов `dup` или `clone` на безопасной строке создаст безопасные строки.

#### `remove`
Метод `remove` уберет все совпадения с шаблоном:
```
"Hello World".remove(/Hello /) # => "World"
```
Также имеется деструктивная версия `String#remove!`.

> Определено в `active_support/core_ext/string/filters.rb`.

#### `squish`
Метод `squish` отсекает начальные и конечные пробелы, а также заменяет внутренние пробелы на один пробел:
```
" \n  foo\n\r \t bar \n".squish # => "foo bar"
```
Также имеется разрушительная версия `String#squish!`.

Отметьте, что он обрабатывает и `ASCII`, и `Unicode` пробелы.

> Определено в `active_support/core_ext/string/filters.rb`.

#### `truncate`
Метод `truncate` возвращает копию получателя, сокращенную после заданного `length`:
```
"Oh dear! Oh dear! I shall be late!".truncate(20)
# => "Oh dear! Oh dear!..."
```
Многоточие может быть настроено с помощью опции `:omission`:
```
"Oh dear! Oh dear! I shall be late!".truncate(20, omission: '&hellip;')
# => "Oh dear! Oh &hellip;"
```
Отметьте, что сокращение учитывает длину строки `omission`.

Передайте `:separator` для сокращения строки по естественным разрывам:
```
"Oh dear! Oh dear! I shall be late!".truncate(18)
# => "Oh dear! Oh dea..."
"Oh dear! Oh dear! I shall be late!".truncate(18, separator: ' ')
# => "Oh dear! Oh..."
```
Опция `:separator` может быть регулярным выражением:
```
"Oh dear! Oh dear! I shall be late!".truncate(18, separator: /\s/)
# => "Oh dear! Oh..."
```
В вышеуказанных примерах "dear" обрезается сначала, а затем `:separator` предотвращает это.

> Определено в `active_support/core_ext/string/filters.rb`.

#### `truncate_words`
Метод `truncate_words` возвращает копию получателя, сокращенную после заданного количества слов:
```
"Oh dear! Oh dear! I shall be late!".truncate_words(4)
# => "Oh dear! Oh dear!..."
```
Многоточие может быть настроено с помощью опции `:omission`:
```
"Oh dear! Oh dear! I shall be late!".truncate_words(4, omission: '&hellip;')
# => "Oh dear! Oh dear!&hellip;"
```
Передайте `:separator` для сокращения строки по естественным разрывам:
```
"Oh dear! Oh dear! I shall be late!".truncate_words(3, separator: '!')
# => "Oh dear! Oh dear! I shall be late..."
```
Опция `:separator` может быть регулярным выражением:
```
"Oh dear! Oh dear! I shall be late!".truncate_words(4, separator: /\s/)
# => "Oh dear! Oh dear!..."
```
> Определено в `active_support/core_ext/string/filters.rb`.

#### `inquiry`

Метод `inquiry` конвертирует строку в объект `StringInquirer`, делая проверки равенства более красивыми.
```
"production".inquiry.production? # => true
"active".inquiry.inactive?       # => false
```

#### `starts_with?` и `ends_with?`
Active Support определяет псевдонимы `String#start_with?` и `String#end_with?` (в связи с особенностями английской морфологии, преобразует глаголы в форму 3-го лица):
```
"foo".starts_with?("f") # => true
"foo".ends_with?("o")   # => true
```
> Определено в `active_support/core_ext/string/starts_ends_with.rb`.

#### `strip_heredoc`
Метод `strip_heredoc` обрезает отступы в heredocs.

Для примера в
```
if options[:usage]
  puts <<-USAGE.strip_heredoc
    This command does such and such.

    Supported options are:
      -h         This message
      ...
  USAGE
end
```
пользователь увидит используемое сообщение, выровненное по левому краю.

Технически это выглядит как выделение красной строки в отдельную строку и удаление всех впередиидущих пробелов.

> Определено в `active_support/core_ext/string/strip.rb`.

#### `indent`

Устанавливает отступы строчкам получателя:
```
<<EOS.indent(2)
def some_method
  some_code
end
EOS
# =>
  def some_method
    some_code
  end
```
Второй аргумент, `indent_string`, определяет, какой отступ строки использовать. По умолчанию `nil`, что сообщает методу самому догадаться на основе первой строчки с отступом, а если такой нет, то использовать пробел.
```
"  foo".indent(2)        # => "    foo"
"foo\n\t\tbar".indent(2) # => "\t\tfoo\n\t\t\t\tbar"
"foo".indent(2, "\t")    # => "\t\tfoo"
```
Хотя `indent_string` это обычно один пробел или табуляция, он может быть любой строкой.

Третий аргумент, `indent_empty_lines`, это флажок, указывающий, должен ли быть отступ для пустых строчек. По умолчанию `false`.
```
"foo\n\nbar".indent(2)            # => "  foo\n\n  bar"
"foo\n\nbar".indent(2, nil, true) # => "  foo\n  \n  bar"
```
Метод `indent!` добавляет отступ строке.

> Определено в `active_support/core_ext/string/indent.rb`.

#### `Доступ`
##### `at(position)`
Возвращает символ строки на позиции `position`:
```
"hello".at(0)  # => "h"
"hello".at(4)  # => "o"
"hello".at(-1) # => "o"
"hello".at(10) # => nil
```
Определено в `active_support/core_ext/string/access.rb`.

##### `from(position)`
Возвращает подстроку строки, начинающуюся с позиции `position`:
```
"hello".from(0)  # => "hello"
"hello".from(2)  # => "llo"
"hello".from(-2) # => "lo"
"hello".from(10) # => nil
```
> Определено в `active_support/core_ext/string/access.rb`.

##### `to(position)`

Возвращает подстроку строки с начала до позиции position:
```
"hello".to(0)  # => "h"
"hello".to(2)  # => "hel"
"hello".to(-2) # => "hell"
"hello".to(10) # => "hello"
```
Определено в `active_support/core_ext/string/access.rb`.

##### `first(limit = 1)`
Вызов `str.first(n)` эквивалентен `str.to(n-1)`, если `n > 0`, и возвращает пустую строку для `n == 0`.

> Определено в `active_support/core_ext/string/access.rb`.

##### `last(limit = 1)`
Вызов `str.last(n)` эквивалентен `str.from(-n)`, если `n > 0`, и возвращает пустую строку для `n == 0`.

> Определено в `active_support/core_ext/string/access.rb`.

#### Изменения слов
##### `pluralize`
Метод `pluralize` возвращает множественное число получателя:
```
"table".pluralize     # => "tables"
"ruby".pluralize      # => "rubies"
"equipment".pluralize # => "equipment"
```
Как показывает предыдущий пример, Active Support знает некоторые неправильные множественные числа и неисчисляемые существительные. Встроенные правила могут быть расширены в `config/initializers/inflections.rb`. Этот файл генерируется командой rails и имеет инструкции в комментариях.

`pluralize` также может принимать опциональный параметр count. Если `count == 1`, будет возвращена единственная форма. Для остальных значений count будет возвращена множественная форма:
```
"dude".pluralize(0) # => "dudes"
"dude".pluralize(1) # => "dude"
"dude".pluralize(2) # => "dudes"
```
Active Record использует этот метод для вычисления дефолтного имени таблицы, соответствующей модели:
```
# active_record/model_schema.rb
def undecorated_table_name(class_name = base_class.name)
  table_name = class_name.to_s.demodulize.underscore
  pluralize_table_names ? table_name.pluralize : table_name
end
```
> Определено в `active_support/core_ext/string/inflections.rb`.

##### `singularize`
Противоположность `pluralize`:
```
"tables".singularize    # => "table"
"rubies".singularize    # => "ruby"
"equipment".singularize # => "equipment"
```
Связи вычисляют имя соответствующего связанного дефолтного класса, используя этот метод:
```
# active_record/reflection.rb
def derive_class_name
  class_name = name.to_s.camelize
  class_name = class_name.singularize if collection?
  class_name
end
```
> Определено в `active_support/core_ext/string/inflections.rb`.

##### `camelize`
Метод `camelize` возвращает получателя в стиле `CamelCase`:
```
"product".camelize    # => "Product"
"admin_user".camelize # => "AdminUser"
```
Как правило, об этом методе думают, как о преобразующем пути в классы Ruby или имена модулей, где слэши разделяют пространства имен:
```
"backoffice/session".camelize # => "Backoffice::Session"
```
Например, Action Pack использует этот метод для загрузки класса, предоставляющего определенное хранилище сессии:
```
# action_controller/metal/session_management.rb
def session_store=(store)
  @@session_store = store.is_a?(Symbol) ?
    ActionDispatch::Session.const_get(store.to_s.camelize) :
    store
end
```
`camelize` принимает опциональный аргумент, он может быть `:upper` (по умолчанию) или `:lower`. В последнем случае первая буква становится строчной:
```
"visual_effect".camelize(:lower) # => "visualEffect"
```
Это может быть удобно для вычисления имен методов на языке, который следует такому соглашению, например JavaScript.

> Как правило, можно рассматривать `camelize` как противоположность underscore, хотя бывают случаи, когда это не так: `"SSLError".underscore.camelize` возвращает "SslError". Для поддержки подобных случаев, Active Support позволяет указывать акронимы в `config/initializers/inflections.rb`
```
ActiveSupport::Inflector.inflections do |inflect|
  inflect.acronym 'SSL'
end

"SSLError".underscore.camelize # => "SSLError"
```
`camelize` имеет псевдоним `camelcase`.

> Определено в `active_support/core_ext/string/inflections.rb`.

##### `underscore`

Метод `underscore`, наоборот, от `CamelCase` к путям:
```
"Product".underscore   # => "product"
"AdminUser".underscore # => "admin_user"
```
Также преобразует "::" обратно в "/":
```
"Backoffice::Session".underscore # => "backoffice/session"
```
и понимает строки, начинающиеся с прописной буквы:
```
"visualEffect".underscore # => "visual_effect"
```
хотя `underscore` не принимает никакие аргументы.

Автозагрузка классов и модулей Rails использует `underscore` для вывода относительного пути без расширения файла, определяющего заданную отсутствующую константу:
```
# active_support/dependencies.rb
def load_missing_constant(from_mod, const_name)
  ...
  qualified_name = qualified_name_for from_mod, const_name
  path_suffix = qualified_name.underscore
  ...
end
```
> Как правило, рассматривайте `underscore` как противоположность `camelize`, хотя бывают случаи, когда это не так. Например, `"SSLError".underscore.camelize` возвратит `"SslError"`.

> Определено в `active_support/core_ext/string/inflections.rb`.

##### `titleize`
Метод `titleize` озаглавит слова в получателе:
```
"alice in wonderland".titleize # => "Alice In Wonderland"
"fermat's enigma".titleize     # => "Fermat's Enigma"
```
`titleize` имеет псевдоним `titlecase`.

> Определено в `active_support/core_ext/string/inflections.rb`.

##### `dasherize`
Метод `dasherize` заменяет подчеркивания в получателе дефисами:
```
"name".dasherize         # => "name"
"contact_data".dasherize # => "contact-data"
```
Сериализатор XML моделей использует этот метод для форматирования имен узлов:
```
# active_model/serializers/xml.rb
def reformat_name(name)
  name = name.camelize if camelize?
  dasherize? ? name.dasherize : name
end
```
> Определено в `active_support/core_ext/string/inflections.rb`.

##### `demodulize`
Для заданной строки с ограниченным именем константы, `demodulize` возвращает само имя константы, то есть правой части этого:
```
"Product".demodulize                        # => "Product"
"Backoffice::UsersController".demodulize    # => "UsersController"
"Admin::Hotel::ReservationUtils".demodulize # => "ReservationUtils"
"::Inflections".demodulize                  # => "Inflections"
"".demodulize                               # => ""
```

Active Record, к примеру, использует этот метод для вычисления имени столбца кэширования счетчика:
```
# active_record/reflection.rb
def counter_cache_column
  if options[:counter_cache] == true
    "#{active_record.name.demodulize.underscore.pluralize}_count"
  elsif options[:counter_cache]
    options[:counter_cache]
  end
end
```
> Определено в `active_support/core_ext/string/inflections.rb`.

##### `deconstantize`
У заданной строки с ограниченным выражением ссылки на константу `deconstantize` убирает самый правый сегмент, в основном оставляя имя контейнера константы:
```
"Product".deconstantize                        # => ""
"Backoffice::UsersController".deconstantize    # => "Backoffice"
"Admin::Hotel::ReservationUtils".deconstantize # => "Admin::Hotel"
```
> Определено в `active_support/core_ext/string/inflections.rb`.

##### `parameterize`
Метод `parameterize` нормализует получателя способом, который может использоваться в красивых URL.
```
"John Smith".parameterize # => "john-smith"
"Kurt Gödel".parameterize # => "kurt-godel"
```
Чтобы сохранить регистр строки, установите аргумент `preserve_case` в `true`. По умолчанию `preserve_case` установлен в `false`.
```
"John Smith".parameterize(preserve_case: true) # => "John-Smith"
"Kurt Gödel".parameterize(preserve_case: true) # => "Kurt-Godel"
```
Чтобы использовать произвольный разделитель, переопределите аргумент `separator`.
```
"John Smith".parameterize(separator: "_") # => "john\_smith"
"Kurt Gödel".parameterize(separator: "_") # => "kurt\_godel"
```
Фактически результирующая строка оборачивается в экземпляр `ActiveSupport::Multibyte::Chars`.

> Определено в `active_support/core_ext/string/inflections.rb`.

##### `tableize`
Метод `tableize` - это underscore вместе с `pluralize`.
```
"Person".tableize      # => "people"
"Invoice".tableize     # => "invoices"
"InvoiceLine".tableize # => "invoice_lines"
```
Как правило, `tableize` возвращает имя таблицы, соответствующей заданной модели для простых случаев. На самом деле фактическая реализация в Active Record не является прямым `tableize`, так как он также демодулизирует имя класса и проверяет несколько опций, которые могут повлиять на возвращаемую строку.

> Определено в `active_support/core_ext/string/inflections.rb`.

##### `classify`
Метод `classify` является противоположностью `tableize`. Он выдает имя класса, соответствующего имени таблицы:
```
"people".classify        # => "Person"
"invoices".classify      # => "Invoice"
"invoice_lines".classify # => "InvoiceLine"
```
Метод понимает ограниченные имена таблиц:
```
"highrise_production.companies".classify # => "Company"
```
Отметьте, что `classify` возвращает имя класса как строку. Можете получить фактический объект класса, вызвав `constantize` на ней, как объяснено далее.

> Определено в `active_support/core_ext/string/inflections.rb`.

##### `constantize`
Метод `constantize` решает выражение, ссылающееся на константу, в его получателе:
```
"Integer".constantize # => Integer

module M
  X = 1
end
"M::X".constantize # => 1
```
Если строка вычисляет неизвестную константу, или ее содержимое даже не является валидным именем константы, `constantize` вызывает `NameError`.

Анализ имени константы с помощью `constantize` начинается всегда с верхнего уровня `Object`, даже если нет предшествующих "::".
```
X = :in_Object
module M
  X = :in_M

  X                 # => :in_M
  "::X".constantize # => :in_Object
  "X".constantize   # => :in_Object (!)
end
```
Таким образом, в общем случае это не эквивалентно тому, что Ruby сделал бы в том же месте, когда вычислял настоящую константу.

Тестовые случаи рассыльщика получают тестируемый рассыльщик из имени класса теста, используя `constantize`:
```
# action_mailer/test_case.rb
def determine_default_mailer(name)
  name.sub(/Test$/, '').constantize
rescue NameError => e
  raise NonInferrableMailerError.new(name)
end
```
> Определено в `active_support/core_ext/string/inflections.rb`.

##### `humanize`
Метод `humanize` настраивает имя атрибута для отображения конечным пользователям.

А в частности выполняет эти преобразования:
* Применяет правила словоизменения к аргументу.
* Удаляет любые предшествующие знаки подчеркивания.
* Убирает суффикс `"_id"`.
* Заменяет знаки подчеркивания пробелами.
* Переводит в нижний регистр все слова, кроме акронимов.
* Озаглавливает первое слово. 

Озаглавливание первого слова может быть выключено с помощью установки опции `:capitalize` в `false` (по умолчанию `true`).
```
"name".humanize                         # => "Name"
"author_id".humanize                    # => "Author"
"author_id".humanize(capitalize: false) # => "author"
"comments_count".humanize               # => "Comments count"
"_id".humanize                          # => "Id"
```
Если "SSL" был определен как акроним:
```
'ssl_error'.humanize # => "SSL error"
```
Метод хелпера `full_messages` использует `humanize` как резервный способ для включения имен атрибутов:
```
def full_messages
  map { |attribute, message| full_message(attribute, message) }
end

def full_message
  attr_name = attribute.to_s.tr('.', '_').humanize
  attr_name = @base.class.human_attribute_name(attribute, default: attr_name)
end
```
> Определено в `active_support/core_ext/string/inflections.rb`.

##### `foreign_key`

Метод `foreign_key` дает имя столбца внешнего ключа из имени класса. Чтобы это сделать он демодулизирует, подчеркивает и добавляет `"_id"`:
```
"User".foreign_key           # => "user_id"
"InvoiceLine".foreign_key    # => "invoice_line_id"
"Admin::Session".foreign_key # => "session_id"
```
Передайте аргумент `false`, если не хотите подчеркивание в `"_id"`:
```
"User".foreign_key(false) # => "userid"
```
Связи используют этот метод для вывода внешних ключей, например has_one и has_many делают так:
```
# active_record/associations.rb
foreign_key = options[:foreign_key] || reflection.active_record.name.foreign_key
```
> Определено в `active_support/core_ext/string/inflections.rb`.

#### Конвертирование
##### `to_date`, `to_time`, `to_datetime`
Методы `to_date`, `to_time` и `to_datetime` - в основном удобные обертки для `Date._parse`:
```
"2010-07-27".to_date              # => Tue, 27 Jul 2010
"2010-07-27 23:37:00".to_time     # => 2010-07-27 23:37:00 +0200
"2010-07-27 23:37:00".to_datetime # => Tue, 27 Jul 2010 23:37:00 +0000
```
`to_time` получает опциональный аргумент `:utc` или `:local`, для указания, время какой временной зоны необходимо:
```
"2010-07-27 23:42:00".to_time(:utc)   # => 2010-07-27 23:42:00 UTC
"2010-07-27 23:42:00".to_time(:local) # => 2010-07-27 23:42:00 +0200
```
По умолчанию `:local`.

Пожалуйста, обратитесь к документации по `Date._parse` для получения дополнительной информации.

> Все три возвратят `nil` для пустых получателей.

> Определено в `active_support/core_ext/string/conversions.rb`.

### Расширения для `Numeric` <a name="5.1.6"></a>
#### Байты
Все числа отвечают на эти методы:
```
bytes
kilobytes
megabytes
gigabytes
terabytes
petabytes
exabytes
```
Они возвращают соответствующее количество байтов, используя конвертирующий множитель 1024:
```
2.kilobytes   # => 2048
3.megabytes   # => 3145728
3.5.gigabytes # => 3758096384
-4.exabytes   # => -4611686018427387904
```
Форма в единственном числе является псевдонимом, поэтому можно написать так:
```
1.megabyte # => 1048576
```
> Определено в `active_support/core_ext/numeric/bytes.rb`.

#### Время
Включает возможность вычисления и объявления времени, подобно `45.minutes + 2.hours + 4.weeks`.

Эти методы используют `Time#advance` для точного вычисления дат с использованием `from_now`, `ago`, и т. д., а также для сложения или вычитания их результата из объекта `Time`. Например:
```
# эквивалент для Time.current.advance(months: 1)
1.month.from_now

# эквивалент для Time.current.advance(weeks: 2)
2.weeks.from_now

# эквивалент для Time.current.advance(months: 4, weeks: 5)
(4.months + 5.weeks).from_now
```
Для других длительностей, обратитесь, пожалуйста, к временному расширению для `Integer`.

> Определено в `active_support/core_ext/numeric/time.rb`

#### Форматирование
Включает форматирование чисел различными способами.

Преобразует число в строковое представление телефонного номера:
```
5551234.to_s(:phone)
# => 555-1234
1235551234.to_s(:phone)
# => 123-555-1234
1235551234.to_s(:phone, area_code: true)
# => (123) 555-1234
1235551234.to_s(:phone, delimiter: " ")
# => 123 555 1234
1235551234.to_s(:phone, area_code: true, extension: 555)
# => (123) 555-1234 x 555
1235551234.to_s(:phone, country_code: 1)
# => +1-123-555-1234
```
Преобразует число в строковое представление валюты:
```
1234567890.50.to_s(:currency)                 # => $1,234,567,890.50
1234567890.506.to_s(:currency)                # => $1,234,567,890.51
1234567890.506.to_s(:currency, precision: 3)  # => $1,234,567,890.506
```
Преобразует число в строковое представление процентов:
```
100.to_s(:percentage)
# => 100.000%
100.to_s(:percentage, precision: 0)
# => 100%
1000.to_s(:percentage, delimiter: '.', separator: ',')
# => 1.000,000%
302.24398923423.to_s(:percentage, precision: 5)
# => 302.24399%
```
Преобразует число в строковое представление числа с разделенными разрядами:
```
12345678.to_s(:delimited)                     # => 12,345,678
12345678.05.to_s(:delimited)                  # => 12,345,678.05
12345678.to_s(:delimited, delimiter: ".")     # => 12.345.678
12345678.to_s(:delimited, delimiter: ",")     # => 12,345,678
12345678.05.to_s(:delimited, separator: " ")  # => 12,345,678 05
```
Преобразует число в строковое представление числа, округленного с определенной точностью:
```
111.2345.to_s(:rounded)                     # => 111.235
111.2345.to_s(:rounded, precision: 2)       # => 111.23
13.to_s(:rounded, precision: 5)             # => 13.00000
389.32314.to_s(:rounded, precision: 0)      # => 389
111.2345.to_s(:rounded, significant: true)  # => 111
```
Преобразует число в строковое представление с удобочитаемым количеством байт:
```
123.to_s(:human_size)                  # => 123 Bytes
1234.to_s(:human_size)                 # => 1.21 KB
12345.to_s(:human_size)                # => 12.1 KB
1234567.to_s(:human_size)              # => 1.18 MB
1234567890.to_s(:human_size)           # => 1.15 GB
1234567890123.to_s(:human_size)        # => 1.12 TB
1234567890123456.to_s(:human_size)     # => 1.1 PB
1234567890123456789.to_s(:human_size)  # => 1.07 EB
```
Преобразует число в строковое представление с удобочитаемым числом слов:
```
123.to_s(:human)               # => "123"
1234.to_s(:human)              # => "1.23 Thousand"
12345.to_s(:human)             # => "12.3 Thousand"
1234567.to_s(:human)           # => "1.23 Million"
1234567890.to_s(:human)        # => "1.23 Billion"
1234567890123.to_s(:human)     # => "1.23 Trillion"
1234567890123456.to_s(:human)  # => "1.23 Quadrillion"
```
> Определено в `active_support/core_ext/numeric/conversions.rb`.

### Расширения для `Integer` <a name="5.1.6"></a>
#### `multiple_of?`
Метод `multiple_of?` проверяет, является ли целое число множителем аргумента:
```
2.multiple_of?(1) # => true
1.multiple_of?(2) # => false
```
> Определено в `active_support/core_ext/integer/multiple.rb`.

#### `ordinal`
Метод `ordinal` возвращает суффикс порядковой строки, соответствующей полученному целому числу:
```
1.ordinal    # => "st"
2.ordinal    # => "nd"
53.ordinal   # => "rd"
2009.ordinal # => "th"
-21.ordinal  # => "st"
-134.ordinal # => "th"
```
> Определено в `active_support/core_ext/integer/inflections.rb`.

#### `ordinalize`
Метод ordinalize возвращает порядковую строку, соответствующую полученному целому числу. Для сравнения отметьте, что метод `ordinal` возвращает только строковый суффикс.
```
1.ordinalize    # => "1st"
2.ordinalize    # => "2nd"
53.ordinalize   # => "53rd"
2009.ordinalize # => "2009th"
-21.ordinalize  # => "-21st"
-134.ordinalize # => "-134th"
```
> Определено в `active_support/core_ext/integer/inflections.rb`.

#### Время
Включает возможность вычисления и объявления времени, подобно `4.months + 5.years`.

Эти методы используют `Time#advance` для точного вычисления дат с использованием `from_now`, `ago`, и т. д., а также для сложения или вычитания их результата из объекта `Time`. Например:
```
# эквивалент для Time.current.advance(months: 1)
1.month.from_now

# эквивалент для Time.current.advance(years: 2)
2.years.from_now

# эквивалент для Time.current.advance(months: 4, years: 5)
(4.months + 5.years).from_now
```
Для других длительностей, обратитесь, пожалуйста, к временному расширению для `Numeric`.

> Определено в `active_support/core_ext/integer/time.rb`.

### Расширения для `BigDecimal` <a name="5.1.8"></a>
#### `to_s`
Метод to_s предоставляет спецификатор по умолчанию для "F". Это означает, что простой вызов `to_s` приведет к представлению с плавающей запятой вместо инженерной нотации:
```
BigDecimal(5.00, 6).to_s       # => "5.0"
```
а также поддерживаются эти спецификаторы символа:
```
BigDecimal(5.00, 6).to_s(:db)  # => "5.0"
```
Инженерная нотация все еще поддерживается:
```
BigDecimal(5.00, 6).to_s("e")  # => "0.5E1"
```

### Расширения для `Enumerable` <a name="5.1.9"></a>
#### `sum`
Метод `sum` складывает элементы перечисления:
```
[1, 2, 3].sum # => 6
(1..100).sum  # => 5050
```
Сложение применяется только к элементам, откликающимся на `+`:
```
[[1, 2], [2, 3], [3, 4]].sum    # => [1, 2, 2, 3, 3, 4]
%w(foo bar baz).sum             # => "foobarbaz"
{a: 1, b: 2, c: 3}.sum          # => [:b, 2, :c, 3, :a, 1]
```
Сумма пустой коллекции равна нулю по умолчанию, но это может быть настроено:
```
[].sum    # => 0
[].sum(1) # => 1
```
Если задан блок, `sum` становится итератором, вкладывающим элементы коллекции и суммирующим возвращаемые значения:
```
(1..5).sum {|n| n * 2 } # => 30
[2, 4, 6, 8, 10].sum    # => 30
```
Сумма пустого получателя также может быть настроена в такой форме:
```
[].sum(1) {|n| n**3} # => 1
```
> Определено в `active_support/core_ext/enumerable.rb`.

#### `index_by`
Метод `index_by` генерирует хэш с элементами перечисления, индексированными по некоторому ключу.

Он перебирает коллекцию и передает каждый элемент в блок. Значение, возвращенное блоком, будет ключом для элемента:
```
invoices.index_by(&:number)
# => {'2009-032' => <Invoice ...>, '2009-008' => <Invoice ...>, ...}
```
Ключи, как правило, должны быть уникальными. Если блок возвратит одно и то же значение для нескольких элементов, для этого ключа не будет построена коллекция. А значение получит последний элемент.

> Определено в `active_support/core_ext/enumerable.rb`.

#### `index_with`
Метод `index_with` генерирует хэш с элементами перечисления в качестве ключей. Значение является либо переданным по умолчанию, либо возвращенным в блоке.
```
%i( title body created_at ).index_with { |attr_name| post.public_send(attr_name) }
# => { title: "hey", body: "what's up?", … }

WEEKDAYS.index_with([Interval.all_day])
# => { monday: [ 0, 1440 ], … }
```
> Определено в `active_support/core_ext/enumerable.rb`.

#### `many?`
Метод `many?` это сокращение для `collection.size > 1`:
```
<% if pages.many? %>
  <%= pagination_links %>
<% end %>
```
Если задан опциональный блок, `many?` учитывает только те элементы, которые возвращают `true`:
```
@see_more = videos.many? {|video| video.category == params[:category]}
```
> Определено в `active_support/core_ext/enumerable.rb`.

#### `exclude?`
Предикат `exclude?` проверяет, является ли заданный объект не принадлежащим коллекции. Это противоположность встроенного `include?`:
```
to_visit << node if visited.exclude?(node)
```
> Определено в `active_support/core_ext/enumerable.rb`.

#### `without`
Метод `without` возвращает копию перечисления без указанных элементов:
```
["David", "Rafael", "Aaron", "Todd"].without("Aaron", "Todd") # => ["David", "Rafael"]
```
> Определено в `active_support/core_ext/enumerable.rb`.

#### `pluck`

Метод `pluck` возвращает массив на основе заданного ключа:
```
[{ name: "David" }, { name: "Rafael" }, { name: "Aaron" }].pluck(:name) # => ["David", "Rafael", "Aaron"]
```
> Определено в `active_support/core_ext/enumerable.rb`.

### Расширения для Array <a name="5.1.10"></a>
#### Доступ
Active Support расширяет API массивов для облегчения нескольких способов доступа к ним. Например, `to` возвращает подмассив элементов от первого до переданного индекса:
```
%w(a b c d).to(2) # => ["a", "b", "c"]
[].to(7)          # => []
```
По аналогии, from возвращает хвост массива, количество элементов которого равно переданному индексу. Если индекс больше длины массива, возвращается пустой массив.
```
%w(a b c d).from(2)  # => ["c", "d"]
%w(a b c d).from(10) # => []
[].from(0)           # => []
```
Методы second, `third`, `fourth` и `fifth` возвращают соответствующие элементы, так же как `second_to_last` и `third_to_last` (`first` и `last` являются встроенными). Благодаря социальной мудрости и всеобщей позитивной конструктивности, `forty_two` также доступен.
```
%w(a b c d).third # => "c"
%w(a b c d).fifth # => nil
```
> Определено в `active_support/core_ext/array/access.rb`.

#### Добавление элементов
##### `prepend`

Этот метод - псевдоним `Array#unshift`.
```
%w(a b c d).prepend('e')  # => ["e", "a", "b", "c", "d"]
[].prepend(10)            # => [10]
```
> Определено в `active_support/core_ext/array/prepend_and_append.rb`.

##### `append`
Этот метод - псевдоним `Array#<<`.
```
%w(a b c d).append('e')  # => ["a", "b", "c", "d", "e"]
[].append([1,2])         # => [[1, 2]]
```
> Определено в `active_support/core_ext/array/prepend_and_append.rb`.

#### Извлечение
Метод `extract!` убирает и возвращает элементы, для которых блок возвращает истинное значение. Если блок не задан, вместо этого возвратиться `Enumerator`.
```
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
odd_numbers = numbers.extract! { |number| number.odd? } # => [1, 3, 5, 7, 9]
numbers # => [0, 2, 4, 6, 8]
```
> Определено в `active_support/core_ext/array/extract.rb`.

#### Извлечение опций
Когда последний аргумент в вызове метода является хэшем, за исключением, пожалуй, аргумента `&block`, Ruby позволяет опустить скобки:
```
User.exists?(email: params[:email])
```
Этот синтаксический сахар часто используется в Rails для избежания позиционных аргументов там, где их не слишком много, предлагая вместо них интерфейсы, эмулирующие именованные параметры. В частности, очень характерно использовать такой хэш для опций.

Если метод ожидает различное количество аргументов и использует `*` в своем объявлении, однако хэш опций завершает их и является последним элементом массива аргументов, тогда тип теряет свою роль.

В этих случаях можно задать хэшу опций отличительную трактовку с помощью `extract_options!`. Метод проверяет тип последнего элемента массива. Если это хэш, он вырезает его и возвращает, в противном случае возвращает пустой хэш.

Давайте рассмотрим пример определения макроса контроллера `caches_action`:
```
def caches_action(*actions)
  return unless cache_configured?
  options = actions.extract_options!
  ...
end
```
Этот метод получает произвольное число имен экшнов и опциональный хэш опций как последний аргумент. Вызвав `extract_options!`, получаем хэш опций и убираем его из actions простым и явным способом.

> Определено в `active_support/core_ext/array/extract_options.rb`.

#### Конвертирование
##### `to_sentence`
Метод `to_sentence` превращает массив в строку, содержащую предложение, в котором перечисляются элементы массива:
```
%w().to_sentence                # => ""
%w(Earth).to_sentence           # => "Earth"
%w(Earth Wind).to_sentence      # => "Earth and Wind"
%w(Earth Wind Fire).to_sentence # => "Earth, Wind, and Fire"
```
Этот метод принимает три опции:
* `:two_words_connector`: Что используется для массивов с длиной 2. По умолчанию " and ".
* `:words_connector`: Что используется для соединения элементов массивов с 3 и более элементами, кроме последних двух. По умолчанию ", ".
* `:last_word_connector`: Что используется для соединения последних элементов массива из 3 и более элементов. По умолчанию ", and ". 

По умолчанию эти опции могут быть локализованы, их ключи следующие:
| Опция | Ключ I18n | 
| `:two_words_connector` | `support.array.two_words_connector` |
| `:words_connector` | `support.array.words_connector` |
| `:last_word_connector` | `support.array.last_word_connector` |

> Определено в `active_support/core_ext/array/conversions.rb`.

##### `to_formatted_s`
Метод `to_formatted_s` по умолчанию работает как `to_s`.

Однако, если массив содержит элементы, откликающиеся на `id`, как аргумент можно передать символ `:db`. Это обычно используется с коллекциями объектов Active Record. Возвращаемые строки следующие:
```
[].to_formatted_s(:db)            # => "null"
[user].to_formatted_s(:db)        # => "8456"
invoice.lines.to_formatted_s(:db) # => "23,567,556,12"
```
Целые числа в примере выше предполагается, что приходят от соответствующих вызовов `id`.

> Определено в `active_support/core_ext/array/conversions.rb`.

##### `to_xml`
Метод `to_xml` возвращает строку, содержащую представление XML его получателя:
```
Contributor.limit(2).order(:rank).to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <contributors type="array">
#   <contributor>
#     <id type="integer">4356</id>
#     <name>Jeremy Kemper</name>
#     <rank type="integer">1</rank>
#     <url-id>jeremy-kemper</url-id>
#   </contributor>
#   <contributor>
#     <id type="integer">4404</id>
#     <name>David Heinemeier Hansson</name>
#     <rank type="integer">2</rank>
#     <url-id>david-heinemeier-hansson</url-id>
#   </contributor>
# </contributors>
```
Чтобы это сделать, он посылает `to_xml` к каждому элементу за раз и собирает результаты в корневом узле. Все элементы должны откликаться на `to_xml`, иначе будет вызвано исключение.

По умолчанию имя корневого элемента - это подчеркнутое и `dasherize` имя класса первого элемента во множественном числе, при условии что остальные элементы принадлежат этому типу (проверяется с помощью `is_a?`) и они не являются хэшами. В примере выше это "contributors".

Если есть какой-либо элемент, не принадлежащий типу первого, корневой узел становится "objects":
```
[Contributor.first, Commit.first].to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <objects type="array">
#   <object>
#     <id type="integer">4583</id>
#     <name>Aaron Batalion</name>
#     <rank type="integer">53</rank>
#     <url-id>aaron-batalion</url-id>
#   </object>
#   <object>
#     <author>Joshua Peek</author>
#     <authored-timestamp type="datetime">2009-09-02T16:44:36Z</authored-timestamp>
#     <branch>origin/master</branch>
#     <committed-timestamp type="datetime">2009-09-02T16:44:36Z</committed-timestamp>
#     <committer>Joshua Peek</committer>
#     <git-show nil="true"></git-show>
#     <id type="integer">190316</id>
#     <imported-from-svn type="boolean">false</imported-from-svn>
#     <message>Kill AMo observing wrap_with_notifications since ARes was only using it</message>
#     <sha1>723a47bfb3708f968821bc969a9a3fc873a3ed58</sha1>
#   </object>
# </objects>
```
Если получатель является массивом хэшей, корневой элемент по умолчанию также "objects":
```
[{a: 1, b: 2}, {c: 3}].to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <objects type="array">
#   <object>
#     <b type="integer">2</b>
#     <a type="integer">1</a>
#   </object>
#   <object>
#     <c type="integer">3</c>
#   </object>
# </objects>
```
> Если коллекция пустая, корневой элемент по умолчанию "nil-classes". Пример для понимания, корневой элемент вышеописанного списка вкладчиков будет не "contributors", если коллекция пустая, а "nil-classes". Можно использовать опцию `:root` для обеспечения согласованного корневого элемента.

Имя дочерних узлов по умолчанию является именем корневого узла в единственном числе. В вышеприведенных примерах мы видели "contributor" и "object". Опция `:children` позволяет установить эти имена узлов.

По умолчанию билдер XML является свежим экземпляром `Builder::XmlMarkup`. Можно сконфигурировать свой собственный билдер через опцию `:builder`. Метод также принимает опции, такие как `:dasherize` и ему подобные, они перенаправляются в билдер:
```
Contributor.limit(2).order(:rank).to_xml(skip_types: true)
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <contributors>
#   <contributor>
#     <id>4356</id>
#     <name>Jeremy Kemper</name>
#     <rank>1</rank>
#     <url-id>jeremy-kemper</url-id>
#   </contributor>
#   <contributor>
#     <id>4404</id>
#     <name>David Heinemeier Hansson</name>
#     <rank>2</rank>
#     <url-id>david-heinemeier-hansson</url-id>
#   </contributor>
# </contributors>
```
> Определено в `active_support/core_ext/array/conversions.rb`.

#### Оборачивание
Метод `Array.wrap` оборачивает свои аргументы в массив, кроме случая когда это уже массив (или массивоподобные).

А именно:
* Если аргумент `nil`, возвращается пустой массив.
* В противном случае, если аргумент откликается на `to_ary`, он вызывается, и, если значение `to_ary` не `nil`, оно возвращается.
* В противном случае, возвращается массив с аргументом в качестве его первого элемента. 
```
Array.wrap(nil)       # => []
Array.wrap([1, 2, 3]) # => [1, 2, 3]
Array.wrap(0)         # => [0]
```
Этот метод похож на `Kernel#Array`, но с некоторыми отличиями:
* Если аргумент откликается на `to_ary`, метод вызывается. `Kernel#Array` начинает пробовать `to_a`, если вернувшееся значение `nil`, а `Arraw.wrap` сразу возвращает массив с аргументом в качестве единственного элемента.
* Если возвращаемое значение от `to_ary` и не `nil`, и не объект `Array`, то `Kernel#Array` вызывает исключение, в то время как `Array.wrap` нет, он просто возвращает значение.
* Он не вызывает `to_a` на аргументе, если аргумент не откликается на `to_ary`, а возвращает массив с аргументом в качестве своего единственного элемента. 

Последний пункт особенно заметен для некоторых перечислений:
```
Array.wrap(foo: :bar) # => [{:foo=>:bar}]
Array(foo: :bar)      # => [[:foo, :bar]]
```
Также имеется связанная идиома, использующая оператор расплющивания:
```
[*object]
```
который в Ruby 1.8 возвращает `[nil]` для `nil`, а в противном случае вызывает `Array(object)`. (Точное поведение в 1.9 пока непонятно)

Таким образом, в этом случае поведение различается для `nil`, а описанные выше различия с `Kernel#Array` применяются к остальным `object`.

> Определено в `active_support/core_ext/array/wrap.rb`.

#### Дублирование

Метод `Array#deep_dup` дублирует себя и все объекты внутри рекурсивно с помощью метода Active Support `Object#deep_dup`. Он работает так же, как `Array#map`, посылая метод `deep_dup` для каждого объекта внутри.
```
array = [1, [2, 3]]
dup = array.deep_dup
dup[1][2] = 4
array[1][2] == nil   # => true
```
> Определено в `active_support/core_ext/object/deep_dup.rb`.

#### Группировка
##### `in_groups_of(number, fill_with = nil)`
Метод `in_groups_of` разделяет массив на последовательные группы определенного размера. Он возвращает массив с группами:
```
[1, 2, 3].in_groups_of(2) # => [[1, 2], [3, nil]]
```
или выдает их по очереди, если передается блок:
```
<% sample.in_groups_of(3) do |a, b, c| %>
  <tr>
    <td><%= a %></td>
    <td><%= b %></td>
    <td><%= c %></td>
  </tr>
<% end %>
```
Первый пример показывает, как `in_groups_of` заполняет последнюю группу столькими элементами `nil`, сколько нужно, чтобы получить требуемый размер. Можно изменить это набивочное значение используя второй опциональный аргумент:
```
[1, 2, 3].in_groups_of(2, 0) # => [[1, 2], [3, 0]]
```
Наконец, можно сказать методу не заполнять последнюю группу, передав `false`:
```
[1, 2, 3].in_groups_of(2, false) # => [[1, 2], [3]]
```
Как следствие `false` не может использоваться как набивочное значение.

> Определено в `active_support/core_ext/array/grouping.rb`.

##### `in_groups(number, fill_with = nil)`
Метод `in_groups` разделяет массив на определенное количество групп. Метод возвращает массив с группами:
```
%w(1 2 3 4 5 6 7).in_groups(3)
# => [["1", "2", "3"], ["4", "5", nil], ["6", "7", nil]]
```
или выдает их по очереди, если передается блок:
```
%w(1 2 3 4 5 6 7).in_groups(3) {|group| p group}
["1", "2", "3"]
["4", "5", nil]
["6", "7", nil]
```
Примеры выше показывают, что `in_groups` заполняет некоторые группы с помощью заключительного элемента `nil`, если необходимо. Группа может получить не более одного из этих дополнительных элементов, самый правый, если таковой имеется. И группы, получившие его, будут всегда последние.

Можно изменить это набивочное значение, используя второй опциональный аргумент:
```
%w(1 2 3 4 5 6 7).in_groups(3, "0")
# => [["1", "2", "3"], ["4", "5", "0"], ["6", "7", "0"]]
```
Также можно сказать методу не заполнять меньшие группы, передав `false`:
```
%w(1 2 3 4 5 6 7).in_groups(3, false)
# => [["1", "2", "3"], ["4", "5"], ["6", "7"]]
```
Как следствие, `false` не может быть набивочным значением.

> Определено в `active_support/core_ext/array/grouping.rb`.

##### `split(value = nil)`
Метод `split` разделяет массив разделителем и возвращает получившиеся куски.

Если передан блок, разделителями будут те элементы массива, для которых блок возвращает `true`:
```
(-5..5).to_a.split { |i| i.multiple_of?(4) }
# => [[-5], [-3, -2, -1], [1, 2, 3], [5]]
```
В противном случае, значение, полученное как аргумент, которое по умолчанию является `nil`, будет разделителем:
```
[0, 1, -5, 1, 1, "foo", "bar"].split(1)
# => [[0], [-5], [], ["foo", "bar"]]
```
Отметьте, в предыдущем примере, что последовательные разделители приводят к пустым массивам.

> Определено в `active_support/core_ext/array/grouping.rb`.

### Расширения для `Hash` <a name="5.1.11"></a>
#### Конверсия
##### `to_xml`
Метод `to_xml` возвращает строку, содержащую представление XML его получателя:
```
{"foo" => 1, "bar" => 2}.to_xml
# =>
# <?xml version="1.0" encoding="UTF-8"?>
# <hash>
#   <foo type="integer">1</foo>
#   <bar type="integer">2</bar>
# </hash>
```
Чтобы это сделать, метод в цикле проходит пары и создает узлы, зависимые от `value`. Для заданной пары `key`, `value`:
* Если `value` - хэш, происходит рекурсивный вызов с `key` как `:root`.
* Если `value` - массив, происходит рекурсивный вызов с `key` как `:root`, и `key` в единственном числе как `:children`.
* Если `value` - вызываемый объект, он должен ожидать один или два аргумента. В зависимости от ситуации, вызываемый объект вызывается с помощью хэша `options` в качестве первого аргумента с `key` как `:root`, и `key` в единственном числе в качестве второго аргумента. Возвращенное значение становится новым узлом.
* Если `value` откликается на `to_xml`, метод вызывается с `key` как `:root`.
* В иных случаях, узел с `key` в качестве тега создается со строковым представлением `value` в качестве текстового узла. Если `value` является `nil`, добавляется атрибут "nil", установленный в "true". Кроме случаев, когда существует опция `:skip_types` со значением `true`, добавляется атрибут "type", соответствующий следующему преобразованию: 
```
XML_TYPE_NAMES = {
  "Symbol"     => "symbol",
  "Integer"    => "integer",
  "BigDecimal" => "decimal",
  "Float"      => "float",
  "TrueClass"  => "boolean",
  "FalseClass" => "boolean",
  "Date"       => "date",
  "DateTime"   => "datetime",
  "Time"       => "datetime"
}
```
По умолчанию корневой узел является "hash", но это настраивается с помощью опции `:root`.

По умолчанию билдер XML является новым экземпляром `Builder::XmlMarkup`. Можно настроить свой собственный билдер с помощью опции `:builder`. Метод также принимает опции, такие как `:dasherize` и ему подобные, они направляются в билдер.

> Определено в `active_support/core_ext/hash/conversions.rb`.

#### Объединение
В Ruby имеется встроенный метод `Hash#merge`, который позволяет объединять два хэша:
```
{a: 1, b: 1}.merge(a: 0, c: 2)
# => {:a=>0, :b=>1, :c=>2}
```
Active Support определяет еще несколько способов объединения хэшей, которые могут быть полезными.

##### `reverse_merge` и `reverse_merge!`
В случае коллизии, в `merge` остается ключ в хэше аргумента. Можно компактно предоставить хэш-опцию со значениями по умолчанию с помощью такой идиомы:
```
options = {length: 30, omission: "..."}.merge(options)
```
Active Support определяет `reverse_merge` в случае, если нужна альтернативная запись:
```
options = options.reverse_merge(length: 30, omission: "...")
```
И вариант с восклицательным знаком `reverse_merge!`, который выполняет объединение, модифицируя на месте:
```
options.reverse_merge!(length: 30, omission: "...")
```
> Обратите внимание, что `reverse_merge!` может изменить хэш в вызывающем методе, что может как быть, так и не быть хорошей идеей.

> Определено в `active_support/core_ext/hash/reverse_merge.rb`.

##### `reverse_update`
Метод `reverse_update` это псевдоним для `reverse_merge!`, описанного выше.

> Отметьте, что у `reverse_update` нет варианта с восклицательным знаком.

> Определено в `active_support/core_ext/hash/reverse_merge.rb`.

##### `deep_merge` и `deep_merge!`
Как можно было видеть в предыдущем примере, если ключ обнаруживается в обоих хэшах, выбирается значение первого из аргументов.

Active Support определяет `Hash#deep_merge`. В углубленном объединении, если один и тот же ключ обнаруживается в обоих хэшах, и их значения также хэши, то в результирующем хэше будет объединение их значений.
```
{a: {b: 1}}.deep_merge(a: {c: 2})
# => {:a=>{:b=>1, :c=>2}}
```
Метод `deep_merge!` выполняет углубленное объединение, модифицируя на месте:

> Определено в `active_support/core_ext/hash/deep_merge.rb`.

#### Глубокое дублирование
Метод `Hash#deep_dup` дублирует себя, а также все ключи и значения внутри, рекурсивно с помощью метода Active Support `Object#deep_dup`. Он работает так же, как `Enumerator#each_with_object`, посылая метод `deep_dup` в каждую пару внутри.
```
hash = { a: 1, b: { c: 2, d: [3, 4] } }

dup = hash.deep_dup
dup[:b][:e] = 5
dup[:b][:d] << 5

hash[:b][:e] == nil      # => true
hash[:b][:d] == [3, 4]   # => true
```
> Определено в `active_support/core_ext/object/deep_dup.rb`.

#### Работа с ключами
##### `except` и `except!`
Метод `except` возвращает хэш с убранными ключами, содержащимися в перечне аргументов, если они существуют:
```
{a: 1, b: 2}.except(:a) # => {:b=>2}
```
Если получатель откликается на `convert_key`, метод вызывается на каждом из аргументов. Это позволяет `except` хорошо обращаться с хэшами с индифферентным доступом, например:
```
{a: 1}.with_indifferent_access.except(:a)  # => {}
{a: 1}.with_indifferent_access.except("a") # => {}
```
Также имеется вариант с восклицательным знаком `except!`, который убирает ключи в самом получателе.

> Определено в `active_support/core_ext/hash/except.rb`.

##### `transform_keys` и `transform_keys!`
Метод `transform_keys` принимает блок и возвращает хэш, в котором к каждому из ключей получателя были применены операции в блоке:
```
{nil => nil, 1 => 1, a: :a}.transform_keys { |key| key.to_s.upcase }
# => {"" => nil, "1" => 1, "A" => :a}
```
В случае коллизии будет выбрано одно из значений. Выбранное значение не всегда будет одинаковым для одного и того же хэша:
```
{"a" => 1, a: 2}.transform_keys { |key| key.to_s.upcase }
# Результатом будет или
# => {"A"=>2}
# или
# => {"A"=>1}
```
Этот метод может помочь, к примеру, при создании специальных преобразований. Например, `stringify_keys` и `symbolize_keys` используют `transform_keys` для выполнения преобразований ключей:
```
def stringify_keys
  transform_keys { |key| key.to_s }
end
...
def symbolize_keys
  transform_keys { |key| key.to_sym rescue key }
end
```
Также имеется вариант с восклицательным знаком `transform_keys!`, применяющий операции в блоке к ключам в самом получателе.

Кроме этого, можно использовать `deep_transform_keys` и `deep_transform_keys!` для выполнения операции в блоке ко всем ключам в заданном хэше и всех хэшах, вложенных в него. Пример результата:
```
{nil => nil, 1 => 1, nested: {a: 3, 5 => 5}}.deep_transform_keys { |key| key.to_s.upcase }
# => {""=>nil, "1"=>1, "NESTED"=>{"A"=>3, "5"=>5}}
```
> Определено в `active_support/core_ext/hash/keys.rb`.

##### `stringify_keys` и `stringify_keys!`
Метод `stringify_keys` возвращает хэш, в котором ключи получателя преобразованы в строку. Это выполняется с помощью применения к ним `to_s`:
```
{nil => nil, 1 => 1, a: :a}.stringify_keys
# => {"" => nil, "1" => 1, "a" => :a}
```
В случае коллизии ключей будет выбрано одно из значений. Выбранное значение не всегда будет одинаковым для одного и того же хэша:
```
{"a" => 1, a: 2}.stringify_keys
# Результатом будет или
# => {"a"=>2}
# или
# => {"a"=>1}
```
Метод может быть полезным, к примеру, для простого принятия и символов, и строк как опций. Например, `ActionView::Helpers::FormHelper` определяет:
```
def to_check_box_tag(options = {}, checked_value = "1", unchecked_value = "0")
  options = options.stringify_keys
  options["type"] = "checkbox"
  ...
end
```
Вторая строчка может безопасно обратиться к ключу "type" и позволить пользователю передавать или `:type`, или "type".

Также имеется вариант с восклицательным знаком `stringify_keys!`, который преобразует к строке ключи в самом получателе.

Кроме этого, можно использовать `deep_stringify_keys` и `deep_stringify_keys!` для преобразования к строке всех ключей в заданном хэше и всех хэшей, вложенных в него. Пример результата:
```
{nil => nil, 1 => 1, nested: {a: 3, 5 => 5}}.deep_stringify_keys
# => {""=>nil, "1"=>1, "nested"=>{"a"=>3, "5"=>5}}
```
> Определено в `active_support/core_ext/hash/keys.rb`

##### `symbolize_keys` и `symbolize_keys!`
Метод `symbolize_keys` возвращает хэш, в котором ключи получателя преобразованы к символам там, где это возможно. Это выполняется с помощью применения к ним `to_sym`:
```
{nil => nil, 1 => 1, "a" => "a"}.symbolize_keys
# => {nil=>nil, 1=>1, :a=>"a"}
```
Отметьте в предыдущем примере, что только один ключ был преобразован к символу.

В случае коллизии ключей будет выбрано одно из значений. Выбранное значение не всегда будет одинаковым для одного и того же хэша:
```
{"a" => 1, a: 2}.symbolize_keys
# Результатом будет или
# => {:a=>2}
# или
# => {:a=>1}
```
Метод может быть полезным, к примеру, для простого принятия и символов, и строк как опций. Например, `ActionController::UrlRewriter` определяет
```
def rewrite_path(options)
  options = options.symbolize_keys
  options.update(options[:params].symbolize_keys) if options[:params]
  ...
end
```
Вторая строчка может безопасно обратиться к ключу `:params` и позволить пользователю передавать или `:params`, или "params".

Также имеется вариант с восклицательным знаком `symbolize_keys!`, который приводит к символу ключи в самом получателе.

Кроме этого, можно использовать `deep_symbolize_keys` и `deep_symbolize_keys!` для преобразования к символам всех ключей в заданном хэше и всех хэшей, вложенных в него. Пример результата:
```
{nil => nil, 1 => 1, "nested" => {"a" => 3, 5 => 5}}.deep_symbolize_keys
# => {nil=>nil, 1=>1, nested:{a:3, 5=>5}}
```
> Определено в `active_support/core_ext/hash/keys.rb`.

##### `to_options` и `to_options!`
Методы `to_options` и `to_options!` являются псевдонимами `symbolize_keys` и `symbolize_keys!` соответственно.

> Определено в `active_support/core_ext/hash/keys.rb`.

##### `assert_valid_keys`
Метод `assert_valid_keys` получает определенное число аргументов и проверяет, имеет ли получатель хоть один ключ вне этого белого списка. Если имеет, вызывается `ArgumentError`.
```
{a: 1}.assert_valid_keys(:a)  # passes
{a: 1}.assert_valid_keys("a") # ArgumentError
```
Active Record не принимает незнакомые опции при создании связей, к примеру. Он реализует такой контроль через `assert_valid_keys`.

> Определено в `active_support/core_ext/hash/keys.rb`.

#### Нарезка
В Ruby есть встроенная поддержка для нарезки строк или массивов. Active Support расширяет нарезку на хэши:
```
{a: 1, b: 2, c: 3}.slice(:a, :c)
# => {:a=>1, :c=>3}

{a: 1, b: 2, c: 3}.slice(:b, :X)
# => {:b=>2} # несуществующие ключи игнорируются
```
Если получатель откликается на `convert_key`, ключи нормализуются:
```
{a: 1, b: 2}.with_indifferent_access.slice("a")
# => {:a=>1}
```
Нарезка может быть полезной для экранизации хэш-опции с помощью белого списка ключей.

Также есть `slice!`, который выполняет нарезку, модифицируя на месте, и возвращает что было убрано:
```
hash = {a: 1, b: 2}
rest = hash.slice!(:a) # => {:b=>2}
hash                   # => {:a=>1}
```
> Определено в `active_support/core_ext/hash/slice.rb`.

#### Извлечение
Метод `extract!` убирает и возвращает пары ключ/значение, соответствующие заданным ключам.
```
hash = {:a => 1, :b => 2}
rest = hash.extract!(:a) # => {:a=>1}
hash                     # => {:b=>2}
```
Метод `extract!` возвращает тот же подкласс `Hash`, каким является получатель.
```
hash = {a: 1, b: 2}.with_indifferent_access
rest = hash.extract!(:a).class
# => ActiveSupport::HashWithIndifferentAccess
```
> Определено в `active_support/core_ext/hash/slice.rb`.

#### Индифферентный доступ
Метод `with_indifferent_access` возвращает `ActiveSupport::HashWithIndifferentAccess` из своего получателя:
```
{a: 1}.with_indifferent_access["a"] # => 1
```
> Определено в `active_support/core_ext/hash/indifferent_access.rb`.

### Расширения для `Regexp` <a name="5.1.12"></a>
#### `multiline?`
Метод `multiline?` говорит, имеет ли регулярное выражение установленный флаг `/m`, то есть соответствует ли точка новым строкам.
```
%r{.}.multiline?  # => false
%r{.}m.multiline? # => true

Regexp.new('.').multiline?                    # => false
Regexp.new('.', Regexp::MULTILINE).multiline? # => true
```
Rails использует этот метод в одном месте, в коде маршрутизации. Регулярные выражения `Multiline` недопустимы для маршрутных требований, и этот флаг облегчает соблюдение этого ограничения.
```
def assign_route_options(segments, defaults, requirements)
  ...
  if requirement.multiline?
    raise ArgumentError, "Regexp multiline option not allowed in routing requirements: #{requirement.inspect}"
  end
  ...
end
```
> Определено в `active_support/core_ext/regexp.rb`.

### Расширения для Range <a name="5.1.13"></a>
#### `to_s`
Active Support расширяет метод `Range#to_s` так, что он понимает опциональный аргумент формата. В настоящий момент имеется только один поддерживаемый формат, отличный от дефолтного, это `:db`:
```
(Date.today..Date.tomorrow).to_s
# => "2009-10-25..2009-10-26"

(Date.today..Date.tomorrow).to_s(:db)
# => "BETWEEN '2009-10-25' AND '2009-10-26'"
```
Как изображено в примере, формат `:db` генерирует SQL условие `BETWEEN`. Это используется Active Record в поддержке значений интервала в условиях.

> Определено в `active_support/core_ext/range/conversions.rb`.

#### `===`, `include?` и `cover?`
Методы `Range#===`, `Range#include?` и `Range#cover?` сообщают, лежит ли некоторое значение между концами заданного экземпляра:
```
(2..3).include?(Math::E) # => true
```
Active Support расширяет эти методы так, что аргумент, в свою очередь, может быть другим интервалом. В этом случае проверяется, принадлежат ли концы интервала аргументов самому получателю:
```
(1..10) === (3..7)  # => true
(1..10) === (0..7)  # => false
(1..10) === (3..11) # => false
(1...9) === (3..9)  # => false

(1..10).include?(3..7)  # => true
(1..10).include?(0..7)  # => false
(1..10).include?(3..11) # => false
(1...9).include?(3..9)  # => false

(1..10).cover?(3..7)  # => true
(1..10).cover?(0..7)  # => false
(1..10).cover?(3..11) # => false
(1...9).cover?(3..9)  # => false
```
> Определено в `active_support/core_ext/range/compare_range.rb`.

#### `overlaps?`
Метод `Range#overlaps?` говорит, имеют ли два заданных интервала непустое пересечение:
```
(1..10).overlaps?(7..11)  # => true
(1..10).overlaps?(0..7)   # => true
(1..10).overlaps?(11..27) # => false
```
> Определено в `active_support/core_ext/range/overlaps.rb`.

### Расширения для Date <a name="5.1.14"></a>
#### Вычисления
> Следующие методы вычисления имеют временную пропасть в октябре 1582 года, когда дней с 5 по 14 (включительно) просто не существовало. Это руководство не документирует свое поведение в те дни для краткости, но достаточно сказать, будет происходит то, что от них ожидается. То есть, `Date.new(1582, 10, 4).tomorrow` возвратит `Date.new(1582, 10, 15)`, и так далее. Пожалуйста, проверьте `test/core_ext/date_ext_test.rb` в тестовом наборе Active Support, чтобы понять ожидаемое поведение.

##### `Date.current`
Active Support определяет `Date.current` как сегодняшний день в текущей временной зоне. Он похож на `Date.today`, за исключением того, что он учитывает временную зону пользователя, если она определена. Он также определяет `Date.yesterday` и `Date.tomorrow`, и предикаты экземпляра `past?`, `today?`, `future?`, `on_weekday?` и `on_weekend?`, все они зависят от `Date.current`.

> Определено в `active_support/core_ext/date/calculations.rb`.

##### Именованные даты
###### `beginning_of_week`, `end_of_week`
Методы `beginning_of_week` и `end_of_week` возвращают даты начала и конца недели соответственно. Предполагается, что неделя начинается с понедельника, но это может быть изменено переданным аргументом, установив локально для треда `Date.beginning_of_week` или `config.beginning_of_week`.
```
d = Date.new(2010, 5, 8)     # => Sat, 08 May 2010
d.beginning_of_week          # => Mon, 03 May 2010
d.beginning_of_week(:sunday) # => Sun, 02 May 2010
d.end_of_week                # => Sun, 09 May 2010
d.end_of_week(:sunday)       # => Sat, 08 May 2010
```
У `beginning_of_week` есть псевдоним `at_beginning_of_week`, а у `end_of_week` есть псевдоним `at_end_of_week`.

> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

###### `monday`, `sunday`
Методы `monday` и `sunday` возвращают даты предыдущего понедельника или следующего воскресенья соответственно.
```
d = Date.new(2010, 5, 8)     # => Sat, 08 May 2010
d.monday                     # => Mon, 03 May 2010
d.sunday                     # => Sun, 09 May 2010

d = Date.new(2012, 9, 10)    # => Mon, 10 Sep 2012
d.monday                     # => Mon, 10 Sep 2012

d = Date.new(2012, 9, 16)    # => Sun, 16 Sep 2012
d.sunday                     # => Sun, 16 Sep 2012
```
> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

###### prev_week, next_week
`next_week` принимает символ с днем недели на английском (по умолчанию локально для треда `Date.beginning_of_week` или `config.beginning_of_week`, или `:monday`) и возвращает дату, соответствующую этому дню на следующей неделе:
```
d = Date.new(2010, 5, 9) # => Sun, 09 May 2010
d.next_week              # => Mon, 10 May 2010
d.next_week(:saturday)   # => Sat, 15 May 2010
```
`prev_week` работает аналогично:
```
d.prev_week              # => Mon, 26 Apr 2010
d.prev_week(:saturday)   # => Sat, 01 May 2010
d.prev_week(:friday)     # => Fri, 30 Apr 2010
```
У `prev_week` есть псевдоним `last_week`.

И `next_week`, и `prev_week` работают так, как нужно, когда установлен `Date.beginning_of_week` или `config.beginning_of_week`.

> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

###### `beginning_of_month`, `end_of_month`
Методы `beginning_of_month` и `end_of_month` возвращают даты начала и конца месяца:
```
d = Date.new(2010, 5, 9) # => Sun, 09 May 2010
d.beginning_of_month     # => Sat, 01 May 2010
d.end_of_month           # => Mon, 31 May 2010
```
У `beginning_of_month` есть псевдоним `at_beginning_of_month`, а у `end_of_month` есть псевдоним `at_end_of_month`.

> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

###### `beginning_of_quarter`, `end_of_quarter`
Методы `beginning_of_quarter` и `end_of_quarter` возвращают даты начала и конца квартала календарного года получателя:
```
d = Date.new(2010, 5, 9) # => Sun, 09 May 2010
d.beginning_of_quarter   # => Thu, 01 Apr 2010
d.end_of_quarter         # => Wed, 30 Jun 2010
```
У `beginning_of_quarter` есть псевдоним `at_beginning_of_quarter`, а у `end_of_quarter` есть псевдоним `at_end_of_quarter`.

> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

###### `beginning_of_year`, `end_of_year`
Методы `beginning_of_year` и `end_of_year` возвращают даты начала и конца года:
```
d = Date.new(2010, 5, 9) # => Sun, 09 May 2010
d.beginning_of_year      # => Fri, 01 Jan 2010
d.end_of_year            # => Fri, 31 Dec 2010
```
У `beginning_of_year` есть псевдоним `at_beginning_of_year`, а у `end_of_year` есть псевдоним `at_end_of_year`.

> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

##### Другие вычисления дат
###### `years_ago`, `years_since`
Метод `years_ago` получает число лет и возвращает ту же дату, что и много лет назад:
```
date = Date.new(2010, 6, 7)
date.years_ago(10) # => Wed, 07 Jun 2000
```
`years_since` перемещает вперед по времени:
```
date = Date.new(2010, 6, 7)
date.years_since(10) # => Sun, 07 Jun 2020
```
Если такая дата не найдена, возвращается последний день соответствующего месяца:
```
Date.new(2012, 2, 29).years_ago(3)     # => Sat, 28 Feb 2009
Date.new(2012, 2, 29).years_since(3)   # => Sat, 28 Feb 2015
```
`last_year` это сокращение для #years_ago(1).

> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

###### `months_ago`, `months_since`
Методы `months_ago` и `months_since` работают аналогично, но для месяцев:
```
Date.new(2010, 4, 30).months_ago(2)   # => Sun, 28 Feb 2010
Date.new(2010, 4, 30).months_since(2) # => Wed, 30 Jun 2010
```
Если такой день не существует, возвращается последний день соответствующего месяца:
```
Date.new(2010, 4, 30).months_ago(2)    # => Sun, 28 Feb 2010
Date.new(2009, 12, 31).months_since(2) # => Sun, 28 Feb 2010
```
`last_month` это сокращение для `#months_ago(1)`.

> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

###### `weeks_ago`
Метод `weeks_ago` работает аналогично для недель:
```
Date.new(2010, 5, 24).weeks_ago(1)    # => Mon, 17 May 2010
Date.new(2010, 5, 24).weeks_ago(2)    # => Mon, 10 May 2010
```
> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

###### `advance`
Более обычным способом перейти на другие дни является `advance`. Этот метод получает хэш с ключами `:years`, `:months`, `:weeks`, `:days`, и возвращает дату, передвинутую на столько, сколько указывают существующие ключи:
```
date = Date.new(2010, 6, 6)
date.advance(years: 1, weeks: 2)  # => Mon, 20 Jun 2011
date.advance(months: 2, days: -2) # => Wed, 04 Aug 2010
```
Отметьте в предыдущем примере, что приросты могут быть отрицательными.

Для выполнения вычисления метод сначала приращивает года, затем месяцы, затем недели, и, наконец, дни. Этот порядок важен в концах месяцев. Скажем, к примеру, мы в конце февраля 2010, и мы хотим переместиться на один месяц и один день вперед.

Метод `advance` передвигает сначала на один месяц, и затем на один день, результат такой:
```
Date.new(2010, 2, 28).advance(months: 1, days: 1)
# => Sun, 29 Mar 2010
```
Хотя, если бы мы делали по-другому, результат тоже был бы другой:
```
Date.new(2010, 2, 28).advance(days: 1).advance(months: 1)
# => Thu, 01 Apr 2010
```
> Определено в `active_support/core_ext/date/calculations.rb`.

##### Изменение компонентов
Метод `change` позволяет получить новую дату, которая идентична получателю, за исключением заданного года, месяца или дня:
```
Date.new(2010, 12, 23).change(year: 2011, month: 11)
# => Wed, 23 Nov 2011
```
Метод не принимает несуществующие даты, если изменение невалидно, вызывается `ArgumentError`:
```
Date.new(2010, 1, 31).change(month: 2)
# => ArgumentError: invalid date
```
> Определено в `active_support/core_ext/date/calculations.rb`.

##### Длительности
Длительности могут добавляться и вычитаться из дат:
```
d = Date.current
# => Mon, 09 Aug 2010
d + 1.year
# => Tue, 09 Aug 2011
d - 3.hours
# => Sun, 08 Aug 2010 21:00:00 UTC +00:00
```
Они переводят в вызовы `since` или `advance`. Например, здесь мы получим правильный переход ко времени календарной реформы:
```
Date.new(1582, 10, 4) + 1.day
# => Fri, 15 Oct 1582
```

##### Временные метки
Следующие методы возвращают объект `Time`, если возможно, в противном случае `DateTime`. Если установлено, учитывается временная зона пользователя.

###### `beginning_of_day`, `end_of_day`
Метод `beginning_of_day` возвращает временную метку для начала дня (00:00:00):
```
date = Date.new(2010, 6, 7)
date.beginning_of_day # => Mon Jun 07 00:00:00 +0200 2010
```
Метод `end_of_day` возвращает временную метку для конца дня (23:59:59):
```
date = Date.new(2010, 6, 7)
date.end_of_day # => Mon Jun 07 23:59:59 +0200 2010
```
У `beginning_of_day` есть псевдонимы `at_beginning_of_day`, `midnight`, `at_midnight`.

> Определено в `active_support/core_ext/date/calculations.rb`.

###### `beginning_of_hour`, `end_of_hour`
Метод `beginning_of_hour` возвращает временную метку в начале часа (hh:00:00):
```
date = DateTime.new(2010, 6, 7, 19, 55, 25)
date.beginning_of_hour # => Mon Jun 07 19:00:00 +0200 2010
```
Метод `end_of_hour` возвращает временную метку в конце часа (hh:59:59):
```
date = DateTime.new(2010, 6, 7, 19, 55, 25)
date.end_of_hour # => Mon Jun 07 19:59:59 +0200 2010
```
У `beginning_of_hour` есть псевдоним `at_beginning_of_hour`.

> Определено в `active_support/core_ext/date_time/calculations.rb`.

###### `beginning_of_minute`, `end_of_minute`
Метод `beginning_of_minute` возвращает временную метку в начале минуты (hh:mm:00):
```
date = DateTime.new(2010, 6, 7, 19, 55, 25)
date.beginning_of_minute # => Mon Jun 07 19:55:00 +0200 2010
```
Метод `end_of_minute` возвращает временную метку в конце минуты (hh:mm:59):
```
date = DateTime.new(2010, 6, 7, 19, 55, 25)
date.end_of_minute # => Mon Jun 07 19:55:59 +0200 2010
```
У `beginning_of_minute` есть псевдоним `at_beginning_of_minute`.

> `beginning_of_hour`, `end_of_hour`, `beginning_of_minute` и `end_of_minute` реализованы для `Time` и `DateTime`, но не для `Date`, так как у экземпляра `Date` не имеет смысла спрашивать о начале или окончании часа или минуты.

> Определено в `active_support/core_ext/date_time/calculations.rb`.

###### `ago`, `since`
Метод `ago` получает количество секунд как аргумент и возвращает временную метку, имеющую столько секунд до полуночи:
```
date = Date.current # => Fri, 11 Jun 2010
date.ago(1)         # => Thu, 10 Jun 2010 23:59:59 EDT -04:00
```
Подобным образом `since` двигается вперед:
```
date = Date.current # => Fri, 11 Jun 2010
date.since(1)       # => Fri, 11 Jun 2010 00:00:01 EDT -04:00
```
> Определено в `active_support/core_ext/date/calculations.rb`.

### Расширения для `DateTime` <a name="5.1.15"></a>
> `DateTime` не знает о правилах DST (переходов на летнее время), и поэтому некоторые из этих методов сталкиваются с временной пропастью, когда переход на и с летнего времени имеет место. К примеру, `seconds_since_midnight` может не возвратить настоящее значение для таких дней.

#### Вычисления
Класс `DateTime` является подклассом `Date`, поэтому загрузив `active_support/core_ext/date/calculations.rb` будут унаследованы эти методы и их псевдонимы, за исключением того, что они будут всегда возвращать дату и время.

Следующие методы переопределены, поэтому не нужно загружать `active_support/core_ext/date/calculations.rb` для них:
```
beginning_of_day (midnight, at_midnight, at_beginning_of_day)
end_of_day
ago
since (in)
```
С другой стороны, `advance` и `change` также определены, и поэтому поддерживают больше опций, описанных ранее.

Следующие методы реализованы только в `active_support/core_ext/date_time/calculations.rb`, так как они имеют смысл только при использовании с экземпляром `DateTime`:
```
beginning_of_hour (at_beginning_of_hour)
end_of_hour
```
##### Именованные `Datetime`
###### `DateTime.current`
Active Support определяет `DateTime.current` похожим на `Time.now.to_datetime`, за исключением того, что он учитывает временную зону пользователя, если она определена. Он также определяет `DateTime.yesterday` и `DateTime.tomorrow`, и предикаты экземпляра `past?` и `future?` относительно `DateTime.current`.

> Определено в `active_support/core_ext/date_time/calculations.rb`.

##### Другие расширения
###### `seconds_since_midnight`
Метод `seconds_since_midnight` возвращает число секунд, прошедших с полуночи:
```
now = DateTime.current     # => Mon, 07 Jun 2010 20:26:36 +0000
now.seconds_since_midnight # => 73596
```
> Определено в `active_support/core_ext/date_time/calculations.rb`.

###### `utc`
Метод `utc` выдает такую же дату и время получателя, но выраженную в UTC.
```
now = DateTime.current # => Mon, 07 Jun 2010 19:27:52 -0400
now.utc                # => Mon, 07 Jun 2010 23:27:52 +0000
```
У этого метода также есть псевдоним `getutc`.

> Определено в `active_support/core_ext/date_time/calculations.rb`.

###### `utc?`
Предикат `utc?` говорит, имеет ли получатель UTC в качестве своей временной зоны:
```
now = DateTime.now # => Mon, 07 Jun 2010 19:30:47 -0400
now.utc?           # => false
now.utc.utc?       # => true
```
> Определено в `active_support/core_ext/date_time/calculations.rb`.

###### `advance`
Более обычным способом перейти к другим дате и времени является `advance`. Этот метод получает хэш с ключами `:years`, `:months`, `:weeks`, `:days`, `:hours`, `:minutes` и `:seconds`, и возвращает дату и время, передвинутые на столько, на сколько указывают существующие ключи.
```
d = DateTime.current
# => Thu, 05 Aug 2010 11:33:31 +0000
d.advance(years: 1, months: 1, days: 1, hours: 1, minutes: 1, seconds: 1)
# => Tue, 06 Sep 2011 12:34:32 +0000
```
Этот метод сначала вычисляет дату назначения, передавая `:years`, `:months`, `:weeks` и `:days` в `Date#advance`, описанный ранее. После этого, он корректирует время, вызвав `since` с количеством секунд, на которое нужно передвинуть. Этот порядок обоснован, другой порядок мог бы дать другие дату и время для некоторых временных пропастей. Используем пример в `Date#advance`, и расширим его, показав обоснованность порядка, применимого к единицам измерения времени.

Если сначала передвинуть единицы измерения даты (относительный порядок вычисления, показанный ранее), а затем единицы измерения времени, мы получим для примера следующее вычисление:
```
d = DateTime.new(2010, 2, 28, 23, 59, 59)
# => Sun, 28 Feb 2010 23:59:59 +0000
d.advance(months: 1, seconds: 1)
# => Mon, 29 Mar 2010 00:00:00 +0000
```
но если мы вычисляем обратным способом, результат будет иным:
```
d.advance(seconds: 1).advance(months: 1)
# => Thu, 01 Apr 2010 00:00:00 +0000
```
Поскольку `DateTime` не поддерживает DST (переход на летнее время), можно получить несуществующий момент времени без каких-либо предупреждений или сообщений об ошибке.

> Определено в `active_support/core_ext/date_time/calculations.rb`.

##### Изменение компонентов
Метод `change` позволяет получить новые дату и время, которая идентична получателю, за исключением заданных опций, включающих `:year`, `:month`, `:day`, `:hour`, `:min`, `:sec`, `:offset`, `:start`:
```
now = DateTime.current
# => Tue, 08 Jun 2010 01:56:22 +0000
now.change(year: 2011, offset: Rational(-6, 24))
# => Wed, 08 Jun 2011 01:56:22 +0600
```
Если часы обнуляются, то минуты и секунды тоже (если у них не заданы значения):
```
now.change(hour: 0)
# => Tue, 08 Jun 2010 00:00:00 +0000
```
Аналогично, если минуты обнуляются, то секунды тоже (если у них не задано значение):
```
now.change(min: 0)
# => Tue, 08 Jun 2010 01:00:00 +0000
```
Этот метод не принимает несуществующие даты, если изменение невалидно, вызывается `ArgumentError`:
```
DateTime.current.change(month: 2, day: 30)Изменение компонентов
```
Метод `change` позволяет получить новые дату и время, которая идентична получателю, за исключением заданных опций, включающих `:year`, `:month`, `:day`, `:hour`, `:min`, `:sec`, `:offset`, `:start`:
```
now = DateTime.current
# => Tue, 08 Jun 2010 01:56:22 +0000
now.change(year: 2011, offset: Rational(-6, 24))
# => Wed, 08 Jun 2011 01:56:22 +0600
```
Если часы обнуляются, то минуты и секунды тоже (если у них не заданы значения):
```
now.change(hour: 0)
# => Tue, 08 Jun 2010 00:00:00 +0000
```
Аналогично, если минуты обнуляются, то секунды тоже (если у них не задано значение):
```
now.change(min: 0)
# => Tue, 08 Jun 2010 01:00:00 +0000
```
Этот метод не принимает несуществующие даты, если изменение невалидно, вызывается `ArgumentError`:
```
DateTime.current.change(month: 2, day: 30)
# => ArgumentError: invalid date
```
> Определено в `active_support/core_ext/date_time/calculations.rb`.

##### Длительности
Длительности могут добавляться и вычитаться из даты и времени:
```
now = DateTime.current
# => Mon, 09 Aug 2010 23:15:17 +0000
now + 1.year
# => Tue, 09 Aug 2011 23:15:17 +0000
now - 1.week
# => Mon, 02 Aug 2010 23:15:17 +0000
```
Они переводят в вызовы `since` или `advance`. Например, здесь мы получим правильный переход ко времени календарной реформы:
```
DateTime.new(1582, 10, 4, 23) + 1.hour
# => Fri, 15 Oct 1582 00:00:00 +0000
```

### Расширения для `Time` <a name="5.1.16"></a>
#### Вычисления
Это аналоги. Обратитесь к их документации выше, но примите во внимание следующие различия:
* `change` принимает дополнительную опцию `:usec`.
* `Time` понимает летнее время (DST), поэтому вы получите правильные вычисления времени как тут: 
```
Time.zone_default
# => #<ActiveSupport::TimeZone:0x7f73654d4f38 @utc_offset=nil, @name="Madrid", ...>

# В Барселоне, 2010/03/28 02:00 +0100 становится 2010/03/28 03:00 +0200 благодаря переходу на летнее время.
t = Time.local(2010, 3, 28, 1, 59, 59)
# => Sun Mar 28 01:59:59 +0100 2010
t.advance(seconds: 1)
# => Sun Mar 28 03:00:00 +0200 2010
```
Если `since` или `ago` переходят на время, которое не может быть выражено с помощью `Time`, вместо него возвращается объект `DateTime`.

##### `Time.current`
Active Support определяет `Time.current` как сегодняшний день в текущей временной зоне. Он похож на `Time.now`, за исключением того, что он учитывает временную зону пользователя, если она определена. Он также определяет предикаты экземпляра `past?`, `today?` и `future?`, все они относительны к `Time.current`.

При осуществлении сравнения `Time` с использованием методов, учитывающих временную зону пользователя, убедитесь, что используете `Time.current` вместо `Time.now`. Есть случаи, когда временная зона пользователя может быть в будущем по сравнению с временной зоной системы, в которой по умолчанию используется `Time.now`. Это означает, что `Time.now.to_date` может быть равным `Date.yesterday`.

> Определено в `active_support/core_ext/time/calculations.rb`.

##### `all_day`, `all_week`, `all_month`, `all_quarter` и `all_year`
Метод `all_day` возвращает интервал, представляющий целый день для текущего времени.
```
now = Time.current
# => Mon, 09 Aug 2010 23:20:05 UTC +00:00
now.all_day
# => Mon, 09 Aug 2010 00:00:00 UTC +00:00..Mon, 09 Aug 2010 23:59:59 UTC +00:00
```
Аналогично `all_week`, `all_month`, `all_quarter` и `all_year` служат целям генерации временных интервалов.
```
now = Time.current
# => Mon, 09 Aug 2010 23:20:05 UTC +00:00
now.all_week
# => Mon, 09 Aug 2010 00:00:00 UTC +00:00..Sun, 15 Aug 2010 23:59:59 UTC +00:00
now.all_week(:sunday)
# => Sun, 16 Sep 2012 00:00:00 UTC +00:00..Sat, 22 Sep 2012 23:59:59 UTC +00:00
now.all_month
# => Sat, 01 Aug 2010 00:00:00 UTC +00:00..Tue, 31 Aug 2010 23:59:59 UTC +00:00
now.all_quarter
# => Thu, 01 Jul 2010 00:00:00 UTC +00:00..Thu, 30 Sep 2010 23:59:59 UTC +00:00
now.all_year
# => Fri, 01 Jan 2010 00:00:00 UTC +00:00..Fri, 31 Dec 2010 23:59:59 UTC +00:00
```
> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

##### `prev_day`, `next_day`
В Ruby 1.9 `prev_day` и `next_day` возвращают дату для последнего или следующего дня:
```
d = Date.new(2010, 5, 8) # => Sat, 08 May 2010
d.prev_day               # => Fri, 07 May 2010
d.next_day               # => Sun, 09 May 2010
```
> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

##### `prev_month`, `next_month`
В Ruby 1.9 `prev_month` и `next_month` возвращают дату с тем же днем в предыдущем или следующем месяце:
```
d = Date.new(2010, 5, 8) # => Sat, 08 May 2010
d.prev_month             # => Thu, 08 Apr 2010
d.next_month             # => Tue, 08 Jun 2010
```
Если такой день не существует, возвращается последний день соответствующего месяца:
```
Date.new(2000, 5, 31).prev_month # => Sun, 30 Apr 2000
Date.new(2000, 3, 31).prev_month # => Tue, 29 Feb 2000
Date.new(2000, 5, 31).next_month # => Fri, 30 Jun 2000
Date.new(2000, 1, 31).next_month # => Tue, 29 Feb 2000
```
> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

##### `prev_year`, `next_year`
В Ruby 1.9 `prev_year` и `next_year` возвращают дату с тем же днем/месяцем в предыдущем или следующем году:
```
d = Date.new(2010, 5, 8) # => Sat, 08 May 2010
d.prev_year              # => Fri, 08 May 2009
d.next_year              # => Sun, 08 May 2011
```
Если датой является 29 февраля високосного года, возвратится 28-е:
```
d = Date.new(2000, 2, 29) # => Tue, 29 Feb 2000
d.prev_year               # => Sun, 28 Feb 1999
d.next_year               # => Wed, 28 Feb 2001
```
> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

##### `prev_quarter`, `next_quarter`
`prev_quarter` и `next_quarter` возвращают дату с тем же днем в предыдущем или следующем квартале:
```
t = Time.local(2010, 5, 8) # => 2010-05-08 00:00:00 0300
t.prev_quarter             # => 2010-02-08 00:00:00 0200
t.next_quarter             # => 2010-08-08 00:00:00 0300
```
Если такой день не существует, возвращается последний день соответствующего месяца:
```
Time.local(2000, 7, 31).prev_quarter  # => 2000-04-30 00:00:00 0300
Time.local(2000, 5, 31).prev_quarter  # => 2000-02-29 00:00:00 0200
Time.local(2000, 10, 31).prev_quarter # => 2000-07-31 00:00:00 0300
Time.local(2000, 11, 31).next_quarter # => 2001-03-01 00:00:00 0200
```
`prev_quarter` имеет псевдоним `last_quarter`.

> Определено в `active_support/core_ext/date_and_time/calculations.rb`.

#### Конструкторы `Time`
Active Support определяет `Time.current` как `Time.zone.now`, если у пользователя определена временная зона, а иначе `Time.now`:
```
Time.zone_default
# => #<ActiveSupport::TimeZone:0x7f73654d4f38 @utc_offset=nil, @name="Madrid", ...>
Time.current
# => Fri, 06 Aug 2010 17:11:58 CEST +02:00
```
Как и у `DateTime`, предикаты `past?` и `future?` выполняются относительно `Time.current`.

Если время, подлежащее конструированию лежит за пределами интервала, поддерживаемого `Time` на запущенной платформе, `usecs` отбрасываются и вместо этого возвращается объект `DateTime`.

##### Длительности
Длительности могут быть добавлены и вычтены из объектов времени:
```
now = Time.current
# => Mon, 09 Aug 2010 23:20:05 UTC +00:00
now + 1.year
# => Tue, 09 Aug 2011 23:21:11 UTC +00:00
now - 1.week
# => Mon, 02 Aug 2010 23:21:11 UTC +00:00
```
Они переводят в вызовы `since` или `advance`. Например, здесь мы получим правильный переход ко времени календарной реформы:
```
Time.utc(1582, 10, 3) + 5.days
# => Mon Oct 18 00:00:00 UTC 1582
```

### Расширения для File <a name="5.1.17"></a>
#### `atomic_write`
С помощью метода класса `File.atomic_write` можно записать в файл способом, предотвращающим от просмотра недописанного содержимого.

Имя файла передается как аргумент, и в метод вкладываются обработчики файла, открытого для записи. Как только блок выполняется, `atomic_write` закрывает файл и завершает свое задание.

Например, Action Pack использует этот метод для записи файлов кэша ассетов, таких как `all.css`:
```
File.atomic_write(joined_asset_path) do |cache|
  cache.write(join_asset_file_contents(asset_paths))
end
```
Для выполнения этого `atomic_write` создает временный файл. Фактически код в блоке пишет в этот файл. При выполнении временный файл переименовывается, что является атомарной операцией в системах POSIX. Если целевой файл существует, `atomic_write` перезаписывает его и сохраняет владельцев и права доступа. Однако в некоторых случаях `atomic_write` не может изменить владельца или права доступа на файл, эта ошибка отлавливается и пропускается, позволяя файловой системе убедиться, что файл доступен для необходимых манипуляций.

Благодаря операции `chmod`, выполняемой `atomic_write`, если у целевого файла установлен ACL, то этот ACL будет пересчитан/модифицирован.

Отметьте, что с помощью `atomic_write` нельзя дописывать.

Вспомогательный файл записывается в стандартной директории для временных файлов, но можно передать эту директорию как второй аргумент.

> Определено в `active_support/core_ext/file/atomic.rb`.

### Расширения для `Marshal` <a name="5.1.18"></a>
#### `load`
Active Support добавляет поддержку постоянной автозагрузки для `load`.

Например, хранилище кэша файлов десериализует следующим образом:
```
File.open(file_name) { |f| Marshal.load(f) }
```
Если закэшированные данные обращаются к константе, которая неизвестна в данный момент, включается механизм автозагрузки и, если он успешен, перевыполняется десериализация.

> Если аргумент `IO`, необходимо, чтобы он отвечал на `rewind`, чтобы быть способным на повтор. Обычные файлы отвечают на `rewind`.

> Определено в `active_support/core_ext/marshal.rb`.

### Расширения для `NameError` <a name="5.1.19"></a>
Active Support добавляет `missing_name?` к `NameError`, который проверяет было ли исключение вызвано в связи с тем, что имя было передано как аргумент.

Имя может быть задано как символ или строка. Символ проверяется как простое имя константы, строка - как полностью ограниченное имя константы.

Символ может представлять полностью ограниченное имя константы как :`"ActiveRecord::Base"`, такое поведение для символов определено для удобства, а не потому, что такое возможно технически.

К примеру, когда вызывается экшн `ArticlesController`, Rails пытается оптимистично использовать `ArticlesHelper`. Это нормально, когда не существует модуля хелпера, поэтому если вызывается исключение для этого имени константы, оно должно молчать. Но в случае, если `articles_helper.rb` вызывает `NameError` благодаря неизвестной константе, оно должно быть перевызвано. Метод `missing_name?` предоставляет способ проведения различия в этих двух случаях:
```
def default_helper_module!
  module_name = name.sub(/Controller$/, '')
  module_path = module_name.underscore
  helper module_path
rescue LoadError => e
  raise e unless e.is_missing? "helpers/#{module_path}_helper"
rescue NameError => e
  raise e unless e.missing_name? "#{module_name}Helper"
end
```
> Определено в `active_support/core_ext/name_error.rb`.

### Расширения для `LoadError` <a name="5.1.20"></a>
Active Support добавляет `is_missing?` к `LoadError`.

Для заданного имени пути `is_missing?` проверяет, будет ли вызвано исключение из-за определенного файла (за исключением файлов с расширением ".rb").

Например, когда вызывается экшн `ArticlesController`, Rails пытается загрузить `articles_helper.rb`, но этот файл может не существовать. Это нормально, модуль хелпера не обязателен, поэтому Rails умалчивает ошибку загрузки. Но может быть случай, что модуль хелпера существует, и в свою очередь требует другую библиотеку, которая отсутствует. В этом случае Rails должен вызвать исключение. Метод `is_missing?` предоставляет способ проведения различия в этих двух случаях:
```
def default_helper_module!
  module_name = name.sub(/Controller$/, '')
  module_path = module_name.underscore
  helper module_path
rescue LoadError => e
  raise e unless e.is_missing? "helpers/#{module_path}_helper"
rescue NameError => e
  raise e unless e.missing_name? "#{module_name}Helper"
end
```
> Определено в `active_support/core_ext/load_error.rb`.

## Инструментарий Active Support <a name="5.2"></a>
Active Support — часть ядра Rails, которая предоставляет расширение языка Ruby, утилиты и другие возможности. Она включает инструментарий API, который может использоваться внутри приложения, для отслеживания определенных действий, которые возникают как в коде Ruby, так и внутри приложения Rails и самого фреймворка. Однако, она не ограничена Rails. При необходимости ее можно независимо использовать в других скриптах Ruby если вы желаете.

В этом руководстве вы научитесь использовать инструменты Active Support API для отслеживания событий внутри Rails или другого Ruby-кода.

### Введение в инструментарий <a name="5.2.1"></a>
Инструментарий API, предоставленный Active Support, позволяет разработчикам создавать хуки, которыми могут пользоваться другие разработчики. 

Например, есть хук внутри Active Record который вызывается каждый раз когда Active Record использует запрос SQL к базе данных. На этот хук можно подписаться и использовать его для отслеживания количества запросов в течении определенного экшна. Есть другой хук, оборачивающий экшны контроллеров. Он может быть использован, например, для отслеживания, как долго выполнялся определенный экшн.

Вы даже можете создать свои собственные события внутри приложения, на которые вы потом сможете подписаться.

### Хуки фреймворка Rails <a name="5.2.2"></a>
Внутри фреймворка Ruby on Rails присутствует множество хуков для обычных событий. Они описываются ниже.

### Action Controller <a name="5.2.3"></a>
#### `write_fragment.action_controller`
| Ключ | Значение |
|------|----------|
| `:key` | Полный ключ |
```
{
  key: 'posts/1-dashboard-view'
}
```

#### `read_fragment.action_controller`
| Ключ | Значение |
|------|----------|
| :key | Полный ключ |
```
{
  key: 'posts/1-dashboard-view'
}
```
#### `expire_fragment.action_controller`
| Ключ | Значение |
|------|----------|
| `:key` | Полный ключ |
```
{
  key: 'posts/1-dashboard-view'
}
```
#### `exist_fragment?.action_controller`
```
{
  key: 'posts/1-dashboard-view'
}
```
#### `write_page.action_controller`
```
{
  path: '/users/1'
}
```
#### `expire_page.action_controller`
```
{
  path: '/users/1'
}
```
#### `start_processing.action_controller`
| Ключ | Значение |
|------|----------|
| `:controller` |	Имя контроллера |
| `:action` | Экшн |
| `:params` | Хэш параметров запроса без фильтрации параметров |
| `:headers` | Заголовки запроса |
| `:format` |	`html/js/json/xml` и.т.д. |
| `:method` |	Метод HTTP-запроса |
| `:path` |	Путь запроса |
```
{
  controller: "PostsController",
  action: "new",
  params: { "action" => "new", "controller" => "posts" },
  headers: #<ActionDispatch::Http::Headers:0x0055a67a519b88>,
  format: :html,
  method: "GET",
  path: "/posts/new"
}
```
#### `process_action.action_controller`
| Ключ | Значение |
|------|----------|
| `:controller` | Имя контроллера |
| `:action` |	Экшн |
| `:params` |	Хэш параметров запроса без фильтрации параметров |
| `:headers` | Заголовки запроса |
| `:format` |	`html/js/json/xml` и.т.д. |
| `:method` |	Метод HTTP-запроса |
| `:path` |	Путь запроса |
| `:status` |	Код статуса HTTP |
| `:view_runtime` |	Количество времени, потраченного во вьюхе |
| `:db_runtime` |	Время, потраченное на выполнение запросов к БД в мс |
```
{
  controller: "PostsController",
  action: "index",
  params: {"action" => "index", "controller" => "posts"},
  headers: #<ActionDispatch::Http::Headers:0x0055a67a519b88>,
  format: :html,
  method: "GET",
  path: "/posts",
  status: 200,
  view_runtime: 46.848,
  db_runtime: 0.157
}
```
#### `send_file.action_controller`
```
:path 	Полный путь к файлу
```
> Дополнительные ключи могут быть добавлены при вызове.

#### `send_data.action_controller`
ActionController не добавляет какой-либо конкретной информации при загрузке. Все опции передаются через полезную нагрузку (`payload`).

#### `redirect_to.action_controller`
| Ключ | Значение |
|------|----------|
| `:status` |	Код HTTP ответа |
| `:location` |	URL для переадресации |
```
{
  status: 302,
  location: "http://localhost:3000/posts/new"
}
```
#### `halted_callback.action_controller`
| Ключ | Значение |
|------|----------|
| `:filter` | Фильтр, прервавший экшн |
```
{
  filter: ":halting_filter"
}
```
#### `unpermitted_parameters.action_controller`
| Ключ | Значение |
|------|----------|
| `:keys` | Неразрешенные ключи |

### Action View <a name="5.2.4"></a>
#### `render_template.action_view`
| Ключ | Значение |
|------|----------|
| `:identifier` | Полный путь до шаблона |
| `:layout` |	Применяемый макет |
```
{
  identifier: "/Users/adam/projects/notifications/app/views/posts/index.html.erb",
  layout: "layouts/application"
}
```
#### `render_partial.action_view`
| Ключ | Значение |
|------|----------|
| `:identifier` |	Полный путь до шаблона |
```
{
  identifier: "/Users/adam/projects/notifications/app/views/posts/_form.html.erb",
}
```
#### `render_collection.action_view`
| Ключ | Значение |
|------|----------|
| `:identifier` | Полный путь к шаблону |
| `:count` | Размер коллекции |
| `:cache_hits` |	Количество партиалов, извлеченных из кэша |

> `:cache_hits` включается, только если коллекция рендерится с `cached: true`.
```
{
  identifier: "/Users/adam/projects/notifications/app/views/posts/_post.html.erb",
  count: 3,
  cache_hits: 0
}
```
### Active Record <a name="5.2.5"></a>
#### `sql.active_record`
| Ключ | Значение |
|------|----------|
| `:sql` | Выражение SQL |
| `:name` |	Имя операции |
| `:connection_id` | Object ID объекта соединения |
| `:connection` |	Объект соединения |
| `:binds` | Связанные параметры |
| `:type_casted_binds` | Приведенные связанные параметры |
| `:statement_name` |	Имя выражения SQL |
| `:cached` | `true` если использованы кэшированные запросы |

Адаптеры будут добавлять свои собственные данные.
```
{
  sql: "SELECT \"posts\".* FROM \"posts\" ",
  name: "Post Load",
  connection_id: 70307250813140,
  connection: #<ActiveRecord::ConnectionAdapters::SQLite3Adapter:0x00007f9f7a838850>,
  binds: [#<ActiveModel::Attribute::WithCastValue:0x00007fe19d15dc00>],
  type_casted_binds: [11],
  statement_name: nil
}
```

#### `sql.active_record`
| Ключ | Значение |
|------|----------|
| `:sql` | Выражение SQL |
| `:name` |	Имя операции |
| `:connection_id` | Object ID объекта соединения |
| `:connection` |	Объект соединения |
| `:binds` | Связанные параметры |
| `:type_casted_binds` | Приведенные связанные параметры |
| `:statement_name` | Имя выражения SQL |
| `:cached` |	`true` если использованы кэшированные запросы |

Адаптеры будут добавлять свои собственные данные.
```
{
  sql: "SELECT \"posts\".* FROM \"posts\" ",
  name: "Post Load",
  connection_id: 70307250813140,
  connection: #<ActiveRecord::ConnectionAdapters::SQLite3Adapter:0x00007f9f7a838850>,
  binds: [#<ActiveModel::Attribute::WithCastValue:0x00007fe19d15dc00>],
  type_casted_binds: [11],
  statement_name: nil
}
```
#### `instantiation.active_record`
| Key | Value |
|-----|-------|
| `:record_count` |	Количество записей |
| `:class_name` | Класс записи |
```
{
  record_count: 1,
  class_name: "User"
}
```
### Action Mailer <a name="5.2.6"></a>
#### `deliver.action_mailer`
| Ключ | Значение |
|------|----------|
| `:mailer` |	Имя класса рассыльщика |
| `:message_id` |	ID сообщения, создается Mail гемом |
| `:subject` | Тема сообщения |
| `:to` | Адресат(ы) сообщения |
| `:from` |	Отправитель сообщения |
|`:bcc` |	BCC адреса сообщения |
| `:cc` |	CC адреса сообщения |
| `:date` |	Дата сообщения |
| `:mail` | Кодированная форма сообщения |
| `:perform_deliveries` |	Была ли вызвана доставка этого сообщения или нет |
```
{
  mailer: "Notification",
  message_id: "4f5b5491f1774_181b23fc3d4434d38138e5@mba.local.mail",
  subject: "Rails Guides",
  to: ["users@rails.com", "dhh@rails.com"],
  from: ["me@rails.com"],
  date: Sat, 10 Mar 2012 14:18:09 +0100,
  mail: "...", # опущено для краткости
  perform_deliveries: true
}
```
#### `process.action_mailer`
| Ключ | Значение |
|------|----------|
| `:mailer` | Имя класса рассыльщика |
| `:action` |	Экшн |
| `:args` |	Аргументы |
```
{
  mailer: "Notification",
  action: "welcome_email",
  args: []
}
```
### Active Support <a name="5.2.7"></a>
#### `cache_read.active_support`
| Ключ | Значение |
|------|----------|
| `:key` | Ключ, используемый при хранении |
| `:hit` | Если это чтение успешно |
| `:super_operation` |` :fetch` добавляется когда чтение используется с `#fetch` |

#### `cache_generate.active_support`
Это событие используется только когда `#fetch` вызывается с блоком.
| Ключ | Значение |
|------|----------|
|`:key` | Ключ, используемый при хранении |

Опции, переданные в вызов, будут объединены с полезной нагрузкой при записи в хранилище.
```
{
  key: 'name-of-complicated-computation'
}
```

#### `cache_fetch_hit.active_support`
Это событие используется только когда `#fetch` вызывается с блоком.
| Ключ | Значение |
|------|----------|
| `:key` | Ключ, используемый при хранении |

Опции, переданные в вызов, будут объединены с полезной нагрузкой.
```
{
  key: 'name-of-complicated-computation'
}
```

#### `cache_write.active_support`
| Ключ | Значение |
|------|----------|
| `:key` | Ключ, используемый при хранении |

Кэш хранилище может добавить свой собственный ключ.
```
{
  key: 'name-of-complicated-computation'
}
```

#### `cache_delete.active_support`
| Ключ | Значение |
| `:key` | Ключ, используемый при хранении |
```
{
  key: 'name-of-complicated-computation'
}
```

#### `cache_exist?.active_support`
| Ключ | Значение |
|------|----------|
| `:key` | Ключ, используемый при хранении |
```
{
  key: 'name-of-complicated-computation'
}
```
### Active Job <a name="5.2.8"></a>
#### `enqueue_at.active_job`
| Ключ | Значение |
|------|----------|
| `:adapter` | Объект QueueAdapter, обрабатывающий задание |
| `:job` | Объект задания |

#### `enqueue.active_job`
| Ключ | Значение |
|------|----------|
| `:adapter` | Объект QueueAdapter, обрабатывающий задание |
| `:job` | Объект задания |

#### `enqueue_retry.active_job`
| Ключ | 	Значение |
|------|-----------|
| `:job` | Объект задания |
| `:adapter` | Объект QueueAdapter, обрабатывающий задание |
| `:error` | Ошибка, вызвавшая повтор |
| `:wait` | Задержка повтора |

#### `perform_start.active_job`
| Ключ | Значение |
|------|----------|
| `:adapter` | Объект QueueAdapter, обрабатывающий задание |
| `:job` | Объект задания |

#### `perform.active_job`
| Ключ | Значение |
|------|----------|
| `:adapter` | Объект QueueAdapter, обрабатывающий задание |
| `:job` | Объект задания |

#### `retry_stopped.active_job`
| Ключ | Значение |
|------|----------|
| `:adapter` | Объект QueueAdapter, обрабатывающий задание |
| `:job` | Объект задания |
| `:error` | Ошибка, вызвавшая повтор |

#### `discard.active_job`
| Ключ | Значение |
|------|----------|
| `:adapter` | Объект QueueAdapter, обрабатывающий задание |
| `:job` | Объект задания |
| `:error` | Ошибка, вызвавшая отказ |

### Action Cable <a name="5.2.9"></a>
#### `perform_action.action_cable`
| Ключ | Значение |
|------|----------|
| `:channel_class` | Имя класса канала |
| `:action` | Экшн |
| `:data` |	Данные хэша |

#### `transmit.action_cable`
| Ключ | Значение |
|------|----------|
| `:channel_class` | Имя класса канала |
| `:data` |	Данные хэша |
| `:via` | С помощью |

#### `transmit_subscription_confirmation.action_cable`
| Ключ | Значение |
|------|----------|
| `:channel_class` | Имя класса канала |

#### `transmit_subscription_rejection.action_cable`
| Ключ | Значение |
|------|----------|
| `:channel_class` | Имя класса канала |

#### `broadcast.action_cable`
| Ключ | Значение |
|------|----------|
| `:broadcasting` | Имя трансляции |
| `:message` | Сообщение хэша |
| `:coder` | Кодировщик |

### Active Storage (Rails 5.2) <a name="5.2.10"></a>
#### `service_upload.active_storage`
| Ключ | Значение |
|------|----------|
| `:key` | Защищенный токен |
| `:service` | Имя сервиса |
| `:checksum` |	Контрольная сумма для обеспечения целостности |

#### `service_streaming_download.active_storage`
| Ключ | Значение |
|------|----------|
| `:key` | Защищенный токен |
| `:service` | Имя сервиса |

#### `service_download.active_storage`
| Ключ | Значение |
|------|----------|
| `:key` | Защищенный токен |
| `:service` | Имя сервиса |

#### `service_delete.active_storage`
| Ключ | Значение |
|------|----------|
| `:key` | Защищенный токен |
| `:service` | Имя сервиса |

#### `service_delete_prefixed.active_storage`
| Ключ | Значение |
|------|----------|
| `:prefix` | Префикс ключа |
| `:service` | Имя сервиса |

#### `service_exist.active_storage`
| Ключ | Значение |
|------|----------|
| `:key` | Защищенный токен |
| `:service` | Имя сервиса |
| `:exist` | Существует или же нет файл или blob |

#### `service_url.active_storage`
| Ключ | Значение |
|------|----------|
| `:key ` | Защищенный токен |
| `:service` | Имя сервиса |
| `:url` | Сгенерированный url |

### Railties <a name="5.2.11"></a>
#### `load_config_initializer.railties`
| Ключ | Значение |
|------|----------|
| `:initializer` | Путь к загруженному инициализатору из config/initializers |

### Rails <a name="5.2.12"></a>
#### `deprecation.rails`
| Ключ | Значение |
|------|----------|
| `:message` | Предупреждение устаревания |
| `:callstack` | Откуда предупреждение пришло |

### Подписка на события <a name="5.2.13"></a>
Подписаться на событие просто. Используйте `ActiveSupport::Notifications.subscribe` с блоком, чтобы слушать любое уведомление.

Блок получает следующие аргументы:
* Имя события
* Время начала
* Время окончания
* Уникальный ID для инструментария, запустившего это событие
* Полезная нагрузка (описывается в предыдущем разделе) 
```
ActiveSupport::Notifications.subscribe "process_action.action_controller" do |name, started, finished, unique_id, data|
  # Ваши собственные настройки
  Rails.logger.info "#{name} Received!"
end
```
Определение всех этих аргументов блока каждый раз может быть утомительно. Можно легко создать `ActiveSupport::Notifications::Event` из блока аргументов, например:
```
ActiveSupport::Notifications.subscribe "process_action.action_controller" do |*args|
  event = ActiveSupport::Notifications::Event.new *args

  event.name      # => "process_action.action_controller"
  event.duration  # => 10 (in milliseconds)
  event.payload   # => {:extra=>information}

  Rails.logger.info "#{event} Received!"
end
```
Также можно передать блок лишь с одним аргументом, в блоке в него будет вложен объект события:
```
ActiveSupport::Notifications.subscribe "process_action.action_controller" do |event|
  event.name      # => "process_action.action_controller"
  event.duration  # => 10 (in milliseconds)
  event.payload   # => {:extra=>information}

  Rails.logger.info "#{event} Received!"
end
```
В основном вас будет интересовать сама информация. Ниже приведен краткий вариант, как можно получить информацию.
```
ActiveSupport::Notifications.subscribe "process_action.action_controller" do |*args|
  data = args.extract_options!
  data # { extra: :information }
end
```
Вы можете также подписаться на события, соответствующие регулярному выражению. Это позволит вам подписаться на несколько событий за раз. Вот как можно подписаться на все события ActionController.
```
ActiveSupport::Notifications.subscribe /action_controller/ do |*args|
  # Проверка всех событий ActionController
end
```

### Создание пользовательского события <a name="5.2.14"></a>
Добавить свои события очень просто.` ActiveSupport::Notifications` будет делать всю тяжелую работу за вас. Просто вызовите `instrument` с `name`, `payload` и блоком. Уведомление будет отправлено после возвращения блока. ActiveSupport сгенерирует время старта и окончания и добавит уникальный ID инструментария. Все данные переданные в вызов `instrument` будут выполнены в полезной нагрузке.

Пример:
```
ActiveSupport::Notifications.instrument "my.custom.event", this: :data do
  # Создание ваших пользовательских настроек тут
end
```
Теперь можно слушать это событие:
```
ActiveSupport::Notifications.subscribe "my.custom.event" do |name, started, finished, unique_id, data|
  puts data.inspect # {:this=>:data}
end
```
Вы должны следовать соглашениям Rails при создании своих событий. Формат: `event.library`. Если ваше приложение отправляет Tweets, вы должны назвать событие `tweet.twitter`.

## Создание пользовательского события <a name="5.3"></a>
В Ruby гем I18n (краткое наименование для internationalization), поставляемый с Ruby on Rails (начиная с Rails 2.2), представляет простой и расширяемый фреймворк для перевода вашего приложения на отдельный другой язык, иной чем английский, или для предоставления поддержки многоязычности в вашем приложении.
> Фреймворк Ruby I18n предоставляет все необходимые средства для интернационализации/локализации приложения на Rails. Можно также использовать другие различные гемы, добавляющие дополнительные функциональность или особенности.
### Как работает I18n в Ruby on Rails <a name="5.3.1"></a>
#### Общая архитектура библиотеки
Таким образом, Ruby гем I18n разделен на две части:
* Публичный API фреймворка i18n - модуль Ruby с публичными методами, определяющими как работает библиотека
* Бэкенд по умолчанию (который специально называется простым бэкендом), реализующий эти методы 

Как у пользователя, у вас всегда будет доступ только к публичным методам модуля I18n, но полезно знать о возможностях бэкенда.

> Возможно поменять встроенный простой бэкенд на более мощный, который будет хранить данные перевода в реляционной базе данных, словаре `GetText` или в чем-то похожем.

#### Публичный I18n API
Наиболее важными методами I18n API являются:
```
translate # Ищет перевод текстов
localize  # Локализует объекты даты и времени в форматы локали
```
Имеются псевдонимы #t и #l, их можно использовать следующим образом:
```
I18n.t 'store.title'
I18n.l Time.now
```
Также имеются методы чтения и записи для следующих атрибутов:
```
load_path                 # Анонсировать ваши пользовательские файлы с переводом
locale                    # Получить и установить текущую локаль
default_locale            # Получить и установить локаль по умолчанию
available_locales         # Разрешенные локали, доступные приложению
enforce_available_locales # Принуждение к разрешенным локалям (true или false)
exception_handler         # Использовать иной exception_handler
backend                   # Использовать иной бэкенд
```
### Настройка приложения на Rails для интернационализации <a name="5.3.2"></a>
#### Конфигурирование модуля I18n
Следуя философии соглашений над конфигурацией, Rails предоставляет приемлемые строки переводов по умолчанию. При необходимости иных строк переводов, они могут быть переопределены.

Rails автоматически добавляет все файлы `.rb` и `.yml` из директории `config/locales` к пути загрузки переводов.

Локаль по умолчанию `en.yml` в этой директории содержит образец строки перевода:
```
en:
  hello: "Hello world"
```
Это означает, что в локали `:en`, ключ hello связан со строкой "Hello world". Каждая строка в Rails интернационализируется подобным образом, смотрите, к примеру, валидационные сообщения Active Model в файле `activemodel/lib/active_model/locale/en.yml` или форматы времени и даты в файле `activesupport/lib/active_support/locale/en.yml`. Для хранения переводов в бэкенде по умолчанию (простом) можете использовать YAML или стандартные хэши Ruby.

Библиотека I18n будет использовать английский как локаль по умолчанию, т.е., если другая локаль не установлена, при поиске переводов будет использоваться :en.

> В библиотеке i18n принят прагматичный подход к ключам локали (после некоторых обсуждений), включающий только часть локаль ("язык"), наподобие `:en`, `:pl`, но не часть регион, подобно :en-US или :en-GB, как традиционно используется для разделения "языков" и "региональных настроек", или "диалектов". Многие международные приложения используют только элемент "язык" локали, такой как `:cs`, `:th` или `:es` (для Чехии, Таиланда и Испании). Однако, также имеются региональные различия внутри языковой группы, которые могут быть важными. Например, в локали `:en-US` как символ валюты будет `$`, а в `:en-GB` будет `£`. Ничто не остановит вас от разделения региональных и других настроек следующим образом: предоставляете полную локаль "English - United Kingdom" в словаре `:en-GB`.

**Путь загрузки переводов** (`I18n.load_path`) - это массив путей к файлам, которые будут загружены автоматически. Настройка этого пути позволяет настроить структуру директорий переводов и схему именования файлов.

Бэкенд лениво загружает эти переводы, когда ищет перевод в первый раз. Этот бэкенд может быть переключен на что-то иное даже после того, как переводы были объявлены.

Можно изменить локаль по умолчанию, так же как и настроить пути загрузки переводов, в `config/application.rb` следующим образом:
```
  config.i18n.load_path += Dir[Rails.root.join('my', 'locales', '*.{rb,yml}')]
  config.i18n.default_locale = :de
```
Путь загрузки должен быть указан до того, как будет произведен поиск любых переводов. Чтобы изменить локаль по умолчанию в инициализаторе вместо `config/application.rb`:
```
# config/initializers/locale.rb

# где библиотека I18n должна искать наши переводы
I18n.load_path += Dir[Rails.root.join('lib', 'locale', '*.{rb,yml}')]

# Разрешенные локали, доступные приложению
I18n.available_locales = [:en, :pt]

# устанавливаем локаль по умолчанию на что-либо другое, чем :en
I18n.default_locale = :pt
```
Отметьте, что добавление напрямую в `I18n.load_paths`, вместо конфигурации i18n приложения, не перезапишет переводы из внешних гемов.

#### Управление локалью через запросы
Локализованному приложению, вероятно, понадобится поддерживать несколько локалей. Для этого локаль должна быть установлена в начале каждого запроса, чтобы все строки были переведены, используя нужную локаль.

Локаль по умолчанию используется для всех переводов за исключением случаев, когда установлены `I18n.locale=` или `I18n.with_locale`.

`I18n.locale` может вытечь в последующие запросы, обслуживаемые тем же тредом/процессом, если она не устанавливается последовательно в каждом контроллере. Например, выполнение `I18n.locale = :es` в одном из запросов POST будет влиять на все последующие запросы в контроллерах, не устанавливающих локаль, но только в этом конкретном треде/процессе. **Поэтому вместо `I18n.locale =` можно использовать `I18n.with_locale`**, не имеющий этой проблемы утечки.
Локаль может быть установлена в `around_action` в `ApplicationController`:
```
around_action :switch_locale

def switch_locale(&action)
  locale = params[:locale] || I18n.default_locale
  I18n.with_locale(locale, &action)
end
```
Этот пример показывает использование параметра запроса URL для установки локали (т.е. http://example.com/books?locale=pt). Таким образом, http://localhost:3000?locale=pt загрузит португальскую локализацию, в то время как http://localhost:3000?locale=de загрузит немецкую локализацию.

Локаль может быть установлена, используя один из множества других способов.

##### Назначение локали из имени домена
Одним из вариантов, которым можно установить локаль, является доменное имя, на котором запущено ваше приложение. Например, мы хотим, чтобы www.example.com загружал английскую локаль (по умолчанию), а www.example.es загружал испанскую локаль. Таким образом, доменное имя верхнего уровня используется для установки локали. В этом есть несколько преимуществ:
* Локаль является явной частью URL.
* Люди интуитивно понимают, на каком языке будет отражено содержимое.
* Это очень просто реализовать в Rails.
* Поисковые движки любят, когда содержимое на различных языках живет на отдельных, взаимосвязанных доменах. 
Это осуществляется так в `ApplicationController`:
```
around_action :switch_locale

def switch_locale(&action)
  locale = extract_locale_from_tld || I18n.default_locale
  I18n.with_locale(locale, &action)
end

# Получаем локаль из домена верхнего уровня или возвращаем +nil+, если такая локаль недоступна
# Вам следует поместить что-то наподобие этого:
#   127.0.0.1 application.com
#   127.0.0.1 application.it
#   127.0.0.1 application.pl
# в ваш файл /etc/hosts, чтобы попробовать это локально
def extract_locale_from_tld
  parsed_locale = request.host.split('.').last
  I18n.available_locales.map(&:to_s).include?(parsed_locale) ? parsed_locale : nil
end
```
Также можно назначить локаль из поддомена похожим образом:
```
# Получаем код локали из поддомена запроса (подобно http://it.application.local:3000)
# Следует поместить что-то вроде:
#   127.0.0.1 gr.application.local
# в ваш файл /etc/hosts, чтобы попробовать это локально
def extract_locale_from_subdomain
  parsed_locale = request.subdomains.first
  I18n.available_locales.map(&:to_s).include?(parsed_locale) ? parsed_locale : nil
end
```
Если ваше приложение включает меню переключения локали, вам следует иметь что-то вроде этого в нем:
```
link_to("Deutsch", "#{APP_CONFIG[:deutsch_website_url]}#{request.env['PATH_INFO']}")
```
предполагая, что вы установили `APP_CONFIG[:deutsch_website_url]` в некоторое значение, наподобие `http://www.application.de`.

У этого решения есть вышеупомянутые преимущества, однако возможно, что вам нельзя или вы не хотите предоставлять разные локализации ("языковые версии") на разных доменах. Наиболее очевидным решением является включить код локали в параметры URL (или пути запроса).

##### Назначение локали из параметров URL
Наиболее обычным способом назначения (и передачи) локали будет включение ее в параметры URL, как мы делали в `I18n.with_locale(params[:locale], &action)` в `around_action` в первом примере. В этом случае нам нужны URL, такие как `www.example.com/books?locale=ja` или `www.example.com/ja/books`.

В этом подходе есть почти тот же набор преимуществ, как и в назначении локали из имени домена, а именно то, что это RESTful и соответствует остальной части Всемирной паутины. Хотя внедрение этого потребует немного больше работы.

Получение локали из params и соответствующее назначение ее не сложно: включаете ее в каждый URL, и таким образом передаете ее через запросы. Конечно, включение явной опции в каждый URL (т.е. `link_to(books_url(locale: I18n.locale))`) было бы утомительно и, вероятно, невозможно.

Rails содержит инфраструктуру для "централизации динамических решений об URL" в его `ApplicationController#default_url_options`, что полезно в этом сценарии: он позволяет нам назначить "defaults" для `url_for` и методов хелпера, основанных на нем (с помощью применения/переопределения метода `default_url_options`).

Затем мы можем включить что-то наподобие этого в наш `ApplicationController`:
```
# app/controllers/application_controller.rb
def default_url_options
  { locale: I18n.locale }
end
```
Каждый метод хелпера, зависимый от `url_for` (т.е. хелперы для именованных маршрутов, такие как `root_path` или `root_url`, ресурсные маршруты, такие как `books_path` или `books_url` и т.д.) теперь будут **автоматически включать локаль в строку запроса**, как тут: `http://localhost:3001/?locale=ja`.

Это может быть достаточным. Хотя и влияет на читаемость URL, когда локаль "висит" в конце каждого URL вашего приложения. Более того, с точки зрения архитектуры, локаль иерархически выше остальных частей домена приложения, и URL должен отражать это.

Вы, возможно, захотите, чтобы URL выглядел так: `http://www.example.com/en/books` (который загружает английскую локаль) и `http://www.example.com/nl/books` (который загружает голландскую локаль). Это достижимо с помощью такой же стратегии, как и с `default_url_options` выше: нужно настроить свои маршруты с помощью `scope`:
```
# config/routes.rb
scope "/:locale" do
  resources :books
end
```
Теперь, когда вы вызовете метод `books_path`, то получите "/en/books" (для локали по умолчанию). URL подобный `http://localhost:3001/nl/books` загрузит голландскую локаль, и затем, последующий вызов `books_path` возвратит "/nl/books" (поскольку локаль изменилась).

> Поскольку возвращаемое значение `default_url_options` кэшируется для каждого запроса, URL адреса в переключателе локали не могут быть сгенерированы при вызове хелперов в цикле, которые устанавливают соответствующие `I18n.locale` в каждой итерации. Вместо этого, не трогайте `I18n.locale` и передайте явно опцию `:locale` в хелпер или измените `request.original_fullpath`.

Если не хотите принудительно использовать локаль в своих маршрутах, можете использовать опциональную область пути (заключенную в скобки), как здесь:
```
# config/routes.rb
scope "(:locale)", locale: /en|nl/ do
  resources :books
end
```
С таким подходом вы не получите `Routing Error` при доступе к своим ресурсам как `http://localhost:3001/books` без локали. Это полезно, когда хочется использовать локаль по умолчанию, если она не определена.

Конечно, нужно специально позаботиться о корневом URL (это обычно "домашняя страница" или "лицевая панель") вашего приложения. URL, такой как `http://localhost:3001/nl` не заработает автоматически, так как объявление `root to: "books#index"` в вашем `routes.rb` не принимает локаль во внимание. (И правильно делает: может быть только один "корневой" URL.)

Вам, вероятно, потребуется связать URL так:
```
# config/routes.rb
get '/:locale' => 'dashboard#index'
```
Особенно побеспокойтесь относительно порядка ваших маршрутов, чтобы одно объявление маршрутов не "съело" другое. (Вы, возможно, захотите добавить его непосредственно перед объявлением `root :to`.)

> Обратите внимание на различные гемы, которые упрощают работу с роутами: `routing_filter`, `rails-translate-routes`, `route_translator`.

##### Указание локали из пользовательских настроек

В приложении с аутентифицированными пользователями можно позволять пользователям устанавливать предпочитаемую локаль через интерфейс приложения. В таком случае, выбранная пользователем установка локали является персистентной в базе данных и используется для установки локали в запросах этого пользователя.
```
around_action :switch_locale

def switch_locale(&action)
  locale = current_user.try(:locale) || I18n.default_locale
  I18n.with_locale(locale, &action)
end
```
##### Выбор предполагаемой локали

Когда локаль не была установлена явно для запроса (например, с помощью одного из представленных выше методов), приложение должно попытаться определить требуемую локаль.

###### Определение локали из языка заголовка

HTTP-заголовок `Accept-Language` указывает предпочтительный язык для отклика запроса. Браузеры устанавливают это значение заголовка на основании языковых настроек пользователя, что делает его хорошим выбором при определении локали.

Обычной реализацией использования заголовка `Accept-Language` будет следующее:
```
def switch_locale(&action)
  logger.debug "* Accept-Language: #{request.env['HTTP_ACCEPT_LANGUAGE']}"
  locale = extract_locale_from_accept_language_header
  logger.debug "* Locale set to '#{locale}'"
  I18n.with_locale(locale, &action)
end

private
  def extract_locale_from_accept_language_header
    request.env['HTTP_ACCEPT_LANGUAGE'].scan(/^[a-z]{2}/).first
  end
```
На практике, чтобы сделать это нужен более надежный код. Библиотека Iain Hecker's http_accept_language или промежуточное приложение Rack от Ryan Tomayko's locale предоставляют решения этой проблемы.

###### Определение локали по IP геолокации

IP-адрес клиента, выполняющего запрос, может использоваться для определения региона и его локали. Сервисы, такие как GeoIP Lite Country, или гемы, такие как geocoder могут быть использованы для реализации этого подхода.

В целом, этот подход является менее надежным, чем при использовании языка заголовка и не рекомендуется для большинства веб-приложений.

##### Хранение локали в сессии или куки

> Вы можете поддаться искушению хранить выбранную локаль в сессии или куки. Однако, не делайте этого. Локаль должна быть понятной и быть частью URL. В таком случае, вы не сломаете базовые представления людей о вебе: если вы отправляете URL друзьям, то они должны увидеть ту же самую страницу и то же содержимое. Причудливое слово для этого будет то, что вы будете спокойны - RESTful. Читайте более подробно о RESTful подходе в статье Stefan Tilkov. Иногда бывают исключения из этого правила, они описаны ниже.

## Интернационализация и Локализация <a name="5.3.4"></a>
### Абстракция локализованного кода
У нас есть две строки в нашем коде, которые на английском и которые будут рендериться пользователям в нашем отклике ("Hello Flash" и "Hello World"). Чтобы интернационализировать этот код, эти строки нужно заменить вызовами хелпера Rails `#t` с соответствующими ключами для каждой строки:
```
# app/controllers/home_controller.rb
class HomeController < ApplicationController
  def index
    flash[:notice] = t(:hello_flash)
  end
end

# app/views/home/index.html.erb
<h1><%= t :hello_world %></h1>
<p><%= flash[:notice] %></p>
```
Теперь при рендеринге вьюхи будет показано сообщение об ошибке, сообщающее, что отсутствуют переводы для ключей `:hello_world` и `:hello_flash`.

> Rails добавляет метод хелпера `t` (`translate`) во вьюхи, так что вам не нужно набирать `I18n.t` каждый раз. Дополнительно этот хелпер ловит отсутствующие переводы и оборачивает результирующее сообщение об ошибке в `<span class="translation_missing">`
  
#### Предоставление переводов для интернационализированных строк

Добавим отсутствующие переводы в файлы словарей:
```
# config/locales/en.yml
en:
  hello_world: Hello world!
  hello_flash: Hello flash!

# config/locales/pirate.yml
pirate:
  hello_world: Ahoy World
  hello_flash: Ahoy Flash
```
Так как `default_locale` не изменялась, переводы будут использовать :en локаль, и в отклике будут рендериться английские строки.
  
Если локаль будет установлена через URL на пиратскую локаль (`http://localhost:3000?locale=pirate`), то в отклике будут рендериться пиратские строки.

> Нужно перезагрузить сервер после того, как вы добавили новые файлы локали.

Для хранения переводов в SimpleStore можно использовать файлы YAML (`.yml`) или чистого Ruby (`.rb`). YAML является наиболее предпочитаемым вариантом среди разработчиков Rails. Однако у него есть один большой недостаток. YAML очень чувствителен к пробелам и спецсимволам, поэтому приложение может неправильно загрузить ваш словарь. Файлы Ruby уронят ваше приложение при первом же обращении, поэтому вам будет просто найти, что в них неправильно. (Если возникают "странности" со словарями YAML, попробуйте поместить соответствующие части словаря в файл Ruby.)

Если переводы хранятся в файлах YAML, определенные ключи должны быть экранированы. Вот они:
```
    true, on, yes
    false, off, no 
```
Примеры:
```
# config/locales/en.yml
en:
  success:
    'true':  'True!'
    'on':    'On!'
    'false': 'False!'
  failure:
    true:    'True!'
    off:     'Off!'
    false:   'False!'
```
```
I18n.t 'success.true'  # => 'True!'
I18n.t 'success.on'    # => 'On!'
I18n.t 'success.false' # => 'False!'
I18n.t 'failure.false' # => Translation Missing
I18n.t 'failure.off'   # => Translation Missing
I18n.t 'failure.true'  # => Translation Missing
```

#### Передача переменных в переводы
Один из ключевых факторов успешной интернационализации приложения - избегать неправильные предположения о грамматических правилах при абстракции локализованного кода. Грамматические правила, кажущиеся принципиальными в одной локали, могут быть неверными в другой.

Неправильная абстракция показана в следующем примере, где делается предположение о порядке в разных частях перевода. Обратите внимание, что Rails предоставляет хелпер `number_to_currency` для обработки следующего случая.
```
# app/views/products/show.html.erb
<%= "#{t('currency')}#{@product.price}" %>

# config/locales/en.yml
en:
  currency: "$"

# config/locales/es.yml
es:
  currency: "€"
```
Если цена продукта 10, тогда соответствующий перевод для испанского - "10 €", вместо "€10", но абстракция не может дать этого.

Для создания правильной абстракции, в геме `i18n` есть возможность, называемая интерполяцией переменных, которая позволяет вам использовать переменные в переводе определений и передавать значения этих переменных в метод перевода.

Правильная абстракция показана в следующем примере:
```
# app/views/products/show.html.erb
<%= t('product_price', price: @product.price) %>

# config/locales/en.yml
en:
  product_price: "$%{price}"

# config/locales/es.yml
es:
  product_price: "%{price} €"
```
Все грамматические и пунктуационные решения принимаются в самом определении, таким образом абстракция может дать верный перевод.

> Опции `default` и scope зарезервированы и не могут быть использованы как переменные. Если перевод использует `:default` или `:scope` как интерполяционную переменную, будет вызвано исключение `I18n::ReservedInterpolationKey`. Если перевод ожидает интерполяционную переменную, но она не была передана в `#translate`, вызовется исключение `I18n::MissingInterpolationArgument`.

#### Добавление форматов даты/времени

Хорошо! Теперь давайте добавим временную метку во вьюху, чтобы продемонстрировать особенности локализации даты/времени. Чтобы локализовать формат даты, нужно передать объект `Time` в `I18n.l`, или (лучше) использовать хелпер `Rails #l`. Формат можно выбрать передав опцию `:format` - по умолчанию используется формат `:default`.
```
# app/views/home/index.html.erb
<h1><%= t :hello_world %></h1>
<p><%= flash[:notice] %></p>
<p><%= l Time.now, format: :short %></p>
```
И в нашем файле переводов на пиратский давайте добавим формат времени (в Rails уже есть формат по умолчанию для английского):
```
# config/locales/pirate.yml
pirate:
  time:
    formats:
      short: "arrrround %H'ish"
```

> Сейчас вам, возможно, захочется добавить больше форматов для того, чтобы бэкенд `I18n` работал как нужно (как минимум для локали "pirate"). Конечно, есть большая вероятность, что кто-то еще выполнил всю работу по переводу значений по умолчанию Rails для вашей локали. Смотрите в репозитории `rails-i18n` на Github архив с различными файлами локали. Когда вы поместите такой файл(ы) в директорию `config/locales/`, они автоматически станут готовыми для использования.

#### Правила словообразования для других локалей

Rails позволяет определить правила словообразования (такие как единственное и множественное число) для локалей, отличных от английской. В `config/initializers/inflections.rb` можно определить эти правила для нескольких локалей. Инициализатор содержит пример по умолчанию для определения дополнительных правил для английского, следуйте этому формату для других локалей.

#### Локализованные вьюхи
Скажем, у вас в приложении есть `BooksController`. Экшн index рендерит содержимое в шаблоне `app/views/books/index.html.erb`. Когда вы помещаете локализованный вариант этого шаблона: `index.es.html.erb` в ту же директорию, Rails будет рендерить содержимое в этот шаблон, когда локаль будет установлена как `:es`. Когда будет установлена локаль по умолчанию, будет использована обычная вьюха `index.html.erb`. (Будущие версии Rails, возможно, перенесут эту возможность автоматической локализации ассетов в public, и т.д.)

Можете использовать эту особенность, например, при работе с большим количеством статичного содержимого, который было бы неудобно вложить в словари YAML или Ruby. Хотя имейте в виду, что любое изменение, которое вы в дальнейшем сделаете в шаблоне, должно быть распространено на все локали.

#### Организация файлов локали 
Организация файлов локали

При использовании дефолтного SimpleStore вместе с библиотекой i18n, словари хранятся в текстовых файлах на диске. Помещение переводов ко всем частям приложения в один файл на локаль будет трудным для управления. Можно хранить эти файлы в иерархии, которая будет для вас понятной.

К примеру, ваша директория `config/locales` может выглядеть так:
```
|-defaults
|---es.rb
|---en.rb
|-models
|---book
|-----es.rb
|-----en.rb
|-views
|---defaults
|-----es.rb
|-----en.rb
|---books
|-----es.rb
|-----en.rb
|---users
|-----es.rb
|-----en.rb
|---navigation
|-----es.rb
|-----en.rb
```
Таким образом можно разделить модель и имена атрибутов модели от текста внутри вьюх, и все это от "defaults" (т.е. форматов даты и времени). Другие хранилища для библиотеки i18n могут предоставить другие средства подобного разделения.

> Механизм загрузки локали по умолчанию в Rails не загружает файлы локали во вложенных словарях, как тут. Поэтому, чтобы это заработало, нужно явно указать Rails смотреть глубже:
```
  # config/application.rb
  config.i18n.load_path += Dir[Rails.root.join('config', 'locales', '**', '*.{rb,yml}')]
```
### Обзор особенностей I18n API <a name="5.3.4"></a>
#### Поиск переводов
##### Основы поиска, области имен и вложенных ключей
Переводы ищутся по ключам, которые могут быть как символами, так и строками, поэтому следующие вызовы эквивалентны:
```
I18n.t :message
I18n.t 'message'
```
Метод translate также принимает опцию :scope, которая содержит один или более дополнительных ключей, которые будут использованы для определения "пространства" или области имен для ключа перевода:
```
I18n.t :record_invalid, scope: [:activerecord, :errors, :messages]
```
Тут будет искаться сообщение `:record_invalid` в сообщениях об ошибке Active Record.

Кроме того, и ключ, и область имен могут быть определены как ключи с точкой в качестве разделителя, как в:
```
I18n.translate "activerecord.errors.messages.record_invalid"
```
Таким образом, следующие вызовы эквивалентны:
```
I18n.t 'activerecord.errors.messages.record_invalid'
I18n.t 'errors.messages.record_invalid', scope: :activerecord
I18n.t :record_invalid, scope: 'activerecord.errors.messages'
I18n.t :record_invalid, scope: [:activerecord, :errors, :messages]
```

##### Значения по умолчанию

Когда задана опция `:default`, будет возвращено ее значение в случае, если отсутствует перевод:
```
I18n.t :missing, default: 'Not here'
# => 'Not here'
```
Если значение `:default` является символом, оно будет использовано как ключ и будет переведено. Может быть представлено несколько значений по умолчанию. Будет возвращено первое, которое даст результат.

Т.е., следующее попытается перевести ключ `:missing`, затем ключ `:also_missing`. Если они оба не дадут результат, будет возвращена строка "Not here":
```
I18n.t :missing, default: [:also_missing, 'Not here']
# => 'Not here'
```
Чтобы найти несколько переводов за раз, может быть передан массив ключей:
```
I18n.t [:odd, :even], scope: 'errors.messages'
# => ["must be odd", "must be even"]
```
Также ключ может перевести хэш (потенциально вложенный) сгруппированных переводов. Т.е. следующее получит все сообщения об ошибке `Active Record` как хэш:
```
I18n.t 'activerecord.errors.messages'
# => {:inclusion=>"is not included in the list", :exclusion=> ... }
```

##### Массовый поиск и поиск в пространстве имен
Если хотите выполнить интерполяцию на вложенном хэше переводов, необходимо передать параметром `deep_interpolation: true`. Когда у вас есть следующий словарь:
```
en:
  welcome:
    title: "Welcome!"
    content: "Welcome to the %{app_name}"
```
тогда вложенные интерполяции будут проигнорированы без этой настройки:
```
I18n.t 'welcome', app_name: 'book store'
# => {:title=>"Welcome!", :content=>"Welcome to the %{app_name}"}

I18n.t 'welcome', deep_interpolation: true, app_name: 'book store'
# => {:title=>"Welcome!", :content=>"Welcome to the book store"}
```
##### "Ленивый" поиск

Rails реализует удобный способ поиска локали внутри вьюх. Когда имеется следующий словарь:
```
es:
  books:
    index:
      title: "Título"
```
можно найти значение `books.index.title` в шаблоне `app/views/books/index.html.erb` таким образом (обратите внимание на точку):
```
<%= t '.title' %>
```
Автоматический скоупинг перевода доступен только из метода хелпера вьюхи `translate`.

"Ленивый" поиск также может быть использован в контроллерах:
```
en:
  books:
    create:
      success: Book created!
```
Это может быть полезным для установки флеш сообщений:
```
class BooksController < ApplicationController
  def create
    # ...
    redirect_to books_url, notice: t('.success')
  end
end
```

#### Множественное число
Во многих языках — включая английский — есть только две формы, единственного числа и множественного числа, для заданной строки, т.е. "1 message" и "2 messages". В других языках: (русском, арабском, японском и многих других) имеются различные правила грамматики, имеющие дополнительные или отсутствующие формы множественного числа. Таким образом, API I18n предоставляет гибкую возможность для форм множественного числа.

У переменной интерполяции `:count` есть специальная роль в том, что она интерполируется для перевода, и используется для подбора множественного числа для перевода в соответствии с правилами множественного числа, определенными в бэкенде множественного числа. По умолчанию применяются правила множественного числа только для английского языка.
```
I18n.backend.store_translations :en, inbox: {
  zero: 'no messages', # опционально
  one: 'one message',
  other: '%{count} messages'
}
I18n.translate :inbox, count: 2
# => '2 messages'

I18n.translate :inbox, count: 1
# => 'one message'

I18n.translate :inbox, count: 0
# => 'no messages'
```
Алгоритм для образования множественного числа в `:en` прост:
```
lookup_key = :zero if count == 0 && entry.has_key?(:zero)
lookup_key ||= count == 1 ? :one : :other
entry[lookup_key]
```
Перевод помеченный как `:one`, рассматривается как единственное число, все другое как множественное. Если количество нулевое, и существует запись `:zero`, тогда будет использоваться она вместо `:other`.

Если поиск по ключу не возвратит хэш, подходящий для образования множественного числа, вызовется исключение `I18n::InvalidPluralizationData`.

##### Локализованные правила
Гем I18n предоставляет бэкенд множественного числа, который может использоваться для включения правил локализации. Добавьте это в простой бэкенд, затем добавьте алгоритмы для локализации множественного числа в хранилище переводов, как `i18n.plural.rule`.
```
I18n::Backend::Simple.include(I18n::Backend::Pluralization)
I18n.backend.store_translations :pt, i18n: { plural: { rule: lambda { |n| [0, 1].include?(n) ? :one : :other } } }
I18n.backend.store_translations :pt, apples: { one: 'one or none', other: 'more than one' }

I18n.t :apples, count: 0, locale: :pt
# => 'one or none'
```
В качестве альтернативы, отдельный гем `rails-i18n` может быть использован для обеспечения более полного набора локализованных правил множественного числа.

#### Настройка и передача локали
Локаль может быть либо установленной псевдо-глобально в `I18n.locale` (когда используется `Thread.current`, например `Time.zone`), либо быть переданной опцией в `#translate` и `#localize`.

Если локаль не была передана, используется `I18n.locale`:
```
I18n.locale = :de
I18n.t :foo
I18n.l Time.now
```
Явно переданная локаль:
```
I18n.t :foo, locale: :de
I18n.l Time.now, locale: :de
```
Умолчанием для `I18n.locale` является `I18n.default_locale`, для которой по умолчанию установлено `:en`. Локаль по умолчанию может быть установлена так:
```
I18n.default_locale = :de
```

#### Использование HTML-безопасных переводов

Ключи с суффиксом _html и ключами с именем html помечаются как HTML-безопасные. При их использовании во вьюхах, HTML не будет экранирован.

# config/locales/en.yml
en:
  welcome: <b>welcome!</b>
  hello_html: <b>hello!</b>
  title:
    html: <b>title!</b>

# app/views/home/index.html.erb
<div><%= t('welcome') %></div>
<div><%= raw t('welcome') %></div>
<div><%= t('hello_html') %></div>
<div><%= t('title.html') %></div>

Интерполяция экранируется по мере необходимости. Например, учитывая:
```
en:
  welcome_html: "<b>Welcome %{username}!</b>"
```
вы можете спокойно передать имя пользователя, установленное пользователем:
```
<%# This is safe, it is going to be escaped if needed. %>
<%= t('welcome_html', username: @current_user.username) %>
```
С другой стороны, безопасные строки интерполируются дословно.

Автоматическое преобразование в HTML-безопасный текст перевода доступен только для метода хелпера вьюхи `translate`.

#### Переводы для моделей Active Record

Можете использовать методы `Model.model_name.human` и `Model.human_attribute_name(attribute)` для прозрачного поиска переводов для ваших моделей и имен атрибутов.

Например, когда добавляем следующие переводы:
```
en:
  activerecord:
    models:
      user: Customer
    attributes:
      user:
        login: "Handle"
      # переводит атрибут "login" у User как "Handle"
```
Тогда `User.model_name.human` возвратит "Customer", а `User.human_attribute_name("login")` возвратит "Handle".

Для имен модели также можно установить множественное число, добавив следующее:
```
en:
  activerecord:
    models:
      user:
        one: Customer
        other: Customers
```
Тогда `User.model_name.human(count: 2)` возвратит "Customers". С `count: 1` или без параметров возвратит "Customer".

В случае необходимости получить доступ к вложенным атрибутам модели, следует показать эту вложенность в виде `model/attribute` на уровне модели в файле переводов:
```
en:
  activerecord:
    attributes:
      user/role:
        admin: "Admin"
        contributor: "Contributor"
```
Тогда `User.human_attribute_name("role.admin")` возвратит "Admin".

> Если используется класс, включающий `ActiveModel`, но не наследованный от `ActiveRecord::Base`, замените `activerecord` на `activemodel` в вышеприведенных путях ключей.

##### Пространства имен сообщений об ошибке

Сообщение об ошибке валидации Active Record также может быть легко переведено. Active Record предоставляет ряд пространств имен, куда можно поместить ваши переводы для передачи различных сообщений и переводы для определенных моделей, атрибутов и/или валидаций. Также учитывается одиночное наследование таблицы (single table inheritance).

Это дает довольно мощное средство для гибкой настройки ваших сообщений в соответствии с потребностями приложения.

Рассмотрим модель User с валидацией `validates_presence_of` для атрибута name, подобную следующей:
```
class User < ApplicationRecord
  validates :name, presence: true
end
```
Ключом для сообщения об ошибке в этом случае будет `:blank`. Active Record будет искать этот ключ в пространствах имен:
```
activerecord.errors.models.[model_name].attributes.[attribute_name]
activerecord.errors.models.[model_name]
activerecord.errors.messages
errors.attributes.[attribute_name]
errors.messages
```
Таким образом, в нашем примере он будет перебирать следующие ключи в указанном порядке и возвратит первый полученный результат:
```
activerecord.errors.models.user.attributes.name.blank
activerecord.errors.models.user.blank
activerecord.errors.messages.blank
errors.attributes.name.blank
errors.messages.blank
```
Когда ваши модели дополнительно используют наследование, тогда сообщения ищутся в цепочке наследования.

Например, у вас может быть модель `Admin`, унаследованная от `User`:
```
class Admin < User
  validates :name, presence: true
end
```
Тогда Active Record будет искать сообщения в этом порядке:
```
activerecord.errors.models.admin.attributes.name.blank
activerecord.errors.models.admin.blank
activerecord.errors.models.user.attributes.name.blank
activerecord.errors.models.user.blank
activerecord.errors.messages.blank
errors.attributes.name.blank
errors.messages.blank
```
Таким образом можно предоставить специальные переводы для различных сообщений об ошибке в различных местах цепочки наследования моделей и в атрибутах, моделях и пространствах имен по умолчанию.

##### Интерполяция сообщения об ошибке
Переведенное имя модели, переведенное имя атрибута и значение всегда доступны для интерполяции как `model`, `attribute` и `value` соответственно.

Так, к примеру, вместо сообщения об ошибке по умолчанию "cannot be blank" можете использовать имя атрибута как тут: "Please fill in your %{attribute}".
* Где это возможно, `count` может быть использован для множественного числа, если оно существует: 
```
валидация 	  с опцией 	    сообщение 	      интерполяция
confirmation 	  - 	        :confirmation 	  attribute
acceptance 	    - 	        :accepted 	      -
presence 	      - 	        :blank 	          -
absence 	      - 	        :present 	        -
length 	      :within, :in 	:too_short 	      count
length 	      :within, :in 	:too_long 	      count
length 	      :is 	        :wrong_length 	  count
length 	      :minimum 	    :too_short 	      count
length 	      :maximum 	    :too_long 	      count
uniqueness 	    - 	        :taken 	          -
format 	        - 	        :invalid 	        -
inclusion 	    - 	        :inclusion 	      -
exclusion 	    - 	        :exclusion 	      -
associated 	    - 	        :invalid 	        -
non-optional association 	- :required 	      -
numericality 	  - 	        :not_a_number 	  -
numericality :greater_than 	:greater_than 	  count
numericality :greater_than_or_equal_to 	:greater_than_or_equal_to 	count
numericality 	:equal_to 	:equal_to 	count
numericality 	:less_than 	:less_than 	count
numericality 	:less_than_or_equal_to 	:less_than_or_equal_to 	count
numericality 	:other_than 	:other_than 	count
numericality 	:only_integer 	:not_an_integer 	-
numericality 	:odd 	:odd 	-
numericality 	:even 	:even 	-
```

#### Перевод для тем писем Action Mailer

Если не передать `subject` в метод mail, Action Mailer попытается найти ее в ваших переводах. Выполняемый поиск будет использовать паттерн `<mailer_scope>.<action_name>.subject` для создания ключа.
```
# user_mailer.rb
class UserMailer < ActionMailer::Base
  def welcome(user)
    #...
  end
end

en:
  user_mailer:
    welcome:
      subject: "Welcome to Rails Guides!"
```
Чтобы отослать параметры в интерполяцию, используйте в рассыльщике метод `default_i18n_subject`.
```
# user_mailer.rb
class UserMailer < ActionMailer::Base
  def welcome(user)
    mail(to: user.email, subject: default_i18n_subject(user: user.name))
  end
end

en:
  user_mailer:
    welcome:
      subject: "%{user}, welcome to Rails Guides!"
```
##### Методы хелпера Action View
* `distance_of_time_in_words` переводит и образует множественное число своего результата и интерполирует число секунд, минут, часов и т.д.
* `datetime_select` и `select_month` используют переведенные имена месяцев для заполнения результирующего тега `select`. `datetime_select` также ищет опцию `order` из `date.order` (если вы передали эту опцию явно). Все хелперы выбора даты переводят `prompt`, используя переводы в пространстве имен `datetime.prompts`, если применимы.
* Хелперы `number_to_currency`, `number_with_precision`, `number_to_percentage`, `number_with_delimiter` и `number_to_human_size` используют настройки формата чисел в пространстве имен `number`. 

##### Методы Active Model
* `human_name` и `human_attribute_name` используют переводы для имен модели и имен атрибутов, если они доступны в пространстве имен `activerecord.models`. Они также предоставляют переводы для имен унаследованного класса (т.е. для использования вместе с STI), как уже объяснялось выше в "Области сообщения об ошибке".
* `ActiveModel::Errors#generate_message` (который используется валидациями `Active Model`, но также может быть использован вручную) использует `human_name` и `human_attribute_name` (смотрите выше). Он также переводит сообщение об ошибке и поддерживает переводы для имен унаследованного класса, как уже объяснялось выше в "Пространства имен сообщений об ошибке".
* `ActiveModel::Errors#full_messages` добавляет имя атрибута к сообщению об ошибке, используя разделитель, который берется из `errors.format` (и по умолчанию равен `"%{attribute} %{message}"`). 

##### Методы Active Support
* `Array#to_sentence` использует настройки формата, которые заданы в пространстве имен `support.array`.

### Как хранить свои переводы <a name="5.3.5"></a>

Простой бэкенд, поставляющийся вместе с `Active Support`, позволяет хранить переводы как в формате чистого Ruby, так и в YAML.

Например, представляющий перевод хэш Ruby выглядит так:
```
{
  pt: {
    foo: {
      bar: "baz"
    }
  }
}
```
Эквивалентный файл YAML выглядит так:
```
pt:
  foo:
    bar: baz
```
Как видите, в обоих случаях ключ верхнего уровня является локалью. `:foo` - это ключ пространства имен, а `:bar` - это ключ для перевода "baz".

Вот "реальный" пример из YAML файла перевода Active Support `en.yml`:
```
en:
  date:
    formats:
      default: "%Y-%m-%d"
      short: "%b %d"
      long: "%B %d, %Y"
```
Таким образом, все из нижеследующих эквивалентов возвратит краткий (`:short`) формат даты "%b %d":
```
I18n.t 'date.formats.short'
I18n.t 'formats.short', scope: :date
I18n.t :short, scope: 'date.formats'
I18n.t :short, scope: [:date, :formats]
```
Как правило, мы рекомендуем использовать YAML как формат хранения переводов. Хотя имеются случаи, когда хочется хранить лямбда-функции Ruby как часть данных локали, например, для специальных форматов дат.

### Настройка I18n <a name="5.3.6"></a>
#### Использование различных бэкендов
Впрочем, это не означает, что вы связаны этими ограничениями. Гем Ruby I18n позволяет с легкостью заменить простой бэкенд на что-то иное, более предпочтительное для ваших нужд, передавая экземпляр бэкенда в сеттер `I18n.backend=`:

Например, можно заменить простой бэкенд на бэкенд Chain для связывания нескольких бэкендов вместе. Это полезно, когда используются стандартные переводы с помощью простого бэкенда, а хранятся собственные переводы приложения в базе данных или других бэкендах.

С помощью бэкенда Chain можно использовать бэкенд Active Record и вернуться к простому бэкенду (по умолчанию):
```
I18n.backend = I18n::Backend::Chain.new(I18n::Backend::ActiveRecord.new, I18n.backend)
```
#### Использование различных обработчиков исключений
API I18n определяет следующие исключения, вызываемые бэкендами, когда происходят соответствующие неожидаемые условия:
```
MissingTranslationData       # не обнаружен перевод для запрашиваемого ключа
InvalidLocale                # локаль, установленная I18n.locale, невалидна (например, nil)
InvalidPluralizationData     # была передана опция count, но данные для перевода не могут быть возведены во множественное число
MissingInterpolationArgument # перевод ожидает интерполяционный аргумент, который не был передан
ReservedInterpolationKey     # перевод содержит зарезервированное имя интерполяционной переменной (т.е. scope, default)
UnknownFileType              # бэкенд не знает, как обработать тип файла, добавленного в I18n.load_path
```
API I18n поймает все эти исключения, когда они были вызваны в бэкенде, и передаст их в метод `default_exception_handler`. Этот метод вызовет заново все исключения, кроме исключений `MissingTranslationData`. Когда было вызвано исключение `MissingTranslationData`, он возвратит строку сообщения об ошибке исключения, содержащую отсутствующие ключ/пространство имен.

Причиной для этого является то, что при разработке вам обычно хочется, чтобы вьюхи рендерились несмотря на отсутствующие переводы.

Впрочем, в иных ситуациях, возможно, захочется изменить это поведение. Например, обработка исключений по умолчанию не позволяет просто ловить отсутствующие переводы во время автоматических тестов. Для этой цели может быть определен иной обработчик исключений. Определенный обработчик исключений должен быть методом в модуле I18n или классом с методом `#call`:
```
module I18n
  class JustRaiseExceptionHandler < ExceptionHandler
    def call(exception, locale, key, options)
      if exception.is_a?(MissingTranslationData)
        raise exception.to_exception
      else
        super
      end
    end
  end
end

I18n.exception_handler = I18n::JustRaiseExceptionHandler.new
```
Это вызовет только исключение `MissingTranslationData`, передав все другие значения в обработчик исключений по умолчанию.

Однако, если вы используете `I18n::Backend::Pluralization`, этот обработчик также вызывает исключение `I18n::MissingTranslationData: translation missing: en.i18n.plural.rule`, которое обычно должно быть проигнорировано для отката к правилу плюрализации по умолчанию в английской локали. Чтобы этого избежать, можно добавить дополнительную проверку ключа перевода:
```
if exception.is_a?(MissingTranslationData) && key.to_s != 'i18n.plural.rule'
  raise exception.to_exception
else
  super
end
```
Другим примером, когда поведение по умолчанию является менее желательным, является `Rails TranslationHelper`, который предоставляет метод `#t` (то же самое, что `#translate`). Когда в этом контексте происходит исключение `MissingTranslationData` хелпер оборачивает сообщение в span с классом CSS `translation_missing`.

Чтобы это осуществить, хелпер заставляет `I18n#translate` вызвать исключения, независимо от того, какой обработчик исключений установлен, определяя опцию `:raise`:
```
I18n.t :foo, raise: true # всегда перевызывает исключения из бэкенда
```
### Перевод контента модели <a name="5.3.7"></a>
API I18n, описанный в этом руководстве, в первую очередь предназначен для перевода строк интерфейса. Если необходимо перевести контент модели (например, сообщений в блоге), может понадобится другое решение, помогающее в этом.

Несколько гемов, которые могут помочь:
* Globalize: Хранит переводы в отдельных таблицах перевода, по одному для каждой переведенной модели
* Mobility: Предоставляет поддержку для хранения переводов во многих форматах, включая таблицы перевода, столбцы json (PostgreSQL) и т.д.
* Traco: Переводимые столбцы для Rails 3 и 4, хранимые в самой таблице моделей

### Заключение <a name="5.3.8"></a>

С этого момента у вас должно быть хорошее понимание, как работает поддержка I18n в Ruby on Rails, и вы должны быть готовы начать переводить свой проект.

### Вклад в Rails I18n <a name="5.3.9"></a>

Поддержка I18n в Ruby on Rails была представлена в релизе 2.2 и до сих пор развивается. Проект следует хорошим традициям разработки Ruby on Rails в виде первоначального развития в виде отдельных гемов и реальных приложений, и только затем извлечения наилучших широко используемых особенностей для включения в ядро.

Поэтому каждый поощряется экспериментировать с новыми идеями и особенностями в гемах или других библиотеках и делать их доступными сообществу.

### Ресурсы <a name="5.3.10"></a>
* Группа Google: rails-i18n - Рассылка проекта.
* GitHub: rails-i18n - Репозиторий кода и трекер проблем для проекта rails-i18n. Много важного можно найти в примере переводов для Rails, в большинстве случаев это будет работать и в вашем приложении.
* GitHub: i18n - Репозиторий кода и трекер проблем для гема i18n. 

### Авторы <a name="5.3.11"></a>
 * Sven Fuchs (первоначальный автор)
 * Karel Minařík 

## Безопасность приложений Rails <a name="5.4"></a>
Это руководство представит вам все, что нужно для того, чтобы отправлять электронную почту в вашем приложении, и раскроет множество внутренних методов Action Mailer. Оно также раскроет, как тестировать ваши рассыльщики.

После прочтения этого руководства, вы узнаете:
* Как отправлять письма в приложении Rails.
* Как генерировать и редактировать класс Action Mailer и вьюху рассыльщика.
* Как настраивать Action Mailer для своей среды.
* Как тестировать свои классы Action Mailer. 

Action Mailer позволяет отправлять электронные письма из приложения, используя классы и вьюхи рассыльщика.
#### Рассыльщики похожи на контроллеры

Они наследуются от `ActionMailer::Base`, и находятся в `app/mailers`. Рассыльщики также работают подобно контроллерами. Некоторые общие черты перечислены ниже. У рассыльщиков есть:
* Экшны, а также связанные вьюхи, которые располагаются в app/views.
* Переменные экземпляра, доступные во вьюхах.
* Возможность использовать макеты и партиалы.
* Возможность доступа к хэшу params.

### Пошаговое руководство по генерации рассыльщика <a name="5.4.1"></a>
#### Создаем рассыльщик

```
$ rails generate mailer UserMailer
create  app/mailers/user_mailer.rb
create  app/mailers/application_mailer.rb
invoke  erb
create    app/views/user_mailer
create    app/views/layouts/mailer.text.erb
create    app/views/layouts/mailer.html.erb
invoke  test_unit
create    test/mailers/user_mailer_test.rb
create    test/mailers/previews/user_mailer_preview.rb
```
```
# app/mailers/application_mailer.rb
class ApplicationMailer < ActionMailer::Base
  default from: "from@example.com"
  layout 'mailer'
end

# app/mailers/user_mailer.rb
class UserMailer < ApplicationMailer
end
```
Если не хотите использовать генератор, можно создать свой файл в `app/mailers`, просто убедитесь, что он унаследован от `ActionMailer::Base`:
```
class MyMailer < ActionMailer::Base
end
```
#### Редактируем рассыльщик

У рассыльщиков есть методы, называемые "экшнами", и они используют вьюхи для структурирования своего контента. В то время, когда контроллер генерирует контент, например HTML, для возврата его на клиент, рассыльщик создает сообщение для доставки по электронной почте.

`app/mailers/user_mailer.rb` содержит пустой рассыльщик:
```
class UserMailer < ApplicationMailer
end
```
Давайте добавим метод, названный `welcome_email`, который будет посылать email на зарегистрированный адрес email пользователя:
```
class UserMailer < ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email, subject: 'Welcome to My Awesome Site')
  end

end
```
Вот краткое описание элементов, представленных в этом методе.
* Хэш `default` - это хэш значений по умолчанию для любых рассылаемых вами email из этого рассыльщика. В этом случае мы присваиваем заголовку `:from` значение для всех сообщений в этом классе. Это может быть переопределено для отдельного письма.
* `mail` - фактическое сообщение `email`, куда мы передаем заголовки `:to` и `:subject`. 
##### Создаем вьюху рассыльщика
Создадим файл, названный `welcome_email.html.erb в app/views/user_mailer/`. Это будет шаблоном, используемым для email, форматированным в HTML:
```
<!DOCTYPE html>
<html>
  <head>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type' />
  </head>
  <body>
    <h1>Welcome to example.com, <%= @user.name %></h1>
    <p>
      You have successfully signed up to example.com,
      your username is: <%= @user.login %>.<br>
    </p>
    <p>
      To login to the site, just follow this link: <%= @url %>.
    </p>
    <p>Thanks for joining and have a great day!</p>
  </body>
</html>
```
Давайте также создадим текстовую часть для этого email. Не все клиенты предпочитают письма HTML, и рассылка обоих является лучшей практикой. Для этого создайте файл с именем `welcome_email.text.erb` в app/views/user_mailer/.
```
Welcome to example.com, <%= @user.name %>
===============================================

You have successfully signed up to example.com,
your username is: <%= @user.login %>.

To login to the site, just follow this link: <%= @url %>.

Thanks for joining and have a great day!
```
Теперь при вызове метода mail, Action Mailer обнаружит два шаблона (text и HTML) и автоматически сгенерирует `multipart/alternative` email.
##### Вызов рассыльщика
Рассыльщики - это всего лишь другой способ отрендерить вьюху. Вместо рендеринга вьюхи и отсылки ее по протоколу HTTP, они всего лишь вместо этого отправляют ее по протоколам email. Благодаря этому имеет смысл, чтобы контроллер сказал рассыльщику отослать письмо тогда, когда пользователь был успешно создан.

Настроить это просто.

Во первых, давайте создадим простой скаффолд User:
```
$ rails generate scaffold user name email login
$ rails db:migrate
```
Теперь, когда у нас есть модель user, с которой мы играем, надо всего лишь отредактировать `app/controllers/users_controller.rb`, чтобы поручить `UserMailer` доставлять email каждому вновь созданному пользователю, изменив экшн create и вставив вызов `UserMailer.with(user: @user).welcome_email` сразу после того, как пользователь был успешно сохранен.

Action Mailer прекрасно интегрирован с Active Job, поэтому можно отправлять электронную почту вне цикла запрос-отклик, таким образом что пользователю не нужно ждать выполнения отправки:
```
class UsersController < ApplicationController
  # POST /users
  # POST /users.json
  def create
    @user = User.new(params[:user])

    respond_to do |format|
      if @user.save
        # Сказать UserMailer отослать приветственное письмо после сохранения
        UserMailer.with(user: @user).welcome_email.deliver_later

        format.html { redirect_to(@user, notice: 'User was successfully created.') }
        format.json { render json: @user, status: :created, location: @user }
      else
        format.html { render action: 'new' }
        format.json { render json: @user.errors, status: :unprocessable_entity }
      end
    end
  end
end
```
> Поведением Active Job по умолчанию является выполнение заданий с помощью адаптера `:async`. Поэтому можно использовать `deliver_later` для отсылки писем прямо сейчас асинхронно. Адаптер `Active Job` по умолчанию запускает задания с помощью пула тредов внутри процесса. Это хорошо подходит для сред `development/test`, так как не требует какой-либо внешней инфраструктуры, но плохо подходит для `production`, так как он теряет отложенные задания при перезагрузке. Если нужен персистентный бэкенд, необходимо использовать адаптер Active Job, у которого такой бэкенд есть (Sidekiq, Resque и т.п.).

> При вызове `deliver_later`, задание будет помещено в очередь `mailers`. Убедитесь, что адаптер Active Job поддерживает ее, иначе это задание будет молча проигнорировано, что предотвратит отправку письма. Ее можно изменить, указав в опции `config.action_mailer.deliver_later_queue_name`.

Если хотите отправлять письма прямо сейчас в любом случае (например, из крона) просто вызовите `deliver_now`:
```
class SendWeeklySummary
  def run
    User.find_each do |user|
      UserMailer.with(user: user).weekly_summary.deliver_now
    end
  end
end
```
Любая пара ключ/значение, переданная в `with`, просто становится `params` для экшна рассыльщика. Поэтому `with(user: @user, account: @user.account)` делает `params[:user]` и `params[:account]` доступными в экшне рассыльщика. Это такой же `params`, который есть в контроллерах.

Метод `welcome_email` возвращает объект `ActionMailer::MessageDelivery`, которому затем можно сказать `deliver_now` или `deliver_later`, чтобы он сам себя отослал. Объект `ActionMailer::MessageDelivery` — это всего лишь обертка для `Mail::Message`. Если хотите исследовать, изменить или еще что-то сделать с объектом `Mail::Message`, к нему можно получить доступ с помощью метода `message` на объекте `ActionMailer::MessageDelivery`.

#### Автоматическое кодирование значений заголовка
Action Mailer осуществляет автоматическое кодирование многобайтовых символов в заголовках и телах.

Для более сложных примеров, таких, как определение альтернативных кодировок или самокодировок текста, обратитесь к библиотеке `Mail`.

#### Полный перечень методов Action Mailer

Имеется всего три метода, необходимых для рассылки почти любых сообщений email:
* `headers` - Определяет любой заголовок email. Можно передать хэш пар имен и значений полей заголовка, или можно вызвать `headers[:field_name] = 'value'`
* `attachments` - Позволяет добавить прикрепленные файлы в email. Например, `attachments['file-name.jpg'] = File.read('file-name.jpg')`
* `mail` - Фактически отсылает сам email. Можете передать в headers хэш к методу mail как параметр, mail затем создаст email, или чистый текст, или `multipart`, в зависимости от определенных вами шаблонов email. 

##### Добавление прикрепленных файлов
В Action Mailer очень просто добавить прикрепленные файлы.

Передайте имя файла и содержимое, и Action Mailer и гем Mail автоматически определят `mime_type`, установят кодировку и создадут прикрепленные файлы.
```
    attachments['filename.jpg'] = File.read('/path/to/filename.jpg')
```
Когда будет вызван метод mail, он отправит multipart email с прикрепленным файлом, должным образом вложенным в верхний уровень, являющийся `multipart/mixed`, и первая часть будет `multipart/alternative`, содержащая чистый текст и сообщения HTML.

> Mail автоматически кодирует прикрепленный файл в Base64. Если хотите что-то иное, закодируйте свое содержимое и передайте в кодированном содержимом, и укажите кодировку в хэше в методе `attachments`.

Передайте имя файла и определите заголовки и содержимое, и Action Mailer и Mail будут использовать переданные вами настройки.
```
    encoded_content = SpecialEncode(File.read('/path/to/filename.jpg'))
    attachments['filename.jpg'] = {
      mime_type: 'application/gzip',
      encoding: 'SpecialEncoding',
      content: encoded_content
    }
```
> Если указать кодировку, Mail будет полагать, что ваше содержимое уже кодировано в ней и не попытается кодировать в Base64.

##### Создание встроенных прикрепленных файлов
Action Mailer 3.0 создает встроенные прикрепленные файлы, которые вовлекали множество хаков в версиях до 3.0, более просто и обычно, так, как и должно было быть.
  Сперва, чтобы сказать Mail превратить прикрепленные файлы во встроенные прикрепленные файлы, надо всего лишь вызвать `#inline` на методе `attachments` в рассыльщике:
```
    def welcome
      attachments.inline['image.jpg'] = File.read('/path/to/image.jpg')
    end
```
   Затем, во вьюхе можно просто сослаться на `attachments` как хэш и определить, какой прикрепленный файл необходимо отобразить, вызвав url на нем, и затем передать результат в метод `image_tag`:
```
    <p>Hello there, this is our image</p>

    <%= image_tag attachments['image.jpg'].url %>
```
   Так как это стандартный вызов `image_tag`, можно передать хэш опций после URL прикрепленного файла, как это делается для любого другого изображения:
```
    <p>Hello there, this is our image</p>

    <%= image_tag attachments['image.jpg'].url, alt: 'My Photo', class: 'photos' %>
```
##### Рассылка Email нескольким получателям
Возможно отослать email одному и более получателям в одном письме (например, информируя всех админов о новой регистрации пользователя), настроив список адресов email в ключе `:to`. Перечень email может быть массивом или отдельной строкой с адресами, разделенными запятыми.
```
class AdminMailer < ApplicationMailer
  default to: -> { Admin.pluck(:email) },
          from: 'notification@example.com'

  def new_registration(user)
    @user = user
    mail(subject: "New User Signup: #{@user.email}")
  end
end
```
Тот же формат может быть использован для назначения получателей копии (`Cc:`) и скрытой копии (`Bcc:`), при использовании ключей `:cc` и `:bcc` соответственно.

##### Рассылка Email с именем
Иногда хочется показать имена людей вместо их электронных адресов, при получении ими email. Фокус в том, что формат адреса email следующий "Full Name" <email>.
```
def welcome_email
  @user = params[:user]
  email_with_name = %("#{@user.name}" <#{@user.email}>)
  mail(to: email_with_name, subject: 'Welcome to My Awesome Site')
end
```
  
#### Вьюхи рассыльщика
Вьюхи рассыльщика расположены в директории `app/views/name_of_mailer_class`. Определенная вьюха рассыльщика известна классу, поскольку у нее имя такое же, как у метода рассыльщика. Так, в нашем примере, вьюха рассыльщика для метода `welcome_email` будет в `app/views/user_mailer/welcome_email.html.erb` для версии HTML и `welcome_email.text.erb` для обычной текстовой версии.

Чтобы изменить вьюху рассыльщика по умолчанию для вашего экшна, сделайте так:
```
class UserMailer < ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site',
         template_path: 'notifications',
         template_name: 'another')
  end
end
```
В этом случае он будет искать шаблон в `app/views/notifications` с именем `another`. Также можно определить массив путей для `template_path`, и они будут искаться в указанном порядке.

Если желаете большей гибкости, также возможно передать блок и рендерить определенный шаблон или даже рендерить вложенный код или текст без использования файла шаблона:
```
class UserMailer < ApplicationMailer
  default from: 'notifications@example.com'

  def welcome_email
    @user = params[:user]
    @url  = 'http://example.com/login'
    mail(to: @user.email,
         subject: 'Welcome to My Awesome Site') do |format|
      format.html { render 'another_template' }
      format.text { render plain: 'Render text' }
    end
  end

end
```
Это отрендерит шаблон 'another_template.html.erb' для HTML части и использует 'Render text' для текстовой части. Команда render та же самая, что используется в Action Controller, поэтому можете использовать те же опции, такие как `:text`, `:inline` и т.д.

Если хотите отрендерить шаблон, расположенный вне директории по умолчанию `app/views/mailer_name/`, можно применить `prepend_view_path`, следующим образом:
```
class UserMailer < ApplicationMailer
  prepend_view_path "custom/path/to/mailer/view"

  # Это попытается загрузить шаблон "custom/path/to/mailer/view/welcome_email"
  def welcome_email
    # ...
  end
end
```
Также рассмотрите использование метода `append_view_path` method.

##### Кэширование вьюх рассыльщика

Во вьюхах рассыльщика можно выполнять кэширование фрагментов так же, как и во вьюхах приложения, с помощью метода `cache`.
```
<% cache do %>
  <%= @company.name %>
<% end %>
```
И чтобы использовать эту особенность, необходимо настроить приложение следующим образом:
```
  config.action_mailer.perform_caching = true
```
Кэширование фрагментов также поддерживается в `multipart` письмах. Подробнее читайте в руководстве Кэширование с Rails.

#### Макеты Action Mailer
Как и во вьюхах контроллера, можно также иметь макеты рассыльщика. Имя макета должно быть таким же, как у вашего рассыльщика, таким как `user_mailer.html.erb` и `user_mailer.text.erb`, чтобы автоматически распознаваться вашим рассыльщиком как макет.

Чтобы задействовать другой файл, вызовите layout в своем рассыльщике:
```
class UserMailer < ApplicationMailer
  layout 'awesome' # использовать awesome.(html|text).erb как макет
end
```
Подобно вьюхам контроллера, используйте `yield` для рендеринга вьюхи внутри макета.

Также можно передать опцию `layout: 'layout_name'` в вызов render в формате блока, чтобы определить различные макеты для различных форматов:
```
class UserMailer < ApplicationMailer
  def welcome_email
    mail(to: params[:user].email) do |format|
      format.html { render layout: 'my_layout' }
      format.text
    end
  end
end
```
Отрендерит часть в HTML, используя файл `my_layout.html.erb`, и текстовую часть с обычным файлом `user_mailer.text.erb`, если он существует.

#### Предпросмотр писем

Предпросмотр Action Mailer предоставляет способ увидеть, как выглядят письма, посетив специальный URL, который отображает их. В приведенном выше примере, класс предпросмотра для `UserMailer` должен называться `UserMailerPreview` и находится в `test/mailers/previews/user_mailer_preview`. Чтобы увидеть предпросмотр `welcome_email`, реализуйте метод с таким же именем и вызовом `UserMailer.welcome_email`:
```
class UserMailerPreview < ActionMailer::Preview
  def welcome_email
    UserMailer.with(user: User.first).welcome_email
  end
end
```
Тогда предпросмотр будет доступно по адресу `http://localhost:3000/rails/mailers/user_mailer/welcome_email`.

Если вы поменяете что-то в `app/views/user_mailer/welcome_email.html.erb` или в самом рассыльщике, это автоматически перезагрузится и отрендерится, таким образом, вы можете увидеть новые стили мгновенно. Список для предпросмотра также доступен по адресу `http://localhost:3000/rails/mailers`.

По умолчанию, классы предпросмотра находятся в `test/mailers/previews`. Это может быть изменено, используя опцию `preview_path`. Например, если вы хотите изменить это на `lib/mailer_previews`, вы можете указать в `config/application.rb`:
```
config.action_mailer.preview_path = "#{Rails.root}/lib/mailer_previews"
```
#### Генерируем URL во вьюхах Action Mailer
В отличие от контроллеров, экземпляр рассыльщика не может использовать какой-либо контекст относительно входящего запроса, поэтому необходимо предоставить параметр `:host` самостоятельно.

Так как `:host` обычно одинаковый для всего приложения, его можно настроить глобально в `config/application.rb`:
```
config.action_mailer.default_url_options = { host: 'example.com' }
```
В связи с таким поведением в письме нельзя использовать любые хелперы `*_path`. Вместо них можно использовать связанные хелперы `*_url`. Например, вместо использования
```
<%= link_to 'welcome', welcome_path %>
```
Нужно использовать:
```
<%= link_to 'welcome', welcome_url %>
```
При использовании полного URL ваши ссылки в письмах будут работать.

##### Генерация URL с помощью `url_for`

`url_for` генерирует полный URL по умолчанию в шаблонах.

Если вы не настроили опцию `:host` глобально, убедитесь, что передали ее в `url_for`.
```
<%= url_for(host: 'example.com',
            controller: 'welcome',
            action: 'greeting') %>
```

##### Генерация URL с помощью именованных маршрутов

У клиентов email отсутствует веб-контекст, таким образом у путей нет базового URL для формирования полного веб-адреса. Поэтому следует всегда использовать только вариант `"_url"` именованных маршрутных хелперов.

Если вы не настроили опцию `:host` глобально, убедитесь, что передали ее в хелпер URL.
```
<%= user_url(@user, host: 'example.com') %>
```
> не GET ссылки требуют rails-ujs или jQuery UJS и не будут работать в шаблонах рассыльщика. Они будут заменятся на простые GET запросы.

#### Добавление картинок во вьюхах Action Mailer
В отличие от контроллеров, экземпляр рассыльщика не может использовать какой-либо контекст относительно входящего запроса, поэтому необходимо предоставить параметр `:asset_host` самостоятельно.

Так как `:asset_host` обычно одинаковый для всего приложения, его можно настроить глобально в `config/application.rb`:
```
config.action_mailer.asset_host = 'http://example.com'
```
Теперь вы можете отображать картинки внутри вашего письма.
```
<%= image_tag 'image.jpg' %>
```

#### Рассылка `multipart` email

Action Mailer автоматически посылает `multipart` email, если имеются разные шаблоны для одного и того же экшна. Таким образом, для нашего примера UserMailer, если есть `welcome_email.text.erb` и `welcome_email.html.erb` в `app/views/user_mailer`, то Action Mailer автоматически пошлет `multipart` email с версиями HTML и текстовой, настроенными как разные части.

Порядок, в котором части будут вставлены, определяется `:parts_order` в методе `ActionMailer::Base.default`.

#### Рассылка писем с динамическими опциями доставки

Если хотите переопределить опции доставки по умолчанию (т.е. учетные данные `SMTP`) во время доставки писем, можно использовать `delivery_method_options` в экшне рассыльщика.
```
class UserMailer < ApplicationMailer
  def welcome_email
    @user = params[:user]
    @url  = user_url(@user)
    delivery_options = { user_name: params[:company].smtp_user,
                         password: params[:company].smtp_password,
                         address: params[:company].smtp_host }
    mail(to: @user.email,
         subject: "Please see the Terms and Conditions attached",
         delivery_method_options: delivery_options)
  end
end
```

#### Рассылка писем без рендеринга шаблона

Бывают ситуации, когда вы хотите пропустить шаг рендеринга шаблона и предоставить тело письма, как строку. Это достигается с использованием опции `:body`. В таком случае, не забудьте добавить опцию `:content_type`. Иначе Rails использует по умолчанию `text/plain`.
```
class UserMailer < ApplicationMailer
  def welcome_email
    mail(to: params[:user].email,
         body: params[:email_body],
         content_type: "text/html",
         subject: "Already rendered!")
  end
end
```

### Колбэки Action Mailer <a name="5.4.2"></a>
Action Mailer позволяет определить `before_action`, `after_action` и `around_action`.
Фильтры могут быть определены в блоке или символом с именем метода рассыльщика, подобно контроллерам.

`before_action` можно использовать для заполнения объекта mail значениями по умолчанию, `delivery_method_options` или вставки дефолтных заголовков и прикрепленных файлов.
```
class InvitationsMailer < ApplicationMailer
  before_action { @inviter, @invitee = params[:inviter], params[:invitee] }
  before_action { @account = params[:inviter].account }

  default to:       -> { @invitee.email_address },
          from:     -> { common_address(@inviter) },
          reply_to: -> { @inviter.email_address_with_name }

  def account_invitation
    mail subject: "#{@inviter.name} invited you to their Basecamp (#{@account.name})"
  end

  def project_invitation
    @project    = params[:project]
    @summarizer = ProjectInvitationSummarizer.new(@project.bucket)

    mail subject: "#{@inviter.name.familiar} added you to a project in Basecamp (#{@account.name})"
  end
end
```
`after_action` можно использовать для подобной настройки, как и в `before_action`, но используя переменные экземпляра, установленные в экшне рассыльщика. 
```
class UserMailer < ApplicationMailer
  before_action { @business, @user = params[:business], params[:user] }

  after_action :set_delivery_options,
               :prevent_delivery_to_guests,
               :set_business_headers

  def feedback_message
  end

  def campaign_message
  end

  private

    def set_delivery_options
      # Тут у вас есть доступ к экземпляру mail и переменным экземпляра
      # @business и @user
      if @business && @business.has_smtp_settings?
        mail.delivery_method.settings.merge!(@business.smtp_settings)
      end
    end

    def prevent_delivery_to_guests
      if @user && @user.guest?
        mail.perform_deliveries = false
      end
    end

    def set_business_headers
      if @business
        headers["X-SMTPAPI-CATEGORY"] = @business.code
      end
    end
end
```
Фильтры рассыльщика прерывают дальнейшую обработку, если body установлено в не-nil значение. 

### Использование хелперов Action Mailer <a name="5.4.3"></a>

Action Mailer теперь всего лишь наследуется от `AbstractController`, поэтому у вас есть доступ к тем же общим хелперам, как и в Action Controller.

### Настройка Action Mailer <a name="5.4.4"></a>

Следующие конфигурационные опции лучше всего делать в одном из файлов среды разработки (environment.rb, production.rb, и т.д...)
```
Конфигурация 	Описание
logger 	logger используется для генерации информации на ходу, если возможно. Можно установить как nil для отсутствия логирования. Совместим как с Logger в Ruby, так и с логгером Log4r.
smtp_settings 	Позволяет подробную настройку для метода доставки :smtp:

    :address - Позволяет использовать удаленный почтовый сервер. Просто измените его изначальное значение "localhost".
    :port - В случае, если почтовый сервер не работает с 25 портом, можете изменить его.
    :domain - Если необходимо определить домен HELO, это можно сделать здесь.
    :user_name - Если почтовый сервер требует аутентификацию, установите имя пользователя этой настройкой.
    :password - Если почтовый сервер требует аутентификацию, установите пароль этой настройкой.
    :authentication - Если почтовый сервер требует аутентификацию, здесь нужно определить тип аутентификации. Это один из символов :plain (будет отправлять пароль в открытом виде), :login (будет отправлять пароль закодированным Base64) или :cram_md5 (сочетает в себе механизм Challenge/Response для обмена информацией и криптографический алгоритм MD5 (Message Digest 5) хэширования важной информации)
    :enable_starttls_auto - Определяет, включен ли STARTTLS в вашем SMTP сервере и будет использовать это. По умолчанию, true.
    :openssl_verify_mode - При использовании TLS, вы можете установить, как OpenSSL проверяет сертификат. Это действительно полезно, если вам нужно производить проверку самостоятельно созданного и/или группового сертификата. Вы можете использовать название проверяющей константы OpenSSL ('none' или 'peer') или непосредственно константу (OpenSSL::SSL::VERIFY_NONE или OpenSSL::SSL::VERIFY_PEER).
    :ssl/:tls - Включает для соединения SMTP использование SMTP/TLS (SMTPS: SMTP над прямым соединением TLS)

sendmail_settings 	Позволяет переопределить опции для метода доставки :sendmail.

    :location - Место расположения исполняемого sendmail. По умолчанию /usr/sbin/sendmail.
    :arguments - Аргументы командной строки. По умолчанию -i.

raise_delivery_errors 	Должны ли быть вызваны ошибки, если email не может быть доставлен. Это работает, если внешний сервер email настроен на немедленную доставку.
delivery_method 	Определяет метод доставки. Возможные значения:

    :smtp (по умолчанию), может быть настроен с помощью config.action_mailer.smtp_settings.
    :sendmail, может быть настроен с помощью config.action_mailer.sendmail_settings.
    :file: сохраняет письма в файлы; может быть настроен с помощью config.action_mailer.file_settings.
    :test: сохраняет письма в массив ActionMailer::Base.deliveries.

Подробнее смотрите в API docs.
perform_deliveries 	Определяет, должны ли методы deliver_* фактически выполняться. По умолчанию должны, но это можно отключить для функционального тестирования. Если это значение false, массив deliveries не будет заполняться, даже если delivery_method это :test.
deliveries 	Содержит массив всех электронных писем, отправленных через Action Mailer с помощью delivery_method :test. Очень полезно для юнит- и функционального тестирования.
default_options 	Позволит вам установить значения по умолчанию для опций метода mail (:from, :reply_to и т.д.).
```
Подробное описание возможных конфигураций смотрите в разделе про настройку Action Mailer нашего руководства по конфигурированию приложений на Rails.

#### Пример настройки Action Mailer

Примером может быть добавление следующего в подходящий файл `config/environments/$RAILS_ENV.rb`:
```
config.action_mailer.delivery_method = :sendmail
# Defaults to:
# config.action_mailer.sendmail_settings = {
#   location: '/usr/sbin/sendmail',
#   arguments: '-i'
# }
config.action_mailer.perform_deliveries = true
config.action_mailer.raise_delivery_errors = true
config.action_mailer.default_options = {from: 'no-reply@example.com'}
```
#### Настройка Action Mailer для `Gmail`

Action Mailer теперь использует гем `Mail`, теперь это сделать просто, нужно добавить в файл `config/environments/$RAILS_ENV.rb`:
```
config.action_mailer.delivery_method = :smtp
config.action_mailer.smtp_settings = {
  address:              'smtp.gmail.com',
  port:                 587,
  domain:               'example.com',
  user_name:            '<username>',
  password:             '<password>',
  authentication:       'plain',
  enable_starttls_auto: true }
```
> 15 июля 2014 Google усилили меры безопасности и теперь блокируют попытки от приложений, которые они сочтут небезопасными. Вы можете изменить ваши настройки gmail здесь, чтобы позволить попытки. Если ваша учетная запись Gmail активирована с использованием двухфакторной аутентификации, вам нужно будет установить пароль приложения и использовать ее вместо обычного пароля. Кроме того, вы можете использовать другой почтовый провайдер (ESP, email service provider) для отправки почты, заменив выше 'smtp.gmail.com' на адрес вашего провайдера.

### Тестирование рассыльщика <a name="5.4.5"></a>
Подробные инструкции, как тестировать ваши рассыльщики, можно найти в руководстве Тестирование приложений на Rails

### Перехват и обзор писем <a name="5.4.6"></a>
Action Mailer предоставляет хуки в методы обозревателя и перехватчика Mail. Они позволяют зарегистрировать классы, которые будут вызваны в течение жизненного цикла доставки письма каждого посланного письма.

#### Перехват писем
Перехватчики позволяют сделать изменения в письма перед тем, как они будут переданы агентам доставки. Класс перехватчика должен реализовывать метод `:delivering_email(message)`, который будет вызван перед отправкой письма.
```
class SandboxEmailInterceptor
  def self.delivering_email(message)
    message.to = ['sandbox@example.com']
  end
end
```
Прежде чем перехватчик сможет выполнить свое задание, необходимо зарегистрировать его с помощью фреймворка Action Mailer. Это можно сделать в файле инициализатора `config/initializers/sandbox_email_interceptor.rb`
```
if Rails.env.staging?
  ActionMailer::Base.register_interceptor(SandboxEmailInterceptor)
end
```
> Вышеприведенный пример использует пользовательское окружение по имени "staging" для сервера, похожего на production, но для целей тестирования. Подробнее о пользовательских окружениях в Rails можно прочитать в Создание сред Rails.

#### Обзор писем

Обозреватели дают доступ к сообщению письма после его отправки. Класс обозревателя должен реализовывать метод `:delivered_email(message)`, который будет вызван после отправки письма.
```
class EmailDeliveryObserver
  def self.delivered_email(message)
    EmailDelivery.log(message)
  end
end
```
Подобно перехватчикам, обозреватели нужно зарегистрировать с помощью фреймворка Action Mailer. Это можно сделать в файле инициализатора `config/initializers/email_delivery_observer.rb`
```
ActionMailer::Base.register_observer(EmailDeliveryObserver)
```ад <a name="7"></a>

# Дополнительно <a name="8"></a>
## Все подряд
### task_desire_api
Модели:
```
rails g model User login:string:uniq password_digest name sign
rails g model Article head:string announcement:string content:text status:boolean user:references
```
Контроллеры:
```
rails g controller Articles create update destroy
```
### Задачи Rake
* `rake db:create` - Cоздать баду данных
* `rake db:drop` - Удалить базу данных
* `rake db:migrate` - Запустить миграцию базы
* `rake db:rollback` - Откатить миграцию данных к предыдущему состоянию
* `rake db:schema:dump` - Построение файла schema.rb на основе текущей структуры базы данных
* `rake db:schema:load` - Восстановление структуры базы данных из schema.rb
* `rake db:seed` - Запускает скрипт db/seed.rb который по идее должен заполнить базу первоначальными данными
* `rake db:setup` - Запустит поочереди create, schema:load, seed
* `rake db:structure:dump` - Сделает дамп структуры в db/structue.sql
* `rake db:structure:load` - Восстановит базу из db/structue.sql

