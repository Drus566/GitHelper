### Позволяет открывать файлы, папки из терминала
`xdg-open`
### Выводит размер папки
`du -hs .`
### Запуск GIMP
`flatpak run org.gimp.GIMP//stable`
### Запуск InkScape
`flatpak run org.inkscape.Inkscape`
### История команд
`history | less`
#### последняя команда из истории 
`!!`
#### Отдельные слова из введенной команды 
`!:1`
`!:0`
#### последняя команда начинающаяся со строки abc
`!abc`
#### поиск по командам в терминале 
`ctrl + R`
`ctrl + C`
### Удаление директории 
`rm -r <dir>`
### Конец файла реализуется на клавиатуре
`Ctrl + D`
### Принудительное завершение программы 
`Ctrl + C , Ctrl + \`
### Остановка вывода программы 
```
Ctrl + S # вкл
Ctrl + Q # выкл
```
### Передача сигналов процессу
#### SIGKILL
`kill -9 <номер процесса>`
`kill -KILL <номер процесса>`
#### SIGINT
`Ctrl+C`
#### SIGQUIT
`Ctrl+\`
#### SIGTERM
`kill <номер процесса>`
> Если после этого процесс не умирает то он зомби. Зомби не потребляет ресурсов а просто висит в таблице. Виной всему процесс предок, который не запрашивает инфу у ОС о завершении работы процесса. Пример `3159 pts/6    Z+    0:00  [prog] <defunct>`. Так как буква `Z` значит зомби.

> Либо процесс мог выполнить системный вызов, а ОС послала его в спящий режим ожидания. Возможны проблемы с ПК(жесткий диск). Пример `4711 pts/6    D    0:01 badblocks   /dev/sdc1`. Буква `D` - режим ожидания.

### Запуск в фоновом режиме 
`firefox &` # в конце добавляется `&`
### Удаление фоновых задач
`kill %<номер фоновой задачи>` # отправляет сигнал `SIGTERM`
### Отправка задачи в фоновую, а затем ее запуск в фоне 
`Ctrl + Z` # задача приостонавливается
`bg` # задача начинает выполнятся в фоновом режиме
`fg` # делает задачу текущей (интерпретатор ожидает её выполнения в первую очередь)

### Перенаправления ввода вывода
#### Запуск программы cmd1, направив ее вывод в file1 с перезаписью
`cmd1 > file1`
#### Запуск программы, выввод с дополнением в конец файла
`cmd1 >> file`
#### Запуск программы, подача на вход file2
`cmd2 < file`
#### Запуск программы, на вход file1, на выход file2
`cmd3 > file2 < file1`
#### Запуск программ cmd1 cmd2, подав вывод первой на вход второй (конвейер)
`cmd1 | cmd2`
#### Поток сообщений об ошибках в файл errfile
`cmd4 2> errfile`
#### Объединение стандартного вывода и вывода ошибок программы и направление на стандартный ввод cmd6
`cmd5 2>&1 | cmd6`

> Поток ввода-вывода - это дискриптор. 0 - поток ввода. 1 - поток вывода. 2 - поток вывода ошибок. 

### Просмотр постранично содержимое файлов
`<имя файла> | less` 
`ls -lR | less` # просмотр директории и всех поддиректорий в страничном режиме
`gcc -Wall -g myprog.c -o myprog 2>&1 | less` просмотр потока вывода и поток ошибок программы

### Перенаправление потока вывода в псевдоустройство /dev/null
`ls -l -R / > list.txt 2> /dev/null`

### Переход к строке текстового редактора
`/<текст строки>`
`:<номер строки>`
### Переход между двумя последними редактируемыми файлами 
`Ctrl + ^`
`:b`
### Удаление текста
`d`
`d + {h,i,j,k,<выделенный блок текста через команду v>}`
### Копирование выделенного текста 
`y`
`yy` - текущая строка
`yw` - текущее слово
`y$` - символы от курсора до конца строки
> Все удаляющие команды (`x, dd, dw, d$ ...`) помещают текст в буфер

### Вставка текста
`p` перед курсором
`P` после курсора

### Права достуа к файлу 
`ls -l <путь к файлу>` # => `-rwxr-xr-x`, `-` - значит обычный файл, `d` - каталог, `rwx` - для владельца, `r-x` - группы и остальные.
### Изменение прав доступа к файлу
`chmod 644 myfile.c` - права записи только для владельца, а права доступа для всех только чтение

`chmod -R u+rwX,go=rX ~` устанавливает в домашней директории и всех её поддиректориях для всех файлов права для владельца на чтения и запись, для директорий, а также для файлов, для которых исполнение разрешено хоть кому-то, владельцу назначаются также права на исполнение. Для группы и остальных пользователей устанавливаются права на чтение, для исполняемых файлов и дриекторий - также права на исполнение, а все остальные права убираются.
> Слово прав доступа к файлу в виде восьмеричного числа. Младший разряд (последняя правая цифра) - права доступа для всех, средний разряд - права для группы, старший разряд - для владельца.
> Для полноценного просмотра каталога, необходимы права на чтение каталога и доступ к файлам, а главное к их атрибутам, т.е. минимальные разумные права на каталог - 5 (r-x). Прав 4 (r–) хватит только на просмотр имен файлов, без атрибутов, т.е. не будут известны размер файла, права доступа, владелец. На практике для каталогов используется только три режима: 7 (rwx), 5 (r-x) и 0 (—). 

> Очень любопытный режим доступа к каталогу - 3 (-wx): он позволяет делать в директории все, что угодно, но не позволяет прочитать имена объектов в директории. Т.е. если вам не известны названия объектов в этом каталоге, то вы сделать с ними ничего не сможете (даже удалить по маске * т.к. маску не к чему применять - имена то недоступны). В каталоге с режимом доступа 3 (-wx) можно создавать новые, переименовывать и удалять файлы и каталоги (если вы знаете их имя); читать, изменять, запускать файл (если достаточно на него прав, и опять же - вы знаете его имя). Можно даже менять права доступа на файлы и каталоги (если вы знаете имя). Но самое интересное, что если вы сможете перейти (по cd5)) в подкаталог такого каталога (а для этого вам опять нужно знать его имя), то там у вас будет «все в ожуре» (если конечно у этого подкаталога будет нормальный режим доступа). Никакой рекурсивный поиск/удаление тоже не сможет залезть внутрь такого каталога - ему ведь нужны названия - а их из такого каталога - никак не получить. Но не надо думать, что такой каталог полноценно заменяет крипто-контейнер (т.е. может использоваться для хранения очень секретных данных). Да, имен объектов из такого каталога никак не получить, однако если попытаться создать объект с именем, которое уже существует, то такая операция закончится неудачей (т.е. мы получим подтверждение, что такое имя уже есть). Так же можно пытаться открыть (как файл или как каталог) объект с произвольным именем, если такого имени нет, то мы получим ошибку. Безусловно имя может быть очень длинным и шансы угадать его могут быть не велики, но не надо забывать, что права доступа могут сменить как владелец каталога так root. Да и пути доступа могут сохраниться в различных логах и файлах истории. 

> https://help.ubuntu.ru/wiki/%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D1%8B%D0%B5_%D0%BF%D1%80%D0%B0%D0%B2%D0%B0_unix

### Справочная информация 
`man` например `man ls`, `man waitpid` и т.п.

`man 2 write` - если в системе есть две команды write, выбираем секцию с системными вызовами(2), всего 8 разных секций(гугл)
> Поиск по документации `/` и `?` - в обратную сторону.

### Более полная справочная информация с гиперссылками
`info`, например `info make`
> `n` и `p` позволяют переходить к следующей или предыдущей странице гипертекста. Гиперссылки заключены в `*` или `::`, кнопка назад - `l`.

### Bourne Shell
#### Должен начинаться с 
`#!/bin/sh`
#### Пример
```
#!/bin/sh
I=10
MYFILE=/tmp/the_file_name
MYSTRING="Here are several words"
echo $I $MYFILE $MYSTRING
# => 10 tmp/the_file_name Here are several words
```
#### Переменные 
```
echo ${I}abc # => 10abc
I=$(($I + 7)) # => увеличит I на 7
```
#### Проверка условий
```
test или
[ -f "file.text" ] # существует ли файл
[ "$I" -lt 25 ] # значение переменной I меньше 25
[ "$A" = "abc" ] # значение переменной A является строкой abc
[ "$A" != "abc" ] # значение переменной A не является строкой abc
```
Пример
```
if [ -f "file.txt" ]; then
  cat "file.txt"
else
  echo "Файл file.txt не найден"
fi
```
или
```
if test -f "file.txt" ; then
  cat "file.txt"
else
  echo "Файл file.txt не найден"
fi
```
или 
```
if gcc -Wall -g myprog.c -o myprog; then
  cat "file.txt"
else
  echo "Файл file.txt не найден"
fi
```
#### Циклы
```
I = 0
while [ $I -le 101]; do
  echo $I
  I=$((I + 1))
done
```
#### Логические цепочки
```
cmd1 && cmd2 #=> если cmd1 выполнилась, то далее выполняется cmd2
cmd1 || cmd2 #=> cmd1 не выполнилась, значит будет выполнятся cmd2
```
